/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 23);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanM/NWI2OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n");

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = __webpack_require__(24);\n} else {\n  module.exports = __webpack_require__(25);\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC9pbmRleC5qcz8xYTIyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qcycpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1\n");

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nfunction makeEmptyFunction(arg) {\n  return function () {\n    return arg;\n  };\n}\n\n/**\n * This function accepts and discards inputs; it has no side effects. This is\n * primarily useful idiomatically for overridable function endpoints which\n * always need to be callable, since JS lacks a null-call idiom ala Cocoa.\n */\nvar emptyFunction = function emptyFunction() {};\n\nemptyFunction.thatReturns = makeEmptyFunction;\nemptyFunction.thatReturnsFalse = makeEmptyFunction(false);\nemptyFunction.thatReturnsTrue = makeEmptyFunction(true);\nemptyFunction.thatReturnsNull = makeEmptyFunction(null);\nemptyFunction.thatReturnsThis = function () {\n  return this;\n};\nemptyFunction.thatReturnsArgument = function (arg) {\n  return arg;\n};\n\nmodule.exports = emptyFunction;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9lbXB0eUZ1bmN0aW9uLmpzPzdiYWYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cblxuZnVuY3Rpb24gbWFrZUVtcHR5RnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFyZztcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgYW5kIGRpc2NhcmRzIGlucHV0czsgaXQgaGFzIG5vIHNpZGUgZWZmZWN0cy4gVGhpcyBpc1xuICogcHJpbWFyaWx5IHVzZWZ1bCBpZGlvbWF0aWNhbGx5IGZvciBvdmVycmlkYWJsZSBmdW5jdGlvbiBlbmRwb2ludHMgd2hpY2hcbiAqIGFsd2F5cyBuZWVkIHRvIGJlIGNhbGxhYmxlLCBzaW5jZSBKUyBsYWNrcyBhIG51bGwtY2FsbCBpZGlvbSBhbGEgQ29jb2EuXG4gKi9cbnZhciBlbXB0eUZ1bmN0aW9uID0gZnVuY3Rpb24gZW1wdHlGdW5jdGlvbigpIHt9O1xuXG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zID0gbWFrZUVtcHR5RnVuY3Rpb247XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2UgPSBtYWtlRW1wdHlGdW5jdGlvbihmYWxzZSk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKHRydWUpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwgPSBtYWtlRW1wdHlGdW5jdGlvbihudWxsKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUaGlzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn07XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQgPSBmdW5jdGlvbiAoYXJnKSB7XG4gIHJldHVybiBhcmc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVtcHR5RnVuY3Rpb247XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZW1wdHlGdW5jdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2\n");

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzPzA0NDQiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbm9iamVjdC1hc3NpZ25cbihjKSBTaW5kcmUgU29yaHVzXG5AbGljZW5zZSBNSVRcbiovXG5cbid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xuXHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcblx0fVxuXG5cdHJldHVybiBPYmplY3QodmFsKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkVXNlTmF0aXZlKCkge1xuXHR0cnkge1xuXHRcdGlmICghT2JqZWN0LmFzc2lnbikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIERldGVjdCBidWdneSBwcm9wZXJ0eSBlbnVtZXJhdGlvbiBvcmRlciBpbiBvbGRlciBWOCB2ZXJzaW9ucy5cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxMThcblx0XHR2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG5cdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcblx0XHR9XG5cdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdHJldHVybiB0ZXN0MltuXTtcblx0XHR9KTtcblx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QzID0ge307XG5cdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdH0pO1xuXHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdC8vIFdlIGRvbid0IGV4cGVjdCBhbnkgb2YgdGhlIGFib3ZlIHRvIHRocm93LCBidXQgYmV0dGVyIHRvIGJlIHNhZmUuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXNlTmF0aXZlKCkgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cdHZhciBmcm9tO1xuXHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHR2YXIgc3ltYm9scztcblxuXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG5cdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdFx0c3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL29iamVjdC1hc3NpZ24vaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3\n");

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\nvar validateFormat = function validateFormat(format) {};\n\nif (process.env.NODE_ENV !== 'production') {\n  validateFormat = function validateFormat(format) {\n    if (format === undefined) {\n      throw new Error('invariant requires an error message argument');\n    }\n  };\n}\n\nfunction invariant(condition, format, a, b, c, d, e, f) {\n  validateFormat(format);\n\n  if (!condition) {\n    var error;\n    if (format === undefined) {\n      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Error(format.replace(/%s/g, function () {\n        return args[argIndex++];\n      }));\n      error.name = 'Invariant Violation';\n    }\n\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n}\n\nmodule.exports = invariant;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9pbnZhcmlhbnQuanM/NzMxMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVXNlIGludmFyaWFudCgpIHRvIGFzc2VydCBzdGF0ZSB3aGljaCB5b3VyIHByb2dyYW0gYXNzdW1lcyB0byBiZSB0cnVlLlxuICpcbiAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXG4gKiB0byBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYnJva2UgYW5kIHdoYXQgeW91IHdlcmVcbiAqIGV4cGVjdGluZy5cbiAqXG4gKiBUaGUgaW52YXJpYW50IG1lc3NhZ2Ugd2lsbCBiZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGludmFyaWFudFxuICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxuICovXG5cbnZhciB2YWxpZGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhbGlkYXRlRm9ybWF0ID0gZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXQoZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbnZhcmlhbnQoY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgdmFsaWRhdGVGb3JtYXQoZm9ybWF0KTtcblxuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHZhciBlcnJvcjtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKCdNaW5pZmllZCBleGNlcHRpb24gb2NjdXJyZWQ7IHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCAnICsgJ2ZvciB0aGUgZnVsbCBlcnJvciBtZXNzYWdlIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcmdzID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgfSkpO1xuICAgICAgZXJyb3IubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICB9XG5cbiAgICBlcnJvci5mcmFtZXNUb1BvcCA9IDE7IC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgaW52YXJpYW50J3Mgb3duIGZyYW1lXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbnZhcmlhbnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaW52YXJpYW50LmpzXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4\n");

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\nvar emptyObject = {};\n\nif (process.env.NODE_ENV !== 'production') {\n  Object.freeze(emptyObject);\n}\n\nmodule.exports = emptyObject;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9lbXB0eU9iamVjdC5qcz80Yzk3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5T2JqZWN0ID0ge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIE9iamVjdC5mcmVlemUoZW1wdHlPYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVtcHR5T2JqZWN0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2VtcHR5T2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5\n");

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\nvar emptyFunction = __webpack_require__(2);\n\n/**\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar warning = emptyFunction;\n\nif (process.env.NODE_ENV !== 'production') {\n  var printWarning = function printWarning(format) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var argIndex = 0;\n    var message = 'Warning: ' + format.replace(/%s/g, function () {\n      return args[argIndex++];\n    });\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n\n  warning = function warning(condition, format) {\n    if (format === undefined) {\n      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');\n    }\n\n    if (format.indexOf('Failed Composite propType: ') === 0) {\n      return; // Ignore CompositeComponent proptype check.\n    }\n\n    if (!condition) {\n      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        args[_key2 - 2] = arguments[_key2];\n      }\n\n      printWarning.apply(undefined, [format].concat(args));\n    }\n  };\n}\n\nmodule.exports = warning;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi93YXJuaW5nLmpzPzYzMjciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJy4vZW1wdHlGdW5jdGlvbicpO1xuXG4vKipcbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xuXG52YXIgd2FybmluZyA9IGVtcHR5RnVuY3Rpb247XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbiBwcmludFdhcm5pbmcoZm9ybWF0KSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcblxuICB3YXJuaW5nID0gZnVuY3Rpb24gd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICsgJ21lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG5cbiAgICBpZiAoZm9ybWF0LmluZGV4T2YoJ0ZhaWxlZCBDb21wb3NpdGUgcHJvcFR5cGU6ICcpID09PSAwKSB7XG4gICAgICByZXR1cm47IC8vIElnbm9yZSBDb21wb3NpdGVDb21wb25lbnQgcHJvcHR5cGUgY2hlY2suXG4gICAgfVxuXG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yID4gMiA/IF9sZW4yIC0gMiA6IDApLCBfa2V5MiA9IDI7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nLmFwcGx5KHVuZGVmaW5lZCwgW2Zvcm1hdF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2FybmluZztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi93YXJuaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6\n");

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (process.env.NODE_ENV !== 'production') {\n  var invariant = __webpack_require__(4);\n  var warning = __webpack_require__(6);\n  var ReactPropTypesSecret = __webpack_require__(8);\n  var loggedTypeFailures = {};\n}\n\n/**\n * Assert that the values match with the type specs.\n * Error messages are memorized and will only be shown once.\n *\n * @param {object} typeSpecs Map of name to a ReactPropType\n * @param {object} values Runtime values that need to be type-checked\n * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n * @param {string} componentName Name of the component for error messages.\n * @param {?Function} getStack Returns the component stack.\n * @private\n */\nfunction checkPropTypes(typeSpecs, values, location, componentName, getStack) {\n  if (process.env.NODE_ENV !== 'production') {\n    for (var typeSpecName in typeSpecs) {\n      if (typeSpecs.hasOwnProperty(typeSpecName)) {\n        var error;\n        // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          invariant(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'the `prop-types` package, but received `%s`.', componentName || 'React class', location, typeSpecName, typeof typeSpecs[typeSpecName]);\n          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);\n        } catch (ex) {\n          error = ex;\n        }\n        warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error);\n        if (error instanceof Error && !(error.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error.message] = true;\n\n          var stack = getStack ? getStack() : '';\n\n          warning(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');\n        }\n      }\n    }\n  }\n}\n\nmodule.exports = checkPropTypes;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzLmpzPzIxZWUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbiAgdmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG4gIHZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG4gIHZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbn1cblxuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgdmFsdWVzIG1hdGNoIHdpdGggdGhlIHR5cGUgc3BlY3MuXG4gKiBFcnJvciBtZXNzYWdlcyBhcmUgbWVtb3JpemVkIGFuZCB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdHlwZVNwZWNzIE1hcCBvZiBuYW1lIHRvIGEgUmVhY3RQcm9wVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyBSdW50aW1lIHZhbHVlcyB0aGF0IG5lZWQgdG8gYmUgdHlwZS1jaGVja2VkXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50TmFtZSBOYW1lIG9mIHRoZSBjb21wb25lbnQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICogQHBhcmFtIHs/RnVuY3Rpb259IGdldFN0YWNrIFJldHVybnMgdGhlIGNvbXBvbmVudCBzdGFjay5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZ2V0U3RhY2spIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAodHlwZVNwZWNzLmhhc093blByb3BlcnR5KHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaW52YXJpYW50KHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSA9PT0gJ2Z1bmN0aW9uJywgJyVzOiAlcyB0eXBlIGAlc2AgaXMgaW52YWxpZDsgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gJyArICd0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJXNgLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKTtcbiAgICAgICAgICBlcnJvciA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yID0gZXg7XG4gICAgICAgIH1cbiAgICAgICAgd2FybmluZyghZXJyb3IgfHwgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciwgJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yKTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgICB2YXIgc3RhY2sgPSBnZXRTdGFjayA/IGdldFN0YWNrKCkgOiAnJztcblxuICAgICAgICAgIHdhcm5pbmcoZmFsc2UsICdGYWlsZWQgJXMgdHlwZTogJXMlcycsIGxvY2F0aW9uLCBlcnJvci5tZXNzYWdlLCBzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjaGVja1Byb3BUeXBlcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMuanNcbi8vIG1vZHVsZSBpZCA9IDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7\n");

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n\nmodule.exports = ReactPropTypesSecret;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldC5qcz84MmRmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzU2VjcmV0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanNcbi8vIG1vZHVsZSBpZCA9IDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8\n");

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {\n\nfunction checkDCE() {\n  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n  if (\n    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||\n    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'\n  ) {\n    return;\n  }\n  if (process.env.NODE_ENV !== 'production') {\n    // This branch is unreachable because this function is only called\n    // in production, but the condition is true only in development.\n    // Therefore if the branch is still here, dead code elimination wasn't\n    // properly applied.\n    // Don't change the message. React DevTools relies on it. Also make sure\n    // this message doesn't occur elsewhere in this function, or it will cause\n    // a false positive.\n    throw new Error('^_^');\n  }\n  try {\n    // Verify that the code above has been dead code eliminated (DCE'd).\n    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);\n  } catch (err) {\n    // DevTools shouldn't crash React, no matter what.\n    // We should still report in case we break this code.\n    console.error(err);\n  }\n}\n\nif (process.env.NODE_ENV === 'production') {\n  // DCE check should happen before ReactDOM bundle executes so that\n  // DevTools can report bad minification during injection.\n  checkDCE();\n  module.exports = __webpack_require__(26);\n} else {\n  module.exports = __webpack_require__(29);\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vaW5kZXguanM/M2I2ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGNoZWNrRENFKCkge1xuICAvKiBnbG9iYWwgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICovXG4gIGlmIChcbiAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fID09PSAndW5kZWZpbmVkJyB8fFxuICAgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uY2hlY2tEQ0UgIT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gVGhpcyBicmFuY2ggaXMgdW5yZWFjaGFibGUgYmVjYXVzZSB0aGlzIGZ1bmN0aW9uIGlzIG9ubHkgY2FsbGVkXG4gICAgLy8gaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBjb25kaXRpb24gaXMgdHJ1ZSBvbmx5IGluIGRldmVsb3BtZW50LlxuICAgIC8vIFRoZXJlZm9yZSBpZiB0aGUgYnJhbmNoIGlzIHN0aWxsIGhlcmUsIGRlYWQgY29kZSBlbGltaW5hdGlvbiB3YXNuJ3RcbiAgICAvLyBwcm9wZXJseSBhcHBsaWVkLlxuICAgIC8vIERvbid0IGNoYW5nZSB0aGUgbWVzc2FnZS4gUmVhY3QgRGV2VG9vbHMgcmVsaWVzIG9uIGl0LiBBbHNvIG1ha2Ugc3VyZVxuICAgIC8vIHRoaXMgbWVzc2FnZSBkb2Vzbid0IG9jY3VyIGVsc2V3aGVyZSBpbiB0aGlzIGZ1bmN0aW9uLCBvciBpdCB3aWxsIGNhdXNlXG4gICAgLy8gYSBmYWxzZSBwb3NpdGl2ZS5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ15fXicpO1xuICB9XG4gIHRyeSB7XG4gICAgLy8gVmVyaWZ5IHRoYXQgdGhlIGNvZGUgYWJvdmUgaGFzIGJlZW4gZGVhZCBjb2RlIGVsaW1pbmF0ZWQgKERDRSdkKS5cbiAgICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uY2hlY2tEQ0UoY2hlY2tEQ0UpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBEZXZUb29scyBzaG91bGRuJ3QgY3Jhc2ggUmVhY3QsIG5vIG1hdHRlciB3aGF0LlxuICAgIC8vIFdlIHNob3VsZCBzdGlsbCByZXBvcnQgaW4gY2FzZSB3ZSBicmVhayB0aGlzIGNvZGUuXG4gICAgY29uc29sZS5lcnJvcihlcnIpO1xuICB9XG59XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIC8vIERDRSBjaGVjayBzaG91bGQgaGFwcGVuIGJlZm9yZSBSZWFjdERPTSBidW5kbGUgZXhlY3V0ZXMgc28gdGhhdFxuICAvLyBEZXZUb29scyBjYW4gcmVwb3J0IGJhZCBtaW5pZmljYXRpb24gZHVyaW5nIGluamVjdGlvbi5cbiAgY2hlY2tEQ0UoKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1kb20ucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtZG9tLmRldmVsb3BtZW50LmpzJyk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9\n");

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\nvar canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n\n/**\n * Simple, lightweight module assisting with the detection and context of\n * Worker. Helps avoid circular dependencies and allows code to reason about\n * whether or not they are in a Worker, even if they never include the main\n * `ReactWorker` dependency.\n */\nvar ExecutionEnvironment = {\n\n  canUseDOM: canUseDOM,\n\n  canUseWorkers: typeof Worker !== 'undefined',\n\n  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),\n\n  canUseViewport: canUseDOM && !!window.screen,\n\n  isInWorker: !canUseDOM // For now, this is true - might change in the future.\n\n};\n\nmodule.exports = ExecutionEnvironment;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQuanM/NzMzNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjYW5Vc2VET00gPSAhISh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xuXG4vKipcbiAqIFNpbXBsZSwgbGlnaHR3ZWlnaHQgbW9kdWxlIGFzc2lzdGluZyB3aXRoIHRoZSBkZXRlY3Rpb24gYW5kIGNvbnRleHQgb2ZcbiAqIFdvcmtlci4gSGVscHMgYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jaWVzIGFuZCBhbGxvd3MgY29kZSB0byByZWFzb24gYWJvdXRcbiAqIHdoZXRoZXIgb3Igbm90IHRoZXkgYXJlIGluIGEgV29ya2VyLCBldmVuIGlmIHRoZXkgbmV2ZXIgaW5jbHVkZSB0aGUgbWFpblxuICogYFJlYWN0V29ya2VyYCBkZXBlbmRlbmN5LlxuICovXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSB7XG5cbiAgY2FuVXNlRE9NOiBjYW5Vc2VET00sXG5cbiAgY2FuVXNlV29ya2VyczogdHlwZW9mIFdvcmtlciAhPT0gJ3VuZGVmaW5lZCcsXG5cbiAgY2FuVXNlRXZlbnRMaXN0ZW5lcnM6IGNhblVzZURPTSAmJiAhISh3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciB8fCB3aW5kb3cuYXR0YWNoRXZlbnQpLFxuXG4gIGNhblVzZVZpZXdwb3J0OiBjYW5Vc2VET00gJiYgISF3aW5kb3cuc2NyZWVuLFxuXG4gIGlzSW5Xb3JrZXI6ICFjYW5Vc2VET00gLy8gRm9yIG5vdywgdGhpcyBpcyB0cnVlIC0gbWlnaHQgY2hhbmdlIGluIHRoZSBmdXR1cmUuXG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXhlY3V0aW9uRW52aXJvbm1lbnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQuanNcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///10\n");

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\n\nvar emptyFunction = __webpack_require__(2);\n\n/**\n * Upstream version of event listener. Does not take into account specific\n * nature of platform.\n */\nvar EventListener = {\n  /**\n   * Listen to DOM events during the bubble phase.\n   *\n   * @param {DOMEventTarget} target DOM element to register listener on.\n   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.\n   * @param {function} callback Callback function.\n   * @return {object} Object with a `remove` method.\n   */\n  listen: function listen(target, eventType, callback) {\n    if (target.addEventListener) {\n      target.addEventListener(eventType, callback, false);\n      return {\n        remove: function remove() {\n          target.removeEventListener(eventType, callback, false);\n        }\n      };\n    } else if (target.attachEvent) {\n      target.attachEvent('on' + eventType, callback);\n      return {\n        remove: function remove() {\n          target.detachEvent('on' + eventType, callback);\n        }\n      };\n    }\n  },\n\n  /**\n   * Listen to DOM events during the capture phase.\n   *\n   * @param {DOMEventTarget} target DOM element to register listener on.\n   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.\n   * @param {function} callback Callback function.\n   * @return {object} Object with a `remove` method.\n   */\n  capture: function capture(target, eventType, callback) {\n    if (target.addEventListener) {\n      target.addEventListener(eventType, callback, true);\n      return {\n        remove: function remove() {\n          target.removeEventListener(eventType, callback, true);\n        }\n      };\n    } else {\n      if (process.env.NODE_ENV !== 'production') {\n        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');\n      }\n      return {\n        remove: emptyFunction\n      };\n    }\n  },\n\n  registerDefault: function registerDefault() {}\n};\n\nmodule.exports = EventListener;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvRXZlbnRMaXN0ZW5lci5qcz9hM2VhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9lbXB0eUZ1bmN0aW9uJyk7XG5cbi8qKlxuICogVXBzdHJlYW0gdmVyc2lvbiBvZiBldmVudCBsaXN0ZW5lci4gRG9lcyBub3QgdGFrZSBpbnRvIGFjY291bnQgc3BlY2lmaWNcbiAqIG5hdHVyZSBvZiBwbGF0Zm9ybS5cbiAqL1xudmFyIEV2ZW50TGlzdGVuZXIgPSB7XG4gIC8qKlxuICAgKiBMaXN0ZW4gdG8gRE9NIGV2ZW50cyBkdXJpbmcgdGhlIGJ1YmJsZSBwaGFzZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdGFyZ2V0IERPTSBlbGVtZW50IHRvIHJlZ2lzdGVyIGxpc3RlbmVyIG9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlIEV2ZW50IHR5cGUsIGUuZy4gJ2NsaWNrJyBvciAnbW91c2VvdmVyJy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IHdpdGggYSBgcmVtb3ZlYCBtZXRob2QuXG4gICAqL1xuICBsaXN0ZW46IGZ1bmN0aW9uIGxpc3Rlbih0YXJnZXQsIGV2ZW50VHlwZSwgY2FsbGJhY2spIHtcbiAgICBpZiAodGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIGZhbHNlKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHRhcmdldC5hdHRhY2hFdmVudCkge1xuICAgICAgdGFyZ2V0LmF0dGFjaEV2ZW50KCdvbicgKyBldmVudFR5cGUsIGNhbGxiYWNrKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICAgIHRhcmdldC5kZXRhY2hFdmVudCgnb24nICsgZXZlbnRUeXBlLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBMaXN0ZW4gdG8gRE9NIGV2ZW50cyBkdXJpbmcgdGhlIGNhcHR1cmUgcGhhc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRhcmdldCBET00gZWxlbWVudCB0byByZWdpc3RlciBsaXN0ZW5lciBvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZSBFdmVudCB0eXBlLCBlLmcuICdjbGljaycgb3IgJ21vdXNlb3ZlcicuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCB3aXRoIGEgYHJlbW92ZWAgbWV0aG9kLlxuICAgKi9cbiAgY2FwdHVyZTogZnVuY3Rpb24gY2FwdHVyZSh0YXJnZXQsIGV2ZW50VHlwZSwgY2FsbGJhY2spIHtcbiAgICBpZiAodGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIHRydWUpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0F0dGVtcHRlZCB0byBsaXN0ZW4gdG8gZXZlbnRzIGR1cmluZyB0aGUgY2FwdHVyZSBwaGFzZSBvbiBhICcgKyAnYnJvd3NlciB0aGF0IGRvZXMgbm90IHN1cHBvcnQgdGhlIGNhcHR1cmUgcGhhc2UuIFlvdXIgYXBwbGljYXRpb24gJyArICd3aWxsIG5vdCByZWNlaXZlIHNvbWUgZXZlbnRzLicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3ZlOiBlbXB0eUZ1bmN0aW9uXG4gICAgICB9O1xuICAgIH1cbiAgfSxcblxuICByZWdpc3RlckRlZmF1bHQ6IGZ1bmN0aW9uIHJlZ2lzdGVyRGVmYXVsdCgpIHt9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50TGlzdGVuZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvRXZlbnRMaXN0ZW5lci5qc1xuLy8gbW9kdWxlIGlkID0gMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///11\n");

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\n\n/* eslint-disable fb-www/typeof-undefined */\n\n/**\n * Same as document.activeElement but wraps in a try-catch block. In IE it is\n * not safe to call document.activeElement if there is nothing focused.\n *\n * The activeElement will be null only if the document or document body is not\n * yet defined.\n *\n * @param {?DOMDocument} doc Defaults to current document.\n * @return {?DOMElement}\n */\nfunction getActiveElement(doc) /*?DOMElement*/{\n  doc = doc || (typeof document !== 'undefined' ? document : undefined);\n  if (typeof doc === 'undefined') {\n    return null;\n  }\n  try {\n    return doc.activeElement || doc.body;\n  } catch (e) {\n    return doc.body;\n  }\n}\n\nmodule.exports = getActiveElement;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZ2V0QWN0aXZlRWxlbWVudC5qcz9mNTRlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbi8qIGVzbGludC1kaXNhYmxlIGZiLXd3dy90eXBlb2YtdW5kZWZpbmVkICovXG5cbi8qKlxuICogU2FtZSBhcyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGJ1dCB3cmFwcyBpbiBhIHRyeS1jYXRjaCBibG9jay4gSW4gSUUgaXQgaXNcbiAqIG5vdCBzYWZlIHRvIGNhbGwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpZiB0aGVyZSBpcyBub3RoaW5nIGZvY3VzZWQuXG4gKlxuICogVGhlIGFjdGl2ZUVsZW1lbnQgd2lsbCBiZSBudWxsIG9ubHkgaWYgdGhlIGRvY3VtZW50IG9yIGRvY3VtZW50IGJvZHkgaXMgbm90XG4gKiB5ZXQgZGVmaW5lZC5cbiAqXG4gKiBAcGFyYW0gez9ET01Eb2N1bWVudH0gZG9jIERlZmF1bHRzIHRvIGN1cnJlbnQgZG9jdW1lbnQuXG4gKiBAcmV0dXJuIHs/RE9NRWxlbWVudH1cbiAqL1xuZnVuY3Rpb24gZ2V0QWN0aXZlRWxlbWVudChkb2MpIC8qP0RPTUVsZW1lbnQqL3tcbiAgZG9jID0gZG9jIHx8ICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQgOiB1bmRlZmluZWQpO1xuICBpZiAodHlwZW9mIGRvYyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiBkb2MuYWN0aXZlRWxlbWVudCB8fCBkb2MuYm9keTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBkb2MuYm9keTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEFjdGl2ZUVsZW1lbnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZ2V0QWN0aXZlRWxlbWVudC5qc1xuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///12\n");

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n * \n */\n\n/*eslint-disable no-self-compare */\n\n\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */\nfunction is(x, y) {\n  // SameValue algorithm\n  if (x === y) {\n    // Steps 1-5, 7-10\n    // Steps 6.b-6.e: +0 != -0\n    // Added the nonzero y check to make Flow happy, but it is redundant\n    return x !== 0 || y !== 0 || 1 / x === 1 / y;\n  } else {\n    // Step 6.a: NaN == NaN\n    return x !== x && y !== y;\n  }\n}\n\n/**\n * Performs equality by iterating through keys on an object and returning false\n * when any key has values which are not strictly equal between the arguments.\n * Returns true when the values of all keys are strictly equal.\n */\nfunction shallowEqual(objA, objB) {\n  if (is(objA, objB)) {\n    return true;\n  }\n\n  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {\n    return false;\n  }\n\n  var keysA = Object.keys(objA);\n  var keysB = Object.keys(objB);\n\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n\n  // Test for A's keys different from B.\n  for (var i = 0; i < keysA.length; i++) {\n    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nmodule.exports = shallowEqual;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvc2hhbGxvd0VxdWFsLmpzP2IyMDYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICogXG4gKi9cblxuLyplc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICovXG5mdW5jdGlvbiBpcyh4LCB5KSB7XG4gIC8vIFNhbWVWYWx1ZSBhbGdvcml0aG1cbiAgaWYgKHggPT09IHkpIHtcbiAgICAvLyBTdGVwcyAxLTUsIDctMTBcbiAgICAvLyBTdGVwcyA2LmItNi5lOiArMCAhPSAtMFxuICAgIC8vIEFkZGVkIHRoZSBub256ZXJvIHkgY2hlY2sgdG8gbWFrZSBGbG93IGhhcHB5LCBidXQgaXQgaXMgcmVkdW5kYW50XG4gICAgcmV0dXJuIHggIT09IDAgfHwgeSAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gIH0gZWxzZSB7XG4gICAgLy8gU3RlcCA2LmE6IE5hTiA9PSBOYU5cbiAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICB9XG59XG5cbi8qKlxuICogUGVyZm9ybXMgZXF1YWxpdHkgYnkgaXRlcmF0aW5nIHRocm91Z2gga2V5cyBvbiBhbiBvYmplY3QgYW5kIHJldHVybmluZyBmYWxzZVxuICogd2hlbiBhbnkga2V5IGhhcyB2YWx1ZXMgd2hpY2ggYXJlIG5vdCBzdHJpY3RseSBlcXVhbCBiZXR3ZWVuIHRoZSBhcmd1bWVudHMuXG4gKiBSZXR1cm5zIHRydWUgd2hlbiB0aGUgdmFsdWVzIG9mIGFsbCBrZXlzIGFyZSBzdHJpY3RseSBlcXVhbC5cbiAqL1xuZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iakEsIG9iakIpIHtcbiAgaWYgKGlzKG9iakEsIG9iakIpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iakEgIT09ICdvYmplY3QnIHx8IG9iakEgPT09IG51bGwgfHwgdHlwZW9mIG9iakIgIT09ICdvYmplY3QnIHx8IG9iakIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhvYmpBKTtcbiAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMob2JqQik7XG5cbiAgaWYgKGtleXNBLmxlbmd0aCAhPT0ga2V5c0IubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gVGVzdCBmb3IgQSdzIGtleXMgZGlmZmVyZW50IGZyb20gQi5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzQS5sZW5ndGg7IGkrKykge1xuICAgIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChvYmpCLCBrZXlzQVtpXSkgfHwgIWlzKG9iakFba2V5c0FbaV1dLCBvYmpCW2tleXNBW2ldXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaGFsbG93RXF1YWw7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvc2hhbGxvd0VxdWFsLmpzXG4vLyBtb2R1bGUgaWQgPSAxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///13\n");

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nvar isTextNode = __webpack_require__(27);\n\n/*eslint-disable no-bitwise */\n\n/**\n * Checks if a given DOM node contains or is another DOM node.\n */\nfunction containsNode(outerNode, innerNode) {\n  if (!outerNode || !innerNode) {\n    return false;\n  } else if (outerNode === innerNode) {\n    return true;\n  } else if (isTextNode(outerNode)) {\n    return false;\n  } else if (isTextNode(innerNode)) {\n    return containsNode(outerNode, innerNode.parentNode);\n  } else if ('contains' in outerNode) {\n    return outerNode.contains(innerNode);\n  } else if (outerNode.compareDocumentPosition) {\n    return !!(outerNode.compareDocumentPosition(innerNode) & 16);\n  } else {\n    return false;\n  }\n}\n\nmodule.exports = containsNode;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvY29udGFpbnNOb2RlLmpzP2Q4MWYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICovXG5cbnZhciBpc1RleHROb2RlID0gcmVxdWlyZSgnLi9pc1RleHROb2RlJyk7XG5cbi8qZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGdpdmVuIERPTSBub2RlIGNvbnRhaW5zIG9yIGlzIGFub3RoZXIgRE9NIG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGNvbnRhaW5zTm9kZShvdXRlck5vZGUsIGlubmVyTm9kZSkge1xuICBpZiAoIW91dGVyTm9kZSB8fCAhaW5uZXJOb2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2UgaWYgKG91dGVyTm9kZSA9PT0gaW5uZXJOb2RlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoaXNUZXh0Tm9kZShvdXRlck5vZGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2UgaWYgKGlzVGV4dE5vZGUoaW5uZXJOb2RlKSkge1xuICAgIHJldHVybiBjb250YWluc05vZGUob3V0ZXJOb2RlLCBpbm5lck5vZGUucGFyZW50Tm9kZSk7XG4gIH0gZWxzZSBpZiAoJ2NvbnRhaW5zJyBpbiBvdXRlck5vZGUpIHtcbiAgICByZXR1cm4gb3V0ZXJOb2RlLmNvbnRhaW5zKGlubmVyTm9kZSk7XG4gIH0gZWxzZSBpZiAob3V0ZXJOb2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuICEhKG91dGVyTm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihpbm5lck5vZGUpICYgMTYpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRhaW5zTm9kZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9jb250YWluc05vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///14\n");

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n/**\n * @param {DOMElement} node input/textarea to focus\n */\n\nfunction focusNode(node) {\n  // IE8 can throw \"Can't move focus to the control because it is invisible,\n  // not enabled, or of a type that does not accept the focus.\" for all kinds of\n  // reasons that are too expensive and fragile to test.\n  try {\n    node.focus();\n  } catch (e) {}\n}\n\nmodule.exports = focusNode;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZm9jdXNOb2RlLmpzPzI1MzgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZSBpbnB1dC90ZXh0YXJlYSB0byBmb2N1c1xuICovXG5cbmZ1bmN0aW9uIGZvY3VzTm9kZShub2RlKSB7XG4gIC8vIElFOCBjYW4gdGhyb3cgXCJDYW4ndCBtb3ZlIGZvY3VzIHRvIHRoZSBjb250cm9sIGJlY2F1c2UgaXQgaXMgaW52aXNpYmxlLFxuICAvLyBub3QgZW5hYmxlZCwgb3Igb2YgYSB0eXBlIHRoYXQgZG9lcyBub3QgYWNjZXB0IHRoZSBmb2N1cy5cIiBmb3IgYWxsIGtpbmRzIG9mXG4gIC8vIHJlYXNvbnMgdGhhdCBhcmUgdG9vIGV4cGVuc2l2ZSBhbmQgZnJhZ2lsZSB0byB0ZXN0LlxuICB0cnkge1xuICAgIG5vZGUuZm9jdXMoKTtcbiAgfSBjYXRjaCAoZSkge31cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmb2N1c05vZGU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZm9jdXNOb2RlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///15\n");

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nif (process.env.NODE_ENV !== 'production') {\n  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&\n    Symbol.for &&\n    Symbol.for('react.element')) ||\n    0xeac7;\n\n  var isValidElement = function(object) {\n    return typeof object === 'object' &&\n      object !== null &&\n      object.$$typeof === REACT_ELEMENT_TYPE;\n  };\n\n  // By explicitly using `prop-types` you are opting into new development behavior.\n  // http://fb.me/prop-types-in-prod\n  var throwOnDirectAccess = true;\n  module.exports = __webpack_require__(43)(isValidElement, throwOnDirectAccess);\n} else {\n  // By explicitly using `prop-types` you are opting into new production behavior.\n  // http://fb.me/prop-types-in-prod\n  module.exports = __webpack_require__(44)();\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9pbmRleC5qcz8yOTIxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9ICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmXG4gICAgU3ltYm9sLmZvciAmJlxuICAgIFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSkgfHxcbiAgICAweGVhYzc7XG5cbiAgdmFyIGlzVmFsaWRFbGVtZW50ID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICBvYmplY3QgIT09IG51bGwgJiZcbiAgICAgIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xuICB9O1xuXG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IGRldmVsb3BtZW50IGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIHZhciB0aHJvd09uRGlyZWN0QWNjZXNzID0gdHJ1ZTtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzJykoaXNWYWxpZEVsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpO1xufSBlbHNlIHtcbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgcHJvZHVjdGlvbiBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zJykoKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///16\n");

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = findTabbableDescendants;\n/*!\n * Adapted from jQuery UI core\n *\n * http://jqueryui.com\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/category/ui-core/\n */\n\nvar tabbableNode = /input|select|textarea|button|object/;\n\nfunction hidesContents(element) {\n  var zeroSize = element.offsetWidth <= 0 && element.offsetHeight <= 0;\n\n  // If the node is empty, this is good enough\n  if (zeroSize && !element.innerHTML) return true;\n\n  // Otherwise we need to check some styles\n  var style = window.getComputedStyle(element);\n  return zeroSize ? style.getPropertyValue(\"overflow\") !== \"visible\" : style.getPropertyValue(\"display\") == \"none\";\n}\n\nfunction visible(element) {\n  var parentElement = element;\n  while (parentElement) {\n    if (parentElement === document.body) break;\n    if (hidesContents(parentElement)) return false;\n    parentElement = parentElement.parentNode;\n  }\n  return true;\n}\n\nfunction focusable(element, isTabIndexNotNaN) {\n  var nodeName = element.nodeName.toLowerCase();\n  var res = tabbableNode.test(nodeName) && !element.disabled || (nodeName === \"a\" ? element.href || isTabIndexNotNaN : isTabIndexNotNaN);\n  return res && visible(element);\n}\n\nfunction tabbable(element) {\n  var tabIndex = element.getAttribute(\"tabindex\");\n  if (tabIndex === null) tabIndex = undefined;\n  var isTabIndexNaN = isNaN(tabIndex);\n  return (isTabIndexNaN || tabIndex >= 0) && focusable(element, !isTabIndexNaN);\n}\n\nfunction findTabbableDescendants(element) {\n  return [].slice.call(element.querySelectorAll(\"*\"), 0).filter(tabbable);\n}\nmodule.exports = exports[\"default\"];//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtbW9kYWwvbGliL2hlbHBlcnMvdGFiYmFibGUuanM/MDcwNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGZpbmRUYWJiYWJsZURlc2NlbmRhbnRzO1xuLyohXG4gKiBBZGFwdGVkIGZyb20galF1ZXJ5IFVJIGNvcmVcbiAqXG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IDIwMTQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL2NhdGVnb3J5L3VpLWNvcmUvXG4gKi9cblxudmFyIHRhYmJhYmxlTm9kZSA9IC9pbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9ufG9iamVjdC87XG5cbmZ1bmN0aW9uIGhpZGVzQ29udGVudHMoZWxlbWVudCkge1xuICB2YXIgemVyb1NpemUgPSBlbGVtZW50Lm9mZnNldFdpZHRoIDw9IDAgJiYgZWxlbWVudC5vZmZzZXRIZWlnaHQgPD0gMDtcblxuICAvLyBJZiB0aGUgbm9kZSBpcyBlbXB0eSwgdGhpcyBpcyBnb29kIGVub3VnaFxuICBpZiAoemVyb1NpemUgJiYgIWVsZW1lbnQuaW5uZXJIVE1MKSByZXR1cm4gdHJ1ZTtcblxuICAvLyBPdGhlcndpc2Ugd2UgbmVlZCB0byBjaGVjayBzb21lIHN0eWxlc1xuICB2YXIgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgcmV0dXJuIHplcm9TaXplID8gc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShcIm92ZXJmbG93XCIpICE9PSBcInZpc2libGVcIiA6IHN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCJkaXNwbGF5XCIpID09IFwibm9uZVwiO1xufVxuXG5mdW5jdGlvbiB2aXNpYmxlKGVsZW1lbnQpIHtcbiAgdmFyIHBhcmVudEVsZW1lbnQgPSBlbGVtZW50O1xuICB3aGlsZSAocGFyZW50RWxlbWVudCkge1xuICAgIGlmIChwYXJlbnRFbGVtZW50ID09PSBkb2N1bWVudC5ib2R5KSBicmVhaztcbiAgICBpZiAoaGlkZXNDb250ZW50cyhwYXJlbnRFbGVtZW50KSkgcmV0dXJuIGZhbHNlO1xuICAgIHBhcmVudEVsZW1lbnQgPSBwYXJlbnRFbGVtZW50LnBhcmVudE5vZGU7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGZvY3VzYWJsZShlbGVtZW50LCBpc1RhYkluZGV4Tm90TmFOKSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgdmFyIHJlcyA9IHRhYmJhYmxlTm9kZS50ZXN0KG5vZGVOYW1lKSAmJiAhZWxlbWVudC5kaXNhYmxlZCB8fCAobm9kZU5hbWUgPT09IFwiYVwiID8gZWxlbWVudC5ocmVmIHx8IGlzVGFiSW5kZXhOb3ROYU4gOiBpc1RhYkluZGV4Tm90TmFOKTtcbiAgcmV0dXJuIHJlcyAmJiB2aXNpYmxlKGVsZW1lbnQpO1xufVxuXG5mdW5jdGlvbiB0YWJiYWJsZShlbGVtZW50KSB7XG4gIHZhciB0YWJJbmRleCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIik7XG4gIGlmICh0YWJJbmRleCA9PT0gbnVsbCkgdGFiSW5kZXggPSB1bmRlZmluZWQ7XG4gIHZhciBpc1RhYkluZGV4TmFOID0gaXNOYU4odGFiSW5kZXgpO1xuICByZXR1cm4gKGlzVGFiSW5kZXhOYU4gfHwgdGFiSW5kZXggPj0gMCkgJiYgZm9jdXNhYmxlKGVsZW1lbnQsICFpc1RhYkluZGV4TmFOKTtcbn1cblxuZnVuY3Rpb24gZmluZFRhYmJhYmxlRGVzY2VuZGFudHMoZWxlbWVudCkge1xuICByZXR1cm4gW10uc2xpY2UuY2FsbChlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIqXCIpLCAwKS5maWx0ZXIodGFiYmFibGUpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1tb2RhbC9saWIvaGVscGVycy90YWJiYWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///17\n");

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.assertNodeList = assertNodeList;\nexports.setElement = setElement;\nexports.validateElement = validateElement;\nexports.hide = hide;\nexports.show = show;\nexports.documentNotReadyOrSSRTesting = documentNotReadyOrSSRTesting;\nexports.resetForTesting = resetForTesting;\n\nvar _warning = __webpack_require__(48);\n\nvar _warning2 = _interopRequireDefault(_warning);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar globalElement = null;\n\nfunction assertNodeList(nodeList, selector) {\n  if (!nodeList || !nodeList.length) {\n    throw new Error(\"react-modal: No elements were found for selector \" + selector + \".\");\n  }\n}\n\nfunction setElement(element) {\n  var useElement = element;\n  if (typeof useElement === \"string\") {\n    var el = document.querySelectorAll(useElement);\n    assertNodeList(el, useElement);\n    useElement = \"length\" in el ? el[0] : el;\n  }\n  globalElement = useElement || globalElement;\n  return globalElement;\n}\n\nfunction validateElement(appElement) {\n  if (!appElement && !globalElement) {\n    (0, _warning2.default)(false, [\"react-modal: App element is not defined.\", \"Please use `Modal.setAppElement(el)` or set `appElement={el}`.\", \"This is needed so screen readers don't see main content\", \"when modal is opened. It is not recommended, but you can opt-out\", \"by setting `ariaHideApp={false}`.\"].join(\" \"));\n\n    return false;\n  }\n\n  return true;\n}\n\nfunction hide(appElement) {\n  if (validateElement(appElement)) {\n    (appElement || globalElement).setAttribute(\"aria-hidden\", \"true\");\n  }\n}\n\nfunction show(appElement) {\n  if (validateElement(appElement)) {\n    (appElement || globalElement).removeAttribute(\"aria-hidden\");\n  }\n}\n\nfunction documentNotReadyOrSSRTesting() {\n  globalElement = null;\n}\n\nfunction resetForTesting() {\n  globalElement = null;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtbW9kYWwvbGliL2hlbHBlcnMvYXJpYUFwcEhpZGVyLmpzP2Q3MDEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmFzc2VydE5vZGVMaXN0ID0gYXNzZXJ0Tm9kZUxpc3Q7XG5leHBvcnRzLnNldEVsZW1lbnQgPSBzZXRFbGVtZW50O1xuZXhwb3J0cy52YWxpZGF0ZUVsZW1lbnQgPSB2YWxpZGF0ZUVsZW1lbnQ7XG5leHBvcnRzLmhpZGUgPSBoaWRlO1xuZXhwb3J0cy5zaG93ID0gc2hvdztcbmV4cG9ydHMuZG9jdW1lbnROb3RSZWFkeU9yU1NSVGVzdGluZyA9IGRvY3VtZW50Tm90UmVhZHlPclNTUlRlc3Rpbmc7XG5leHBvcnRzLnJlc2V0Rm9yVGVzdGluZyA9IHJlc2V0Rm9yVGVzdGluZztcblxudmFyIF93YXJuaW5nID0gcmVxdWlyZShcIndhcm5pbmdcIik7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGdsb2JhbEVsZW1lbnQgPSBudWxsO1xuXG5mdW5jdGlvbiBhc3NlcnROb2RlTGlzdChub2RlTGlzdCwgc2VsZWN0b3IpIHtcbiAgaWYgKCFub2RlTGlzdCB8fCAhbm9kZUxpc3QubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwicmVhY3QtbW9kYWw6IE5vIGVsZW1lbnRzIHdlcmUgZm91bmQgZm9yIHNlbGVjdG9yIFwiICsgc2VsZWN0b3IgKyBcIi5cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0RWxlbWVudChlbGVtZW50KSB7XG4gIHZhciB1c2VFbGVtZW50ID0gZWxlbWVudDtcbiAgaWYgKHR5cGVvZiB1c2VFbGVtZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgdmFyIGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCh1c2VFbGVtZW50KTtcbiAgICBhc3NlcnROb2RlTGlzdChlbCwgdXNlRWxlbWVudCk7XG4gICAgdXNlRWxlbWVudCA9IFwibGVuZ3RoXCIgaW4gZWwgPyBlbFswXSA6IGVsO1xuICB9XG4gIGdsb2JhbEVsZW1lbnQgPSB1c2VFbGVtZW50IHx8IGdsb2JhbEVsZW1lbnQ7XG4gIHJldHVybiBnbG9iYWxFbGVtZW50O1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUVsZW1lbnQoYXBwRWxlbWVudCkge1xuICBpZiAoIWFwcEVsZW1lbnQgJiYgIWdsb2JhbEVsZW1lbnQpIHtcbiAgICAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCBbXCJyZWFjdC1tb2RhbDogQXBwIGVsZW1lbnQgaXMgbm90IGRlZmluZWQuXCIsIFwiUGxlYXNlIHVzZSBgTW9kYWwuc2V0QXBwRWxlbWVudChlbClgIG9yIHNldCBgYXBwRWxlbWVudD17ZWx9YC5cIiwgXCJUaGlzIGlzIG5lZWRlZCBzbyBzY3JlZW4gcmVhZGVycyBkb24ndCBzZWUgbWFpbiBjb250ZW50XCIsIFwid2hlbiBtb2RhbCBpcyBvcGVuZWQuIEl0IGlzIG5vdCByZWNvbW1lbmRlZCwgYnV0IHlvdSBjYW4gb3B0LW91dFwiLCBcImJ5IHNldHRpbmcgYGFyaWFIaWRlQXBwPXtmYWxzZX1gLlwiXS5qb2luKFwiIFwiKSk7XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaGlkZShhcHBFbGVtZW50KSB7XG4gIGlmICh2YWxpZGF0ZUVsZW1lbnQoYXBwRWxlbWVudCkpIHtcbiAgICAoYXBwRWxlbWVudCB8fCBnbG9iYWxFbGVtZW50KS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdyhhcHBFbGVtZW50KSB7XG4gIGlmICh2YWxpZGF0ZUVsZW1lbnQoYXBwRWxlbWVudCkpIHtcbiAgICAoYXBwRWxlbWVudCB8fCBnbG9iYWxFbGVtZW50KS5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkb2N1bWVudE5vdFJlYWR5T3JTU1JUZXN0aW5nKCkge1xuICBnbG9iYWxFbGVtZW50ID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gcmVzZXRGb3JUZXN0aW5nKCkge1xuICBnbG9iYWxFbGVtZW50ID0gbnVsbDtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1tb2RhbC9saWIvaGVscGVycy9hcmlhQXBwSGlkZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///18\n");

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.get = get;\nexports.add = add;\nexports.remove = remove;\nexports.totalCount = totalCount;\nvar classListMap = {};\n\nfunction get() {\n  return classListMap;\n}\n\nfunction add(bodyClass) {\n  // Set variable and default if none\n  if (!classListMap[bodyClass]) {\n    classListMap[bodyClass] = 0;\n  }\n  classListMap[bodyClass] += 1;\n  return bodyClass;\n}\n\nfunction remove(bodyClass) {\n  if (classListMap[bodyClass]) {\n    classListMap[bodyClass] -= 1;\n  }\n  return bodyClass;\n}\n\nfunction totalCount() {\n  return Object.keys(classListMap).reduce(function (acc, curr) {\n    return acc + classListMap[curr];\n  }, 0);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtbW9kYWwvbGliL2hlbHBlcnMvcmVmQ291bnQuanM/Mjg5MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZ2V0ID0gZ2V0O1xuZXhwb3J0cy5hZGQgPSBhZGQ7XG5leHBvcnRzLnJlbW92ZSA9IHJlbW92ZTtcbmV4cG9ydHMudG90YWxDb3VudCA9IHRvdGFsQ291bnQ7XG52YXIgY2xhc3NMaXN0TWFwID0ge307XG5cbmZ1bmN0aW9uIGdldCgpIHtcbiAgcmV0dXJuIGNsYXNzTGlzdE1hcDtcbn1cblxuZnVuY3Rpb24gYWRkKGJvZHlDbGFzcykge1xuICAvLyBTZXQgdmFyaWFibGUgYW5kIGRlZmF1bHQgaWYgbm9uZVxuICBpZiAoIWNsYXNzTGlzdE1hcFtib2R5Q2xhc3NdKSB7XG4gICAgY2xhc3NMaXN0TWFwW2JvZHlDbGFzc10gPSAwO1xuICB9XG4gIGNsYXNzTGlzdE1hcFtib2R5Q2xhc3NdICs9IDE7XG4gIHJldHVybiBib2R5Q2xhc3M7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZShib2R5Q2xhc3MpIHtcbiAgaWYgKGNsYXNzTGlzdE1hcFtib2R5Q2xhc3NdKSB7XG4gICAgY2xhc3NMaXN0TWFwW2JvZHlDbGFzc10gLT0gMTtcbiAgfVxuICByZXR1cm4gYm9keUNsYXNzO1xufVxuXG5mdW5jdGlvbiB0b3RhbENvdW50KCkge1xuICByZXR1cm4gT2JqZWN0LmtleXMoY2xhc3NMaXN0TWFwKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgY3Vycikge1xuICAgIHJldHVybiBhY2MgKyBjbGFzc0xpc3RNYXBbY3Vycl07XG4gIH0sIDApO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LW1vZGFsL2xpYi9oZWxwZXJzL3JlZkNvdW50LmpzXG4vLyBtb2R1bGUgaWQgPSAxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///19\n");

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.canUseDOM = undefined;\n\nvar _exenv = __webpack_require__(50);\n\nvar _exenv2 = _interopRequireDefault(_exenv);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar EE = _exenv2.default;\n\nvar SafeHTMLElement = EE.canUseDOM ? window.HTMLElement : {};\n\nvar canUseDOM = exports.canUseDOM = EE.canUseDOM;\n\nexports.default = SafeHTMLElement;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtbW9kYWwvbGliL2hlbHBlcnMvc2FmZUhUTUxFbGVtZW50LmpzPzMxMTQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmNhblVzZURPTSA9IHVuZGVmaW5lZDtcblxudmFyIF9leGVudiA9IHJlcXVpcmUoXCJleGVudlwiKTtcblxudmFyIF9leGVudjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9leGVudik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBFRSA9IF9leGVudjIuZGVmYXVsdDtcblxudmFyIFNhZmVIVE1MRWxlbWVudCA9IEVFLmNhblVzZURPTSA/IHdpbmRvdy5IVE1MRWxlbWVudCA6IHt9O1xuXG52YXIgY2FuVXNlRE9NID0gZXhwb3J0cy5jYW5Vc2VET00gPSBFRS5jYW5Vc2VET007XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFNhZmVIVE1MRWxlbWVudDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1tb2RhbC9saWIvaGVscGVycy9zYWZlSFRNTEVsZW1lbnQuanNcbi8vIG1vZHVsZSBpZCA9IDIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///20\n");

/***/ }),
/* 21 */
/***/ (function(module, exports) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanM/MTU5ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXNlU291cmNlTWFwKSB7XG5cdHZhciBsaXN0ID0gW107XG5cblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHR2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblx0XHRcdGlmKGl0ZW1bMl0pIHtcblx0XHRcdFx0cmV0dXJuIFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgY29udGVudCArIFwifVwiO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdFx0XHR9XG5cdFx0fSkuam9pbihcIlwiKTtcblx0fTtcblxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuXHRcdH1cblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcblx0dmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnO1xuXHR2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cdGlmICghY3NzTWFwcGluZykge1xuXHRcdHJldHVybiBjb250ZW50O1xuXHR9XG5cblx0aWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuXHRcdHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0XHRyZXR1cm4gJy8qIyBzb3VyY2VVUkw9JyArIGNzc01hcHBpbmcuc291cmNlUm9vdCArIHNvdXJjZSArICcgKi8nXG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXG4nKTtcblx0fVxuXG5cdHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59XG5cbi8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG5cdHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuXHR2YXIgZGF0YSA9ICdzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCwnICsgYmFzZTY0O1xuXG5cdHJldHVybiAnLyojICcgKyBkYXRhICsgJyAqLyc7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1xuLy8gbW9kdWxlIGlkID0gMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///21\n");

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(selector) {\n\t\tif (typeof memo[selector] === \"undefined\") {\n\t\t\tvar styleTarget = fn.call(this, selector);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[selector] = styleTarget;\n\t\t}\n\t\treturn memo[selector]\n\t};\n})(function (target) {\n\treturn document.querySelector(target)\n});\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = __webpack_require__(53);\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== \"boolean\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n\tif (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === \"object\" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertInto + \" \" + options.insertAt.before);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\toptions.attrs.type = \"text/css\";\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\toptions.attrs.type = \"text/css\";\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = options.transform(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanM/MzEzMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuXG52YXIgc3R5bGVzSW5Eb20gPSB7fTtcblxudmFyXHRtZW1vaXplID0gZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHR5cGVvZiBtZW1vID09PSBcInVuZGVmaW5lZFwiKSBtZW1vID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbWVtbztcblx0fTtcbn07XG5cbnZhciBpc09sZElFID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XG5cdC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG5cdC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcblx0Ly8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlclxuXHQvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcblx0Ly8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XG5cdHJldHVybiB3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYjtcbn0pO1xuXG52YXIgZ2V0RWxlbWVudCA9IChmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW8gPSB7fTtcblxuXHRyZXR1cm4gZnVuY3Rpb24oc2VsZWN0b3IpIHtcblx0XHRpZiAodHlwZW9mIG1lbW9bc2VsZWN0b3JdID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHR2YXIgc3R5bGVUYXJnZXQgPSBmbi5jYWxsKHRoaXMsIHNlbGVjdG9yKTtcblx0XHRcdC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG5cdFx0XHRpZiAoc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHQvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuXHRcdFx0XHRcdC8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXG5cdFx0XHRcdFx0c3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcblx0XHRcdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRcdFx0c3R5bGVUYXJnZXQgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRtZW1vW3NlbGVjdG9yXSA9IHN0eWxlVGFyZ2V0O1xuXHRcdH1cblx0XHRyZXR1cm4gbWVtb1tzZWxlY3Rvcl1cblx0fTtcbn0pKGZ1bmN0aW9uICh0YXJnZXQpIHtcblx0cmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KVxufSk7XG5cbnZhciBzaW5nbGV0b24gPSBudWxsO1xudmFyXHRzaW5nbGV0b25Db3VudGVyID0gMDtcbnZhclx0c3R5bGVzSW5zZXJ0ZWRBdFRvcCA9IFtdO1xuXG52YXJcdGZpeFVybHMgPSByZXF1aXJlKFwiLi91cmxzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcblx0aWYgKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xuXHRcdGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudFwiKTtcblx0fVxuXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdG9wdGlvbnMuYXR0cnMgPSB0eXBlb2Ygb3B0aW9ucy5hdHRycyA9PT0gXCJvYmplY3RcIiA/IG9wdGlvbnMuYXR0cnMgOiB7fTtcblxuXHQvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cblx0Ly8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuXHRpZiAoIW9wdGlvbnMuc2luZ2xldG9uICYmIHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiAhPT0gXCJib29sZWFuXCIpIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIDxoZWFkPiBlbGVtZW50XG5cdGlmICghb3B0aW9ucy5pbnNlcnRJbnRvKSBvcHRpb25zLmluc2VydEludG8gPSBcImhlYWRcIjtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSBib3R0b20gb2YgdGhlIHRhcmdldFxuXHRpZiAoIW9wdGlvbnMuaW5zZXJ0QXQpIG9wdGlvbnMuaW5zZXJ0QXQgPSBcImJvdHRvbVwiO1xuXG5cdHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCwgb3B0aW9ucyk7XG5cblx0YWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlIChuZXdMaXN0KSB7XG5cdFx0dmFyIG1heVJlbW92ZSA9IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRcdGRvbVN0eWxlLnJlZnMtLTtcblx0XHRcdG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKTtcblx0XHR9XG5cblx0XHRpZihuZXdMaXN0KSB7XG5cdFx0XHR2YXIgbmV3U3R5bGVzID0gbGlzdFRvU3R5bGVzKG5ld0xpc3QsIG9wdGlvbnMpO1xuXHRcdFx0YWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldO1xuXG5cdFx0XHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIGRvbVN0eWxlLnBhcnRzW2pdKCk7XG5cblx0XHRcdFx0ZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59O1xuXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbSAoc3R5bGVzLCBvcHRpb25zKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRpZihkb21TdHlsZSkge1xuXHRcdFx0ZG9tU3R5bGUucmVmcysrO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XG5cdFx0XHR9XG5cblx0XHRcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcGFydHMgPSBbXTtcblxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0cGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cblx0XHRcdHN0eWxlc0luRG9tW2l0ZW0uaWRdID0ge2lkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHN9O1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMgKGxpc3QsIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlcyA9IFtdO1xuXHR2YXIgbmV3U3R5bGVzID0ge307XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBsaXN0W2ldO1xuXHRcdHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuXHRcdHZhciBjc3MgPSBpdGVtWzFdO1xuXHRcdHZhciBtZWRpYSA9IGl0ZW1bMl07XG5cdFx0dmFyIHNvdXJjZU1hcCA9IGl0ZW1bM107XG5cdFx0dmFyIHBhcnQgPSB7Y3NzOiBjc3MsIG1lZGlhOiBtZWRpYSwgc291cmNlTWFwOiBzb3VyY2VNYXB9O1xuXG5cdFx0aWYoIW5ld1N0eWxlc1tpZF0pIHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7aWQ6IGlkLCBwYXJ0czogW3BhcnRdfSk7XG5cdFx0ZWxzZSBuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XG5cdH1cblxuXHRyZXR1cm4gc3R5bGVzO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQgKG9wdGlvbnMsIHN0eWxlKSB7XG5cdHZhciB0YXJnZXQgPSBnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0SW50bylcblxuXHRpZiAoIXRhcmdldCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0SW50bycgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuXHR9XG5cblx0dmFyIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcFtzdHlsZXNJbnNlcnRlZEF0VG9wLmxlbmd0aCAtIDFdO1xuXG5cdGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcInRvcFwiKSB7XG5cdFx0aWYgKCFsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCkge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgdGFyZ2V0LmZpcnN0Q2hpbGQpO1xuXHRcdH0gZWxzZSBpZiAobGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpIHtcblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0XHR9XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5wdXNoKHN0eWxlKTtcblx0fSBlbHNlIGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcImJvdHRvbVwiKSB7XG5cdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0fSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJvYmplY3RcIiAmJiBvcHRpb25zLmluc2VydEF0LmJlZm9yZSkge1xuXHRcdHZhciBuZXh0U2libGluZyA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRJbnRvICsgXCIgXCIgKyBvcHRpb25zLmluc2VydEF0LmJlZm9yZSk7XG5cdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgbmV4dFNpYmxpbmcpO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIltTdHlsZSBMb2FkZXJdXFxuXFxuIEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnaW5zZXJ0QXQnICgnb3B0aW9ucy5pbnNlcnRBdCcpIGZvdW5kLlxcbiBNdXN0IGJlICd0b3AnLCAnYm90dG9tJywgb3IgT2JqZWN0LlxcbiAoaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIjaW5zZXJ0YXQpXFxuXCIpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudCAoc3R5bGUpIHtcblx0aWYgKHN0eWxlLnBhcmVudE5vZGUgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblx0c3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG5cblx0dmFyIGlkeCA9IHN0eWxlc0luc2VydGVkQXRUb3AuaW5kZXhPZihzdHlsZSk7XG5cdGlmKGlkeCA+PSAwKSB7XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5zcGxpY2UoaWR4LCAxKTtcblx0fVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuXG5cdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcblxuXHRhZGRBdHRycyhzdHlsZSwgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZSk7XG5cblx0cmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMaW5rRWxlbWVudCAob3B0aW9ucykge1xuXHR2YXIgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xuXG5cdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcblx0b3B0aW9ucy5hdHRycy5yZWwgPSBcInN0eWxlc2hlZXRcIjtcblxuXHRhZGRBdHRycyhsaW5rLCBvcHRpb25zLmF0dHJzKTtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIGxpbmspO1xuXG5cdHJldHVybiBsaW5rO1xufVxuXG5mdW5jdGlvbiBhZGRBdHRycyAoZWwsIGF0dHJzKSB7XG5cdE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRlbC5zZXRBdHRyaWJ1dGUoa2V5LCBhdHRyc1trZXldKTtcblx0fSk7XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlIChvYmosIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlLCB1cGRhdGUsIHJlbW92ZSwgcmVzdWx0O1xuXG5cdC8vIElmIGEgdHJhbnNmb3JtIGZ1bmN0aW9uIHdhcyBkZWZpbmVkLCBydW4gaXQgb24gdGhlIGNzc1xuXHRpZiAob3B0aW9ucy50cmFuc2Zvcm0gJiYgb2JqLmNzcykge1xuXHQgICAgcmVzdWx0ID0gb3B0aW9ucy50cmFuc2Zvcm0ob2JqLmNzcyk7XG5cblx0ICAgIGlmIChyZXN1bHQpIHtcblx0ICAgIFx0Ly8gSWYgdHJhbnNmb3JtIHJldHVybnMgYSB2YWx1ZSwgdXNlIHRoYXQgaW5zdGVhZCBvZiB0aGUgb3JpZ2luYWwgY3NzLlxuXHQgICAgXHQvLyBUaGlzIGFsbG93cyBydW5uaW5nIHJ1bnRpbWUgdHJhbnNmb3JtYXRpb25zIG9uIHRoZSBjc3MuXG5cdCAgICBcdG9iai5jc3MgPSByZXN1bHQ7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgXHQvLyBJZiB0aGUgdHJhbnNmb3JtIGZ1bmN0aW9uIHJldHVybnMgYSBmYWxzeSB2YWx1ZSwgZG9uJ3QgYWRkIHRoaXMgY3NzLlxuXHQgICAgXHQvLyBUaGlzIGFsbG93cyBjb25kaXRpb25hbCBsb2FkaW5nIG9mIGNzc1xuXHQgICAgXHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdCAgICBcdFx0Ly8gbm9vcFxuXHQgICAgXHR9O1xuXHQgICAgfVxuXHR9XG5cblx0aWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XG5cdFx0dmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XG5cblx0XHRzdHlsZSA9IHNpbmdsZXRvbiB8fCAoc2luZ2xldG9uID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcblxuXHRcdHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgZmFsc2UpO1xuXHRcdHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgdHJ1ZSk7XG5cblx0fSBlbHNlIGlmIChcblx0XHRvYmouc291cmNlTWFwICYmXG5cdFx0dHlwZW9mIFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5jcmVhdGVPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwucmV2b2tlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgQmxvYiA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIGJ0b2EgPT09IFwiZnVuY3Rpb25cIlxuXHQpIHtcblx0XHRzdHlsZSA9IGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpO1xuXHRcdHVwZGF0ZSA9IHVwZGF0ZUxpbmsuYmluZChudWxsLCBzdHlsZSwgb3B0aW9ucyk7XG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcblxuXHRcdFx0aWYoc3R5bGUuaHJlZikgVVJMLnJldm9rZU9iamVjdFVSTChzdHlsZS5ocmVmKTtcblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdHN0eWxlID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuXHRcdHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZSk7XG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcblx0XHR9O1xuXHR9XG5cblx0dXBkYXRlKG9iaik7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlIChuZXdPYmopIHtcblx0XHRpZiAobmV3T2JqKSB7XG5cdFx0XHRpZiAoXG5cdFx0XHRcdG5ld09iai5jc3MgPT09IG9iai5jc3MgJiZcblx0XHRcdFx0bmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiZcblx0XHRcdFx0bmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcFxuXHRcdFx0KSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dXBkYXRlKG9iaiA9IG5ld09iaik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlbW92ZSgpO1xuXHRcdH1cblx0fTtcbn1cblxudmFyIHJlcGxhY2VUZXh0ID0gKGZ1bmN0aW9uICgpIHtcblx0dmFyIHRleHRTdG9yZSA9IFtdO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG5cdFx0dGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xuXG5cdFx0cmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XG5cdH07XG59KSgpO1xuXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnIChzdHlsZSwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG5cdHZhciBjc3MgPSByZW1vdmUgPyBcIlwiIDogb2JqLmNzcztcblxuXHRpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuXHRcdHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xuXHR9IGVsc2Uge1xuXHRcdHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcblx0XHR2YXIgY2hpbGROb2RlcyA9IHN0eWxlLmNoaWxkTm9kZXM7XG5cblx0XHRpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHN0eWxlLnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcblxuXHRcdGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuXHRcdFx0c3R5bGUuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c3R5bGUuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VG9UYWcgKHN0eWxlLCBvYmopIHtcblx0dmFyIGNzcyA9IG9iai5jc3M7XG5cdHZhciBtZWRpYSA9IG9iai5tZWRpYTtcblxuXHRpZihtZWRpYSkge1xuXHRcdHN0eWxlLnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsIG1lZGlhKVxuXHR9XG5cblx0aWYoc3R5bGUuc3R5bGVTaGVldCkge1xuXHRcdHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcblx0fSBlbHNlIHtcblx0XHR3aGlsZShzdHlsZS5maXJzdENoaWxkKSB7XG5cdFx0XHRzdHlsZS5yZW1vdmVDaGlsZChzdHlsZS5maXJzdENoaWxkKTtcblx0XHR9XG5cblx0XHRzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcblx0fVxufVxuXG5mdW5jdGlvbiB1cGRhdGVMaW5rIChsaW5rLCBvcHRpb25zLCBvYmopIHtcblx0dmFyIGNzcyA9IG9iai5jc3M7XG5cdHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xuXG5cdC8qXG5cdFx0SWYgY29udmVydFRvQWJzb2x1dGVVcmxzIGlzbid0IGRlZmluZWQsIGJ1dCBzb3VyY2VtYXBzIGFyZSBlbmFibGVkXG5cdFx0YW5kIHRoZXJlIGlzIG5vIHB1YmxpY1BhdGggZGVmaW5lZCB0aGVuIGxldHMgdHVybiBjb252ZXJ0VG9BYnNvbHV0ZVVybHNcblx0XHRvbiBieSBkZWZhdWx0LiAgT3RoZXJ3aXNlIGRlZmF1bHQgdG8gdGhlIGNvbnZlcnRUb0Fic29sdXRlVXJscyBvcHRpb25cblx0XHRkaXJlY3RseVxuXHQqL1xuXHR2YXIgYXV0b0ZpeFVybHMgPSBvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyA9PT0gdW5kZWZpbmVkICYmIHNvdXJjZU1hcDtcblxuXHRpZiAob3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgfHwgYXV0b0ZpeFVybHMpIHtcblx0XHRjc3MgPSBmaXhVcmxzKGNzcyk7XG5cdH1cblxuXHRpZiAoc291cmNlTWFwKSB7XG5cdFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcblx0XHRjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSArIFwiICovXCI7XG5cdH1cblxuXHR2YXIgYmxvYiA9IG5ldyBCbG9iKFtjc3NdLCB7IHR5cGU6IFwidGV4dC9jc3NcIiB9KTtcblxuXHR2YXIgb2xkU3JjID0gbGluay5ocmVmO1xuXG5cdGxpbmsuaHJlZiA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG5cblx0aWYob2xkU3JjKSBVUkwucmV2b2tlT2JqZWN0VVJMKG9sZFNyYyk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1xuLy8gbW9kdWxlIGlkID0gMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///22\n");

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _react = __webpack_require__(1);\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _reactDom = __webpack_require__(9);\n\nvar _reactDom2 = _interopRequireDefault(_reactDom);\n\nvar _IndecisionApp = __webpack_require__(34);\n\nvar _IndecisionApp2 = _interopRequireDefault(_IndecisionApp);\n\n__webpack_require__(51);\n\n__webpack_require__(54);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n_reactDom2.default.render(_react2.default.createElement(_IndecisionApp2.default, null), document.getElementById('app'));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2FwcC5qcz9iZDljIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCBJbmRlY2lzaW9uQXBwIGZyb20gJy4vY29tcG9uZW50cy9JbmRlY2lzaW9uQXBwJztcbmltcG9ydCAnbm9ybWFsaXplLmNzcy9ub3JtYWxpemUuY3NzJztcbmltcG9ydCAnLi9zdHlsZXMvc3R5bGVzLnNjc3MnXG5cblxuXG5SZWFjdERPTS5yZW5kZXIoPEluZGVjaXNpb25BcHAgLz4sIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhcHAnKSlcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2FwcC5qcyJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBO0FBQUE7QUFDQTs7O0FBR0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///23\n");

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/** @license React v16.2.0\n * react.production.min.js\n *\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar m=__webpack_require__(3),n=__webpack_require__(5),p=__webpack_require__(2),q=\"function\"===typeof Symbol&&Symbol[\"for\"],r=q?Symbol[\"for\"](\"react.element\"):60103,t=q?Symbol[\"for\"](\"react.call\"):60104,u=q?Symbol[\"for\"](\"react.return\"):60105,v=q?Symbol[\"for\"](\"react.portal\"):60106,w=q?Symbol[\"for\"](\"react.fragment\"):60107,x=\"function\"===typeof Symbol&&Symbol.iterator;\nfunction y(a){for(var b=arguments.length-1,e=\"Minified React error #\"+a+\"; visit http://facebook.github.io/react/docs/error-decoder.html?invariant\\x3d\"+a,c=0;c<b;c++)e+=\"\\x26args[]\\x3d\"+encodeURIComponent(arguments[c+1]);b=Error(e+\" for the full message or use the non-minified dev environment for full errors and additional helpful warnings.\");b.name=\"Invariant Violation\";b.framesToPop=1;throw b;}\nvar z={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}};function A(a,b,e){this.props=a;this.context=b;this.refs=n;this.updater=e||z}A.prototype.isReactComponent={};A.prototype.setState=function(a,b){\"object\"!==typeof a&&\"function\"!==typeof a&&null!=a?y(\"85\"):void 0;this.updater.enqueueSetState(this,a,b,\"setState\")};A.prototype.forceUpdate=function(a){this.updater.enqueueForceUpdate(this,a,\"forceUpdate\")};\nfunction B(a,b,e){this.props=a;this.context=b;this.refs=n;this.updater=e||z}function C(){}C.prototype=A.prototype;var D=B.prototype=new C;D.constructor=B;m(D,A.prototype);D.isPureReactComponent=!0;function E(a,b,e){this.props=a;this.context=b;this.refs=n;this.updater=e||z}var F=E.prototype=new C;F.constructor=E;m(F,A.prototype);F.unstable_isAsyncReactComponent=!0;F.render=function(){return this.props.children};var G={current:null},H=Object.prototype.hasOwnProperty,I={key:!0,ref:!0,__self:!0,__source:!0};\nfunction J(a,b,e){var c,d={},g=null,k=null;if(null!=b)for(c in void 0!==b.ref&&(k=b.ref),void 0!==b.key&&(g=\"\"+b.key),b)H.call(b,c)&&!I.hasOwnProperty(c)&&(d[c]=b[c]);var f=arguments.length-2;if(1===f)d.children=e;else if(1<f){for(var h=Array(f),l=0;l<f;l++)h[l]=arguments[l+2];d.children=h}if(a&&a.defaultProps)for(c in f=a.defaultProps,f)void 0===d[c]&&(d[c]=f[c]);return{$$typeof:r,type:a,key:g,ref:k,props:d,_owner:G.current}}function K(a){return\"object\"===typeof a&&null!==a&&a.$$typeof===r}\nfunction escape(a){var b={\"\\x3d\":\"\\x3d0\",\":\":\"\\x3d2\"};return\"$\"+(\"\"+a).replace(/[=:]/g,function(a){return b[a]})}var L=/\\/+/g,M=[];function N(a,b,e,c){if(M.length){var d=M.pop();d.result=a;d.keyPrefix=b;d.func=e;d.context=c;d.count=0;return d}return{result:a,keyPrefix:b,func:e,context:c,count:0}}function O(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>M.length&&M.push(a)}\nfunction P(a,b,e,c){var d=typeof a;if(\"undefined\"===d||\"boolean\"===d)a=null;var g=!1;if(null===a)g=!0;else switch(d){case \"string\":case \"number\":g=!0;break;case \"object\":switch(a.$$typeof){case r:case t:case u:case v:g=!0}}if(g)return e(c,a,\"\"===b?\".\"+Q(a,0):b),1;g=0;b=\"\"===b?\".\":b+\":\";if(Array.isArray(a))for(var k=0;k<a.length;k++){d=a[k];var f=b+Q(d,k);g+=P(d,f,e,c)}else if(null===a||\"undefined\"===typeof a?f=null:(f=x&&a[x]||a[\"@@iterator\"],f=\"function\"===typeof f?f:null),\"function\"===typeof f)for(a=\nf.call(a),k=0;!(d=a.next()).done;)d=d.value,f=b+Q(d,k++),g+=P(d,f,e,c);else\"object\"===d&&(e=\"\"+a,y(\"31\",\"[object Object]\"===e?\"object with keys {\"+Object.keys(a).join(\", \")+\"}\":e,\"\"));return g}function Q(a,b){return\"object\"===typeof a&&null!==a&&null!=a.key?escape(a.key):b.toString(36)}function R(a,b){a.func.call(a.context,b,a.count++)}\nfunction S(a,b,e){var c=a.result,d=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?T(a,c,e,p.thatReturnsArgument):null!=a&&(K(a)&&(b=d+(!a.key||b&&b.key===a.key?\"\":(\"\"+a.key).replace(L,\"$\\x26/\")+\"/\")+e,a={$$typeof:r,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}),c.push(a))}function T(a,b,e,c,d){var g=\"\";null!=e&&(g=(\"\"+e).replace(L,\"$\\x26/\")+\"/\");b=N(b,g,c,d);null==a||P(a,\"\",S,b);O(b)}\nvar U={Children:{map:function(a,b,e){if(null==a)return a;var c=[];T(a,c,null,b,e);return c},forEach:function(a,b,e){if(null==a)return a;b=N(null,null,b,e);null==a||P(a,\"\",R,b);O(b)},count:function(a){return null==a?0:P(a,\"\",p.thatReturnsNull,null)},toArray:function(a){var b=[];T(a,b,null,p.thatReturnsArgument);return b},only:function(a){K(a)?void 0:y(\"143\");return a}},Component:A,PureComponent:B,unstable_AsyncComponent:E,Fragment:w,createElement:J,cloneElement:function(a,b,e){var c=m({},a.props),\nd=a.key,g=a.ref,k=a._owner;if(null!=b){void 0!==b.ref&&(g=b.ref,k=G.current);void 0!==b.key&&(d=\"\"+b.key);if(a.type&&a.type.defaultProps)var f=a.type.defaultProps;for(h in b)H.call(b,h)&&!I.hasOwnProperty(h)&&(c[h]=void 0===b[h]&&void 0!==f?f[h]:b[h])}var h=arguments.length-2;if(1===h)c.children=e;else if(1<h){f=Array(h);for(var l=0;l<h;l++)f[l]=arguments[l+2];c.children=f}return{$$typeof:r,type:a.type,key:d,ref:g,props:c,_owner:k}},createFactory:function(a){var b=J.bind(null,a);b.type=a;return b},\nisValidElement:K,version:\"16.2.0\",__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:{ReactCurrentOwner:G,assign:m}},V=Object.freeze({default:U}),W=V&&U||V;module.exports=W[\"default\"]?W[\"default\"]:W;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LnByb2R1Y3Rpb24ubWluLmpzP2JlZGIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi4yLjBcbiAqIHJlYWN0LnByb2R1Y3Rpb24ubWluLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO3ZhciBtPXJlcXVpcmUoXCJvYmplY3QtYXNzaWduXCIpLG49cmVxdWlyZShcImZianMvbGliL2VtcHR5T2JqZWN0XCIpLHA9cmVxdWlyZShcImZianMvbGliL2VtcHR5RnVuY3Rpb25cIikscT1cImZ1bmN0aW9uXCI9PT10eXBlb2YgU3ltYm9sJiZTeW1ib2xbXCJmb3JcIl0scj1xP1N5bWJvbFtcImZvclwiXShcInJlYWN0LmVsZW1lbnRcIik6NjAxMDMsdD1xP1N5bWJvbFtcImZvclwiXShcInJlYWN0LmNhbGxcIik6NjAxMDQsdT1xP1N5bWJvbFtcImZvclwiXShcInJlYWN0LnJldHVyblwiKTo2MDEwNSx2PXE/U3ltYm9sW1wiZm9yXCJdKFwicmVhY3QucG9ydGFsXCIpOjYwMTA2LHc9cT9TeW1ib2xbXCJmb3JcIl0oXCJyZWFjdC5mcmFnbWVudFwiKTo2MDEwNyx4PVwiZnVuY3Rpb25cIj09PXR5cGVvZiBTeW1ib2wmJlN5bWJvbC5pdGVyYXRvcjtcbmZ1bmN0aW9uIHkoYSl7Zm9yKHZhciBiPWFyZ3VtZW50cy5sZW5ndGgtMSxlPVwiTWluaWZpZWQgUmVhY3QgZXJyb3IgI1wiK2ErXCI7IHZpc2l0IGh0dHA6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy9lcnJvci1kZWNvZGVyLmh0bWw/aW52YXJpYW50XFx4M2RcIithLGM9MDtjPGI7YysrKWUrPVwiXFx4MjZhcmdzW11cXHgzZFwiK2VuY29kZVVSSUNvbXBvbmVudChhcmd1bWVudHNbYysxXSk7Yj1FcnJvcihlK1wiIGZvciB0aGUgZnVsbCBtZXNzYWdlIG9yIHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCBmb3IgZnVsbCBlcnJvcnMgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy5cIik7Yi5uYW1lPVwiSW52YXJpYW50IFZpb2xhdGlvblwiO2IuZnJhbWVzVG9Qb3A9MTt0aHJvdyBiO31cbnZhciB6PXtpc01vdW50ZWQ6ZnVuY3Rpb24oKXtyZXR1cm4hMX0sZW5xdWV1ZUZvcmNlVXBkYXRlOmZ1bmN0aW9uKCl7fSxlbnF1ZXVlUmVwbGFjZVN0YXRlOmZ1bmN0aW9uKCl7fSxlbnF1ZXVlU2V0U3RhdGU6ZnVuY3Rpb24oKXt9fTtmdW5jdGlvbiBBKGEsYixlKXt0aGlzLnByb3BzPWE7dGhpcy5jb250ZXh0PWI7dGhpcy5yZWZzPW47dGhpcy51cGRhdGVyPWV8fHp9QS5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudD17fTtBLnByb3RvdHlwZS5zZXRTdGF0ZT1mdW5jdGlvbihhLGIpe1wib2JqZWN0XCIhPT10eXBlb2YgYSYmXCJmdW5jdGlvblwiIT09dHlwZW9mIGEmJm51bGwhPWE/eShcIjg1XCIpOnZvaWQgMDt0aGlzLnVwZGF0ZXIuZW5xdWV1ZVNldFN0YXRlKHRoaXMsYSxiLFwic2V0U3RhdGVcIil9O0EucHJvdG90eXBlLmZvcmNlVXBkYXRlPWZ1bmN0aW9uKGEpe3RoaXMudXBkYXRlci5lbnF1ZXVlRm9yY2VVcGRhdGUodGhpcyxhLFwiZm9yY2VVcGRhdGVcIil9O1xuZnVuY3Rpb24gQihhLGIsZSl7dGhpcy5wcm9wcz1hO3RoaXMuY29udGV4dD1iO3RoaXMucmVmcz1uO3RoaXMudXBkYXRlcj1lfHx6fWZ1bmN0aW9uIEMoKXt9Qy5wcm90b3R5cGU9QS5wcm90b3R5cGU7dmFyIEQ9Qi5wcm90b3R5cGU9bmV3IEM7RC5jb25zdHJ1Y3Rvcj1CO20oRCxBLnByb3RvdHlwZSk7RC5pc1B1cmVSZWFjdENvbXBvbmVudD0hMDtmdW5jdGlvbiBFKGEsYixlKXt0aGlzLnByb3BzPWE7dGhpcy5jb250ZXh0PWI7dGhpcy5yZWZzPW47dGhpcy51cGRhdGVyPWV8fHp9dmFyIEY9RS5wcm90b3R5cGU9bmV3IEM7Ri5jb25zdHJ1Y3Rvcj1FO20oRixBLnByb3RvdHlwZSk7Ri51bnN0YWJsZV9pc0FzeW5jUmVhY3RDb21wb25lbnQ9ITA7Ri5yZW5kZXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbn07dmFyIEc9e2N1cnJlbnQ6bnVsbH0sSD1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LEk9e2tleTohMCxyZWY6ITAsX19zZWxmOiEwLF9fc291cmNlOiEwfTtcbmZ1bmN0aW9uIEooYSxiLGUpe3ZhciBjLGQ9e30sZz1udWxsLGs9bnVsbDtpZihudWxsIT1iKWZvcihjIGluIHZvaWQgMCE9PWIucmVmJiYoaz1iLnJlZiksdm9pZCAwIT09Yi5rZXkmJihnPVwiXCIrYi5rZXkpLGIpSC5jYWxsKGIsYykmJiFJLmhhc093blByb3BlcnR5KGMpJiYoZFtjXT1iW2NdKTt2YXIgZj1hcmd1bWVudHMubGVuZ3RoLTI7aWYoMT09PWYpZC5jaGlsZHJlbj1lO2Vsc2UgaWYoMTxmKXtmb3IodmFyIGg9QXJyYXkoZiksbD0wO2w8ZjtsKyspaFtsXT1hcmd1bWVudHNbbCsyXTtkLmNoaWxkcmVuPWh9aWYoYSYmYS5kZWZhdWx0UHJvcHMpZm9yKGMgaW4gZj1hLmRlZmF1bHRQcm9wcyxmKXZvaWQgMD09PWRbY10mJihkW2NdPWZbY10pO3JldHVybnskJHR5cGVvZjpyLHR5cGU6YSxrZXk6ZyxyZWY6ayxwcm9wczpkLF9vd25lcjpHLmN1cnJlbnR9fWZ1bmN0aW9uIEsoYSl7cmV0dXJuXCJvYmplY3RcIj09PXR5cGVvZiBhJiZudWxsIT09YSYmYS4kJHR5cGVvZj09PXJ9XG5mdW5jdGlvbiBlc2NhcGUoYSl7dmFyIGI9e1wiXFx4M2RcIjpcIlxceDNkMFwiLFwiOlwiOlwiXFx4M2QyXCJ9O3JldHVyblwiJFwiKyhcIlwiK2EpLnJlcGxhY2UoL1s9Ol0vZyxmdW5jdGlvbihhKXtyZXR1cm4gYlthXX0pfXZhciBMPS9cXC8rL2csTT1bXTtmdW5jdGlvbiBOKGEsYixlLGMpe2lmKE0ubGVuZ3RoKXt2YXIgZD1NLnBvcCgpO2QucmVzdWx0PWE7ZC5rZXlQcmVmaXg9YjtkLmZ1bmM9ZTtkLmNvbnRleHQ9YztkLmNvdW50PTA7cmV0dXJuIGR9cmV0dXJue3Jlc3VsdDphLGtleVByZWZpeDpiLGZ1bmM6ZSxjb250ZXh0OmMsY291bnQ6MH19ZnVuY3Rpb24gTyhhKXthLnJlc3VsdD1udWxsO2Eua2V5UHJlZml4PW51bGw7YS5mdW5jPW51bGw7YS5jb250ZXh0PW51bGw7YS5jb3VudD0wOzEwPk0ubGVuZ3RoJiZNLnB1c2goYSl9XG5mdW5jdGlvbiBQKGEsYixlLGMpe3ZhciBkPXR5cGVvZiBhO2lmKFwidW5kZWZpbmVkXCI9PT1kfHxcImJvb2xlYW5cIj09PWQpYT1udWxsO3ZhciBnPSExO2lmKG51bGw9PT1hKWc9ITA7ZWxzZSBzd2l0Y2goZCl7Y2FzZSBcInN0cmluZ1wiOmNhc2UgXCJudW1iZXJcIjpnPSEwO2JyZWFrO2Nhc2UgXCJvYmplY3RcIjpzd2l0Y2goYS4kJHR5cGVvZil7Y2FzZSByOmNhc2UgdDpjYXNlIHU6Y2FzZSB2Omc9ITB9fWlmKGcpcmV0dXJuIGUoYyxhLFwiXCI9PT1iP1wiLlwiK1EoYSwwKTpiKSwxO2c9MDtiPVwiXCI9PT1iP1wiLlwiOmIrXCI6XCI7aWYoQXJyYXkuaXNBcnJheShhKSlmb3IodmFyIGs9MDtrPGEubGVuZ3RoO2srKyl7ZD1hW2tdO3ZhciBmPWIrUShkLGspO2crPVAoZCxmLGUsYyl9ZWxzZSBpZihudWxsPT09YXx8XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhP2Y9bnVsbDooZj14JiZhW3hdfHxhW1wiQEBpdGVyYXRvclwiXSxmPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBmP2Y6bnVsbCksXCJmdW5jdGlvblwiPT09dHlwZW9mIGYpZm9yKGE9XG5mLmNhbGwoYSksaz0wOyEoZD1hLm5leHQoKSkuZG9uZTspZD1kLnZhbHVlLGY9YitRKGQsaysrKSxnKz1QKGQsZixlLGMpO2Vsc2VcIm9iamVjdFwiPT09ZCYmKGU9XCJcIithLHkoXCIzMVwiLFwiW29iamVjdCBPYmplY3RdXCI9PT1lP1wib2JqZWN0IHdpdGgga2V5cyB7XCIrT2JqZWN0LmtleXMoYSkuam9pbihcIiwgXCIpK1wifVwiOmUsXCJcIikpO3JldHVybiBnfWZ1bmN0aW9uIFEoYSxiKXtyZXR1cm5cIm9iamVjdFwiPT09dHlwZW9mIGEmJm51bGwhPT1hJiZudWxsIT1hLmtleT9lc2NhcGUoYS5rZXkpOmIudG9TdHJpbmcoMzYpfWZ1bmN0aW9uIFIoYSxiKXthLmZ1bmMuY2FsbChhLmNvbnRleHQsYixhLmNvdW50KyspfVxuZnVuY3Rpb24gUyhhLGIsZSl7dmFyIGM9YS5yZXN1bHQsZD1hLmtleVByZWZpeDthPWEuZnVuYy5jYWxsKGEuY29udGV4dCxiLGEuY291bnQrKyk7QXJyYXkuaXNBcnJheShhKT9UKGEsYyxlLHAudGhhdFJldHVybnNBcmd1bWVudCk6bnVsbCE9YSYmKEsoYSkmJihiPWQrKCFhLmtleXx8YiYmYi5rZXk9PT1hLmtleT9cIlwiOihcIlwiK2Eua2V5KS5yZXBsYWNlKEwsXCIkXFx4MjYvXCIpK1wiL1wiKStlLGE9eyQkdHlwZW9mOnIsdHlwZTphLnR5cGUsa2V5OmIscmVmOmEucmVmLHByb3BzOmEucHJvcHMsX293bmVyOmEuX293bmVyfSksYy5wdXNoKGEpKX1mdW5jdGlvbiBUKGEsYixlLGMsZCl7dmFyIGc9XCJcIjtudWxsIT1lJiYoZz0oXCJcIitlKS5yZXBsYWNlKEwsXCIkXFx4MjYvXCIpK1wiL1wiKTtiPU4oYixnLGMsZCk7bnVsbD09YXx8UChhLFwiXCIsUyxiKTtPKGIpfVxudmFyIFU9e0NoaWxkcmVuOnttYXA6ZnVuY3Rpb24oYSxiLGUpe2lmKG51bGw9PWEpcmV0dXJuIGE7dmFyIGM9W107VChhLGMsbnVsbCxiLGUpO3JldHVybiBjfSxmb3JFYWNoOmZ1bmN0aW9uKGEsYixlKXtpZihudWxsPT1hKXJldHVybiBhO2I9TihudWxsLG51bGwsYixlKTtudWxsPT1hfHxQKGEsXCJcIixSLGIpO08oYil9LGNvdW50OmZ1bmN0aW9uKGEpe3JldHVybiBudWxsPT1hPzA6UChhLFwiXCIscC50aGF0UmV0dXJuc051bGwsbnVsbCl9LHRvQXJyYXk6ZnVuY3Rpb24oYSl7dmFyIGI9W107VChhLGIsbnVsbCxwLnRoYXRSZXR1cm5zQXJndW1lbnQpO3JldHVybiBifSxvbmx5OmZ1bmN0aW9uKGEpe0soYSk/dm9pZCAwOnkoXCIxNDNcIik7cmV0dXJuIGF9fSxDb21wb25lbnQ6QSxQdXJlQ29tcG9uZW50OkIsdW5zdGFibGVfQXN5bmNDb21wb25lbnQ6RSxGcmFnbWVudDp3LGNyZWF0ZUVsZW1lbnQ6SixjbG9uZUVsZW1lbnQ6ZnVuY3Rpb24oYSxiLGUpe3ZhciBjPW0oe30sYS5wcm9wcyksXG5kPWEua2V5LGc9YS5yZWYsaz1hLl9vd25lcjtpZihudWxsIT1iKXt2b2lkIDAhPT1iLnJlZiYmKGc9Yi5yZWYsaz1HLmN1cnJlbnQpO3ZvaWQgMCE9PWIua2V5JiYoZD1cIlwiK2Iua2V5KTtpZihhLnR5cGUmJmEudHlwZS5kZWZhdWx0UHJvcHMpdmFyIGY9YS50eXBlLmRlZmF1bHRQcm9wcztmb3IoaCBpbiBiKUguY2FsbChiLGgpJiYhSS5oYXNPd25Qcm9wZXJ0eShoKSYmKGNbaF09dm9pZCAwPT09YltoXSYmdm9pZCAwIT09Zj9mW2hdOmJbaF0pfXZhciBoPWFyZ3VtZW50cy5sZW5ndGgtMjtpZigxPT09aCljLmNoaWxkcmVuPWU7ZWxzZSBpZigxPGgpe2Y9QXJyYXkoaCk7Zm9yKHZhciBsPTA7bDxoO2wrKylmW2xdPWFyZ3VtZW50c1tsKzJdO2MuY2hpbGRyZW49Zn1yZXR1cm57JCR0eXBlb2Y6cix0eXBlOmEudHlwZSxrZXk6ZCxyZWY6Zyxwcm9wczpjLF9vd25lcjprfX0sY3JlYXRlRmFjdG9yeTpmdW5jdGlvbihhKXt2YXIgYj1KLmJpbmQobnVsbCxhKTtiLnR5cGU9YTtyZXR1cm4gYn0sXG5pc1ZhbGlkRWxlbWVudDpLLHZlcnNpb246XCIxNi4yLjBcIixfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDp7UmVhY3RDdXJyZW50T3duZXI6Ryxhc3NpZ246bX19LFY9T2JqZWN0LmZyZWV6ZSh7ZGVmYXVsdDpVfSksVz1WJiZVfHxWO21vZHVsZS5leHBvcnRzPVdbXCJkZWZhdWx0XCJdP1dbXCJkZWZhdWx0XCJdOlc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QucHJvZHVjdGlvbi5taW4uanNcbi8vIG1vZHVsZSBpZCA9IDI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///24\n");

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {/** @license React v16.2.0\n * react.development.js\n *\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n'use strict';\n\nvar _assign = __webpack_require__(3);\nvar emptyObject = __webpack_require__(5);\nvar invariant = __webpack_require__(4);\nvar warning = __webpack_require__(6);\nvar emptyFunction = __webpack_require__(2);\nvar checkPropTypes = __webpack_require__(7);\n\n// TODO: this is special because it gets imported during build.\n\nvar ReactVersion = '16.2.0';\n\n// The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nvar hasSymbol = typeof Symbol === 'function' && Symbol['for'];\n\nvar REACT_ELEMENT_TYPE = hasSymbol ? Symbol['for']('react.element') : 0xeac7;\nvar REACT_CALL_TYPE = hasSymbol ? Symbol['for']('react.call') : 0xeac8;\nvar REACT_RETURN_TYPE = hasSymbol ? Symbol['for']('react.return') : 0xeac9;\nvar REACT_PORTAL_TYPE = hasSymbol ? Symbol['for']('react.portal') : 0xeaca;\nvar REACT_FRAGMENT_TYPE = hasSymbol ? Symbol['for']('react.fragment') : 0xeacb;\n\nvar MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\n\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable === 'undefined') {\n    return null;\n  }\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n  return null;\n}\n\n/**\n * WARNING: DO NOT manually require this module.\n * This is a replacement for `invariant(...)` used by the error code system\n * and will _only_ be required by the corresponding babel pass.\n * It always throws.\n */\n\n/**\n * Forked from fbjs/warning:\n * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js\n *\n * Only change is we use console.warn instead of console.error,\n * and do nothing when 'console' is not supported.\n * This really simplifies the code.\n * ---\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar lowPriorityWarning = function () {};\n\n{\n  var printWarning = function (format) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var argIndex = 0;\n    var message = 'Warning: ' + format.replace(/%s/g, function () {\n      return args[argIndex++];\n    });\n    if (typeof console !== 'undefined') {\n      console.warn(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n\n  lowPriorityWarning = function (condition, format) {\n    if (format === undefined) {\n      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');\n    }\n    if (!condition) {\n      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        args[_key2 - 2] = arguments[_key2];\n      }\n\n      printWarning.apply(undefined, [format].concat(args));\n    }\n  };\n}\n\nvar lowPriorityWarning$1 = lowPriorityWarning;\n\nvar didWarnStateUpdateForUnmountedComponent = {};\n\nfunction warnNoop(publicInstance, callerName) {\n  {\n    var constructor = publicInstance.constructor;\n    var componentName = constructor && (constructor.displayName || constructor.name) || 'ReactClass';\n    var warningKey = componentName + '.' + callerName;\n    if (didWarnStateUpdateForUnmountedComponent[warningKey]) {\n      return;\n    }\n    warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op.\\n\\nPlease check the code for the %s component.', callerName, callerName, componentName);\n    didWarnStateUpdateForUnmountedComponent[warningKey] = true;\n  }\n}\n\n/**\n * This is the abstract API for an update queue.\n */\nvar ReactNoopUpdateQueue = {\n  /**\n   * Checks whether or not this composite component is mounted.\n   * @param {ReactClass} publicInstance The instance we want to test.\n   * @return {boolean} True if mounted, false otherwise.\n   * @protected\n   * @final\n   */\n  isMounted: function (publicInstance) {\n    return false;\n  },\n\n  /**\n   * Forces an update. This should only be invoked when it is known with\n   * certainty that we are **not** in a DOM transaction.\n   *\n   * You may want to call this when you know that some deeper aspect of the\n   * component's state has changed but `setState` was not called.\n   *\n   * This will not invoke `shouldComponentUpdate`, but it will invoke\n   * `componentWillUpdate` and `componentDidUpdate`.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} callerName name of the calling function in the public API.\n   * @internal\n   */\n  enqueueForceUpdate: function (publicInstance, callback, callerName) {\n    warnNoop(publicInstance, 'forceUpdate');\n  },\n\n  /**\n   * Replaces all of the state. Always use this or `setState` to mutate state.\n   * You should treat `this.state` as immutable.\n   *\n   * There is no guarantee that `this.state` will be immediately updated, so\n   * accessing `this.state` after calling this method may return the old value.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} completeState Next state.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} callerName name of the calling function in the public API.\n   * @internal\n   */\n  enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {\n    warnNoop(publicInstance, 'replaceState');\n  },\n\n  /**\n   * Sets a subset of the state. This only exists because _pendingState is\n   * internal. This provides a merging strategy that is not available to deep\n   * properties which is confusing. TODO: Expose pendingState or don't use it\n   * during the merge.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} partialState Next partial state to be merged with state.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} Name of the calling function in the public API.\n   * @internal\n   */\n  enqueueSetState: function (publicInstance, partialState, callback, callerName) {\n    warnNoop(publicInstance, 'setState');\n  }\n};\n\n/**\n * Base class helpers for the updating state of a component.\n */\nfunction Component(props, context, updater) {\n  this.props = props;\n  this.context = context;\n  this.refs = emptyObject;\n  // We initialize the default updater but the real one gets injected by the\n  // renderer.\n  this.updater = updater || ReactNoopUpdateQueue;\n}\n\nComponent.prototype.isReactComponent = {};\n\n/**\n * Sets a subset of the state. Always use this to mutate\n * state. You should treat `this.state` as immutable.\n *\n * There is no guarantee that `this.state` will be immediately updated, so\n * accessing `this.state` after calling this method may return the old value.\n *\n * There is no guarantee that calls to `setState` will run synchronously,\n * as they may eventually be batched together.  You can provide an optional\n * callback that will be executed when the call to setState is actually\n * completed.\n *\n * When a function is provided to setState, it will be called at some point in\n * the future (not synchronously). It will be called with the up to date\n * component arguments (state, props, context). These values can be different\n * from this.* because your function may be called after receiveProps but before\n * shouldComponentUpdate, and this new state, props, and context will not yet be\n * assigned to this.\n *\n * @param {object|function} partialState Next partial state or function to\n *        produce next partial state to be merged with current state.\n * @param {?function} callback Called after state is updated.\n * @final\n * @protected\n */\nComponent.prototype.setState = function (partialState, callback) {\n  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : void 0;\n  this.updater.enqueueSetState(this, partialState, callback, 'setState');\n};\n\n/**\n * Forces an update. This should only be invoked when it is known with\n * certainty that we are **not** in a DOM transaction.\n *\n * You may want to call this when you know that some deeper aspect of the\n * component's state has changed but `setState` was not called.\n *\n * This will not invoke `shouldComponentUpdate`, but it will invoke\n * `componentWillUpdate` and `componentDidUpdate`.\n *\n * @param {?function} callback Called after update is complete.\n * @final\n * @protected\n */\nComponent.prototype.forceUpdate = function (callback) {\n  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');\n};\n\n/**\n * Deprecated APIs. These APIs used to exist on classic React classes but since\n * we would like to deprecate them, we're not going to move them over to this\n * modern base class. Instead, we define a getter that warns if it's accessed.\n */\n{\n  var deprecatedAPIs = {\n    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],\n    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']\n  };\n  var defineDeprecationWarning = function (methodName, info) {\n    Object.defineProperty(Component.prototype, methodName, {\n      get: function () {\n        lowPriorityWarning$1(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);\n        return undefined;\n      }\n    });\n  };\n  for (var fnName in deprecatedAPIs) {\n    if (deprecatedAPIs.hasOwnProperty(fnName)) {\n      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);\n    }\n  }\n}\n\n/**\n * Base class helpers for the updating state of a component.\n */\nfunction PureComponent(props, context, updater) {\n  // Duplicated from Component.\n  this.props = props;\n  this.context = context;\n  this.refs = emptyObject;\n  // We initialize the default updater but the real one gets injected by the\n  // renderer.\n  this.updater = updater || ReactNoopUpdateQueue;\n}\n\nfunction ComponentDummy() {}\nComponentDummy.prototype = Component.prototype;\nvar pureComponentPrototype = PureComponent.prototype = new ComponentDummy();\npureComponentPrototype.constructor = PureComponent;\n// Avoid an extra prototype jump for these methods.\n_assign(pureComponentPrototype, Component.prototype);\npureComponentPrototype.isPureReactComponent = true;\n\nfunction AsyncComponent(props, context, updater) {\n  // Duplicated from Component.\n  this.props = props;\n  this.context = context;\n  this.refs = emptyObject;\n  // We initialize the default updater but the real one gets injected by the\n  // renderer.\n  this.updater = updater || ReactNoopUpdateQueue;\n}\n\nvar asyncComponentPrototype = AsyncComponent.prototype = new ComponentDummy();\nasyncComponentPrototype.constructor = AsyncComponent;\n// Avoid an extra prototype jump for these methods.\n_assign(asyncComponentPrototype, Component.prototype);\nasyncComponentPrototype.unstable_isAsyncReactComponent = true;\nasyncComponentPrototype.render = function () {\n  return this.props.children;\n};\n\n/**\n * Keeps track of the current owner.\n *\n * The current owner is the component who should own any components that are\n * currently being constructed.\n */\nvar ReactCurrentOwner = {\n  /**\n   * @internal\n   * @type {ReactComponent}\n   */\n  current: null\n};\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true\n};\n\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n  return config.key !== undefined;\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  var warnAboutAccessingKey = function () {\n    if (!specialPropKeyWarningShown) {\n      specialPropKeyWarningShown = true;\n      warning(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);\n    }\n  };\n  warnAboutAccessingKey.isReactWarning = true;\n  Object.defineProperty(props, 'key', {\n    get: warnAboutAccessingKey,\n    configurable: true\n  });\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  var warnAboutAccessingRef = function () {\n    if (!specialPropRefWarningShown) {\n      specialPropRefWarningShown = true;\n      warning(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);\n    }\n  };\n  warnAboutAccessingRef.isReactWarning = true;\n  Object.defineProperty(props, 'ref', {\n    get: warnAboutAccessingRef,\n    configurable: true\n  });\n}\n\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, no instanceof check\n * will work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} key\n * @param {string|object} ref\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @param {*} owner\n * @param {*} props\n * @internal\n */\nvar ReactElement = function (type, key, ref, self, source, owner, props) {\n  var element = {\n    // This tag allow us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {};\n\n    // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    });\n    // self and source are DEV only properties.\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    });\n    // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n};\n\n/**\n * Create and return a new ReactElement of the given type.\n * See https://reactjs.org/docs/react-api.html#createelement\n */\nfunction createElement(type, config, children) {\n  var propName;\n\n  // Reserved names are extracted\n  var props = {};\n\n  var key = null;\n  var ref = null;\n  var self = null;\n  var source = null;\n\n  if (config != null) {\n    if (hasValidRef(config)) {\n      ref = config.ref;\n    }\n    if (hasValidKey(config)) {\n      key = '' + config.key;\n    }\n\n    self = config.__self === undefined ? null : config.__self;\n    source = config.__source === undefined ? null : config.__source;\n    // Remaining properties are added to a new props object\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n  // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n  var childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    var childArray = Array(childrenLength);\n    for (var i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    {\n      if (Object.freeze) {\n        Object.freeze(childArray);\n      }\n    }\n    props.children = childArray;\n  }\n\n  // Resolve default props\n  if (type && type.defaultProps) {\n    var defaultProps = type.defaultProps;\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n  {\n    if (key || ref) {\n      if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {\n        var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n        if (key) {\n          defineKeyPropWarningGetter(props, displayName);\n        }\n        if (ref) {\n          defineRefPropWarningGetter(props, displayName);\n        }\n      }\n    }\n  }\n  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n}\n\n/**\n * Return a function that produces ReactElements of a given type.\n * See https://reactjs.org/docs/react-api.html#createfactory\n */\n\n\nfunction cloneAndReplaceKey(oldElement, newKey) {\n  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);\n\n  return newElement;\n}\n\n/**\n * Clone and return a new ReactElement using element as the starting point.\n * See https://reactjs.org/docs/react-api.html#cloneelement\n */\nfunction cloneElement(element, config, children) {\n  var propName;\n\n  // Original props are copied\n  var props = _assign({}, element.props);\n\n  // Reserved names are extracted\n  var key = element.key;\n  var ref = element.ref;\n  // Self is preserved since the owner is preserved.\n  var self = element._self;\n  // Source is preserved since cloneElement is unlikely to be targeted by a\n  // transpiler, and the original source is probably a better indicator of the\n  // true owner.\n  var source = element._source;\n\n  // Owner will be preserved, unless ref is overridden\n  var owner = element._owner;\n\n  if (config != null) {\n    if (hasValidRef(config)) {\n      // Silently steal the ref from the parent.\n      ref = config.ref;\n      owner = ReactCurrentOwner.current;\n    }\n    if (hasValidKey(config)) {\n      key = '' + config.key;\n    }\n\n    // Remaining properties override existing props\n    var defaultProps;\n    if (element.type && element.type.defaultProps) {\n      defaultProps = element.type.defaultProps;\n    }\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        if (config[propName] === undefined && defaultProps !== undefined) {\n          // Resolve default props\n          props[propName] = defaultProps[propName];\n        } else {\n          props[propName] = config[propName];\n        }\n      }\n    }\n  }\n\n  // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n  var childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    var childArray = Array(childrenLength);\n    for (var i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    props.children = childArray;\n  }\n\n  return ReactElement(element.type, key, ref, self, source, owner, props);\n}\n\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a valid component.\n * @final\n */\nfunction isValidElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\n\nvar ReactDebugCurrentFrame = {};\n\n{\n  // Component that is being worked on\n  ReactDebugCurrentFrame.getCurrentStack = null;\n\n  ReactDebugCurrentFrame.getStackAddendum = function () {\n    var impl = ReactDebugCurrentFrame.getCurrentStack;\n    if (impl) {\n      return impl();\n    }\n    return null;\n  };\n}\n\nvar SEPARATOR = '.';\nvar SUBSEPARATOR = ':';\n\n/**\n * Escape and wrap key so it is safe to use as a reactid\n *\n * @param {string} key to be escaped.\n * @return {string} the escaped key.\n */\nfunction escape(key) {\n  var escapeRegex = /[=:]/g;\n  var escaperLookup = {\n    '=': '=0',\n    ':': '=2'\n  };\n  var escapedString = ('' + key).replace(escapeRegex, function (match) {\n    return escaperLookup[match];\n  });\n\n  return '$' + escapedString;\n}\n\n/**\n * TODO: Test that a single child and an array with one item have the same key\n * pattern.\n */\n\nvar didWarnAboutMaps = false;\n\nvar userProvidedKeyEscapeRegex = /\\/+/g;\nfunction escapeUserProvidedKey(text) {\n  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');\n}\n\nvar POOL_SIZE = 10;\nvar traverseContextPool = [];\nfunction getPooledTraverseContext(mapResult, keyPrefix, mapFunction, mapContext) {\n  if (traverseContextPool.length) {\n    var traverseContext = traverseContextPool.pop();\n    traverseContext.result = mapResult;\n    traverseContext.keyPrefix = keyPrefix;\n    traverseContext.func = mapFunction;\n    traverseContext.context = mapContext;\n    traverseContext.count = 0;\n    return traverseContext;\n  } else {\n    return {\n      result: mapResult,\n      keyPrefix: keyPrefix,\n      func: mapFunction,\n      context: mapContext,\n      count: 0\n    };\n  }\n}\n\nfunction releaseTraverseContext(traverseContext) {\n  traverseContext.result = null;\n  traverseContext.keyPrefix = null;\n  traverseContext.func = null;\n  traverseContext.context = null;\n  traverseContext.count = 0;\n  if (traverseContextPool.length < POOL_SIZE) {\n    traverseContextPool.push(traverseContext);\n  }\n}\n\n/**\n * @param {?*} children Children tree container.\n * @param {!string} nameSoFar Name of the key path so far.\n * @param {!function} callback Callback to invoke with each child found.\n * @param {?*} traverseContext Used to pass information throughout the traversal\n * process.\n * @return {!number} The number of children in this subtree.\n */\nfunction traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {\n  var type = typeof children;\n\n  if (type === 'undefined' || type === 'boolean') {\n    // All of the above are perceived as null.\n    children = null;\n  }\n\n  var invokeCallback = false;\n\n  if (children === null) {\n    invokeCallback = true;\n  } else {\n    switch (type) {\n      case 'string':\n      case 'number':\n        invokeCallback = true;\n        break;\n      case 'object':\n        switch (children.$$typeof) {\n          case REACT_ELEMENT_TYPE:\n          case REACT_CALL_TYPE:\n          case REACT_RETURN_TYPE:\n          case REACT_PORTAL_TYPE:\n            invokeCallback = true;\n        }\n    }\n  }\n\n  if (invokeCallback) {\n    callback(traverseContext, children,\n    // If it's the only child, treat the name as if it was wrapped in an array\n    // so that it's consistent if the number of children grows.\n    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);\n    return 1;\n  }\n\n  var child;\n  var nextName;\n  var subtreeCount = 0; // Count of children found in the current subtree.\n  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;\n\n  if (Array.isArray(children)) {\n    for (var i = 0; i < children.length; i++) {\n      child = children[i];\n      nextName = nextNamePrefix + getComponentKey(child, i);\n      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);\n    }\n  } else {\n    var iteratorFn = getIteratorFn(children);\n    if (typeof iteratorFn === 'function') {\n      {\n        // Warn about using Maps as children\n        if (iteratorFn === children.entries) {\n          warning(didWarnAboutMaps, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.%s', ReactDebugCurrentFrame.getStackAddendum());\n          didWarnAboutMaps = true;\n        }\n      }\n\n      var iterator = iteratorFn.call(children);\n      var step;\n      var ii = 0;\n      while (!(step = iterator.next()).done) {\n        child = step.value;\n        nextName = nextNamePrefix + getComponentKey(child, ii++);\n        subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);\n      }\n    } else if (type === 'object') {\n      var addendum = '';\n      {\n        addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + ReactDebugCurrentFrame.getStackAddendum();\n      }\n      var childrenString = '' + children;\n      invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum);\n    }\n  }\n\n  return subtreeCount;\n}\n\n/**\n * Traverses children that are typically specified as `props.children`, but\n * might also be specified through attributes:\n *\n * - `traverseAllChildren(this.props.children, ...)`\n * - `traverseAllChildren(this.props.leftPanelChildren, ...)`\n *\n * The `traverseContext` is an optional argument that is passed through the\n * entire traversal. It can be used to store accumulations or anything else that\n * the callback might find relevant.\n *\n * @param {?*} children Children tree object.\n * @param {!function} callback To invoke upon traversing each child.\n * @param {?*} traverseContext Context for traversal.\n * @return {!number} The number of children in this subtree.\n */\nfunction traverseAllChildren(children, callback, traverseContext) {\n  if (children == null) {\n    return 0;\n  }\n\n  return traverseAllChildrenImpl(children, '', callback, traverseContext);\n}\n\n/**\n * Generate a key string that identifies a component within a set.\n *\n * @param {*} component A component that could contain a manual key.\n * @param {number} index Index that is used if a manual key is not provided.\n * @return {string}\n */\nfunction getComponentKey(component, index) {\n  // Do some typechecking here since we call this blindly. We want to ensure\n  // that we don't block potential future ES APIs.\n  if (typeof component === 'object' && component !== null && component.key != null) {\n    // Explicit key\n    return escape(component.key);\n  }\n  // Implicit key determined by the index in the set\n  return index.toString(36);\n}\n\nfunction forEachSingleChild(bookKeeping, child, name) {\n  var func = bookKeeping.func,\n      context = bookKeeping.context;\n\n  func.call(context, child, bookKeeping.count++);\n}\n\n/**\n * Iterates through children that are typically specified as `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#react.children.foreach\n *\n * The provided forEachFunc(child, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} forEachFunc\n * @param {*} forEachContext Context for forEachContext.\n */\nfunction forEachChildren(children, forEachFunc, forEachContext) {\n  if (children == null) {\n    return children;\n  }\n  var traverseContext = getPooledTraverseContext(null, null, forEachFunc, forEachContext);\n  traverseAllChildren(children, forEachSingleChild, traverseContext);\n  releaseTraverseContext(traverseContext);\n}\n\nfunction mapSingleChildIntoContext(bookKeeping, child, childKey) {\n  var result = bookKeeping.result,\n      keyPrefix = bookKeeping.keyPrefix,\n      func = bookKeeping.func,\n      context = bookKeeping.context;\n\n\n  var mappedChild = func.call(context, child, bookKeeping.count++);\n  if (Array.isArray(mappedChild)) {\n    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);\n  } else if (mappedChild != null) {\n    if (isValidElement(mappedChild)) {\n      mappedChild = cloneAndReplaceKey(mappedChild,\n      // Keep both the (mapped) and old keys if they differ, just as\n      // traverseAllChildren used to do for objects as children\n      keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);\n    }\n    result.push(mappedChild);\n  }\n}\n\nfunction mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {\n  var escapedPrefix = '';\n  if (prefix != null) {\n    escapedPrefix = escapeUserProvidedKey(prefix) + '/';\n  }\n  var traverseContext = getPooledTraverseContext(array, escapedPrefix, func, context);\n  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);\n  releaseTraverseContext(traverseContext);\n}\n\n/**\n * Maps children that are typically specified as `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#react.children.map\n *\n * The provided mapFunction(child, key, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} func The map function.\n * @param {*} context Context for mapFunction.\n * @return {object} Object containing the ordered map of results.\n */\nfunction mapChildren(children, func, context) {\n  if (children == null) {\n    return children;\n  }\n  var result = [];\n  mapIntoWithKeyPrefixInternal(children, result, null, func, context);\n  return result;\n}\n\n/**\n * Count the number of children that are typically specified as\n * `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#react.children.count\n *\n * @param {?*} children Children tree container.\n * @return {number} The number of children.\n */\nfunction countChildren(children, context) {\n  return traverseAllChildren(children, emptyFunction.thatReturnsNull, null);\n}\n\n/**\n * Flatten a children object (typically specified as `props.children`) and\n * return an array with appropriately re-keyed children.\n *\n * See https://reactjs.org/docs/react-api.html#react.children.toarray\n */\nfunction toArray(children) {\n  var result = [];\n  mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);\n  return result;\n}\n\n/**\n * Returns the first child in a collection of children and verifies that there\n * is only one child in the collection.\n *\n * See https://reactjs.org/docs/react-api.html#react.children.only\n *\n * The current implementation of this function assumes that a single child gets\n * passed without a wrapper, but the purpose of this helper function is to\n * abstract away the particular structure of children.\n *\n * @param {?object} children Child collection structure.\n * @return {ReactElement} The first and only `ReactElement` contained in the\n * structure.\n */\nfunction onlyChild(children) {\n  !isValidElement(children) ? invariant(false, 'React.Children.only expected to receive a single React element child.') : void 0;\n  return children;\n}\n\nvar describeComponentFrame = function (name, source, ownerName) {\n  return '\\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');\n};\n\nfunction getComponentName(fiber) {\n  var type = fiber.type;\n\n  if (typeof type === 'string') {\n    return type;\n  }\n  if (typeof type === 'function') {\n    return type.displayName || type.name;\n  }\n  return null;\n}\n\n/**\n * ReactElementValidator provides a wrapper around a element factory\n * which validates the props passed to the element. This is intended to be\n * used only in DEV and could be replaced by a static type checker for languages\n * that support it.\n */\n\n{\n  var currentlyValidatingElement = null;\n\n  var propTypesMisspellWarningShown = false;\n\n  var getDisplayName = function (element) {\n    if (element == null) {\n      return '#empty';\n    } else if (typeof element === 'string' || typeof element === 'number') {\n      return '#text';\n    } else if (typeof element.type === 'string') {\n      return element.type;\n    } else if (element.type === REACT_FRAGMENT_TYPE) {\n      return 'React.Fragment';\n    } else {\n      return element.type.displayName || element.type.name || 'Unknown';\n    }\n  };\n\n  var getStackAddendum = function () {\n    var stack = '';\n    if (currentlyValidatingElement) {\n      var name = getDisplayName(currentlyValidatingElement);\n      var owner = currentlyValidatingElement._owner;\n      stack += describeComponentFrame(name, currentlyValidatingElement._source, owner && getComponentName(owner));\n    }\n    stack += ReactDebugCurrentFrame.getStackAddendum() || '';\n    return stack;\n  };\n\n  var VALID_FRAGMENT_PROPS = new Map([['children', true], ['key', true]]);\n}\n\nfunction getDeclarationErrorAddendum() {\n  if (ReactCurrentOwner.current) {\n    var name = getComponentName(ReactCurrentOwner.current);\n    if (name) {\n      return '\\n\\nCheck the render method of `' + name + '`.';\n    }\n  }\n  return '';\n}\n\nfunction getSourceInfoErrorAddendum(elementProps) {\n  if (elementProps !== null && elementProps !== undefined && elementProps.__source !== undefined) {\n    var source = elementProps.__source;\n    var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n    var lineNumber = source.lineNumber;\n    return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n  }\n  return '';\n}\n\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\nvar ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  var info = getDeclarationErrorAddendum();\n\n  if (!info) {\n    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n    if (parentName) {\n      info = '\\n\\nCheck the top-level render call using <' + parentName + '>.';\n    }\n  }\n  return info;\n}\n\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\nfunction validateExplicitKey(element, parentType) {\n  if (!element._store || element._store.validated || element.key != null) {\n    return;\n  }\n  element._store.validated = true;\n\n  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n  if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n    return;\n  }\n  ownerHasKeyUseWarning[currentComponentErrorInfo] = true;\n\n  // Usually the current owner is the offender, but if it accepts children as a\n  // property, it may be the creator of the child that's responsible for\n  // assigning it a key.\n  var childOwner = '';\n  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n    // Give the component that originally created this child.\n    childOwner = ' It was passed a child from ' + getComponentName(element._owner) + '.';\n  }\n\n  currentlyValidatingElement = element;\n  {\n    warning(false, 'Each child in an array or iterator should have a unique \"key\" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, getStackAddendum());\n  }\n  currentlyValidatingElement = null;\n}\n\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\nfunction validateChildKeys(node, parentType) {\n  if (typeof node !== 'object') {\n    return;\n  }\n  if (Array.isArray(node)) {\n    for (var i = 0; i < node.length; i++) {\n      var child = node[i];\n      if (isValidElement(child)) {\n        validateExplicitKey(child, parentType);\n      }\n    }\n  } else if (isValidElement(node)) {\n    // This element was passed in a valid location.\n    if (node._store) {\n      node._store.validated = true;\n    }\n  } else if (node) {\n    var iteratorFn = getIteratorFn(node);\n    if (typeof iteratorFn === 'function') {\n      // Entry iterators used to provide implicit keys,\n      // but now we print a separate warning for them later.\n      if (iteratorFn !== node.entries) {\n        var iterator = iteratorFn.call(node);\n        var step;\n        while (!(step = iterator.next()).done) {\n          if (isValidElement(step.value)) {\n            validateExplicitKey(step.value, parentType);\n          }\n        }\n      }\n    }\n  }\n}\n\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\nfunction validatePropTypes(element) {\n  var componentClass = element.type;\n  if (typeof componentClass !== 'function') {\n    return;\n  }\n  var name = componentClass.displayName || componentClass.name;\n  var propTypes = componentClass.propTypes;\n  if (propTypes) {\n    currentlyValidatingElement = element;\n    checkPropTypes(propTypes, element.props, 'prop', name, getStackAddendum);\n    currentlyValidatingElement = null;\n  } else if (componentClass.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n    propTypesMisspellWarningShown = true;\n    warning(false, 'Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', name || 'Unknown');\n  }\n  if (typeof componentClass.getDefaultProps === 'function') {\n    warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n  }\n}\n\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\nfunction validateFragmentProps(fragment) {\n  currentlyValidatingElement = fragment;\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = Object.keys(fragment.props)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var key = _step.value;\n\n      if (!VALID_FRAGMENT_PROPS.has(key)) {\n        warning(false, 'Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.%s', key, getStackAddendum());\n        break;\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator['return']) {\n        _iterator['return']();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  if (fragment.ref !== null) {\n    warning(false, 'Invalid attribute `ref` supplied to `React.Fragment`.%s', getStackAddendum());\n  }\n\n  currentlyValidatingElement = null;\n}\n\nfunction createElementWithValidation(type, props, children) {\n  var validType = typeof type === 'string' || typeof type === 'function' || typeof type === 'symbol' || typeof type === 'number';\n  // We warn in this case but don't throw. We expect the element creation to\n  // succeed and there will likely be errors in render.\n  if (!validType) {\n    var info = '';\n    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n      info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n    }\n\n    var sourceInfo = getSourceInfoErrorAddendum(props);\n    if (sourceInfo) {\n      info += sourceInfo;\n    } else {\n      info += getDeclarationErrorAddendum();\n    }\n\n    info += getStackAddendum() || '';\n\n    warning(false, 'React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', type == null ? type : typeof type, info);\n  }\n\n  var element = createElement.apply(this, arguments);\n\n  // The result can be nullish if a mock or a custom function is used.\n  // TODO: Drop this when these are no longer allowed as the type argument.\n  if (element == null) {\n    return element;\n  }\n\n  // Skip key warning if the type isn't valid since our key validation logic\n  // doesn't expect a non-string/function type and can throw confusing errors.\n  // We don't want exception behavior to differ between dev and prod.\n  // (Rendering will throw with a helpful message and as soon as the type is\n  // fixed, the key warnings will appear.)\n  if (validType) {\n    for (var i = 2; i < arguments.length; i++) {\n      validateChildKeys(arguments[i], type);\n    }\n  }\n\n  if (typeof type === 'symbol' && type === REACT_FRAGMENT_TYPE) {\n    validateFragmentProps(element);\n  } else {\n    validatePropTypes(element);\n  }\n\n  return element;\n}\n\nfunction createFactoryWithValidation(type) {\n  var validatedFactory = createElementWithValidation.bind(null, type);\n  // Legacy hook TODO: Warn if this is accessed\n  validatedFactory.type = type;\n\n  {\n    Object.defineProperty(validatedFactory, 'type', {\n      enumerable: false,\n      get: function () {\n        lowPriorityWarning$1(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');\n        Object.defineProperty(this, 'type', {\n          value: type\n        });\n        return type;\n      }\n    });\n  }\n\n  return validatedFactory;\n}\n\nfunction cloneElementWithValidation(element, props, children) {\n  var newElement = cloneElement.apply(this, arguments);\n  for (var i = 2; i < arguments.length; i++) {\n    validateChildKeys(arguments[i], newElement.type);\n  }\n  validatePropTypes(newElement);\n  return newElement;\n}\n\nvar React = {\n  Children: {\n    map: mapChildren,\n    forEach: forEachChildren,\n    count: countChildren,\n    toArray: toArray,\n    only: onlyChild\n  },\n\n  Component: Component,\n  PureComponent: PureComponent,\n  unstable_AsyncComponent: AsyncComponent,\n\n  Fragment: REACT_FRAGMENT_TYPE,\n\n  createElement: createElementWithValidation,\n  cloneElement: cloneElementWithValidation,\n  createFactory: createFactoryWithValidation,\n  isValidElement: isValidElement,\n\n  version: ReactVersion,\n\n  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {\n    ReactCurrentOwner: ReactCurrentOwner,\n    // Used by renderers to avoid bundling object-assign twice in UMD bundles:\n    assign: _assign\n  }\n};\n\n{\n  _assign(React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, {\n    // These should not be included in production.\n    ReactDebugCurrentFrame: ReactDebugCurrentFrame,\n    // Shim for React DOM 16.0.0 which still destructured (but not used) this.\n    // TODO: remove in React 17.0.\n    ReactComponentTreeHook: {}\n  });\n}\n\n\n\nvar React$2 = Object.freeze({\n\tdefault: React\n});\n\nvar React$3 = ( React$2 && React ) || React$2;\n\n// TODO: decide on the top-level export form.\n// This is hacky but makes it work with both Rollup and Jest.\nvar react = React$3['default'] ? React$3['default'] : React$3;\n\nmodule.exports = react;\n  })();\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LmRldmVsb3BtZW50LmpzPzk5ZWUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi4yLjBcbiAqIHJlYWN0LmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xudmFyIGVtcHR5T2JqZWN0ID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlPYmplY3QnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgY2hlY2tQcm9wVHlwZXMgPSByZXF1aXJlKCdwcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzJyk7XG5cbi8vIFRPRE86IHRoaXMgaXMgc3BlY2lhbCBiZWNhdXNlIGl0IGdldHMgaW1wb3J0ZWQgZHVyaW5nIGJ1aWxkLlxuXG52YXIgUmVhY3RWZXJzaW9uID0gJzE2LjIuMCc7XG5cbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgaGFzU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2xbJ2ZvciddO1xuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sWydmb3InXSgncmVhY3QuZWxlbWVudCcpIDogMHhlYWM3O1xudmFyIFJFQUNUX0NBTExfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbFsnZm9yJ10oJ3JlYWN0LmNhbGwnKSA6IDB4ZWFjODtcbnZhciBSRUFDVF9SRVRVUk5fVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbFsnZm9yJ10oJ3JlYWN0LnJldHVybicpIDogMHhlYWM5O1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sWydmb3InXSgncmVhY3QucG9ydGFsJykgOiAweGVhY2E7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbFsnZm9yJ10oJ3JlYWN0LmZyYWdtZW50JykgOiAweGVhY2I7XG5cbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcblxuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcbiAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3I7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogV0FSTklORzogRE8gTk9UIG1hbnVhbGx5IHJlcXVpcmUgdGhpcyBtb2R1bGUuXG4gKiBUaGlzIGlzIGEgcmVwbGFjZW1lbnQgZm9yIGBpbnZhcmlhbnQoLi4uKWAgdXNlZCBieSB0aGUgZXJyb3IgY29kZSBzeXN0ZW1cbiAqIGFuZCB3aWxsIF9vbmx5XyBiZSByZXF1aXJlZCBieSB0aGUgY29ycmVzcG9uZGluZyBiYWJlbCBwYXNzLlxuICogSXQgYWx3YXlzIHRocm93cy5cbiAqL1xuXG4vKipcbiAqIEZvcmtlZCBmcm9tIGZianMvd2FybmluZzpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mYmpzL2Jsb2IvZTY2YmEyMGFkNWJlNDMzZWI1NDQyM2YyYjA5N2Q4MjkzMjRkOWRlNi9wYWNrYWdlcy9mYmpzL3NyYy9fX2ZvcmtzX18vd2FybmluZy5qc1xuICpcbiAqIE9ubHkgY2hhbmdlIGlzIHdlIHVzZSBjb25zb2xlLndhcm4gaW5zdGVhZCBvZiBjb25zb2xlLmVycm9yLFxuICogYW5kIGRvIG5vdGhpbmcgd2hlbiAnY29uc29sZScgaXMgbm90IHN1cHBvcnRlZC5cbiAqIFRoaXMgcmVhbGx5IHNpbXBsaWZpZXMgdGhlIGNvZGUuXG4gKiAtLS1cbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xuXG52YXIgbG93UHJpb3JpdHlXYXJuaW5nID0gZnVuY3Rpb24gKCkge307XG5cbntcbiAgdmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG5cbiAgbG93UHJpb3JpdHlXYXJuaW5nID0gZnVuY3Rpb24gKGNvbmRpdGlvbiwgZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2B3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgKyAnbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIgPiAyID8gX2xlbjIgLSAyIDogMCksIF9rZXkyID0gMjsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMl0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcuYXBwbHkodW5kZWZpbmVkLCBbZm9ybWF0XS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIGxvd1ByaW9yaXR5V2FybmluZyQxID0gbG93UHJpb3JpdHlXYXJuaW5nO1xuXG52YXIgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50ID0ge307XG5cbmZ1bmN0aW9uIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gIHtcbiAgICB2YXIgY29uc3RydWN0b3IgPSBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGNvbnN0cnVjdG9yICYmIChjb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCBjb25zdHJ1Y3Rvci5uYW1lKSB8fCAnUmVhY3RDbGFzcyc7XG4gICAgdmFyIHdhcm5pbmdLZXkgPSBjb21wb25lbnROYW1lICsgJy4nICsgY2FsbGVyTmFtZTtcbiAgICBpZiAoZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W3dhcm5pbmdLZXldKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHdhcm5pbmcoZmFsc2UsICclcyguLi4pOiBDYW4gb25seSB1cGRhdGUgYSBtb3VudGVkIG9yIG1vdW50aW5nIGNvbXBvbmVudC4gJyArICdUaGlzIHVzdWFsbHkgbWVhbnMgeW91IGNhbGxlZCAlcygpIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuICcgKyAnVGhpcyBpcyBhIG5vLW9wLlxcblxcblBsZWFzZSBjaGVjayB0aGUgY29kZSBmb3IgdGhlICVzIGNvbXBvbmVudC4nLCBjYWxsZXJOYW1lLCBjYWxsZXJOYW1lLCBjb21wb25lbnROYW1lKTtcbiAgICBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbd2FybmluZ0tleV0gPSB0cnVlO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgYWJzdHJhY3QgQVBJIGZvciBhbiB1cGRhdGUgcXVldWUuXG4gKi9cbnZhciBSZWFjdE5vb3BVcGRhdGVRdWV1ZSA9IHtcbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGNvbXBvc2l0ZSBjb21wb25lbnQgaXMgbW91bnRlZC5cbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2Ugd2Ugd2FudCB0byB0ZXN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1vdW50ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAZmluYWxcbiAgICovXG4gIGlzTW91bnRlZDogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gICAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gICAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICAgKlxuICAgKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gICAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IGNhbGxlck5hbWUgbmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ2ZvcmNlVXBkYXRlJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyBvciBgc2V0U3RhdGVgIHRvIG11dGF0ZSBzdGF0ZS5cbiAgICogWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICAgKlxuICAgKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICAgKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbXBsZXRlU3RhdGUgTmV4dCBzdGF0ZS5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBjYWxsZXJOYW1lIG5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjb21wbGV0ZVN0YXRlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAncmVwbGFjZVN0YXRlJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBUaGlzIG9ubHkgZXhpc3RzIGJlY2F1c2UgX3BlbmRpbmdTdGF0ZSBpc1xuICAgKiBpbnRlcm5hbC4gVGhpcyBwcm92aWRlcyBhIG1lcmdpbmcgc3RyYXRlZ3kgdGhhdCBpcyBub3QgYXZhaWxhYmxlIHRvIGRlZXBcbiAgICogcHJvcGVydGllcyB3aGljaCBpcyBjb25mdXNpbmcuIFRPRE86IEV4cG9zZSBwZW5kaW5nU3RhdGUgb3IgZG9uJ3QgdXNlIGl0XG4gICAqIGR1cmluZyB0aGUgbWVyZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBzdGF0ZS5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBOYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdzZXRTdGF0ZScpO1xuICB9XG59O1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgaGVscGVycyBmb3IgdGhlIHVwZGF0aW5nIHN0YXRlIG9mIGEgY29tcG9uZW50LlxuICovXG5mdW5jdGlvbiBDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgLy8gV2UgaW5pdGlhbGl6ZSB0aGUgZGVmYXVsdCB1cGRhdGVyIGJ1dCB0aGUgcmVhbCBvbmUgZ2V0cyBpbmplY3RlZCBieSB0aGVcbiAgLy8gcmVuZGVyZXIuXG4gIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG59XG5cbkNvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IHt9O1xuXG4vKipcbiAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgdG8gbXV0YXRlXG4gKiBzdGF0ZS4gWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICpcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICpcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGNhbGxzIHRvIGBzZXRTdGF0ZWAgd2lsbCBydW4gc3luY2hyb25vdXNseSxcbiAqIGFzIHRoZXkgbWF5IGV2ZW50dWFsbHkgYmUgYmF0Y2hlZCB0b2dldGhlci4gIFlvdSBjYW4gcHJvdmlkZSBhbiBvcHRpb25hbFxuICogY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGNhbGwgdG8gc2V0U3RhdGUgaXMgYWN0dWFsbHlcbiAqIGNvbXBsZXRlZC5cbiAqXG4gKiBXaGVuIGEgZnVuY3Rpb24gaXMgcHJvdmlkZWQgdG8gc2V0U3RhdGUsIGl0IHdpbGwgYmUgY2FsbGVkIGF0IHNvbWUgcG9pbnQgaW5cbiAqIHRoZSBmdXR1cmUgKG5vdCBzeW5jaHJvbm91c2x5KS4gSXQgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgdXAgdG8gZGF0ZVxuICogY29tcG9uZW50IGFyZ3VtZW50cyAoc3RhdGUsIHByb3BzLCBjb250ZXh0KS4gVGhlc2UgdmFsdWVzIGNhbiBiZSBkaWZmZXJlbnRcbiAqIGZyb20gdGhpcy4qIGJlY2F1c2UgeW91ciBmdW5jdGlvbiBtYXkgYmUgY2FsbGVkIGFmdGVyIHJlY2VpdmVQcm9wcyBidXQgYmVmb3JlXG4gKiBzaG91bGRDb21wb25lbnRVcGRhdGUsIGFuZCB0aGlzIG5ldyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHdpbGwgbm90IHlldCBiZVxuICogYXNzaWduZWQgdG8gdGhpcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdHxmdW5jdGlvbn0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSBvciBmdW5jdGlvbiB0b1xuICogICAgICAgIHByb2R1Y2UgbmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIGN1cnJlbnQgc3RhdGUuXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uIChwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrKSB7XG4gICEodHlwZW9mIHBhcnRpYWxTdGF0ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHBhcnRpYWxTdGF0ZSA9PT0gJ2Z1bmN0aW9uJyB8fCBwYXJ0aWFsU3RhdGUgPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdzZXRTdGF0ZSguLi4pOiB0YWtlcyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzIHRvIHVwZGF0ZSBvciBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcy4nKSA6IHZvaWQgMDtcbiAgdGhpcy51cGRhdGVyLmVucXVldWVTZXRTdGF0ZSh0aGlzLCBwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrLCAnc2V0U3RhdGUnKTtcbn07XG5cbi8qKlxuICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gKlxuICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gKlxuICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAqXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHVwZGF0ZSBpcyBjb21wbGV0ZS5cbiAqIEBmaW5hbFxuICogQHByb3RlY3RlZFxuICovXG5Db21wb25lbnQucHJvdG90eXBlLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlRm9yY2VVcGRhdGUodGhpcywgY2FsbGJhY2ssICdmb3JjZVVwZGF0ZScpO1xufTtcblxuLyoqXG4gKiBEZXByZWNhdGVkIEFQSXMuIFRoZXNlIEFQSXMgdXNlZCB0byBleGlzdCBvbiBjbGFzc2ljIFJlYWN0IGNsYXNzZXMgYnV0IHNpbmNlXG4gKiB3ZSB3b3VsZCBsaWtlIHRvIGRlcHJlY2F0ZSB0aGVtLCB3ZSdyZSBub3QgZ29pbmcgdG8gbW92ZSB0aGVtIG92ZXIgdG8gdGhpc1xuICogbW9kZXJuIGJhc2UgY2xhc3MuIEluc3RlYWQsIHdlIGRlZmluZSBhIGdldHRlciB0aGF0IHdhcm5zIGlmIGl0J3MgYWNjZXNzZWQuXG4gKi9cbntcbiAgdmFyIGRlcHJlY2F0ZWRBUElzID0ge1xuICAgIGlzTW91bnRlZDogWydpc01vdW50ZWQnLCAnSW5zdGVhZCwgbWFrZSBzdXJlIHRvIGNsZWFuIHVwIHN1YnNjcmlwdGlvbnMgYW5kIHBlbmRpbmcgcmVxdWVzdHMgaW4gJyArICdjb21wb25lbnRXaWxsVW5tb3VudCB0byBwcmV2ZW50IG1lbW9yeSBsZWFrcy4nXSxcbiAgICByZXBsYWNlU3RhdGU6IFsncmVwbGFjZVN0YXRlJywgJ1JlZmFjdG9yIHlvdXIgY29kZSB0byB1c2Ugc2V0U3RhdGUgaW5zdGVhZCAoc2VlICcgKyAnaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8zMjM2KS4nXVxuICB9O1xuICB2YXIgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUsIGluZm8pIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50LnByb3RvdHlwZSwgbWV0aG9kTmFtZSwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvd1ByaW9yaXR5V2FybmluZyQxKGZhbHNlLCAnJXMoLi4uKSBpcyBkZXByZWNhdGVkIGluIHBsYWluIEphdmFTY3JpcHQgUmVhY3QgY2xhc3Nlcy4gJXMnLCBpbmZvWzBdLCBpbmZvWzFdKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgZm9yICh2YXIgZm5OYW1lIGluIGRlcHJlY2F0ZWRBUElzKSB7XG4gICAgaWYgKGRlcHJlY2F0ZWRBUElzLmhhc093blByb3BlcnR5KGZuTmFtZSkpIHtcbiAgICAgIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyhmbk5hbWUsIGRlcHJlY2F0ZWRBUElzW2ZuTmFtZV0pO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEJhc2UgY2xhc3MgaGVscGVycyBmb3IgdGhlIHVwZGF0aW5nIHN0YXRlIG9mIGEgY29tcG9uZW50LlxuICovXG5mdW5jdGlvbiBQdXJlQ29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gIC8vIER1cGxpY2F0ZWQgZnJvbSBDb21wb25lbnQuXG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gIC8vIFdlIGluaXRpYWxpemUgdGhlIGRlZmF1bHQgdXBkYXRlciBidXQgdGhlIHJlYWwgb25lIGdldHMgaW5qZWN0ZWQgYnkgdGhlXG4gIC8vIHJlbmRlcmVyLlxuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG5mdW5jdGlvbiBDb21wb25lbnREdW1teSgpIHt9XG5Db21wb25lbnREdW1teS5wcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xudmFyIHB1cmVDb21wb25lbnRQcm90b3R5cGUgPSBQdXJlQ29tcG9uZW50LnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnREdW1teSgpO1xucHVyZUNvbXBvbmVudFByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFB1cmVDb21wb25lbnQ7XG4vLyBBdm9pZCBhbiBleHRyYSBwcm90b3R5cGUganVtcCBmb3IgdGhlc2UgbWV0aG9kcy5cbl9hc3NpZ24ocHVyZUNvbXBvbmVudFByb3RvdHlwZSwgQ29tcG9uZW50LnByb3RvdHlwZSk7XG5wdXJlQ29tcG9uZW50UHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50ID0gdHJ1ZTtcblxuZnVuY3Rpb24gQXN5bmNDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgLy8gRHVwbGljYXRlZCBmcm9tIENvbXBvbmVudC5cbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgLy8gV2UgaW5pdGlhbGl6ZSB0aGUgZGVmYXVsdCB1cGRhdGVyIGJ1dCB0aGUgcmVhbCBvbmUgZ2V0cyBpbmplY3RlZCBieSB0aGVcbiAgLy8gcmVuZGVyZXIuXG4gIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG59XG5cbnZhciBhc3luY0NvbXBvbmVudFByb3RvdHlwZSA9IEFzeW5jQ29tcG9uZW50LnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnREdW1teSgpO1xuYXN5bmNDb21wb25lbnRQcm90b3R5cGUuY29uc3RydWN0b3IgPSBBc3luY0NvbXBvbmVudDtcbi8vIEF2b2lkIGFuIGV4dHJhIHByb3RvdHlwZSBqdW1wIGZvciB0aGVzZSBtZXRob2RzLlxuX2Fzc2lnbihhc3luY0NvbXBvbmVudFByb3RvdHlwZSwgQ29tcG9uZW50LnByb3RvdHlwZSk7XG5hc3luY0NvbXBvbmVudFByb3RvdHlwZS51bnN0YWJsZV9pc0FzeW5jUmVhY3RDb21wb25lbnQgPSB0cnVlO1xuYXN5bmNDb21wb25lbnRQcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbn07XG5cbi8qKlxuICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgb3duZXIuXG4gKlxuICogVGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIGNvbXBvbmVudCB3aG8gc2hvdWxkIG93biBhbnkgY29tcG9uZW50cyB0aGF0IGFyZVxuICogY3VycmVudGx5IGJlaW5nIGNvbnN0cnVjdGVkLlxuICovXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHR5cGUge1JlYWN0Q29tcG9uZW50fVxuICAgKi9cbiAgY3VycmVudDogbnVsbFxufTtcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIFJFU0VSVkVEX1BST1BTID0ge1xuICBrZXk6IHRydWUsXG4gIHJlZjogdHJ1ZSxcbiAgX19zZWxmOiB0cnVlLFxuICBfX3NvdXJjZTogdHJ1ZVxufTtcblxudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xudmFyIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duO1xuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbmZpZy5rZXkgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuICAgICAgd2FybmluZyhmYWxzZSwgJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9mYi5tZS9yZWFjdC1zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICB9XG4gIH07XG4gIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duID0gdHJ1ZTtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vZmIubWUvcmVhY3Qtc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgfVxuICB9O1xuICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgbm8gaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gcHJvcHNcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3RFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xuICB2YXIgZWxlbWVudCA9IHtcbiAgICAvLyBUaGlzIHRhZyBhbGxvdyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG5cbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG5cbiAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgIF9vd25lcjogb3duZXJcbiAgfTtcblxuICB7XG4gICAgLy8gVGhlIHZhbGlkYXRpb24gZmxhZyBpcyBjdXJyZW50bHkgbXV0YXRpdmUuIFdlIHB1dCBpdCBvblxuICAgIC8vIGFuIGV4dGVybmFsIGJhY2tpbmcgc3RvcmUgc28gdGhhdCB3ZSBjYW4gZnJlZXplIHRoZSB3aG9sZSBvYmplY3QuXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxuICAgIC8vIGNvbW1vbmx5IHVzZWQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxuICAgIGVsZW1lbnQuX3N0b3JlID0ge307XG5cbiAgICAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQuX3N0b3JlLCAndmFsaWRhdGVkJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9KTtcbiAgICAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc2VsZicsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzZWxmXG4gICAgfSk7XG4gICAgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zb3VyY2UnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc291cmNlXG4gICAgfSk7XG4gICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYW5kIHJldHVybiBhIG5ldyBSZWFjdEVsZW1lbnQgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2NyZWF0ZWVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0eXBlLCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIHZhciBwcm9wTmFtZTtcblxuICAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG4gIHZhciBwcm9wcyA9IHt9O1xuXG4gIHZhciBrZXkgPSBudWxsO1xuICB2YXIgcmVmID0gbnVsbDtcbiAgdmFyIHNlbGYgPSBudWxsO1xuICB2YXIgc291cmNlID0gbnVsbDtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICB9XG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBzZWxmID0gY29uZmlnLl9fc2VsZiA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NlbGY7XG4gICAgc291cmNlID0gY29uZmlnLl9fc291cmNlID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc291cmNlO1xuICAgIC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuICAgIHtcbiAgICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRBcnJheSk7XG4gICAgICB9XG4gICAgfVxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgfVxuXG4gIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcbiAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHtcbiAgICBpZiAoa2V5IHx8IHJlZikge1xuICAgICAgaWYgKHR5cGVvZiBwcm9wcy4kJHR5cGVvZiA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcHMuJCR0eXBlb2YgIT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xufVxuXG4vKipcbiAqIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcHJvZHVjZXMgUmVhY3RFbGVtZW50cyBvZiBhIGdpdmVuIHR5cGUuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2NyZWF0ZWZhY3RvcnlcbiAqL1xuXG5cbmZ1bmN0aW9uIGNsb25lQW5kUmVwbGFjZUtleShvbGRFbGVtZW50LCBuZXdLZXkpIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBSZWFjdEVsZW1lbnQob2xkRWxlbWVudC50eXBlLCBuZXdLZXksIG9sZEVsZW1lbnQucmVmLCBvbGRFbGVtZW50Ll9zZWxmLCBvbGRFbGVtZW50Ll9zb3VyY2UsIG9sZEVsZW1lbnQuX293bmVyLCBvbGRFbGVtZW50LnByb3BzKTtcblxuICByZXR1cm4gbmV3RWxlbWVudDtcbn1cblxuLyoqXG4gKiBDbG9uZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCB1c2luZyBlbGVtZW50IGFzIHRoZSBzdGFydGluZyBwb2ludC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjY2xvbmVlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIGNsb25lRWxlbWVudChlbGVtZW50LCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIHZhciBwcm9wTmFtZTtcblxuICAvLyBPcmlnaW5hbCBwcm9wcyBhcmUgY29waWVkXG4gIHZhciBwcm9wcyA9IF9hc3NpZ24oe30sIGVsZW1lbnQucHJvcHMpO1xuXG4gIC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcbiAgdmFyIGtleSA9IGVsZW1lbnQua2V5O1xuICB2YXIgcmVmID0gZWxlbWVudC5yZWY7XG4gIC8vIFNlbGYgaXMgcHJlc2VydmVkIHNpbmNlIHRoZSBvd25lciBpcyBwcmVzZXJ2ZWQuXG4gIHZhciBzZWxmID0gZWxlbWVudC5fc2VsZjtcbiAgLy8gU291cmNlIGlzIHByZXNlcnZlZCBzaW5jZSBjbG9uZUVsZW1lbnQgaXMgdW5saWtlbHkgdG8gYmUgdGFyZ2V0ZWQgYnkgYVxuICAvLyB0cmFuc3BpbGVyLCBhbmQgdGhlIG9yaWdpbmFsIHNvdXJjZSBpcyBwcm9iYWJseSBhIGJldHRlciBpbmRpY2F0b3Igb2YgdGhlXG4gIC8vIHRydWUgb3duZXIuXG4gIHZhciBzb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7XG5cbiAgLy8gT3duZXIgd2lsbCBiZSBwcmVzZXJ2ZWQsIHVubGVzcyByZWYgaXMgb3ZlcnJpZGRlblxuICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgLy8gU2lsZW50bHkgc3RlYWwgdGhlIHJlZiBmcm9tIHRoZSBwYXJlbnQuXG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgIH1cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIG92ZXJyaWRlIGV4aXN0aW5nIHByb3BzXG4gICAgdmFyIGRlZmF1bHRQcm9wcztcbiAgICBpZiAoZWxlbWVudC50eXBlICYmIGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIGRlZmF1bHRQcm9wcyA9IGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHM7XG4gICAgfVxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIGlmIChjb25maWdbcHJvcE5hbWVdID09PSB1bmRlZmluZWQgJiYgZGVmYXVsdFByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH1cblxuICByZXR1cm4gUmVhY3RFbGVtZW50KGVsZW1lbnQudHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKTtcbn1cblxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSB2YWxpZCBjb21wb25lbnQuXG4gKiBAZmluYWxcbiAqL1xuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG5cbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0ge307XG5cbntcbiAgLy8gQ29tcG9uZW50IHRoYXQgaXMgYmVpbmcgd29ya2VkIG9uXG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrID0gbnVsbDtcblxuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGltcGwgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjaztcbiAgICBpZiAoaW1wbCkge1xuICAgICAgcmV0dXJuIGltcGwoKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG59XG5cbnZhciBTRVBBUkFUT1IgPSAnLic7XG52YXIgU1VCU0VQQVJBVE9SID0gJzonO1xuXG4vKipcbiAqIEVzY2FwZSBhbmQgd3JhcCBrZXkgc28gaXQgaXMgc2FmZSB0byB1c2UgYXMgYSByZWFjdGlkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSB0byBiZSBlc2NhcGVkLlxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgZXNjYXBlZCBrZXkuXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZShrZXkpIHtcbiAgdmFyIGVzY2FwZVJlZ2V4ID0gL1s9Ol0vZztcbiAgdmFyIGVzY2FwZXJMb29rdXAgPSB7XG4gICAgJz0nOiAnPTAnLFxuICAgICc6JzogJz0yJ1xuICB9O1xuICB2YXIgZXNjYXBlZFN0cmluZyA9ICgnJyArIGtleSkucmVwbGFjZShlc2NhcGVSZWdleCwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVzY2FwZXJMb29rdXBbbWF0Y2hdO1xuICB9KTtcblxuICByZXR1cm4gJyQnICsgZXNjYXBlZFN0cmluZztcbn1cblxuLyoqXG4gKiBUT0RPOiBUZXN0IHRoYXQgYSBzaW5nbGUgY2hpbGQgYW5kIGFuIGFycmF5IHdpdGggb25lIGl0ZW0gaGF2ZSB0aGUgc2FtZSBrZXlcbiAqIHBhdHRlcm4uXG4gKi9cblxudmFyIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcblxudmFyIHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4ID0gL1xcLysvZztcbmZ1bmN0aW9uIGVzY2FwZVVzZXJQcm92aWRlZEtleSh0ZXh0KSB7XG4gIHJldHVybiAoJycgKyB0ZXh0KS5yZXBsYWNlKHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4LCAnJCYvJyk7XG59XG5cbnZhciBQT09MX1NJWkUgPSAxMDtcbnZhciB0cmF2ZXJzZUNvbnRleHRQb29sID0gW107XG5mdW5jdGlvbiBnZXRQb29sZWRUcmF2ZXJzZUNvbnRleHQobWFwUmVzdWx0LCBrZXlQcmVmaXgsIG1hcEZ1bmN0aW9uLCBtYXBDb250ZXh0KSB7XG4gIGlmICh0cmF2ZXJzZUNvbnRleHRQb29sLmxlbmd0aCkge1xuICAgIHZhciB0cmF2ZXJzZUNvbnRleHQgPSB0cmF2ZXJzZUNvbnRleHRQb29sLnBvcCgpO1xuICAgIHRyYXZlcnNlQ29udGV4dC5yZXN1bHQgPSBtYXBSZXN1bHQ7XG4gICAgdHJhdmVyc2VDb250ZXh0LmtleVByZWZpeCA9IGtleVByZWZpeDtcbiAgICB0cmF2ZXJzZUNvbnRleHQuZnVuYyA9IG1hcEZ1bmN0aW9uO1xuICAgIHRyYXZlcnNlQ29udGV4dC5jb250ZXh0ID0gbWFwQ29udGV4dDtcbiAgICB0cmF2ZXJzZUNvbnRleHQuY291bnQgPSAwO1xuICAgIHJldHVybiB0cmF2ZXJzZUNvbnRleHQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3VsdDogbWFwUmVzdWx0LFxuICAgICAga2V5UHJlZml4OiBrZXlQcmVmaXgsXG4gICAgICBmdW5jOiBtYXBGdW5jdGlvbixcbiAgICAgIGNvbnRleHQ6IG1hcENvbnRleHQsXG4gICAgICBjb3VudDogMFxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVsZWFzZVRyYXZlcnNlQ29udGV4dCh0cmF2ZXJzZUNvbnRleHQpIHtcbiAgdHJhdmVyc2VDb250ZXh0LnJlc3VsdCA9IG51bGw7XG4gIHRyYXZlcnNlQ29udGV4dC5rZXlQcmVmaXggPSBudWxsO1xuICB0cmF2ZXJzZUNvbnRleHQuZnVuYyA9IG51bGw7XG4gIHRyYXZlcnNlQ29udGV4dC5jb250ZXh0ID0gbnVsbDtcbiAgdHJhdmVyc2VDb250ZXh0LmNvdW50ID0gMDtcbiAgaWYgKHRyYXZlcnNlQ29udGV4dFBvb2wubGVuZ3RoIDwgUE9PTF9TSVpFKSB7XG4gICAgdHJhdmVyc2VDb250ZXh0UG9vbC5wdXNoKHRyYXZlcnNlQ29udGV4dCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7IXN0cmluZ30gbmFtZVNvRmFyIE5hbWUgb2YgdGhlIGtleSBwYXRoIHNvIGZhci5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2l0aCBlYWNoIGNoaWxkIGZvdW5kLlxuICogQHBhcmFtIHs/Kn0gdHJhdmVyc2VDb250ZXh0IFVzZWQgdG8gcGFzcyBpbmZvcm1hdGlvbiB0aHJvdWdob3V0IHRoZSB0cmF2ZXJzYWxcbiAqIHByb2Nlc3MuXG4gKiBAcmV0dXJuIHshbnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIGluIHRoaXMgc3VidHJlZS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGRyZW4sIG5hbWVTb0ZhciwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBjaGlsZHJlbjtcblxuICBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgLy8gQWxsIG9mIHRoZSBhYm92ZSBhcmUgcGVyY2VpdmVkIGFzIG51bGwuXG4gICAgY2hpbGRyZW4gPSBudWxsO1xuICB9XG5cbiAgdmFyIGludm9rZUNhbGxiYWNrID0gZmFsc2U7XG5cbiAgaWYgKGNoaWxkcmVuID09PSBudWxsKSB7XG4gICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBzd2l0Y2ggKGNoaWxkcmVuLiQkdHlwZW9mKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9DQUxMX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9SRVRVUk5fVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGludm9rZUNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sodHJhdmVyc2VDb250ZXh0LCBjaGlsZHJlbixcbiAgICAvLyBJZiBpdCdzIHRoZSBvbmx5IGNoaWxkLCB0cmVhdCB0aGUgbmFtZSBhcyBpZiBpdCB3YXMgd3JhcHBlZCBpbiBhbiBhcnJheVxuICAgIC8vIHNvIHRoYXQgaXQncyBjb25zaXN0ZW50IGlmIHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gZ3Jvd3MuXG4gICAgbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiArIGdldENvbXBvbmVudEtleShjaGlsZHJlbiwgMCkgOiBuYW1lU29GYXIpO1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgdmFyIGNoaWxkO1xuICB2YXIgbmV4dE5hbWU7XG4gIHZhciBzdWJ0cmVlQ291bnQgPSAwOyAvLyBDb3VudCBvZiBjaGlsZHJlbiBmb3VuZCBpbiB0aGUgY3VycmVudCBzdWJ0cmVlLlxuICB2YXIgbmV4dE5hbWVQcmVmaXggPSBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SIDogbmFtZVNvRmFyICsgU1VCU0VQQVJBVE9SO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkLCBpKTtcbiAgICAgIHN1YnRyZWVDb3VudCArPSB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZCwgbmV4dE5hbWUsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4oY2hpbGRyZW4pO1xuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAge1xuICAgICAgICAvLyBXYXJuIGFib3V0IHVzaW5nIE1hcHMgYXMgY2hpbGRyZW5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gPT09IGNoaWxkcmVuLmVudHJpZXMpIHtcbiAgICAgICAgICB3YXJuaW5nKGRpZFdhcm5BYm91dE1hcHMsICdVc2luZyBNYXBzIGFzIGNoaWxkcmVuIGlzIHVuc3VwcG9ydGVkIGFuZCB3aWxsIGxpa2VseSB5aWVsZCAnICsgJ3VuZXhwZWN0ZWQgcmVzdWx0cy4gQ29udmVydCBpdCB0byBhIHNlcXVlbmNlL2l0ZXJhYmxlIG9mIGtleWVkICcgKyAnUmVhY3RFbGVtZW50cyBpbnN0ZWFkLiVzJywgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCkpO1xuICAgICAgICAgIGRpZFdhcm5BYm91dE1hcHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChjaGlsZHJlbik7XG4gICAgICB2YXIgc3RlcDtcbiAgICAgIHZhciBpaSA9IDA7XG4gICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgIGNoaWxkID0gc3RlcC52YWx1ZTtcbiAgICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldENvbXBvbmVudEtleShjaGlsZCwgaWkrKyk7XG4gICAgICAgIHN1YnRyZWVDb3VudCArPSB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZCwgbmV4dE5hbWUsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBhZGRlbmR1bSA9ICcnO1xuICAgICAge1xuICAgICAgICBhZGRlbmR1bSA9ICcgSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4sIHVzZSBhbiBhcnJheSAnICsgJ2luc3RlYWQuJyArIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuICAgICAgfVxuICAgICAgdmFyIGNoaWxkcmVuU3RyaW5nID0gJycgKyBjaGlsZHJlbjtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ09iamVjdHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkIChmb3VuZDogJXMpLiVzJywgY2hpbGRyZW5TdHJpbmcgPT09ICdbb2JqZWN0IE9iamVjdF0nID8gJ29iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhjaGlsZHJlbikuam9pbignLCAnKSArICd9JyA6IGNoaWxkcmVuU3RyaW5nLCBhZGRlbmR1bSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN1YnRyZWVDb3VudDtcbn1cblxuLyoqXG4gKiBUcmF2ZXJzZXMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLCBidXRcbiAqIG1pZ2h0IGFsc28gYmUgc3BlY2lmaWVkIHRocm91Z2ggYXR0cmlidXRlczpcbiAqXG4gKiAtIGB0cmF2ZXJzZUFsbENoaWxkcmVuKHRoaXMucHJvcHMuY2hpbGRyZW4sIC4uLilgXG4gKiAtIGB0cmF2ZXJzZUFsbENoaWxkcmVuKHRoaXMucHJvcHMubGVmdFBhbmVsQ2hpbGRyZW4sIC4uLilgXG4gKlxuICogVGhlIGB0cmF2ZXJzZUNvbnRleHRgIGlzIGFuIG9wdGlvbmFsIGFyZ3VtZW50IHRoYXQgaXMgcGFzc2VkIHRocm91Z2ggdGhlXG4gKiBlbnRpcmUgdHJhdmVyc2FsLiBJdCBjYW4gYmUgdXNlZCB0byBzdG9yZSBhY2N1bXVsYXRpb25zIG9yIGFueXRoaW5nIGVsc2UgdGhhdFxuICogdGhlIGNhbGxiYWNrIG1pZ2h0IGZpbmQgcmVsZXZhbnQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBvYmplY3QuXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gY2FsbGJhY2sgVG8gaW52b2tlIHVwb24gdHJhdmVyc2luZyBlYWNoIGNoaWxkLlxuICogQHBhcmFtIHs/Kn0gdHJhdmVyc2VDb250ZXh0IENvbnRleHQgZm9yIHRyYXZlcnNhbC5cbiAqIEByZXR1cm4geyFudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4gaW4gdGhpcyBzdWJ0cmVlLlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGRyZW4sICcnLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIGtleSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIGEgY29tcG9uZW50IHdpdGhpbiBhIHNldC5cbiAqXG4gKiBAcGFyYW0geyp9IGNvbXBvbmVudCBBIGNvbXBvbmVudCB0aGF0IGNvdWxkIGNvbnRhaW4gYSBtYW51YWwga2V5LlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IHRoYXQgaXMgdXNlZCBpZiBhIG1hbnVhbCBrZXkgaXMgbm90IHByb3ZpZGVkLlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXRDb21wb25lbnRLZXkoY29tcG9uZW50LCBpbmRleCkge1xuICAvLyBEbyBzb21lIHR5cGVjaGVja2luZyBoZXJlIHNpbmNlIHdlIGNhbGwgdGhpcyBibGluZGx5LiBXZSB3YW50IHRvIGVuc3VyZVxuICAvLyB0aGF0IHdlIGRvbid0IGJsb2NrIHBvdGVudGlhbCBmdXR1cmUgRVMgQVBJcy5cbiAgaWYgKHR5cGVvZiBjb21wb25lbnQgPT09ICdvYmplY3QnICYmIGNvbXBvbmVudCAhPT0gbnVsbCAmJiBjb21wb25lbnQua2V5ICE9IG51bGwpIHtcbiAgICAvLyBFeHBsaWNpdCBrZXlcbiAgICByZXR1cm4gZXNjYXBlKGNvbXBvbmVudC5rZXkpO1xuICB9XG4gIC8vIEltcGxpY2l0IGtleSBkZXRlcm1pbmVkIGJ5IHRoZSBpbmRleCBpbiB0aGUgc2V0XG4gIHJldHVybiBpbmRleC50b1N0cmluZygzNik7XG59XG5cbmZ1bmN0aW9uIGZvckVhY2hTaW5nbGVDaGlsZChib29rS2VlcGluZywgY2hpbGQsIG5hbWUpIHtcbiAgdmFyIGZ1bmMgPSBib29rS2VlcGluZy5mdW5jLFxuICAgICAgY29udGV4dCA9IGJvb2tLZWVwaW5nLmNvbnRleHQ7XG5cbiAgZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBib29rS2VlcGluZy5jb3VudCsrKTtcbn1cblxuLyoqXG4gKiBJdGVyYXRlcyB0aHJvdWdoIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLmZvcmVhY2hcbiAqXG4gKiBUaGUgcHJvdmlkZWQgZm9yRWFjaEZ1bmMoY2hpbGQsIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gZm9yRWFjaEZ1bmNcbiAqIEBwYXJhbSB7Kn0gZm9yRWFjaENvbnRleHQgQ29udGV4dCBmb3IgZm9yRWFjaENvbnRleHQuXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2hDaGlsZHJlbihjaGlsZHJlbiwgZm9yRWFjaEZ1bmMsIGZvckVhY2hDb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG4gIHZhciB0cmF2ZXJzZUNvbnRleHQgPSBnZXRQb29sZWRUcmF2ZXJzZUNvbnRleHQobnVsbCwgbnVsbCwgZm9yRWFjaEZ1bmMsIGZvckVhY2hDb250ZXh0KTtcbiAgdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgZm9yRWFjaFNpbmdsZUNoaWxkLCB0cmF2ZXJzZUNvbnRleHQpO1xuICByZWxlYXNlVHJhdmVyc2VDb250ZXh0KHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbmZ1bmN0aW9uIG1hcFNpbmdsZUNoaWxkSW50b0NvbnRleHQoYm9va0tlZXBpbmcsIGNoaWxkLCBjaGlsZEtleSkge1xuICB2YXIgcmVzdWx0ID0gYm9va0tlZXBpbmcucmVzdWx0LFxuICAgICAga2V5UHJlZml4ID0gYm9va0tlZXBpbmcua2V5UHJlZml4LFxuICAgICAgZnVuYyA9IGJvb2tLZWVwaW5nLmZ1bmMsXG4gICAgICBjb250ZXh0ID0gYm9va0tlZXBpbmcuY29udGV4dDtcblxuXG4gIHZhciBtYXBwZWRDaGlsZCA9IGZ1bmMuY2FsbChjb250ZXh0LCBjaGlsZCwgYm9va0tlZXBpbmcuY291bnQrKyk7XG4gIGlmIChBcnJheS5pc0FycmF5KG1hcHBlZENoaWxkKSkge1xuICAgIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwobWFwcGVkQ2hpbGQsIHJlc3VsdCwgY2hpbGRLZXksIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNBcmd1bWVudCk7XG4gIH0gZWxzZSBpZiAobWFwcGVkQ2hpbGQgIT0gbnVsbCkge1xuICAgIGlmIChpc1ZhbGlkRWxlbWVudChtYXBwZWRDaGlsZCkpIHtcbiAgICAgIG1hcHBlZENoaWxkID0gY2xvbmVBbmRSZXBsYWNlS2V5KG1hcHBlZENoaWxkLFxuICAgICAgLy8gS2VlcCBib3RoIHRoZSAobWFwcGVkKSBhbmQgb2xkIGtleXMgaWYgdGhleSBkaWZmZXIsIGp1c3QgYXNcbiAgICAgIC8vIHRyYXZlcnNlQWxsQ2hpbGRyZW4gdXNlZCB0byBkbyBmb3Igb2JqZWN0cyBhcyBjaGlsZHJlblxuICAgICAga2V5UHJlZml4ICsgKG1hcHBlZENoaWxkLmtleSAmJiAoIWNoaWxkIHx8IGNoaWxkLmtleSAhPT0gbWFwcGVkQ2hpbGQua2V5KSA/IGVzY2FwZVVzZXJQcm92aWRlZEtleShtYXBwZWRDaGlsZC5rZXkpICsgJy8nIDogJycpICsgY2hpbGRLZXkpO1xuICAgIH1cbiAgICByZXN1bHQucHVzaChtYXBwZWRDaGlsZCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChjaGlsZHJlbiwgYXJyYXksIHByZWZpeCwgZnVuYywgY29udGV4dCkge1xuICB2YXIgZXNjYXBlZFByZWZpeCA9ICcnO1xuICBpZiAocHJlZml4ICE9IG51bGwpIHtcbiAgICBlc2NhcGVkUHJlZml4ID0gZXNjYXBlVXNlclByb3ZpZGVkS2V5KHByZWZpeCkgKyAnLyc7XG4gIH1cbiAgdmFyIHRyYXZlcnNlQ29udGV4dCA9IGdldFBvb2xlZFRyYXZlcnNlQ29udGV4dChhcnJheSwgZXNjYXBlZFByZWZpeCwgZnVuYywgY29udGV4dCk7XG4gIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIG1hcFNpbmdsZUNoaWxkSW50b0NvbnRleHQsIHRyYXZlcnNlQ29udGV4dCk7XG4gIHJlbGVhc2VUcmF2ZXJzZUNvbnRleHQodHJhdmVyc2VDb250ZXh0KTtcbn1cblxuLyoqXG4gKiBNYXBzIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLm1hcFxuICpcbiAqIFRoZSBwcm92aWRlZCBtYXBGdW5jdGlvbihjaGlsZCwga2V5LCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZ1bmMgVGhlIG1hcCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBDb250ZXh0IGZvciBtYXBGdW5jdGlvbi5cbiAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9yZGVyZWQgbWFwIG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jLCBjb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChjaGlsZHJlbiwgcmVzdWx0LCBudWxsLCBmdW5jLCBjb250ZXh0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDb3VudCB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXNcbiAqIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdC5jaGlsZHJlbi5jb3VudFxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuLlxuICovXG5mdW5jdGlvbiBjb3VudENoaWxkcmVuKGNoaWxkcmVuLCBjb250ZXh0KSB7XG4gIHJldHVybiB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCwgbnVsbCk7XG59XG5cbi8qKlxuICogRmxhdHRlbiBhIGNoaWxkcmVuIG9iamVjdCAodHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gKSBhbmRcbiAqIHJldHVybiBhbiBhcnJheSB3aXRoIGFwcHJvcHJpYXRlbHkgcmUta2V5ZWQgY2hpbGRyZW4uXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdC5jaGlsZHJlbi50b2FycmF5XG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkoY2hpbGRyZW4pIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCByZXN1bHQsIG51bGwsIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNBcmd1bWVudCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgY2hpbGQgaW4gYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuIGFuZCB2ZXJpZmllcyB0aGF0IHRoZXJlXG4gKiBpcyBvbmx5IG9uZSBjaGlsZCBpbiB0aGUgY29sbGVjdGlvbi5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLm9ubHlcbiAqXG4gKiBUaGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCBhIHNpbmdsZSBjaGlsZCBnZXRzXG4gKiBwYXNzZWQgd2l0aG91dCBhIHdyYXBwZXIsIGJ1dCB0aGUgcHVycG9zZSBvZiB0aGlzIGhlbHBlciBmdW5jdGlvbiBpcyB0b1xuICogYWJzdHJhY3QgYXdheSB0aGUgcGFydGljdWxhciBzdHJ1Y3R1cmUgb2YgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBjaGlsZHJlbiBDaGlsZCBjb2xsZWN0aW9uIHN0cnVjdHVyZS5cbiAqIEByZXR1cm4ge1JlYWN0RWxlbWVudH0gVGhlIGZpcnN0IGFuZCBvbmx5IGBSZWFjdEVsZW1lbnRgIGNvbnRhaW5lZCBpbiB0aGVcbiAqIHN0cnVjdHVyZS5cbiAqL1xuZnVuY3Rpb24gb25seUNoaWxkKGNoaWxkcmVuKSB7XG4gICFpc1ZhbGlkRWxlbWVudChjaGlsZHJlbikgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdC5DaGlsZHJlbi5vbmx5IGV4cGVjdGVkIHRvIHJlY2VpdmUgYSBzaW5nbGUgUmVhY3QgZWxlbWVudCBjaGlsZC4nKSA6IHZvaWQgMDtcbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG52YXIgZGVzY3JpYmVDb21wb25lbnRGcmFtZSA9IGZ1bmN0aW9uIChuYW1lLCBzb3VyY2UsIG93bmVyTmFtZSkge1xuICByZXR1cm4gJ1xcbiAgICBpbiAnICsgKG5hbWUgfHwgJ1Vua25vd24nKSArIChzb3VyY2UgPyAnIChhdCAnICsgc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKSArICc6JyArIHNvdXJjZS5saW5lTnVtYmVyICsgJyknIDogb3duZXJOYW1lID8gJyAoY3JlYXRlZCBieSAnICsgb3duZXJOYW1lICsgJyknIDogJycpO1xufTtcblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZShmaWJlcikge1xuICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBSZWFjdEVsZW1lbnRWYWxpZGF0b3IgcHJvdmlkZXMgYSB3cmFwcGVyIGFyb3VuZCBhIGVsZW1lbnQgZmFjdG9yeVxuICogd2hpY2ggdmFsaWRhdGVzIHRoZSBwcm9wcyBwYXNzZWQgdG8gdGhlIGVsZW1lbnQuIFRoaXMgaXMgaW50ZW5kZWQgdG8gYmVcbiAqIHVzZWQgb25seSBpbiBERVYgYW5kIGNvdWxkIGJlIHJlcGxhY2VkIGJ5IGEgc3RhdGljIHR5cGUgY2hlY2tlciBmb3IgbGFuZ3VhZ2VzXG4gKiB0aGF0IHN1cHBvcnQgaXQuXG4gKi9cblxue1xuICB2YXIgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSBudWxsO1xuXG4gIHZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xuXG4gIHZhciBnZXREaXNwbGF5TmFtZSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcjZW1wdHknO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBlbGVtZW50ID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuICcjdGV4dCc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudC50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGVsZW1lbnQudHlwZTtcbiAgICB9IGVsc2UgaWYgKGVsZW1lbnQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgcmV0dXJuICdSZWFjdC5GcmFnbWVudCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBlbGVtZW50LnR5cGUuZGlzcGxheU5hbWUgfHwgZWxlbWVudC50eXBlLm5hbWUgfHwgJ1Vua25vd24nO1xuICAgIH1cbiAgfTtcblxuICB2YXIgZ2V0U3RhY2tBZGRlbmR1bSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhY2sgPSAnJztcbiAgICBpZiAoY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQpIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0RGlzcGxheU5hbWUoY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQpO1xuICAgICAgdmFyIG93bmVyID0gY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQuX293bmVyO1xuICAgICAgc3RhY2sgKz0gZGVzY3JpYmVDb21wb25lbnRGcmFtZShuYW1lLCBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudC5fc291cmNlLCBvd25lciAmJiBnZXRDb21wb25lbnROYW1lKG93bmVyKSk7XG4gICAgfVxuICAgIHN0YWNrICs9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpIHx8ICcnO1xuICAgIHJldHVybiBzdGFjaztcbiAgfTtcblxuICB2YXIgVkFMSURfRlJBR01FTlRfUFJPUFMgPSBuZXcgTWFwKFtbJ2NoaWxkcmVuJywgdHJ1ZV0sIFsna2V5JywgdHJ1ZV1dKTtcbn1cblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xuICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKGVsZW1lbnRQcm9wcykge1xuICBpZiAoZWxlbWVudFByb3BzICE9PSBudWxsICYmIGVsZW1lbnRQcm9wcyAhPT0gdW5kZWZpbmVkICYmIGVsZW1lbnRQcm9wcy5fX3NvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHNvdXJjZSA9IGVsZW1lbnRQcm9wcy5fX3NvdXJjZTtcbiAgICB2YXIgZmlsZU5hbWUgPSBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpO1xuICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgcmV0dXJuICdcXG5cXG5DaGVjayB5b3VyIGNvZGUgYXQgJyArIGZpbGVOYW1lICsgJzonICsgbGluZU51bWJlciArICcuJztcbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gKiB1cGRhdGVzLlxuICovXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB2YXIgaW5mbyA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuXG4gIGlmICghaW5mbykge1xuICAgIHZhciBwYXJlbnROYW1lID0gdHlwZW9mIHBhcmVudFR5cGUgPT09ICdzdHJpbmcnID8gcGFyZW50VHlwZSA6IHBhcmVudFR5cGUuZGlzcGxheU5hbWUgfHwgcGFyZW50VHlwZS5uYW1lO1xuICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICBpbmZvID0gJ1xcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPCcgKyBwYXJlbnROYW1lICsgJz4uJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGluZm87XG59XG5cbi8qKlxuICogV2FybiBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYW4gZXhwbGljaXQga2V5IGFzc2lnbmVkIHRvIGl0LlxuICogVGhpcyBlbGVtZW50IGlzIGluIGFuIGFycmF5LiBUaGUgYXJyYXkgY291bGQgZ3JvdyBhbmQgc2hyaW5rIG9yIGJlXG4gKiByZW9yZGVyZWQuIEFsbCBjaGlsZHJlbiB0aGF0IGhhdmVuJ3QgYWxyZWFkeSBiZWVuIHZhbGlkYXRlZCBhcmUgcmVxdWlyZWQgdG9cbiAqIGhhdmUgYSBcImtleVwiIHByb3BlcnR5IGFzc2lnbmVkIHRvIGl0LiBFcnJvciBzdGF0dXNlcyBhcmUgY2FjaGVkIHNvIGEgd2FybmluZ1xuICogd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRoYXQgcmVxdWlyZXMgYSBrZXkuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgZWxlbWVudCdzIHBhcmVudCdzIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICBpZiAoIWVsZW1lbnQuX3N0b3JlIHx8IGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCB8fCBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG5cbiAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuICBpZiAob3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7XG5cbiAgLy8gVXN1YWxseSB0aGUgY3VycmVudCBvd25lciBpcyB0aGUgb2ZmZW5kZXIsIGJ1dCBpZiBpdCBhY2NlcHRzIGNoaWxkcmVuIGFzIGFcbiAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAvLyBhc3NpZ25pbmcgaXQgYSBrZXkuXG4gIHZhciBjaGlsZE93bmVyID0gJyc7XG4gIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX293bmVyICE9PSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgY2hpbGRPd25lciA9ICcgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gJyArIGdldENvbXBvbmVudE5hbWUoZWxlbWVudC5fb3duZXIpICsgJy4nO1xuICB9XG5cbiAgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSBlbGVtZW50O1xuICB7XG4gICAgd2FybmluZyhmYWxzZSwgJ0VhY2ggY2hpbGQgaW4gYW4gYXJyYXkgb3IgaXRlcmF0b3Igc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLicgKyAnJXMlcyBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJXMnLCBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvLCBjaGlsZE93bmVyLCBnZXRTdGFja0FkZGVuZHVtKCkpO1xuICB9XG4gIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50ID0gbnVsbDtcbn1cblxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcbiAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG4gICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgIG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKG5vZGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCkge1xuICB2YXIgY29tcG9uZW50Q2xhc3MgPSBlbGVtZW50LnR5cGU7XG4gIGlmICh0eXBlb2YgY29tcG9uZW50Q2xhc3MgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG5hbWUgPSBjb21wb25lbnRDbGFzcy5kaXNwbGF5TmFtZSB8fCBjb21wb25lbnRDbGFzcy5uYW1lO1xuICB2YXIgcHJvcFR5cGVzID0gY29tcG9uZW50Q2xhc3MucHJvcFR5cGVzO1xuICBpZiAocHJvcFR5cGVzKSB7XG4gICAgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSBlbGVtZW50O1xuICAgIGNoZWNrUHJvcFR5cGVzKHByb3BUeXBlcywgZWxlbWVudC5wcm9wcywgJ3Byb3AnLCBuYW1lLCBnZXRTdGFja0FkZGVuZHVtKTtcbiAgICBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IG51bGw7XG4gIH0gZWxzZSBpZiAoY29tcG9uZW50Q2xhc3MuUHJvcFR5cGVzICE9PSB1bmRlZmluZWQgJiYgIXByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duKSB7XG4gICAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsICdDb21wb25lbnQgJXMgZGVjbGFyZWQgYFByb3BUeXBlc2AgaW5zdGVhZCBvZiBgcHJvcFR5cGVzYC4gRGlkIHlvdSBtaXNzcGVsbCB0aGUgcHJvcGVydHkgYXNzaWdubWVudD8nLCBuYW1lIHx8ICdVbmtub3duJyk7XG4gIH1cbiAgaWYgKHR5cGVvZiBjb21wb25lbnRDbGFzcy5nZXREZWZhdWx0UHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICB3YXJuaW5nKGNvbXBvbmVudENsYXNzLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCwgJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcbiAgfVxufVxuXG4vKipcbiAqIEdpdmVuIGEgZnJhZ21lbnQsIHZhbGlkYXRlIHRoYXQgaXQgY2FuIG9ubHkgYmUgcHJvdmlkZWQgd2l0aCBmcmFnbWVudCBwcm9wc1xuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGZyYWdtZW50XG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IGZyYWdtZW50O1xuXG4gIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuICB0cnkge1xuICAgIGZvciAodmFyIF9pdGVyYXRvciA9IE9iamVjdC5rZXlzKGZyYWdtZW50LnByb3BzKVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcbiAgICAgIHZhciBrZXkgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgaWYgKCFWQUxJRF9GUkFHTUVOVF9QUk9QUy5oYXMoa2V5KSkge1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLiVzJywga2V5LCBnZXRTdGFja0FkZGVuZHVtKCkpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvclsncmV0dXJuJ10pIHtcbiAgICAgICAgX2l0ZXJhdG9yWydyZXR1cm4nXSgpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGF0dHJpYnV0ZSBgcmVmYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiVzJywgZ2V0U3RhY2tBZGRlbmR1bSgpKTtcbiAgfVxuXG4gIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50ID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBjaGlsZHJlbikge1xuICB2YXIgdmFsaWRUeXBlID0gdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiB0eXBlID09PSAnc3ltYm9sJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ251bWJlcic7XG4gIC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gIC8vIHN1Y2NlZWQgYW5kIHRoZXJlIHdpbGwgbGlrZWx5IGJlIGVycm9ycyBpbiByZW5kZXIuXG4gIGlmICghdmFsaWRUeXBlKSB7XG4gICAgdmFyIGluZm8gPSAnJztcbiAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICB9XG5cbiAgICB2YXIgc291cmNlSW5mbyA9IGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHByb3BzKTtcbiAgICBpZiAoc291cmNlSW5mbykge1xuICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbmZvICs9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuICAgIH1cblxuICAgIGluZm8gKz0gZ2V0U3RhY2tBZGRlbmR1bSgpIHx8ICcnO1xuXG4gICAgd2FybmluZyhmYWxzZSwgJ1JlYWN0LmNyZWF0ZUVsZW1lbnQ6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZSA9PSBudWxsID8gdHlwZSA6IHR5cGVvZiB0eXBlLCBpbmZvKTtcbiAgfVxuXG4gIHZhciBlbGVtZW50ID0gY3JlYXRlRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIC8vIFRoZSByZXN1bHQgY2FuIGJlIG51bGxpc2ggaWYgYSBtb2NrIG9yIGEgY3VzdG9tIGZ1bmN0aW9uIGlzIHVzZWQuXG4gIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cbiAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmcgZXJyb3JzLlxuICAvLyBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kIHByb2QuXG4gIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gIC8vIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcbiAgaWYgKHZhbGlkVHlwZSkge1xuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIHR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N5bWJvbCcgJiYgdHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgfSBlbHNlIHtcbiAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGYWN0b3J5V2l0aFZhbGlkYXRpb24odHlwZSkge1xuICB2YXIgdmFsaWRhdGVkRmFjdG9yeSA9IGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbi5iaW5kKG51bGwsIHR5cGUpO1xuICAvLyBMZWdhY3kgaG9vayBUT0RPOiBXYXJuIGlmIHRoaXMgaXMgYWNjZXNzZWRcbiAgdmFsaWRhdGVkRmFjdG9yeS50eXBlID0gdHlwZTtcblxuICB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbGlkYXRlZEZhY3RvcnksICd0eXBlJywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG93UHJpb3JpdHlXYXJuaW5nJDEoZmFsc2UsICdGYWN0b3J5LnR5cGUgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHRoZSBjbGFzcyBkaXJlY3RseSAnICsgJ2JlZm9yZSBwYXNzaW5nIGl0IHRvIGNyZWF0ZUZhY3RvcnkuJyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAndHlwZScsIHtcbiAgICAgICAgICB2YWx1ZTogdHlwZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdmFsaWRhdGVkRmFjdG9yeTtcbn1cblxuZnVuY3Rpb24gY2xvbmVFbGVtZW50V2l0aFZhbGlkYXRpb24oZWxlbWVudCwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gIHZhciBuZXdFbGVtZW50ID0gY2xvbmVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCBuZXdFbGVtZW50LnR5cGUpO1xuICB9XG4gIHZhbGlkYXRlUHJvcFR5cGVzKG5ld0VsZW1lbnQpO1xuICByZXR1cm4gbmV3RWxlbWVudDtcbn1cblxudmFyIFJlYWN0ID0ge1xuICBDaGlsZHJlbjoge1xuICAgIG1hcDogbWFwQ2hpbGRyZW4sXG4gICAgZm9yRWFjaDogZm9yRWFjaENoaWxkcmVuLFxuICAgIGNvdW50OiBjb3VudENoaWxkcmVuLFxuICAgIHRvQXJyYXk6IHRvQXJyYXksXG4gICAgb25seTogb25seUNoaWxkXG4gIH0sXG5cbiAgQ29tcG9uZW50OiBDb21wb25lbnQsXG4gIFB1cmVDb21wb25lbnQ6IFB1cmVDb21wb25lbnQsXG4gIHVuc3RhYmxlX0FzeW5jQ29tcG9uZW50OiBBc3luY0NvbXBvbmVudCxcblxuICBGcmFnbWVudDogUkVBQ1RfRlJBR01FTlRfVFlQRSxcblxuICBjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24sXG4gIGNsb25lRWxlbWVudDogY2xvbmVFbGVtZW50V2l0aFZhbGlkYXRpb24sXG4gIGNyZWF0ZUZhY3Rvcnk6IGNyZWF0ZUZhY3RvcnlXaXRoVmFsaWRhdGlvbixcbiAgaXNWYWxpZEVsZW1lbnQ6IGlzVmFsaWRFbGVtZW50LFxuXG4gIHZlcnNpb246IFJlYWN0VmVyc2lvbixcblxuICBfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDoge1xuICAgIFJlYWN0Q3VycmVudE93bmVyOiBSZWFjdEN1cnJlbnRPd25lcixcbiAgICAvLyBVc2VkIGJ5IHJlbmRlcmVycyB0byBhdm9pZCBidW5kbGluZyBvYmplY3QtYXNzaWduIHR3aWNlIGluIFVNRCBidW5kbGVzOlxuICAgIGFzc2lnbjogX2Fzc2lnblxuICB9XG59O1xuXG57XG4gIF9hc3NpZ24oUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQsIHtcbiAgICAvLyBUaGVzZSBzaG91bGQgbm90IGJlIGluY2x1ZGVkIGluIHByb2R1Y3Rpb24uXG4gICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTogUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSxcbiAgICAvLyBTaGltIGZvciBSZWFjdCBET00gMTYuMC4wIHdoaWNoIHN0aWxsIGRlc3RydWN0dXJlZCAoYnV0IG5vdCB1c2VkKSB0aGlzLlxuICAgIC8vIFRPRE86IHJlbW92ZSBpbiBSZWFjdCAxNy4wLlxuICAgIFJlYWN0Q29tcG9uZW50VHJlZUhvb2s6IHt9XG4gIH0pO1xufVxuXG5cblxudmFyIFJlYWN0JDIgPSBPYmplY3QuZnJlZXplKHtcblx0ZGVmYXVsdDogUmVhY3Rcbn0pO1xuXG52YXIgUmVhY3QkMyA9ICggUmVhY3QkMiAmJiBSZWFjdCApIHx8IFJlYWN0JDI7XG5cbi8vIFRPRE86IGRlY2lkZSBvbiB0aGUgdG9wLWxldmVsIGV4cG9ydCBmb3JtLlxuLy8gVGhpcyBpcyBoYWNreSBidXQgbWFrZXMgaXQgd29yayB3aXRoIGJvdGggUm9sbHVwIGFuZCBKZXN0LlxudmFyIHJlYWN0ID0gUmVhY3QkM1snZGVmYXVsdCddID8gUmVhY3QkM1snZGVmYXVsdCddIDogUmVhY3QkMztcblxubW9kdWxlLmV4cG9ydHMgPSByZWFjdDtcbiAgfSkoKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qc1xuLy8gbW9kdWxlIGlkID0gMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///25\n");

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/** @license React v16.2.0\n * react-dom.production.min.js\n *\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/*\n Modernizr 3.0.0pre (Custom Build) | MIT\n*/\nvar aa=__webpack_require__(1),l=__webpack_require__(10),B=__webpack_require__(3),C=__webpack_require__(2),ba=__webpack_require__(11),da=__webpack_require__(12),ea=__webpack_require__(13),fa=__webpack_require__(14),ia=__webpack_require__(15),D=__webpack_require__(5);\nfunction E(a){for(var b=arguments.length-1,c=\"Minified React error #\"+a+\"; visit http://facebook.github.io/react/docs/error-decoder.html?invariant\\x3d\"+a,d=0;d<b;d++)c+=\"\\x26args[]\\x3d\"+encodeURIComponent(arguments[d+1]);b=Error(c+\" for the full message or use the non-minified dev environment for full errors and additional helpful warnings.\");b.name=\"Invariant Violation\";b.framesToPop=1;throw b;}aa?void 0:E(\"227\");\nvar oa={children:!0,dangerouslySetInnerHTML:!0,defaultValue:!0,defaultChecked:!0,innerHTML:!0,suppressContentEditableWarning:!0,suppressHydrationWarning:!0,style:!0};function pa(a,b){return(a&b)===b}\nvar ta={MUST_USE_PROPERTY:1,HAS_BOOLEAN_VALUE:4,HAS_NUMERIC_VALUE:8,HAS_POSITIVE_NUMERIC_VALUE:24,HAS_OVERLOADED_BOOLEAN_VALUE:32,HAS_STRING_BOOLEAN_VALUE:64,injectDOMPropertyConfig:function(a){var b=ta,c=a.Properties||{},d=a.DOMAttributeNamespaces||{},e=a.DOMAttributeNames||{};a=a.DOMMutationMethods||{};for(var f in c){ua.hasOwnProperty(f)?E(\"48\",f):void 0;var g=f.toLowerCase(),h=c[f];g={attributeName:g,attributeNamespace:null,propertyName:f,mutationMethod:null,mustUseProperty:pa(h,b.MUST_USE_PROPERTY),\nhasBooleanValue:pa(h,b.HAS_BOOLEAN_VALUE),hasNumericValue:pa(h,b.HAS_NUMERIC_VALUE),hasPositiveNumericValue:pa(h,b.HAS_POSITIVE_NUMERIC_VALUE),hasOverloadedBooleanValue:pa(h,b.HAS_OVERLOADED_BOOLEAN_VALUE),hasStringBooleanValue:pa(h,b.HAS_STRING_BOOLEAN_VALUE)};1>=g.hasBooleanValue+g.hasNumericValue+g.hasOverloadedBooleanValue?void 0:E(\"50\",f);e.hasOwnProperty(f)&&(g.attributeName=e[f]);d.hasOwnProperty(f)&&(g.attributeNamespace=d[f]);a.hasOwnProperty(f)&&(g.mutationMethod=a[f]);ua[f]=g}}},ua={};\nfunction va(a,b){if(oa.hasOwnProperty(a)||2<a.length&&(\"o\"===a[0]||\"O\"===a[0])&&(\"n\"===a[1]||\"N\"===a[1]))return!1;if(null===b)return!0;switch(typeof b){case \"boolean\":return oa.hasOwnProperty(a)?a=!0:(b=wa(a))?a=b.hasBooleanValue||b.hasStringBooleanValue||b.hasOverloadedBooleanValue:(a=a.toLowerCase().slice(0,5),a=\"data-\"===a||\"aria-\"===a),a;case \"undefined\":case \"number\":case \"string\":case \"object\":return!0;default:return!1}}function wa(a){return ua.hasOwnProperty(a)?ua[a]:null}\nvar xa=ta,ya=xa.MUST_USE_PROPERTY,K=xa.HAS_BOOLEAN_VALUE,za=xa.HAS_NUMERIC_VALUE,Aa=xa.HAS_POSITIVE_NUMERIC_VALUE,Ba=xa.HAS_OVERLOADED_BOOLEAN_VALUE,Ca=xa.HAS_STRING_BOOLEAN_VALUE,Da={Properties:{allowFullScreen:K,async:K,autoFocus:K,autoPlay:K,capture:Ba,checked:ya|K,cols:Aa,contentEditable:Ca,controls:K,\"default\":K,defer:K,disabled:K,download:Ba,draggable:Ca,formNoValidate:K,hidden:K,loop:K,multiple:ya|K,muted:ya|K,noValidate:K,open:K,playsInline:K,readOnly:K,required:K,reversed:K,rows:Aa,rowSpan:za,\nscoped:K,seamless:K,selected:ya|K,size:Aa,start:za,span:Aa,spellCheck:Ca,style:0,tabIndex:0,itemScope:K,acceptCharset:0,className:0,htmlFor:0,httpEquiv:0,value:Ca},DOMAttributeNames:{acceptCharset:\"accept-charset\",className:\"class\",htmlFor:\"for\",httpEquiv:\"http-equiv\"},DOMMutationMethods:{value:function(a,b){if(null==b)return a.removeAttribute(\"value\");\"number\"!==a.type||!1===a.hasAttribute(\"value\")?a.setAttribute(\"value\",\"\"+b):a.validity&&!a.validity.badInput&&a.ownerDocument.activeElement!==a&&\na.setAttribute(\"value\",\"\"+b)}}},Ea=xa.HAS_STRING_BOOLEAN_VALUE,M={xlink:\"http://www.w3.org/1999/xlink\",xml:\"http://www.w3.org/XML/1998/namespace\"},Ga={Properties:{autoReverse:Ea,externalResourcesRequired:Ea,preserveAlpha:Ea},DOMAttributeNames:{autoReverse:\"autoReverse\",externalResourcesRequired:\"externalResourcesRequired\",preserveAlpha:\"preserveAlpha\"},DOMAttributeNamespaces:{xlinkActuate:M.xlink,xlinkArcrole:M.xlink,xlinkHref:M.xlink,xlinkRole:M.xlink,xlinkShow:M.xlink,xlinkTitle:M.xlink,xlinkType:M.xlink,\nxmlBase:M.xml,xmlLang:M.xml,xmlSpace:M.xml}},Ha=/[\\-\\:]([a-z])/g;function Ia(a){return a[1].toUpperCase()}\n\"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode x-height xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xmlns:xlink xml:lang xml:space\".split(\" \").forEach(function(a){var b=a.replace(Ha,\nIa);Ga.Properties[b]=0;Ga.DOMAttributeNames[b]=a});xa.injectDOMPropertyConfig(Da);xa.injectDOMPropertyConfig(Ga);\nvar P={_caughtError:null,_hasCaughtError:!1,_rethrowError:null,_hasRethrowError:!1,injection:{injectErrorUtils:function(a){\"function\"!==typeof a.invokeGuardedCallback?E(\"197\"):void 0;Ja=a.invokeGuardedCallback}},invokeGuardedCallback:function(a,b,c,d,e,f,g,h,k){Ja.apply(P,arguments)},invokeGuardedCallbackAndCatchFirstError:function(a,b,c,d,e,f,g,h,k){P.invokeGuardedCallback.apply(this,arguments);if(P.hasCaughtError()){var q=P.clearCaughtError();P._hasRethrowError||(P._hasRethrowError=!0,P._rethrowError=\nq)}},rethrowCaughtError:function(){return Ka.apply(P,arguments)},hasCaughtError:function(){return P._hasCaughtError},clearCaughtError:function(){if(P._hasCaughtError){var a=P._caughtError;P._caughtError=null;P._hasCaughtError=!1;return a}E(\"198\")}};function Ja(a,b,c,d,e,f,g,h,k){P._hasCaughtError=!1;P._caughtError=null;var q=Array.prototype.slice.call(arguments,3);try{b.apply(c,q)}catch(v){P._caughtError=v,P._hasCaughtError=!0}}\nfunction Ka(){if(P._hasRethrowError){var a=P._rethrowError;P._rethrowError=null;P._hasRethrowError=!1;throw a;}}var La=null,Ma={};\nfunction Na(){if(La)for(var a in Ma){var b=Ma[a],c=La.indexOf(a);-1<c?void 0:E(\"96\",a);if(!Oa[c]){b.extractEvents?void 0:E(\"97\",a);Oa[c]=b;c=b.eventTypes;for(var d in c){var e=void 0;var f=c[d],g=b,h=d;Pa.hasOwnProperty(h)?E(\"99\",h):void 0;Pa[h]=f;var k=f.phasedRegistrationNames;if(k){for(e in k)k.hasOwnProperty(e)&&Qa(k[e],g,h);e=!0}else f.registrationName?(Qa(f.registrationName,g,h),e=!0):e=!1;e?void 0:E(\"98\",d,a)}}}}\nfunction Qa(a,b,c){Ra[a]?E(\"100\",a):void 0;Ra[a]=b;Sa[a]=b.eventTypes[c].dependencies}var Oa=[],Pa={},Ra={},Sa={};function Ta(a){La?E(\"101\"):void 0;La=Array.prototype.slice.call(a);Na()}function Ua(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];Ma.hasOwnProperty(c)&&Ma[c]===d||(Ma[c]?E(\"102\",c):void 0,Ma[c]=d,b=!0)}b&&Na()}\nvar Va=Object.freeze({plugins:Oa,eventNameDispatchConfigs:Pa,registrationNameModules:Ra,registrationNameDependencies:Sa,possibleRegistrationNames:null,injectEventPluginOrder:Ta,injectEventPluginsByName:Ua}),Wa=null,Xa=null,Ya=null;function Za(a,b,c,d){b=a.type||\"unknown-event\";a.currentTarget=Ya(d);P.invokeGuardedCallbackAndCatchFirstError(b,c,void 0,a);a.currentTarget=null}\nfunction $a(a,b){null==b?E(\"30\"):void 0;if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function ab(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}var bb=null;\nfunction cb(a,b){if(a){var c=a._dispatchListeners,d=a._dispatchInstances;if(Array.isArray(c))for(var e=0;e<c.length&&!a.isPropagationStopped();e++)Za(a,b,c[e],d[e]);else c&&Za(a,b,c,d);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}}function db(a){return cb(a,!0)}function gb(a){return cb(a,!1)}var hb={injectEventPluginOrder:Ta,injectEventPluginsByName:Ua};\nfunction ib(a,b){var c=a.stateNode;if(!c)return null;var d=Wa(c);if(!d)return null;c=d[b];a:switch(b){case \"onClick\":case \"onClickCapture\":case \"onDoubleClick\":case \"onDoubleClickCapture\":case \"onMouseDown\":case \"onMouseDownCapture\":case \"onMouseMove\":case \"onMouseMoveCapture\":case \"onMouseUp\":case \"onMouseUpCapture\":(d=!d.disabled)||(a=a.type,d=!(\"button\"===a||\"input\"===a||\"select\"===a||\"textarea\"===a));a=!d;break a;default:a=!1}if(a)return null;c&&\"function\"!==typeof c?E(\"231\",b,typeof c):void 0;\nreturn c}function jb(a,b,c,d){for(var e,f=0;f<Oa.length;f++){var g=Oa[f];g&&(g=g.extractEvents(a,b,c,d))&&(e=$a(e,g))}return e}function kb(a){a&&(bb=$a(bb,a))}function lb(a){var b=bb;bb=null;b&&(a?ab(b,db):ab(b,gb),bb?E(\"95\"):void 0,P.rethrowCaughtError())}var mb=Object.freeze({injection:hb,getListener:ib,extractEvents:jb,enqueueEvents:kb,processEventQueue:lb}),nb=Math.random().toString(36).slice(2),Q=\"__reactInternalInstance$\"+nb,ob=\"__reactEventHandlers$\"+nb;\nfunction pb(a){if(a[Q])return a[Q];for(var b=[];!a[Q];)if(b.push(a),a.parentNode)a=a.parentNode;else return null;var c=void 0,d=a[Q];if(5===d.tag||6===d.tag)return d;for(;a&&(d=a[Q]);a=b.pop())c=d;return c}function qb(a){if(5===a.tag||6===a.tag)return a.stateNode;E(\"33\")}function rb(a){return a[ob]||null}\nvar sb=Object.freeze({precacheFiberNode:function(a,b){b[Q]=a},getClosestInstanceFromNode:pb,getInstanceFromNode:function(a){a=a[Q];return!a||5!==a.tag&&6!==a.tag?null:a},getNodeFromInstance:qb,getFiberCurrentPropsFromNode:rb,updateFiberProps:function(a,b){a[ob]=b}});function tb(a){do a=a[\"return\"];while(a&&5!==a.tag);return a?a:null}function ub(a,b,c){for(var d=[];a;)d.push(a),a=tb(a);for(a=d.length;0<a--;)b(d[a],\"captured\",c);for(a=0;a<d.length;a++)b(d[a],\"bubbled\",c)}\nfunction vb(a,b,c){if(b=ib(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=$a(c._dispatchListeners,b),c._dispatchInstances=$a(c._dispatchInstances,a)}function wb(a){a&&a.dispatchConfig.phasedRegistrationNames&&ub(a._targetInst,vb,a)}function xb(a){if(a&&a.dispatchConfig.phasedRegistrationNames){var b=a._targetInst;b=b?tb(b):null;ub(b,vb,a)}}\nfunction yb(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=ib(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=$a(c._dispatchListeners,b),c._dispatchInstances=$a(c._dispatchInstances,a))}function zb(a){a&&a.dispatchConfig.registrationName&&yb(a._targetInst,null,a)}function Ab(a){ab(a,wb)}\nfunction Bb(a,b,c,d){if(c&&d)a:{var e=c;for(var f=d,g=0,h=e;h;h=tb(h))g++;h=0;for(var k=f;k;k=tb(k))h++;for(;0<g-h;)e=tb(e),g--;for(;0<h-g;)f=tb(f),h--;for(;g--;){if(e===f||e===f.alternate)break a;e=tb(e);f=tb(f)}e=null}else e=null;f=e;for(e=[];c&&c!==f;){g=c.alternate;if(null!==g&&g===f)break;e.push(c);c=tb(c)}for(c=[];d&&d!==f;){g=d.alternate;if(null!==g&&g===f)break;c.push(d);d=tb(d)}for(d=0;d<e.length;d++)yb(e[d],\"bubbled\",a);for(a=c.length;0<a--;)yb(c[a],\"captured\",b)}\nvar Cb=Object.freeze({accumulateTwoPhaseDispatches:Ab,accumulateTwoPhaseDispatchesSkipTarget:function(a){ab(a,xb)},accumulateEnterLeaveDispatches:Bb,accumulateDirectDispatches:function(a){ab(a,zb)}}),Db=null;function Eb(){!Db&&l.canUseDOM&&(Db=\"textContent\"in document.documentElement?\"textContent\":\"innerText\");return Db}var S={_root:null,_startText:null,_fallbackText:null};\nfunction Fb(){if(S._fallbackText)return S._fallbackText;var a,b=S._startText,c=b.length,d,e=Gb(),f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);S._fallbackText=e.slice(a,1<d?1-d:void 0);return S._fallbackText}function Gb(){return\"value\"in S._root?S._root.value:S._root[Eb()]}\nvar Hb=\"dispatchConfig _targetInst nativeEvent isDefaultPrevented isPropagationStopped _dispatchListeners _dispatchInstances\".split(\" \"),Ib={type:null,target:null,currentTarget:C.thatReturnsNull,eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||Date.now()},defaultPrevented:null,isTrusted:null};\nfunction T(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):\"target\"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?C.thatReturnsTrue:C.thatReturnsFalse;this.isPropagationStopped=C.thatReturnsFalse;return this}\nB(T.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():\"unknown\"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=C.thatReturnsTrue)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():\"unknown\"!==typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=C.thatReturnsTrue)},persist:function(){this.isPersistent=C.thatReturnsTrue},isPersistent:C.thatReturnsFalse,\ndestructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;for(a=0;a<Hb.length;a++)this[Hb[a]]=null}});T.Interface=Ib;T.augmentClass=function(a,b){function c(){}c.prototype=this.prototype;var d=new c;B(d,a.prototype);a.prototype=d;a.prototype.constructor=a;a.Interface=B({},this.Interface,b);a.augmentClass=this.augmentClass;Jb(a)};Jb(T);function Kb(a,b,c,d){if(this.eventPool.length){var e=this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}\nfunction Lb(a){a instanceof this?void 0:E(\"223\");a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function Jb(a){a.eventPool=[];a.getPooled=Kb;a.release=Lb}function Mb(a,b,c,d){return T.call(this,a,b,c,d)}T.augmentClass(Mb,{data:null});function Nb(a,b,c,d){return T.call(this,a,b,c,d)}T.augmentClass(Nb,{data:null});var Pb=[9,13,27,32],Vb=l.canUseDOM&&\"CompositionEvent\"in window,Wb=null;l.canUseDOM&&\"documentMode\"in document&&(Wb=document.documentMode);var Xb;\nif(Xb=l.canUseDOM&&\"TextEvent\"in window&&!Wb){var Yb=window.opera;Xb=!(\"object\"===typeof Yb&&\"function\"===typeof Yb.version&&12>=parseInt(Yb.version(),10))}\nvar Zb=Xb,$b=l.canUseDOM&&(!Vb||Wb&&8<Wb&&11>=Wb),ac=String.fromCharCode(32),bc={beforeInput:{phasedRegistrationNames:{bubbled:\"onBeforeInput\",captured:\"onBeforeInputCapture\"},dependencies:[\"topCompositionEnd\",\"topKeyPress\",\"topTextInput\",\"topPaste\"]},compositionEnd:{phasedRegistrationNames:{bubbled:\"onCompositionEnd\",captured:\"onCompositionEndCapture\"},dependencies:\"topBlur topCompositionEnd topKeyDown topKeyPress topKeyUp topMouseDown\".split(\" \")},compositionStart:{phasedRegistrationNames:{bubbled:\"onCompositionStart\",\ncaptured:\"onCompositionStartCapture\"},dependencies:\"topBlur topCompositionStart topKeyDown topKeyPress topKeyUp topMouseDown\".split(\" \")},compositionUpdate:{phasedRegistrationNames:{bubbled:\"onCompositionUpdate\",captured:\"onCompositionUpdateCapture\"},dependencies:\"topBlur topCompositionUpdate topKeyDown topKeyPress topKeyUp topMouseDown\".split(\" \")}},cc=!1;\nfunction dc(a,b){switch(a){case \"topKeyUp\":return-1!==Pb.indexOf(b.keyCode);case \"topKeyDown\":return 229!==b.keyCode;case \"topKeyPress\":case \"topMouseDown\":case \"topBlur\":return!0;default:return!1}}function ec(a){a=a.detail;return\"object\"===typeof a&&\"data\"in a?a.data:null}var fc=!1;function gc(a,b){switch(a){case \"topCompositionEnd\":return ec(b);case \"topKeyPress\":if(32!==b.which)return null;cc=!0;return ac;case \"topTextInput\":return a=b.data,a===ac&&cc?null:a;default:return null}}\nfunction hc(a,b){if(fc)return\"topCompositionEnd\"===a||!Vb&&dc(a,b)?(a=Fb(),S._root=null,S._startText=null,S._fallbackText=null,fc=!1,a):null;switch(a){case \"topPaste\":return null;case \"topKeyPress\":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;case \"topCompositionEnd\":return $b?null:b.data;default:return null}}\nvar ic={eventTypes:bc,extractEvents:function(a,b,c,d){var e;if(Vb)b:{switch(a){case \"topCompositionStart\":var f=bc.compositionStart;break b;case \"topCompositionEnd\":f=bc.compositionEnd;break b;case \"topCompositionUpdate\":f=bc.compositionUpdate;break b}f=void 0}else fc?dc(a,c)&&(f=bc.compositionEnd):\"topKeyDown\"===a&&229===c.keyCode&&(f=bc.compositionStart);f?($b&&(fc||f!==bc.compositionStart?f===bc.compositionEnd&&fc&&(e=Fb()):(S._root=d,S._startText=Gb(),fc=!0)),f=Mb.getPooled(f,b,c,d),e?f.data=\ne:(e=ec(c),null!==e&&(f.data=e)),Ab(f),e=f):e=null;(a=Zb?gc(a,c):hc(a,c))?(b=Nb.getPooled(bc.beforeInput,b,c,d),b.data=a,Ab(b)):b=null;return[e,b]}},jc=null,kc=null,lc=null;function mc(a){if(a=Xa(a)){jc&&\"function\"===typeof jc.restoreControlledState?void 0:E(\"194\");var b=Wa(a.stateNode);jc.restoreControlledState(a.stateNode,a.type,b)}}var nc={injectFiberControlledHostComponent:function(a){jc=a}};function oc(a){kc?lc?lc.push(a):lc=[a]:kc=a}\nfunction pc(){if(kc){var a=kc,b=lc;lc=kc=null;mc(a);if(b)for(a=0;a<b.length;a++)mc(b[a])}}var qc=Object.freeze({injection:nc,enqueueStateRestore:oc,restoreStateIfNeeded:pc});function rc(a,b){return a(b)}var sc=!1;function tc(a,b){if(sc)return rc(a,b);sc=!0;try{return rc(a,b)}finally{sc=!1,pc()}}var uc={color:!0,date:!0,datetime:!0,\"datetime-local\":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};\nfunction vc(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return\"input\"===b?!!uc[a.type]:\"textarea\"===b?!0:!1}function wc(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:a}var xc;l.canUseDOM&&(xc=document.implementation&&document.implementation.hasFeature&&!0!==document.implementation.hasFeature(\"\",\"\"));\nfunction yc(a,b){if(!l.canUseDOM||b&&!(\"addEventListener\"in document))return!1;b=\"on\"+a;var c=b in document;c||(c=document.createElement(\"div\"),c.setAttribute(b,\"return;\"),c=\"function\"===typeof c[b]);!c&&xc&&\"wheel\"===a&&(c=document.implementation.hasFeature(\"Events.wheel\",\"3.0\"));return c}function zc(a){var b=a.type;return(a=a.nodeName)&&\"input\"===a.toLowerCase()&&(\"checkbox\"===b||\"radio\"===b)}\nfunction Ac(a){var b=zc(a)?\"checked\":\"value\",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=\"\"+a[b];if(!a.hasOwnProperty(b)&&\"function\"===typeof c.get&&\"function\"===typeof c.set)return Object.defineProperty(a,b,{enumerable:c.enumerable,configurable:!0,get:function(){return c.get.call(this)},set:function(a){d=\"\"+a;c.set.call(this,a)}}),{getValue:function(){return d},setValue:function(a){d=\"\"+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}\nfunction Bc(a){a._valueTracker||(a._valueTracker=Ac(a))}function Cc(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d=\"\";a&&(d=zc(a)?a.checked?\"true\":\"false\":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}var Dc={change:{phasedRegistrationNames:{bubbled:\"onChange\",captured:\"onChangeCapture\"},dependencies:\"topBlur topChange topClick topFocus topInput topKeyDown topKeyUp topSelectionChange\".split(\" \")}};\nfunction Ec(a,b,c){a=T.getPooled(Dc.change,a,b,c);a.type=\"change\";oc(c);Ab(a);return a}var Fc=null,Gc=null;function Hc(a){kb(a);lb(!1)}function Ic(a){var b=qb(a);if(Cc(b))return a}function Jc(a,b){if(\"topChange\"===a)return b}var Kc=!1;l.canUseDOM&&(Kc=yc(\"input\")&&(!document.documentMode||9<document.documentMode));function Lc(){Fc&&(Fc.detachEvent(\"onpropertychange\",Mc),Gc=Fc=null)}function Mc(a){\"value\"===a.propertyName&&Ic(Gc)&&(a=Ec(Gc,a,wc(a)),tc(Hc,a))}\nfunction Nc(a,b,c){\"topFocus\"===a?(Lc(),Fc=b,Gc=c,Fc.attachEvent(\"onpropertychange\",Mc)):\"topBlur\"===a&&Lc()}function Oc(a){if(\"topSelectionChange\"===a||\"topKeyUp\"===a||\"topKeyDown\"===a)return Ic(Gc)}function Pc(a,b){if(\"topClick\"===a)return Ic(b)}function $c(a,b){if(\"topInput\"===a||\"topChange\"===a)return Ic(b)}\nvar ad={eventTypes:Dc,_isInputEventSupported:Kc,extractEvents:function(a,b,c,d){var e=b?qb(b):window,f=e.nodeName&&e.nodeName.toLowerCase();if(\"select\"===f||\"input\"===f&&\"file\"===e.type)var g=Jc;else if(vc(e))if(Kc)g=$c;else{g=Oc;var h=Nc}else f=e.nodeName,!f||\"input\"!==f.toLowerCase()||\"checkbox\"!==e.type&&\"radio\"!==e.type||(g=Pc);if(g&&(g=g(a,b)))return Ec(g,c,d);h&&h(a,e,b);\"topBlur\"===a&&null!=b&&(a=b._wrapperState||e._wrapperState)&&a.controlled&&\"number\"===e.type&&(a=\"\"+e.value,e.getAttribute(\"value\")!==\na&&e.setAttribute(\"value\",a))}};function bd(a,b,c,d){return T.call(this,a,b,c,d)}T.augmentClass(bd,{view:null,detail:null});var cd={Alt:\"altKey\",Control:\"ctrlKey\",Meta:\"metaKey\",Shift:\"shiftKey\"};function dd(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=cd[a])?!!b[a]:!1}function ed(){return dd}function fd(a,b,c,d){return T.call(this,a,b,c,d)}\nbd.augmentClass(fd,{screenX:null,screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:ed,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)}});\nvar gd={mouseEnter:{registrationName:\"onMouseEnter\",dependencies:[\"topMouseOut\",\"topMouseOver\"]},mouseLeave:{registrationName:\"onMouseLeave\",dependencies:[\"topMouseOut\",\"topMouseOver\"]}},hd={eventTypes:gd,extractEvents:function(a,b,c,d){if(\"topMouseOver\"===a&&(c.relatedTarget||c.fromElement)||\"topMouseOut\"!==a&&\"topMouseOver\"!==a)return null;var e=d.window===d?d:(e=d.ownerDocument)?e.defaultView||e.parentWindow:window;\"topMouseOut\"===a?(a=b,b=(b=c.relatedTarget||c.toElement)?pb(b):null):a=null;if(a===\nb)return null;var f=null==a?e:qb(a);e=null==b?e:qb(b);var g=fd.getPooled(gd.mouseLeave,a,c,d);g.type=\"mouseleave\";g.target=f;g.relatedTarget=e;c=fd.getPooled(gd.mouseEnter,b,c,d);c.type=\"mouseenter\";c.target=e;c.relatedTarget=f;Bb(g,c,a,b);return[g,c]}},id=aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner;function jd(a){a=a.type;return\"string\"===typeof a?a:\"function\"===typeof a?a.displayName||a.name:null}\nfunction kd(a){var b=a;if(a.alternate)for(;b[\"return\"];)b=b[\"return\"];else{if(0!==(b.effectTag&2))return 1;for(;b[\"return\"];)if(b=b[\"return\"],0!==(b.effectTag&2))return 1}return 3===b.tag?2:3}function ld(a){return(a=a._reactInternalFiber)?2===kd(a):!1}function md(a){2!==kd(a)?E(\"188\"):void 0}\nfunction nd(a){var b=a.alternate;if(!b)return b=kd(a),3===b?E(\"188\"):void 0,1===b?null:a;for(var c=a,d=b;;){var e=c[\"return\"],f=e?e.alternate:null;if(!e||!f)break;if(e.child===f.child){for(var g=e.child;g;){if(g===c)return md(e),a;if(g===d)return md(e),b;g=g.sibling}E(\"188\")}if(c[\"return\"]!==d[\"return\"])c=e,d=f;else{g=!1;for(var h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}g?\nvoid 0:E(\"189\")}}c.alternate!==d?E(\"190\"):void 0}3!==c.tag?E(\"188\"):void 0;return c.stateNode.current===c?a:b}function od(a){a=nd(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child[\"return\"]=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b[\"return\"]||b[\"return\"]===a)return null;b=b[\"return\"]}b.sibling[\"return\"]=b[\"return\"];b=b.sibling}}return null}\nfunction pd(a){a=nd(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child&&4!==b.tag)b.child[\"return\"]=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b[\"return\"]||b[\"return\"]===a)return null;b=b[\"return\"]}b.sibling[\"return\"]=b[\"return\"];b=b.sibling}}return null}var qd=[];\nfunction rd(a){var b=a.targetInst;do{if(!b){a.ancestors.push(b);break}var c;for(c=b;c[\"return\"];)c=c[\"return\"];c=3!==c.tag?null:c.stateNode.containerInfo;if(!c)break;a.ancestors.push(b);b=pb(c)}while(b);for(c=0;c<a.ancestors.length;c++)b=a.ancestors[c],sd(a.topLevelType,b,a.nativeEvent,wc(a.nativeEvent))}var td=!0,sd=void 0;function ud(a){td=!!a}function U(a,b,c){return c?ba.listen(c,b,vd.bind(null,a)):null}function wd(a,b,c){return c?ba.capture(c,b,vd.bind(null,a)):null}\nfunction vd(a,b){if(td){var c=wc(b);c=pb(c);null===c||\"number\"!==typeof c.tag||2===kd(c)||(c=null);if(qd.length){var d=qd.pop();d.topLevelType=a;d.nativeEvent=b;d.targetInst=c;a=d}else a={topLevelType:a,nativeEvent:b,targetInst:c,ancestors:[]};try{tc(rd,a)}finally{a.topLevelType=null,a.nativeEvent=null,a.targetInst=null,a.ancestors.length=0,10>qd.length&&qd.push(a)}}}\nvar xd=Object.freeze({get _enabled(){return td},get _handleTopLevel(){return sd},setHandleTopLevel:function(a){sd=a},setEnabled:ud,isEnabled:function(){return td},trapBubbledEvent:U,trapCapturedEvent:wd,dispatchEvent:vd});function yd(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c[\"Webkit\"+a]=\"webkit\"+b;c[\"Moz\"+a]=\"moz\"+b;c[\"ms\"+a]=\"MS\"+b;c[\"O\"+a]=\"o\"+b.toLowerCase();return c}\nvar zd={animationend:yd(\"Animation\",\"AnimationEnd\"),animationiteration:yd(\"Animation\",\"AnimationIteration\"),animationstart:yd(\"Animation\",\"AnimationStart\"),transitionend:yd(\"Transition\",\"TransitionEnd\")},Ad={},Bd={};l.canUseDOM&&(Bd=document.createElement(\"div\").style,\"AnimationEvent\"in window||(delete zd.animationend.animation,delete zd.animationiteration.animation,delete zd.animationstart.animation),\"TransitionEvent\"in window||delete zd.transitionend.transition);\nfunction Cd(a){if(Ad[a])return Ad[a];if(!zd[a])return a;var b=zd[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Bd)return Ad[a]=b[c];return\"\"}\nvar Dd={topAbort:\"abort\",topAnimationEnd:Cd(\"animationend\")||\"animationend\",topAnimationIteration:Cd(\"animationiteration\")||\"animationiteration\",topAnimationStart:Cd(\"animationstart\")||\"animationstart\",topBlur:\"blur\",topCancel:\"cancel\",topCanPlay:\"canplay\",topCanPlayThrough:\"canplaythrough\",topChange:\"change\",topClick:\"click\",topClose:\"close\",topCompositionEnd:\"compositionend\",topCompositionStart:\"compositionstart\",topCompositionUpdate:\"compositionupdate\",topContextMenu:\"contextmenu\",topCopy:\"copy\",\ntopCut:\"cut\",topDoubleClick:\"dblclick\",topDrag:\"drag\",topDragEnd:\"dragend\",topDragEnter:\"dragenter\",topDragExit:\"dragexit\",topDragLeave:\"dragleave\",topDragOver:\"dragover\",topDragStart:\"dragstart\",topDrop:\"drop\",topDurationChange:\"durationchange\",topEmptied:\"emptied\",topEncrypted:\"encrypted\",topEnded:\"ended\",topError:\"error\",topFocus:\"focus\",topInput:\"input\",topKeyDown:\"keydown\",topKeyPress:\"keypress\",topKeyUp:\"keyup\",topLoadedData:\"loadeddata\",topLoad:\"load\",topLoadedMetadata:\"loadedmetadata\",topLoadStart:\"loadstart\",\ntopMouseDown:\"mousedown\",topMouseMove:\"mousemove\",topMouseOut:\"mouseout\",topMouseOver:\"mouseover\",topMouseUp:\"mouseup\",topPaste:\"paste\",topPause:\"pause\",topPlay:\"play\",topPlaying:\"playing\",topProgress:\"progress\",topRateChange:\"ratechange\",topScroll:\"scroll\",topSeeked:\"seeked\",topSeeking:\"seeking\",topSelectionChange:\"selectionchange\",topStalled:\"stalled\",topSuspend:\"suspend\",topTextInput:\"textInput\",topTimeUpdate:\"timeupdate\",topToggle:\"toggle\",topTouchCancel:\"touchcancel\",topTouchEnd:\"touchend\",topTouchMove:\"touchmove\",\ntopTouchStart:\"touchstart\",topTransitionEnd:Cd(\"transitionend\")||\"transitionend\",topVolumeChange:\"volumechange\",topWaiting:\"waiting\",topWheel:\"wheel\"},Ed={},Fd=0,Gd=\"_reactListenersID\"+(\"\"+Math.random()).slice(2);function Hd(a){Object.prototype.hasOwnProperty.call(a,Gd)||(a[Gd]=Fd++,Ed[a[Gd]]={});return Ed[a[Gd]]}function Id(a){for(;a&&a.firstChild;)a=a.firstChild;return a}\nfunction Jd(a,b){var c=Id(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=Id(c)}}function Kd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&(\"input\"===b&&\"text\"===a.type||\"textarea\"===b||\"true\"===a.contentEditable)}\nvar Ld=l.canUseDOM&&\"documentMode\"in document&&11>=document.documentMode,Md={select:{phasedRegistrationNames:{bubbled:\"onSelect\",captured:\"onSelectCapture\"},dependencies:\"topBlur topContextMenu topFocus topKeyDown topKeyUp topMouseDown topMouseUp topSelectionChange\".split(\" \")}},Nd=null,Od=null,Pd=null,Qd=!1;\nfunction Rd(a,b){if(Qd||null==Nd||Nd!==da())return null;var c=Nd;\"selectionStart\"in c&&Kd(c)?c={start:c.selectionStart,end:c.selectionEnd}:window.getSelection?(c=window.getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset}):c=void 0;return Pd&&ea(Pd,c)?null:(Pd=c,a=T.getPooled(Md.select,Od,a,b),a.type=\"select\",a.target=Nd,Ab(a),a)}\nvar Sd={eventTypes:Md,extractEvents:function(a,b,c,d){var e=d.window===d?d.document:9===d.nodeType?d:d.ownerDocument,f;if(!(f=!e)){a:{e=Hd(e);f=Sa.onSelect;for(var g=0;g<f.length;g++){var h=f[g];if(!e.hasOwnProperty(h)||!e[h]){e=!1;break a}}e=!0}f=!e}if(f)return null;e=b?qb(b):window;switch(a){case \"topFocus\":if(vc(e)||\"true\"===e.contentEditable)Nd=e,Od=b,Pd=null;break;case \"topBlur\":Pd=Od=Nd=null;break;case \"topMouseDown\":Qd=!0;break;case \"topContextMenu\":case \"topMouseUp\":return Qd=!1,Rd(c,d);case \"topSelectionChange\":if(Ld)break;\ncase \"topKeyDown\":case \"topKeyUp\":return Rd(c,d)}return null}};function Td(a,b,c,d){return T.call(this,a,b,c,d)}T.augmentClass(Td,{animationName:null,elapsedTime:null,pseudoElement:null});function Ud(a,b,c,d){return T.call(this,a,b,c,d)}T.augmentClass(Ud,{clipboardData:function(a){return\"clipboardData\"in a?a.clipboardData:window.clipboardData}});function Vd(a,b,c,d){return T.call(this,a,b,c,d)}bd.augmentClass(Vd,{relatedTarget:null});\nfunction Wd(a){var b=a.keyCode;\"charCode\"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;return 32<=a||13===a?a:0}\nvar Xd={Esc:\"Escape\",Spacebar:\" \",Left:\"ArrowLeft\",Up:\"ArrowUp\",Right:\"ArrowRight\",Down:\"ArrowDown\",Del:\"Delete\",Win:\"OS\",Menu:\"ContextMenu\",Apps:\"ContextMenu\",Scroll:\"ScrollLock\",MozPrintableKey:\"Unidentified\"},Yd={8:\"Backspace\",9:\"Tab\",12:\"Clear\",13:\"Enter\",16:\"Shift\",17:\"Control\",18:\"Alt\",19:\"Pause\",20:\"CapsLock\",27:\"Escape\",32:\" \",33:\"PageUp\",34:\"PageDown\",35:\"End\",36:\"Home\",37:\"ArrowLeft\",38:\"ArrowUp\",39:\"ArrowRight\",40:\"ArrowDown\",45:\"Insert\",46:\"Delete\",112:\"F1\",113:\"F2\",114:\"F3\",115:\"F4\",\n116:\"F5\",117:\"F6\",118:\"F7\",119:\"F8\",120:\"F9\",121:\"F10\",122:\"F11\",123:\"F12\",144:\"NumLock\",145:\"ScrollLock\",224:\"Meta\"};function Zd(a,b,c,d){return T.call(this,a,b,c,d)}\nbd.augmentClass(Zd,{key:function(a){if(a.key){var b=Xd[a.key]||a.key;if(\"Unidentified\"!==b)return b}return\"keypress\"===a.type?(a=Wd(a),13===a?\"Enter\":String.fromCharCode(a)):\"keydown\"===a.type||\"keyup\"===a.type?Yd[a.keyCode]||\"Unidentified\":\"\"},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:ed,charCode:function(a){return\"keypress\"===a.type?Wd(a):0},keyCode:function(a){return\"keydown\"===a.type||\"keyup\"===a.type?a.keyCode:0},which:function(a){return\"keypress\"===\na.type?Wd(a):\"keydown\"===a.type||\"keyup\"===a.type?a.keyCode:0}});function $d(a,b,c,d){return T.call(this,a,b,c,d)}fd.augmentClass($d,{dataTransfer:null});function ae(a,b,c,d){return T.call(this,a,b,c,d)}bd.augmentClass(ae,{touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:ed});function be(a,b,c,d){return T.call(this,a,b,c,d)}T.augmentClass(be,{propertyName:null,elapsedTime:null,pseudoElement:null});\nfunction ce(a,b,c,d){return T.call(this,a,b,c,d)}fd.augmentClass(ce,{deltaX:function(a){return\"deltaX\"in a?a.deltaX:\"wheelDeltaX\"in a?-a.wheelDeltaX:0},deltaY:function(a){return\"deltaY\"in a?a.deltaY:\"wheelDeltaY\"in a?-a.wheelDeltaY:\"wheelDelta\"in a?-a.wheelDelta:0},deltaZ:null,deltaMode:null});var de={},ee={};\n\"abort animationEnd animationIteration animationStart blur cancel canPlay canPlayThrough click close contextMenu copy cut doubleClick drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error focus input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing progress rateChange reset scroll seeked seeking stalled submit suspend timeUpdate toggle touchCancel touchEnd touchMove touchStart transitionEnd volumeChange waiting wheel\".split(\" \").forEach(function(a){var b=a[0].toUpperCase()+\na.slice(1),c=\"on\"+b;b=\"top\"+b;c={phasedRegistrationNames:{bubbled:c,captured:c+\"Capture\"},dependencies:[b]};de[a]=c;ee[b]=c});\nvar fe={eventTypes:de,extractEvents:function(a,b,c,d){var e=ee[a];if(!e)return null;switch(a){case \"topKeyPress\":if(0===Wd(c))return null;case \"topKeyDown\":case \"topKeyUp\":a=Zd;break;case \"topBlur\":case \"topFocus\":a=Vd;break;case \"topClick\":if(2===c.button)return null;case \"topDoubleClick\":case \"topMouseDown\":case \"topMouseMove\":case \"topMouseUp\":case \"topMouseOut\":case \"topMouseOver\":case \"topContextMenu\":a=fd;break;case \"topDrag\":case \"topDragEnd\":case \"topDragEnter\":case \"topDragExit\":case \"topDragLeave\":case \"topDragOver\":case \"topDragStart\":case \"topDrop\":a=\n$d;break;case \"topTouchCancel\":case \"topTouchEnd\":case \"topTouchMove\":case \"topTouchStart\":a=ae;break;case \"topAnimationEnd\":case \"topAnimationIteration\":case \"topAnimationStart\":a=Td;break;case \"topTransitionEnd\":a=be;break;case \"topScroll\":a=bd;break;case \"topWheel\":a=ce;break;case \"topCopy\":case \"topCut\":case \"topPaste\":a=Ud;break;default:a=T}b=a.getPooled(e,b,c,d);Ab(b);return b}};sd=function(a,b,c,d){a=jb(a,b,c,d);kb(a);lb(!1)};hb.injectEventPluginOrder(\"ResponderEventPlugin SimpleEventPlugin TapEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin\".split(\" \"));\nWa=sb.getFiberCurrentPropsFromNode;Xa=sb.getInstanceFromNode;Ya=sb.getNodeFromInstance;hb.injectEventPluginsByName({SimpleEventPlugin:fe,EnterLeaveEventPlugin:hd,ChangeEventPlugin:ad,SelectEventPlugin:Sd,BeforeInputEventPlugin:ic});var ge=[],he=-1;function V(a){0>he||(a.current=ge[he],ge[he]=null,he--)}function W(a,b){he++;ge[he]=a.current;a.current=b}new Set;var ie={current:D},X={current:!1},je=D;function ke(a){return le(a)?je:ie.current}\nfunction me(a,b){var c=a.type.contextTypes;if(!c)return D;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function le(a){return 2===a.tag&&null!=a.type.childContextTypes}function ne(a){le(a)&&(V(X,a),V(ie,a))}\nfunction oe(a,b,c){null!=ie.cursor?E(\"168\"):void 0;W(ie,b,a);W(X,c,a)}function pe(a,b){var c=a.stateNode,d=a.type.childContextTypes;if(\"function\"!==typeof c.getChildContext)return b;c=c.getChildContext();for(var e in c)e in d?void 0:E(\"108\",jd(a)||\"Unknown\",e);return B({},b,c)}function qe(a){if(!le(a))return!1;var b=a.stateNode;b=b&&b.__reactInternalMemoizedMergedChildContext||D;je=ie.current;W(ie,b,a);W(X,X.current,a);return!0}\nfunction re(a,b){var c=a.stateNode;c?void 0:E(\"169\");if(b){var d=pe(a,je);c.__reactInternalMemoizedMergedChildContext=d;V(X,a);V(ie,a);W(ie,d,a)}else V(X,a);W(X,b,a)}\nfunction Y(a,b,c){this.tag=a;this.key=b;this.stateNode=this.type=null;this.sibling=this.child=this[\"return\"]=null;this.index=0;this.memoizedState=this.updateQueue=this.memoizedProps=this.pendingProps=this.ref=null;this.internalContextTag=c;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=null;this.expirationTime=0;this.alternate=null}\nfunction se(a,b,c){var d=a.alternate;null===d?(d=new Y(a.tag,a.key,a.internalContextTag),d.type=a.type,d.stateNode=a.stateNode,d.alternate=a,a.alternate=d):(d.effectTag=0,d.nextEffect=null,d.firstEffect=null,d.lastEffect=null);d.expirationTime=c;d.pendingProps=b;d.child=a.child;d.memoizedProps=a.memoizedProps;d.memoizedState=a.memoizedState;d.updateQueue=a.updateQueue;d.sibling=a.sibling;d.index=a.index;d.ref=a.ref;return d}\nfunction te(a,b,c){var d=void 0,e=a.type,f=a.key;\"function\"===typeof e?(d=e.prototype&&e.prototype.isReactComponent?new Y(2,f,b):new Y(0,f,b),d.type=e,d.pendingProps=a.props):\"string\"===typeof e?(d=new Y(5,f,b),d.type=e,d.pendingProps=a.props):\"object\"===typeof e&&null!==e&&\"number\"===typeof e.tag?(d=e,d.pendingProps=a.props):E(\"130\",null==e?e:typeof e,\"\");d.expirationTime=c;return d}function ue(a,b,c,d){b=new Y(10,d,b);b.pendingProps=a;b.expirationTime=c;return b}\nfunction ve(a,b,c){b=new Y(6,null,b);b.pendingProps=a;b.expirationTime=c;return b}function we(a,b,c){b=new Y(7,a.key,b);b.type=a.handler;b.pendingProps=a;b.expirationTime=c;return b}function xe(a,b,c){a=new Y(9,null,b);a.expirationTime=c;return a}function ye(a,b,c){b=new Y(4,a.key,b);b.pendingProps=a.children||[];b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}var ze=null,Ae=null;\nfunction Be(a){return function(b){try{return a(b)}catch(c){}}}function Ce(a){if(\"undefined\"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=b.inject(a);ze=Be(function(a){return b.onCommitFiberRoot(c,a)});Ae=Be(function(a){return b.onCommitFiberUnmount(c,a)})}catch(d){}return!0}function De(a){\"function\"===typeof ze&&ze(a)}function Ee(a){\"function\"===typeof Ae&&Ae(a)}\nfunction Fe(a){return{baseState:a,expirationTime:0,first:null,last:null,callbackList:null,hasForceUpdate:!1,isInitialized:!1}}function Ge(a,b){null===a.last?a.first=a.last=b:(a.last.next=b,a.last=b);if(0===a.expirationTime||a.expirationTime>b.expirationTime)a.expirationTime=b.expirationTime}\nfunction He(a,b){var c=a.alternate,d=a.updateQueue;null===d&&(d=a.updateQueue=Fe(null));null!==c?(a=c.updateQueue,null===a&&(a=c.updateQueue=Fe(null))):a=null;a=a!==d?a:null;null===a?Ge(d,b):null===d.last||null===a.last?(Ge(d,b),Ge(a,b)):(Ge(d,b),a.last=b)}function Ie(a,b,c,d){a=a.partialState;return\"function\"===typeof a?a.call(b,c,d):a}\nfunction Je(a,b,c,d,e,f){null!==a&&a.updateQueue===c&&(c=b.updateQueue={baseState:c.baseState,expirationTime:c.expirationTime,first:c.first,last:c.last,isInitialized:c.isInitialized,callbackList:null,hasForceUpdate:!1});c.expirationTime=0;c.isInitialized?a=c.baseState:(a=c.baseState=b.memoizedState,c.isInitialized=!0);for(var g=!0,h=c.first,k=!1;null!==h;){var q=h.expirationTime;if(q>f){var v=c.expirationTime;if(0===v||v>q)c.expirationTime=q;k||(k=!0,c.baseState=a)}else{k||(c.first=h.next,null===\nc.first&&(c.last=null));if(h.isReplace)a=Ie(h,d,a,e),g=!0;else if(q=Ie(h,d,a,e))a=g?B({},a,q):B(a,q),g=!1;h.isForced&&(c.hasForceUpdate=!0);null!==h.callback&&(q=c.callbackList,null===q&&(q=c.callbackList=[]),q.push(h))}h=h.next}null!==c.callbackList?b.effectTag|=32:null!==c.first||c.hasForceUpdate||(b.updateQueue=null);k||(c.baseState=a);return a}\nfunction Ke(a,b){var c=a.callbackList;if(null!==c)for(a.callbackList=null,a=0;a<c.length;a++){var d=c[a],e=d.callback;d.callback=null;\"function\"!==typeof e?E(\"191\",e):void 0;e.call(b)}}\nfunction Le(a,b,c,d){function e(a,b){b.updater=f;a.stateNode=b;b._reactInternalFiber=a}var f={isMounted:ld,enqueueSetState:function(c,d,e){c=c._reactInternalFiber;e=void 0===e?null:e;var g=b(c);He(c,{expirationTime:g,partialState:d,callback:e,isReplace:!1,isForced:!1,nextCallback:null,next:null});a(c,g)},enqueueReplaceState:function(c,d,e){c=c._reactInternalFiber;e=void 0===e?null:e;var g=b(c);He(c,{expirationTime:g,partialState:d,callback:e,isReplace:!0,isForced:!1,nextCallback:null,next:null});\na(c,g)},enqueueForceUpdate:function(c,d){c=c._reactInternalFiber;d=void 0===d?null:d;var e=b(c);He(c,{expirationTime:e,partialState:null,callback:d,isReplace:!1,isForced:!0,nextCallback:null,next:null});a(c,e)}};return{adoptClassInstance:e,constructClassInstance:function(a,b){var c=a.type,d=ke(a),f=2===a.tag&&null!=a.type.contextTypes,g=f?me(a,d):D;b=new c(b,g);e(a,b);f&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=d,a.__reactInternalMemoizedMaskedChildContext=g);return b},mountClassInstance:function(a,\nb){var c=a.alternate,d=a.stateNode,e=d.state||null,g=a.pendingProps;g?void 0:E(\"158\");var h=ke(a);d.props=g;d.state=a.memoizedState=e;d.refs=D;d.context=me(a,h);null!=a.type&&null!=a.type.prototype&&!0===a.type.prototype.unstable_isAsyncReactComponent&&(a.internalContextTag|=1);\"function\"===typeof d.componentWillMount&&(e=d.state,d.componentWillMount(),e!==d.state&&f.enqueueReplaceState(d,d.state,null),e=a.updateQueue,null!==e&&(d.state=Je(c,a,e,d,g,b)));\"function\"===typeof d.componentDidMount&&(a.effectTag|=\n4)},updateClassInstance:function(a,b,e){var g=b.stateNode;g.props=b.memoizedProps;g.state=b.memoizedState;var h=b.memoizedProps,k=b.pendingProps;k||(k=h,null==k?E(\"159\"):void 0);var u=g.context,z=ke(b);z=me(b,z);\"function\"!==typeof g.componentWillReceiveProps||h===k&&u===z||(u=g.state,g.componentWillReceiveProps(k,z),g.state!==u&&f.enqueueReplaceState(g,g.state,null));u=b.memoizedState;e=null!==b.updateQueue?Je(a,b,b.updateQueue,g,k,e):u;if(!(h!==k||u!==e||X.current||null!==b.updateQueue&&b.updateQueue.hasForceUpdate))return\"function\"!==\ntypeof g.componentDidUpdate||h===a.memoizedProps&&u===a.memoizedState||(b.effectTag|=4),!1;var G=k;if(null===h||null!==b.updateQueue&&b.updateQueue.hasForceUpdate)G=!0;else{var I=b.stateNode,L=b.type;G=\"function\"===typeof I.shouldComponentUpdate?I.shouldComponentUpdate(G,e,z):L.prototype&&L.prototype.isPureReactComponent?!ea(h,G)||!ea(u,e):!0}G?(\"function\"===typeof g.componentWillUpdate&&g.componentWillUpdate(k,e,z),\"function\"===typeof g.componentDidUpdate&&(b.effectTag|=4)):(\"function\"!==typeof g.componentDidUpdate||\nh===a.memoizedProps&&u===a.memoizedState||(b.effectTag|=4),c(b,k),d(b,e));g.props=k;g.state=e;g.context=z;return G}}}var Qe=\"function\"===typeof Symbol&&Symbol[\"for\"],Re=Qe?Symbol[\"for\"](\"react.element\"):60103,Se=Qe?Symbol[\"for\"](\"react.call\"):60104,Te=Qe?Symbol[\"for\"](\"react.return\"):60105,Ue=Qe?Symbol[\"for\"](\"react.portal\"):60106,Ve=Qe?Symbol[\"for\"](\"react.fragment\"):60107,We=\"function\"===typeof Symbol&&Symbol.iterator;\nfunction Xe(a){if(null===a||\"undefined\"===typeof a)return null;a=We&&a[We]||a[\"@@iterator\"];return\"function\"===typeof a?a:null}var Ye=Array.isArray;\nfunction Ze(a,b){var c=b.ref;if(null!==c&&\"function\"!==typeof c){if(b._owner){b=b._owner;var d=void 0;b&&(2!==b.tag?E(\"110\"):void 0,d=b.stateNode);d?void 0:E(\"147\",c);var e=\"\"+c;if(null!==a&&null!==a.ref&&a.ref._stringRef===e)return a.ref;a=function(a){var b=d.refs===D?d.refs={}:d.refs;null===a?delete b[e]:b[e]=a};a._stringRef=e;return a}\"string\"!==typeof c?E(\"148\"):void 0;b._owner?void 0:E(\"149\",c)}return c}\nfunction $e(a,b){\"textarea\"!==a.type&&E(\"31\",\"[object Object]\"===Object.prototype.toString.call(b)?\"object with keys {\"+Object.keys(b).join(\", \")+\"}\":b,\"\")}\nfunction af(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,b),b=b.sibling;return a}function e(a,b,c){a=se(a,b,c);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=\n2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=ve(c,a.internalContextTag,d),b[\"return\"]=a,b;b=e(b,c,d);b[\"return\"]=a;return b}function k(a,b,c,d){if(null!==b&&b.type===c.type)return d=e(b,c.props,d),d.ref=Ze(b,c),d[\"return\"]=a,d;d=te(c,a.internalContextTag,d);d.ref=Ze(b,c);d[\"return\"]=a;return d}function q(a,b,c,d){if(null===b||7!==b.tag)return b=we(c,a.internalContextTag,d),b[\"return\"]=a,b;b=e(b,c,d);\nb[\"return\"]=a;return b}function v(a,b,c,d){if(null===b||9!==b.tag)return b=xe(c,a.internalContextTag,d),b.type=c.value,b[\"return\"]=a,b;b=e(b,null,d);b.type=c.value;b[\"return\"]=a;return b}function y(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=ye(c,a.internalContextTag,d),b[\"return\"]=a,b;b=e(b,c.children||[],d);b[\"return\"]=a;return b}function u(a,b,c,d,f){if(null===b||10!==b.tag)return b=ue(c,a.internalContextTag,\nd,f),b[\"return\"]=a,b;b=e(b,c,d);b[\"return\"]=a;return b}function z(a,b,c){if(\"string\"===typeof b||\"number\"===typeof b)return b=ve(\"\"+b,a.internalContextTag,c),b[\"return\"]=a,b;if(\"object\"===typeof b&&null!==b){switch(b.$$typeof){case Re:if(b.type===Ve)return b=ue(b.props.children,a.internalContextTag,c,b.key),b[\"return\"]=a,b;c=te(b,a.internalContextTag,c);c.ref=Ze(null,b);c[\"return\"]=a;return c;case Se:return b=we(b,a.internalContextTag,c),b[\"return\"]=a,b;case Te:return c=xe(b,a.internalContextTag,\nc),c.type=b.value,c[\"return\"]=a,c;case Ue:return b=ye(b,a.internalContextTag,c),b[\"return\"]=a,b}if(Ye(b)||Xe(b))return b=ue(b,a.internalContextTag,c,null),b[\"return\"]=a,b;$e(a,b)}return null}function G(a,b,c,d){var e=null!==b?b.key:null;if(\"string\"===typeof c||\"number\"===typeof c)return null!==e?null:h(a,b,\"\"+c,d);if(\"object\"===typeof c&&null!==c){switch(c.$$typeof){case Re:return c.key===e?c.type===Ve?u(a,b,c.props.children,d,e):k(a,b,c,d):null;case Se:return c.key===e?q(a,b,c,d):null;case Te:return null===\ne?v(a,b,c,d):null;case Ue:return c.key===e?y(a,b,c,d):null}if(Ye(c)||Xe(c))return null!==e?null:u(a,b,c,d,null);$e(a,c)}return null}function I(a,b,c,d,e){if(\"string\"===typeof d||\"number\"===typeof d)return a=a.get(c)||null,h(b,a,\"\"+d,e);if(\"object\"===typeof d&&null!==d){switch(d.$$typeof){case Re:return a=a.get(null===d.key?c:d.key)||null,d.type===Ve?u(b,a,d.props.children,e,d.key):k(b,a,d,e);case Se:return a=a.get(null===d.key?c:d.key)||null,q(b,a,d,e);case Te:return a=a.get(c)||null,v(b,a,d,e);case Ue:return a=\na.get(null===d.key?c:d.key)||null,y(b,a,d,e)}if(Ye(d)||Xe(d))return a=a.get(c)||null,u(b,a,d,e,null);$e(b,d)}return null}function L(e,g,m,A){for(var h=null,r=null,n=g,w=g=0,k=null;null!==n&&w<m.length;w++){n.index>w?(k=n,n=null):k=n.sibling;var x=G(e,n,m[w],A);if(null===x){null===n&&(n=k);break}a&&n&&null===x.alternate&&b(e,n);g=f(x,g,w);null===r?h=x:r.sibling=x;r=x;n=k}if(w===m.length)return c(e,n),h;if(null===n){for(;w<m.length;w++)if(n=z(e,m[w],A))g=f(n,g,w),null===r?h=n:r.sibling=n,r=n;return h}for(n=\nd(e,n);w<m.length;w++)if(k=I(n,e,w,m[w],A)){if(a&&null!==k.alternate)n[\"delete\"](null===k.key?w:k.key);g=f(k,g,w);null===r?h=k:r.sibling=k;r=k}a&&n.forEach(function(a){return b(e,a)});return h}function N(e,g,m,A){var h=Xe(m);\"function\"!==typeof h?E(\"150\"):void 0;m=h.call(m);null==m?E(\"151\"):void 0;for(var r=h=null,n=g,w=g=0,k=null,x=m.next();null!==n&&!x.done;w++,x=m.next()){n.index>w?(k=n,n=null):k=n.sibling;var J=G(e,n,x.value,A);if(null===J){n||(n=k);break}a&&n&&null===J.alternate&&b(e,n);g=f(J,\ng,w);null===r?h=J:r.sibling=J;r=J;n=k}if(x.done)return c(e,n),h;if(null===n){for(;!x.done;w++,x=m.next())x=z(e,x.value,A),null!==x&&(g=f(x,g,w),null===r?h=x:r.sibling=x,r=x);return h}for(n=d(e,n);!x.done;w++,x=m.next())if(x=I(n,e,w,x.value,A),null!==x){if(a&&null!==x.alternate)n[\"delete\"](null===x.key?w:x.key);g=f(x,g,w);null===r?h=x:r.sibling=x;r=x}a&&n.forEach(function(a){return b(e,a)});return h}return function(a,d,f,h){\"object\"===typeof f&&null!==f&&f.type===Ve&&null===f.key&&(f=f.props.children);\nvar m=\"object\"===typeof f&&null!==f;if(m)switch(f.$$typeof){case Re:a:{var r=f.key;for(m=d;null!==m;){if(m.key===r)if(10===m.tag?f.type===Ve:m.type===f.type){c(a,m.sibling);d=e(m,f.type===Ve?f.props.children:f.props,h);d.ref=Ze(m,f);d[\"return\"]=a;a=d;break a}else{c(a,m);break}else b(a,m);m=m.sibling}f.type===Ve?(d=ue(f.props.children,a.internalContextTag,h,f.key),d[\"return\"]=a,a=d):(h=te(f,a.internalContextTag,h),h.ref=Ze(d,f),h[\"return\"]=a,a=h)}return g(a);case Se:a:{for(m=f.key;null!==d;){if(d.key===\nm)if(7===d.tag){c(a,d.sibling);d=e(d,f,h);d[\"return\"]=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=we(f,a.internalContextTag,h);d[\"return\"]=a;a=d}return g(a);case Te:a:{if(null!==d)if(9===d.tag){c(a,d.sibling);d=e(d,null,h);d.type=f.value;d[\"return\"]=a;a=d;break a}else c(a,d);d=xe(f,a.internalContextTag,h);d.type=f.value;d[\"return\"]=a;a=d}return g(a);case Ue:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===f.containerInfo&&d.stateNode.implementation===\nf.implementation){c(a,d.sibling);d=e(d,f.children||[],h);d[\"return\"]=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=ye(f,a.internalContextTag,h);d[\"return\"]=a;a=d}return g(a)}if(\"string\"===typeof f||\"number\"===typeof f)return f=\"\"+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f,h)):(c(a,d),d=ve(f,a.internalContextTag,h)),d[\"return\"]=a,a=d,g(a);if(Ye(f))return L(a,d,f,h);if(Xe(f))return N(a,d,f,h);m&&$e(a,f);if(\"undefined\"===typeof f)switch(a.tag){case 2:case 1:h=a.type,E(\"152\",h.displayName||\nh.name||\"Component\")}return c(a,d)}}var bf=af(!0),cf=af(!1);\nfunction df(a,b,c,d,e){function f(a,b,c){var d=b.expirationTime;b.child=null===a?cf(b,null,c,d):bf(b,a.child,c,d)}function g(a,b){var c=b.ref;null===c||a&&a.ref===c||(b.effectTag|=128)}function h(a,b,c,d){g(a,b);if(!c)return d&&re(b,!1),q(a,b);c=b.stateNode;id.current=b;var e=c.render();b.effectTag|=1;f(a,b,e);b.memoizedState=c.state;b.memoizedProps=c.props;d&&re(b,!0);return b.child}function k(a){var b=a.stateNode;b.pendingContext?oe(a,b.pendingContext,b.pendingContext!==b.context):b.context&&oe(a,\nb.context,!1);I(a,b.containerInfo)}function q(a,b){null!==a&&b.child!==a.child?E(\"153\"):void 0;if(null!==b.child){a=b.child;var c=se(a,a.pendingProps,a.expirationTime);b.child=c;for(c[\"return\"]=b;null!==a.sibling;)a=a.sibling,c=c.sibling=se(a,a.pendingProps,a.expirationTime),c[\"return\"]=b;c.sibling=null}return b.child}function v(a,b){switch(b.tag){case 3:k(b);break;case 2:qe(b);break;case 4:I(b,b.stateNode.containerInfo)}return null}var y=a.shouldSetTextContent,u=a.useSyncScheduling,z=a.shouldDeprioritizeSubtree,\nG=b.pushHostContext,I=b.pushHostContainer,L=c.enterHydrationState,N=c.resetHydrationState,J=c.tryToClaimNextHydratableInstance;a=Le(d,e,function(a,b){a.memoizedProps=b},function(a,b){a.memoizedState=b});var w=a.adoptClassInstance,m=a.constructClassInstance,A=a.mountClassInstance,Ob=a.updateClassInstance;return{beginWork:function(a,b,c){if(0===b.expirationTime||b.expirationTime>c)return v(a,b);switch(b.tag){case 0:null!==a?E(\"155\"):void 0;var d=b.type,e=b.pendingProps,r=ke(b);r=me(b,r);d=d(e,r);b.effectTag|=\n1;\"object\"===typeof d&&null!==d&&\"function\"===typeof d.render?(b.tag=2,e=qe(b),w(b,d),A(b,c),b=h(a,b,!0,e)):(b.tag=1,f(a,b,d),b.memoizedProps=e,b=b.child);return b;case 1:a:{e=b.type;c=b.pendingProps;d=b.memoizedProps;if(X.current)null===c&&(c=d);else if(null===c||d===c){b=q(a,b);break a}d=ke(b);d=me(b,d);e=e(c,d);b.effectTag|=1;f(a,b,e);b.memoizedProps=c;b=b.child}return b;case 2:return e=qe(b),d=void 0,null===a?b.stateNode?E(\"153\"):(m(b,b.pendingProps),A(b,c),d=!0):d=Ob(a,b,c),h(a,b,d,e);case 3:return k(b),\ne=b.updateQueue,null!==e?(d=b.memoizedState,e=Je(a,b,e,null,null,c),d===e?(N(),b=q(a,b)):(d=e.element,r=b.stateNode,(null===a||null===a.child)&&r.hydrate&&L(b)?(b.effectTag|=2,b.child=cf(b,null,d,c)):(N(),f(a,b,d)),b.memoizedState=e,b=b.child)):(N(),b=q(a,b)),b;case 5:G(b);null===a&&J(b);e=b.type;var n=b.memoizedProps;d=b.pendingProps;null===d&&(d=n,null===d?E(\"154\"):void 0);r=null!==a?a.memoizedProps:null;X.current||null!==d&&n!==d?(n=d.children,y(e,d)?n=null:r&&y(e,r)&&(b.effectTag|=16),g(a,b),\n2147483647!==c&&!u&&z(e,d)?(b.expirationTime=2147483647,b=null):(f(a,b,n),b.memoizedProps=d,b=b.child)):b=q(a,b);return b;case 6:return null===a&&J(b),a=b.pendingProps,null===a&&(a=b.memoizedProps),b.memoizedProps=a,null;case 8:b.tag=7;case 7:e=b.pendingProps;if(X.current)null===e&&(e=a&&a.memoizedProps,null===e?E(\"154\"):void 0);else if(null===e||b.memoizedProps===e)e=b.memoizedProps;d=e.children;b.stateNode=null===a?cf(b,b.stateNode,d,c):bf(b,b.stateNode,d,c);b.memoizedProps=e;return b.stateNode;\ncase 9:return null;case 4:a:{I(b,b.stateNode.containerInfo);e=b.pendingProps;if(X.current)null===e&&(e=a&&a.memoizedProps,null==e?E(\"154\"):void 0);else if(null===e||b.memoizedProps===e){b=q(a,b);break a}null===a?b.child=bf(b,null,e,c):f(a,b,e);b.memoizedProps=e;b=b.child}return b;case 10:a:{c=b.pendingProps;if(X.current)null===c&&(c=b.memoizedProps);else if(null===c||b.memoizedProps===c){b=q(a,b);break a}f(a,b,c);b.memoizedProps=c;b=b.child}return b;default:E(\"156\")}},beginFailedWork:function(a,b,\nc){switch(b.tag){case 2:qe(b);break;case 3:k(b);break;default:E(\"157\")}b.effectTag|=64;null===a?b.child=null:b.child!==a.child&&(b.child=a.child);if(0===b.expirationTime||b.expirationTime>c)return v(a,b);b.firstEffect=null;b.lastEffect=null;b.child=null===a?cf(b,null,null,c):bf(b,a.child,null,c);2===b.tag&&(a=b.stateNode,b.memoizedProps=a.props,b.memoizedState=a.state);return b.child}}}\nfunction ef(a,b,c){function d(a){a.effectTag|=4}var e=a.createInstance,f=a.createTextInstance,g=a.appendInitialChild,h=a.finalizeInitialChildren,k=a.prepareUpdate,q=a.persistence,v=b.getRootHostContainer,y=b.popHostContext,u=b.getHostContext,z=b.popHostContainer,G=c.prepareToHydrateHostInstance,I=c.prepareToHydrateHostTextInstance,L=c.popHydrationState,N=void 0,J=void 0,w=void 0;a.mutation?(N=function(){},J=function(a,b,c){(b.updateQueue=c)&&d(b)},w=function(a,b,c,e){c!==e&&d(b)}):q?E(\"235\"):E(\"236\");\nreturn{completeWork:function(a,b,c){var m=b.pendingProps;if(null===m)m=b.memoizedProps;else if(2147483647!==b.expirationTime||2147483647===c)b.pendingProps=null;switch(b.tag){case 1:return null;case 2:return ne(b),null;case 3:z(b);V(X,b);V(ie,b);m=b.stateNode;m.pendingContext&&(m.context=m.pendingContext,m.pendingContext=null);if(null===a||null===a.child)L(b),b.effectTag&=-3;N(b);return null;case 5:y(b);c=v();var A=b.type;if(null!==a&&null!=b.stateNode){var p=a.memoizedProps,q=b.stateNode,x=u();q=\nk(q,A,p,m,c,x);J(a,b,q,A,p,m,c);a.ref!==b.ref&&(b.effectTag|=128)}else{if(!m)return null===b.stateNode?E(\"166\"):void 0,null;a=u();if(L(b))G(b,c,a)&&d(b);else{a=e(A,m,c,a,b);a:for(p=b.child;null!==p;){if(5===p.tag||6===p.tag)g(a,p.stateNode);else if(4!==p.tag&&null!==p.child){p.child[\"return\"]=p;p=p.child;continue}if(p===b)break;for(;null===p.sibling;){if(null===p[\"return\"]||p[\"return\"]===b)break a;p=p[\"return\"]}p.sibling[\"return\"]=p[\"return\"];p=p.sibling}h(a,A,m,c)&&d(b);b.stateNode=a}null!==b.ref&&\n(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)w(a,b,a.memoizedProps,m);else{if(\"string\"!==typeof m)return null===b.stateNode?E(\"166\"):void 0,null;a=v();c=u();L(b)?I(b)&&d(b):b.stateNode=f(m,a,c,b)}return null;case 7:(m=b.memoizedProps)?void 0:E(\"165\");b.tag=8;A=[];a:for((p=b.stateNode)&&(p[\"return\"]=b);null!==p;){if(5===p.tag||6===p.tag||4===p.tag)E(\"247\");else if(9===p.tag)A.push(p.type);else if(null!==p.child){p.child[\"return\"]=p;p=p.child;continue}for(;null===p.sibling;){if(null===\np[\"return\"]||p[\"return\"]===b)break a;p=p[\"return\"]}p.sibling[\"return\"]=p[\"return\"];p=p.sibling}p=m.handler;m=p(m.props,A);b.child=bf(b,null!==a?a.child:null,m,c);return b.child;case 8:return b.tag=7,null;case 9:return null;case 10:return null;case 4:return z(b),N(b),null;case 0:E(\"167\");default:E(\"156\")}}}}\nfunction ff(a,b){function c(a){var c=a.ref;if(null!==c)try{c(null)}catch(A){b(a,A)}}function d(a){\"function\"===typeof Ee&&Ee(a);switch(a.tag){case 2:c(a);var d=a.stateNode;if(\"function\"===typeof d.componentWillUnmount)try{d.props=a.memoizedProps,d.state=a.memoizedState,d.componentWillUnmount()}catch(A){b(a,A)}break;case 5:c(a);break;case 7:e(a.stateNode);break;case 4:k&&g(a)}}function e(a){for(var b=a;;)if(d(b),null===b.child||k&&4===b.tag){if(b===a)break;for(;null===b.sibling;){if(null===b[\"return\"]||\nb[\"return\"]===a)return;b=b[\"return\"]}b.sibling[\"return\"]=b[\"return\"];b=b.sibling}else b.child[\"return\"]=b,b=b.child}function f(a){return 5===a.tag||3===a.tag||4===a.tag}function g(a){for(var b=a,c=!1,f=void 0,g=void 0;;){if(!c){c=b[\"return\"];a:for(;;){null===c?E(\"160\"):void 0;switch(c.tag){case 5:f=c.stateNode;g=!1;break a;case 3:f=c.stateNode.containerInfo;g=!0;break a;case 4:f=c.stateNode.containerInfo;g=!0;break a}c=c[\"return\"]}c=!0}if(5===b.tag||6===b.tag)e(b),g?J(f,b.stateNode):N(f,b.stateNode);\nelse if(4===b.tag?f=b.stateNode.containerInfo:d(b),null!==b.child){b.child[\"return\"]=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b[\"return\"]||b[\"return\"]===a)return;b=b[\"return\"];4===b.tag&&(c=!1)}b.sibling[\"return\"]=b[\"return\"];b=b.sibling}}var h=a.getPublicInstance,k=a.mutation;a=a.persistence;k||(a?E(\"235\"):E(\"236\"));var q=k.commitMount,v=k.commitUpdate,y=k.resetTextContent,u=k.commitTextUpdate,z=k.appendChild,G=k.appendChildToContainer,I=k.insertBefore,L=k.insertInContainerBefore,\nN=k.removeChild,J=k.removeChildFromContainer;return{commitResetTextContent:function(a){y(a.stateNode)},commitPlacement:function(a){a:{for(var b=a[\"return\"];null!==b;){if(f(b)){var c=b;break a}b=b[\"return\"]}E(\"160\");c=void 0}var d=b=void 0;switch(c.tag){case 5:b=c.stateNode;d=!1;break;case 3:b=c.stateNode.containerInfo;d=!0;break;case 4:b=c.stateNode.containerInfo;d=!0;break;default:E(\"161\")}c.effectTag&16&&(y(b),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c[\"return\"]||f(c[\"return\"])){c=\nnull;break a}c=c[\"return\"]}c.sibling[\"return\"]=c[\"return\"];for(c=c.sibling;5!==c.tag&&6!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;else c.child[\"return\"]=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}for(var e=a;;){if(5===e.tag||6===e.tag)c?d?L(b,e.stateNode,c):I(b,e.stateNode,c):d?G(b,e.stateNode):z(b,e.stateNode);else if(4!==e.tag&&null!==e.child){e.child[\"return\"]=e;e=e.child;continue}if(e===a)break;for(;null===e.sibling;){if(null===e[\"return\"]||e[\"return\"]===\na)return;e=e[\"return\"]}e.sibling[\"return\"]=e[\"return\"];e=e.sibling}},commitDeletion:function(a){g(a);a[\"return\"]=null;a.child=null;a.alternate&&(a.alternate.child=null,a.alternate[\"return\"]=null)},commitWork:function(a,b){switch(b.tag){case 2:break;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps;a=null!==a?a.memoizedProps:d;var e=b.type,f=b.updateQueue;b.updateQueue=null;null!==f&&v(c,f,e,a,d,b)}break;case 6:null===b.stateNode?E(\"162\"):void 0;c=b.memoizedProps;u(b.stateNode,null!==a?a.memoizedProps:\nc,c);break;case 3:break;default:E(\"163\")}},commitLifeCycles:function(a,b){switch(b.tag){case 2:var c=b.stateNode;if(b.effectTag&4)if(null===a)c.props=b.memoizedProps,c.state=b.memoizedState,c.componentDidMount();else{var d=a.memoizedProps;a=a.memoizedState;c.props=b.memoizedProps;c.state=b.memoizedState;c.componentDidUpdate(d,a)}b=b.updateQueue;null!==b&&Ke(b,c);break;case 3:c=b.updateQueue;null!==c&&Ke(c,null!==b.child?b.child.stateNode:null);break;case 5:c=b.stateNode;null===a&&b.effectTag&4&&q(c,\nb.type,b.memoizedProps,b);break;case 6:break;case 4:break;default:E(\"163\")}},commitAttachRef:function(a){var b=a.ref;if(null!==b){var c=a.stateNode;switch(a.tag){case 5:b(h(c));break;default:b(c)}}},commitDetachRef:function(a){a=a.ref;null!==a&&a(null)}}}var gf={};\nfunction hf(a){function b(a){a===gf?E(\"174\"):void 0;return a}var c=a.getChildHostContext,d=a.getRootHostContext,e={current:gf},f={current:gf},g={current:gf};return{getHostContext:function(){return b(e.current)},getRootHostContainer:function(){return b(g.current)},popHostContainer:function(a){V(e,a);V(f,a);V(g,a)},popHostContext:function(a){f.current===a&&(V(e,a),V(f,a))},pushHostContainer:function(a,b){W(g,b,a);b=d(b);W(f,a,a);W(e,b,a)},pushHostContext:function(a){var d=b(g.current),h=b(e.current);\nd=c(h,a.type,d);h!==d&&(W(f,a,a),W(e,d,a))},resetHostContainer:function(){e.current=gf;g.current=gf}}}\nfunction jf(a){function b(a,b){var c=new Y(5,null,0);c.type=\"DELETED\";c.stateNode=b;c[\"return\"]=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function c(a,b){switch(a.tag){case 5:return b=f(b,a.type,a.pendingProps),null!==b?(a.stateNode=b,!0):!1;case 6:return b=g(b,a.pendingProps),null!==b?(a.stateNode=b,!0):!1;default:return!1}}function d(a){for(a=a[\"return\"];null!==a&&5!==a.tag&&3!==a.tag;)a=a[\"return\"];y=a}var e=a.shouldSetTextContent;\na=a.hydration;if(!a)return{enterHydrationState:function(){return!1},resetHydrationState:function(){},tryToClaimNextHydratableInstance:function(){},prepareToHydrateHostInstance:function(){E(\"175\")},prepareToHydrateHostTextInstance:function(){E(\"176\")},popHydrationState:function(){return!1}};var f=a.canHydrateInstance,g=a.canHydrateTextInstance,h=a.getNextHydratableSibling,k=a.getFirstHydratableChild,q=a.hydrateInstance,v=a.hydrateTextInstance,y=null,u=null,z=!1;return{enterHydrationState:function(a){u=\nk(a.stateNode.containerInfo);y=a;return z=!0},resetHydrationState:function(){u=y=null;z=!1},tryToClaimNextHydratableInstance:function(a){if(z){var d=u;if(d){if(!c(a,d)){d=h(d);if(!d||!c(a,d)){a.effectTag|=2;z=!1;y=a;return}b(y,u)}y=a;u=k(d)}else a.effectTag|=2,z=!1,y=a}},prepareToHydrateHostInstance:function(a,b,c){b=q(a.stateNode,a.type,a.memoizedProps,b,c,a);a.updateQueue=b;return null!==b?!0:!1},prepareToHydrateHostTextInstance:function(a){return v(a.stateNode,a.memoizedProps,a)},popHydrationState:function(a){if(a!==\ny)return!1;if(!z)return d(a),z=!0,!1;var c=a.type;if(5!==a.tag||\"head\"!==c&&\"body\"!==c&&!e(c,a.memoizedProps))for(c=u;c;)b(a,c),c=h(c);d(a);u=y?h(a.stateNode):null;return!0}}}\nfunction kf(a){function b(a){Qb=ja=!0;var b=a.stateNode;b.current===a?E(\"177\"):void 0;b.isReadyForCommit=!1;id.current=null;if(1<a.effectTag)if(null!==a.lastEffect){a.lastEffect.nextEffect=a;var c=a.firstEffect}else c=a;else c=a.firstEffect;yg();for(t=c;null!==t;){var d=!1,e=void 0;try{for(;null!==t;){var f=t.effectTag;f&16&&zg(t);if(f&128){var g=t.alternate;null!==g&&Ag(g)}switch(f&-242){case 2:Ne(t);t.effectTag&=-3;break;case 6:Ne(t);t.effectTag&=-3;Oe(t.alternate,t);break;case 4:Oe(t.alternate,\nt);break;case 8:Sc=!0,Bg(t),Sc=!1}t=t.nextEffect}}catch(Tc){d=!0,e=Tc}d&&(null===t?E(\"178\"):void 0,h(t,e),null!==t&&(t=t.nextEffect))}Cg();b.current=a;for(t=c;null!==t;){c=!1;d=void 0;try{for(;null!==t;){var k=t.effectTag;k&36&&Dg(t.alternate,t);k&128&&Eg(t);if(k&64)switch(e=t,f=void 0,null!==R&&(f=R.get(e),R[\"delete\"](e),null==f&&null!==e.alternate&&(e=e.alternate,f=R.get(e),R[\"delete\"](e))),null==f?E(\"184\"):void 0,e.tag){case 2:e.stateNode.componentDidCatch(f.error,{componentStack:f.componentStack});\nbreak;case 3:null===ca&&(ca=f.error);break;default:E(\"157\")}var Qc=t.nextEffect;t.nextEffect=null;t=Qc}}catch(Tc){c=!0,d=Tc}c&&(null===t?E(\"178\"):void 0,h(t,d),null!==t&&(t=t.nextEffect))}ja=Qb=!1;\"function\"===typeof De&&De(a.stateNode);ha&&(ha.forEach(G),ha=null);null!==ca&&(a=ca,ca=null,Ob(a));b=b.current.expirationTime;0===b&&(qa=R=null);return b}function c(a){for(;;){var b=Fg(a.alternate,a,H),c=a[\"return\"],d=a.sibling;var e=a;if(2147483647===H||2147483647!==e.expirationTime){if(2!==e.tag&&3!==\ne.tag)var f=0;else f=e.updateQueue,f=null===f?0:f.expirationTime;for(var g=e.child;null!==g;)0!==g.expirationTime&&(0===f||f>g.expirationTime)&&(f=g.expirationTime),g=g.sibling;e.expirationTime=f}if(null!==b)return b;null!==c&&(null===c.firstEffect&&(c.firstEffect=a.firstEffect),null!==a.lastEffect&&(null!==c.lastEffect&&(c.lastEffect.nextEffect=a.firstEffect),c.lastEffect=a.lastEffect),1<a.effectTag&&(null!==c.lastEffect?c.lastEffect.nextEffect=a:c.firstEffect=a,c.lastEffect=a));if(null!==d)return d;\nif(null!==c)a=c;else{a.stateNode.isReadyForCommit=!0;break}}return null}function d(a){var b=rg(a.alternate,a,H);null===b&&(b=c(a));id.current=null;return b}function e(a){var b=Gg(a.alternate,a,H);null===b&&(b=c(a));id.current=null;return b}function f(a){if(null!==R){if(!(0===H||H>a))if(H<=Uc)for(;null!==F;)F=k(F)?e(F):d(F);else for(;null!==F&&!A();)F=k(F)?e(F):d(F)}else if(!(0===H||H>a))if(H<=Uc)for(;null!==F;)F=d(F);else for(;null!==F&&!A();)F=d(F)}function g(a,b){ja?E(\"243\"):void 0;ja=!0;a.isReadyForCommit=\n!1;if(a!==ra||b!==H||null===F){for(;-1<he;)ge[he]=null,he--;je=D;ie.current=D;X.current=!1;x();ra=a;H=b;F=se(ra.current,null,b)}var c=!1,d=null;try{f(b)}catch(Rc){c=!0,d=Rc}for(;c;){if(eb){ca=d;break}var g=F;if(null===g)eb=!0;else{var k=h(g,d);null===k?E(\"183\"):void 0;if(!eb){try{c=k;d=b;for(k=c;null!==g;){switch(g.tag){case 2:ne(g);break;case 5:qg(g);break;case 3:p(g);break;case 4:p(g)}if(g===k||g.alternate===k)break;g=g[\"return\"]}F=e(c);f(d)}catch(Rc){c=!0;d=Rc;continue}break}}}b=ca;eb=ja=!1;ca=\nnull;null!==b&&Ob(b);return a.isReadyForCommit?a.current.alternate:null}function h(a,b){var c=id.current=null,d=!1,e=!1,f=null;if(3===a.tag)c=a,q(a)&&(eb=!0);else for(var g=a[\"return\"];null!==g&&null===c;){2===g.tag?\"function\"===typeof g.stateNode.componentDidCatch&&(d=!0,f=jd(g),c=g,e=!0):3===g.tag&&(c=g);if(q(g)){if(Sc||null!==ha&&(ha.has(g)||null!==g.alternate&&ha.has(g.alternate)))return null;c=null;e=!1}g=g[\"return\"]}if(null!==c){null===qa&&(qa=new Set);qa.add(c);var h=\"\";g=a;do{a:switch(g.tag){case 0:case 1:case 2:case 5:var k=\ng._debugOwner,Qc=g._debugSource;var m=jd(g);var n=null;k&&(n=jd(k));k=Qc;m=\"\\n    in \"+(m||\"Unknown\")+(k?\" (at \"+k.fileName.replace(/^.*[\\\\\\/]/,\"\")+\":\"+k.lineNumber+\")\":n?\" (created by \"+n+\")\":\"\");break a;default:m=\"\"}h+=m;g=g[\"return\"]}while(g);g=h;a=jd(a);null===R&&(R=new Map);b={componentName:a,componentStack:g,error:b,errorBoundary:d?c.stateNode:null,errorBoundaryFound:d,errorBoundaryName:f,willRetry:e};R.set(c,b);try{var p=b.error;p&&p.suppressReactErrorLogging||console.error(p)}catch(Vc){Vc&&\nVc.suppressReactErrorLogging||console.error(Vc)}Qb?(null===ha&&(ha=new Set),ha.add(c)):G(c);return c}null===ca&&(ca=b);return null}function k(a){return null!==R&&(R.has(a)||null!==a.alternate&&R.has(a.alternate))}function q(a){return null!==qa&&(qa.has(a)||null!==a.alternate&&qa.has(a.alternate))}function v(){return 20*(((I()+100)/20|0)+1)}function y(a){return 0!==ka?ka:ja?Qb?1:H:!Hg||a.internalContextTag&1?v():1}function u(a,b){return z(a,b,!1)}function z(a,b){for(;null!==a;){if(0===a.expirationTime||\na.expirationTime>b)a.expirationTime=b;null!==a.alternate&&(0===a.alternate.expirationTime||a.alternate.expirationTime>b)&&(a.alternate.expirationTime=b);if(null===a[\"return\"])if(3===a.tag){var c=a.stateNode;!ja&&c===ra&&b<H&&(F=ra=null,H=0);var d=c,e=b;Rb>Ig&&E(\"185\");if(null===d.nextScheduledRoot)d.remainingExpirationTime=e,null===O?(sa=O=d,d.nextScheduledRoot=d):(O=O.nextScheduledRoot=d,O.nextScheduledRoot=sa);else{var f=d.remainingExpirationTime;if(0===f||e<f)d.remainingExpirationTime=e}Fa||(la?\nSb&&(ma=d,na=1,m(ma,na)):1===e?w(1,null):L(e));!ja&&c===ra&&b<H&&(F=ra=null,H=0)}else break;a=a[\"return\"]}}function G(a){z(a,1,!0)}function I(){return Uc=((Wc()-Pe)/10|0)+2}function L(a){if(0!==Tb){if(a>Tb)return;Jg(Xc)}var b=Wc()-Pe;Tb=a;Xc=Kg(J,{timeout:10*(a-2)-b})}function N(){var a=0,b=null;if(null!==O)for(var c=O,d=sa;null!==d;){var e=d.remainingExpirationTime;if(0===e){null===c||null===O?E(\"244\"):void 0;if(d===d.nextScheduledRoot){sa=O=d.nextScheduledRoot=null;break}else if(d===sa)sa=e=d.nextScheduledRoot,\nO.nextScheduledRoot=e,d.nextScheduledRoot=null;else if(d===O){O=c;O.nextScheduledRoot=sa;d.nextScheduledRoot=null;break}else c.nextScheduledRoot=d.nextScheduledRoot,d.nextScheduledRoot=null;d=c.nextScheduledRoot}else{if(0===a||e<a)a=e,b=d;if(d===O)break;c=d;d=d.nextScheduledRoot}}c=ma;null!==c&&c===b?Rb++:Rb=0;ma=b;na=a}function J(a){w(0,a)}function w(a,b){fb=b;for(N();null!==ma&&0!==na&&(0===a||na<=a)&&!Yc;)m(ma,na),N();null!==fb&&(Tb=0,Xc=-1);0!==na&&L(na);fb=null;Yc=!1;Rb=0;if(Ub)throw a=Zc,Zc=\nnull,Ub=!1,a;}function m(a,c){Fa?E(\"245\"):void 0;Fa=!0;if(c<=I()){var d=a.finishedWork;null!==d?(a.finishedWork=null,a.remainingExpirationTime=b(d)):(a.finishedWork=null,d=g(a,c),null!==d&&(a.remainingExpirationTime=b(d)))}else d=a.finishedWork,null!==d?(a.finishedWork=null,a.remainingExpirationTime=b(d)):(a.finishedWork=null,d=g(a,c),null!==d&&(A()?a.finishedWork=d:a.remainingExpirationTime=b(d)));Fa=!1}function A(){return null===fb||fb.timeRemaining()>Lg?!1:Yc=!0}function Ob(a){null===ma?E(\"246\"):\nvoid 0;ma.remainingExpirationTime=0;Ub||(Ub=!0,Zc=a)}var r=hf(a),n=jf(a),p=r.popHostContainer,qg=r.popHostContext,x=r.resetHostContainer,Me=df(a,r,n,u,y),rg=Me.beginWork,Gg=Me.beginFailedWork,Fg=ef(a,r,n).completeWork;r=ff(a,h);var zg=r.commitResetTextContent,Ne=r.commitPlacement,Bg=r.commitDeletion,Oe=r.commitWork,Dg=r.commitLifeCycles,Eg=r.commitAttachRef,Ag=r.commitDetachRef,Wc=a.now,Kg=a.scheduleDeferredCallback,Jg=a.cancelDeferredCallback,Hg=a.useSyncScheduling,yg=a.prepareForCommit,Cg=a.resetAfterCommit,\nPe=Wc(),Uc=2,ka=0,ja=!1,F=null,ra=null,H=0,t=null,R=null,qa=null,ha=null,ca=null,eb=!1,Qb=!1,Sc=!1,sa=null,O=null,Tb=0,Xc=-1,Fa=!1,ma=null,na=0,Yc=!1,Ub=!1,Zc=null,fb=null,la=!1,Sb=!1,Ig=1E3,Rb=0,Lg=1;return{computeAsyncExpiration:v,computeExpirationForFiber:y,scheduleWork:u,batchedUpdates:function(a,b){var c=la;la=!0;try{return a(b)}finally{(la=c)||Fa||w(1,null)}},unbatchedUpdates:function(a){if(la&&!Sb){Sb=!0;try{return a()}finally{Sb=!1}}return a()},flushSync:function(a){var b=la;la=!0;try{a:{var c=\nka;ka=1;try{var d=a();break a}finally{ka=c}d=void 0}return d}finally{la=b,Fa?E(\"187\"):void 0,w(1,null)}},deferredUpdates:function(a){var b=ka;ka=v();try{return a()}finally{ka=b}}}}\nfunction lf(a){function b(a){a=od(a);return null===a?null:a.stateNode}var c=a.getPublicInstance;a=kf(a);var d=a.computeAsyncExpiration,e=a.computeExpirationForFiber,f=a.scheduleWork;return{createContainer:function(a,b){var c=new Y(3,null,0);a={current:c,containerInfo:a,pendingChildren:null,remainingExpirationTime:0,isReadyForCommit:!1,finishedWork:null,context:null,pendingContext:null,hydrate:b,nextScheduledRoot:null};return c.stateNode=a},updateContainer:function(a,b,c,q){var g=b.current;if(c){c=\nc._reactInternalFiber;var h;b:{2===kd(c)&&2===c.tag?void 0:E(\"170\");for(h=c;3!==h.tag;){if(le(h)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}(h=h[\"return\"])?void 0:E(\"171\")}h=h.stateNode.context}c=le(c)?pe(c,h):h}else c=D;null===b.context?b.context=c:b.pendingContext=c;b=q;b=void 0===b?null:b;q=null!=a&&null!=a.type&&null!=a.type.prototype&&!0===a.type.prototype.unstable_isAsyncReactComponent?d():e(g);He(g,{expirationTime:q,partialState:{element:a},callback:b,isReplace:!1,isForced:!1,\nnextCallback:null,next:null});f(g,q)},batchedUpdates:a.batchedUpdates,unbatchedUpdates:a.unbatchedUpdates,deferredUpdates:a.deferredUpdates,flushSync:a.flushSync,getPublicRootInstance:function(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return c(a.child.stateNode);default:return a.child.stateNode}},findHostInstance:b,findHostInstanceWithNoPortals:function(a){a=pd(a);return null===a?null:a.stateNode},injectIntoDevTools:function(a){var c=a.findFiberByHostInstance;return Ce(B({},\na,{findHostInstanceByFiber:function(a){return b(a)},findFiberByHostInstance:function(a){return c?c(a):null}}))}}}var mf=Object.freeze({default:lf}),nf=mf&&lf||mf,of=nf[\"default\"]?nf[\"default\"]:nf;function pf(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:Ue,key:null==d?null:\"\"+d,children:a,containerInfo:b,implementation:c}}var qf=\"object\"===typeof performance&&\"function\"===typeof performance.now,rf=void 0;rf=qf?function(){return performance.now()}:function(){return Date.now()};\nvar sf=void 0,tf=void 0;\nif(l.canUseDOM)if(\"function\"!==typeof requestIdleCallback||\"function\"!==typeof cancelIdleCallback){var uf=null,vf=!1,wf=-1,xf=!1,yf=0,zf=33,Af=33,Bf;Bf=qf?{didTimeout:!1,timeRemaining:function(){var a=yf-performance.now();return 0<a?a:0}}:{didTimeout:!1,timeRemaining:function(){var a=yf-Date.now();return 0<a?a:0}};var Cf=\"__reactIdleCallback$\"+Math.random().toString(36).slice(2);window.addEventListener(\"message\",function(a){if(a.source===window&&a.data===Cf){vf=!1;a=rf();if(0>=yf-a)if(-1!==wf&&wf<=\na)Bf.didTimeout=!0;else{xf||(xf=!0,requestAnimationFrame(Df));return}else Bf.didTimeout=!1;wf=-1;a=uf;uf=null;null!==a&&a(Bf)}},!1);var Df=function(a){xf=!1;var b=a-yf+Af;b<Af&&zf<Af?(8>b&&(b=8),Af=b<zf?zf:b):zf=b;yf=a+Af;vf||(vf=!0,window.postMessage(Cf,\"*\"))};sf=function(a,b){uf=a;null!=b&&\"number\"===typeof b.timeout&&(wf=rf()+b.timeout);xf||(xf=!0,requestAnimationFrame(Df));return 0};tf=function(){uf=null;vf=!1;wf=-1}}else sf=window.requestIdleCallback,tf=window.cancelIdleCallback;else sf=function(a){return setTimeout(function(){a({timeRemaining:function(){return Infinity}})})},\ntf=function(a){clearTimeout(a)};var Ef=/^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$/,Ff={},Gf={};\nfunction Hf(a){if(Gf.hasOwnProperty(a))return!0;if(Ff.hasOwnProperty(a))return!1;if(Ef.test(a))return Gf[a]=!0;Ff[a]=!0;return!1}\nfunction If(a,b,c){var d=wa(b);if(d&&va(b,c)){var e=d.mutationMethod;e?e(a,c):null==c||d.hasBooleanValue&&!c||d.hasNumericValue&&isNaN(c)||d.hasPositiveNumericValue&&1>c||d.hasOverloadedBooleanValue&&!1===c?Jf(a,b):d.mustUseProperty?a[d.propertyName]=c:(b=d.attributeName,(e=d.attributeNamespace)?a.setAttributeNS(e,b,\"\"+c):d.hasBooleanValue||d.hasOverloadedBooleanValue&&!0===c?a.setAttribute(b,\"\"):a.setAttribute(b,\"\"+c))}else Kf(a,b,va(b,c)?c:null)}\nfunction Kf(a,b,c){Hf(b)&&(null==c?a.removeAttribute(b):a.setAttribute(b,\"\"+c))}function Jf(a,b){var c=wa(b);c?(b=c.mutationMethod)?b(a,void 0):c.mustUseProperty?a[c.propertyName]=c.hasBooleanValue?!1:\"\":a.removeAttribute(c.attributeName):a.removeAttribute(b)}\nfunction Lf(a,b){var c=b.value,d=b.checked;return B({type:void 0,step:void 0,min:void 0,max:void 0},b,{defaultChecked:void 0,defaultValue:void 0,value:null!=c?c:a._wrapperState.initialValue,checked:null!=d?d:a._wrapperState.initialChecked})}function Mf(a,b){var c=b.defaultValue;a._wrapperState={initialChecked:null!=b.checked?b.checked:b.defaultChecked,initialValue:null!=b.value?b.value:c,controlled:\"checkbox\"===b.type||\"radio\"===b.type?null!=b.checked:null!=b.value}}\nfunction Nf(a,b){b=b.checked;null!=b&&If(a,\"checked\",b)}function Of(a,b){Nf(a,b);var c=b.value;if(null!=c)if(0===c&&\"\"===a.value)a.value=\"0\";else if(\"number\"===b.type){if(b=parseFloat(a.value)||0,c!=b||c==b&&a.value!=c)a.value=\"\"+c}else a.value!==\"\"+c&&(a.value=\"\"+c);else null==b.value&&null!=b.defaultValue&&a.defaultValue!==\"\"+b.defaultValue&&(a.defaultValue=\"\"+b.defaultValue),null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}\nfunction Pf(a,b){switch(b.type){case \"submit\":case \"reset\":break;case \"color\":case \"date\":case \"datetime\":case \"datetime-local\":case \"month\":case \"time\":case \"week\":a.value=\"\";a.value=a.defaultValue;break;default:a.value=a.value}b=a.name;\"\"!==b&&(a.name=\"\");a.defaultChecked=!a.defaultChecked;a.defaultChecked=!a.defaultChecked;\"\"!==b&&(a.name=b)}function Qf(a){var b=\"\";aa.Children.forEach(a,function(a){null==a||\"string\"!==typeof a&&\"number\"!==typeof a||(b+=a)});return b}\nfunction Rf(a,b){a=B({children:void 0},b);if(b=Qf(b.children))a.children=b;return a}function Sf(a,b,c,d){a=a.options;if(b){b={};for(var e=0;e<c.length;e++)b[\"$\"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty(\"$\"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=\"\"+c;b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}\nfunction Tf(a,b){var c=b.value;a._wrapperState={initialValue:null!=c?c:b.defaultValue,wasMultiple:!!b.multiple}}function Uf(a,b){null!=b.dangerouslySetInnerHTML?E(\"91\"):void 0;return B({},b,{value:void 0,defaultValue:void 0,children:\"\"+a._wrapperState.initialValue})}function Vf(a,b){var c=b.value;null==c&&(c=b.defaultValue,b=b.children,null!=b&&(null!=c?E(\"92\"):void 0,Array.isArray(b)&&(1>=b.length?void 0:E(\"93\"),b=b[0]),c=\"\"+b),null==c&&(c=\"\"));a._wrapperState={initialValue:\"\"+c}}\nfunction Wf(a,b){var c=b.value;null!=c&&(c=\"\"+c,c!==a.value&&(a.value=c),null==b.defaultValue&&(a.defaultValue=c));null!=b.defaultValue&&(a.defaultValue=b.defaultValue)}function Xf(a){var b=a.textContent;b===a._wrapperState.initialValue&&(a.value=b)}var Yf={html:\"http://www.w3.org/1999/xhtml\",mathml:\"http://www.w3.org/1998/Math/MathML\",svg:\"http://www.w3.org/2000/svg\"};\nfunction Zf(a){switch(a){case \"svg\":return\"http://www.w3.org/2000/svg\";case \"math\":return\"http://www.w3.org/1998/Math/MathML\";default:return\"http://www.w3.org/1999/xhtml\"}}function $f(a,b){return null==a||\"http://www.w3.org/1999/xhtml\"===a?Zf(b):\"http://www.w3.org/2000/svg\"===a&&\"foreignObject\"===b?\"http://www.w3.org/1999/xhtml\":a}\nvar ag=void 0,bg=function(a){return\"undefined\"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if(a.namespaceURI!==Yf.svg||\"innerHTML\"in a)a.innerHTML=b;else{ag=ag||document.createElement(\"div\");ag.innerHTML=\"\\x3csvg\\x3e\"+b+\"\\x3c/svg\\x3e\";for(b=ag.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}});\nfunction cg(a,b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b}\nvar dg={animationIterationCount:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,\nstopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},eg=[\"Webkit\",\"ms\",\"Moz\",\"O\"];Object.keys(dg).forEach(function(a){eg.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);dg[b]=dg[a]})});\nfunction fg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf(\"--\");var e=c;var f=b[c];e=null==f||\"boolean\"===typeof f||\"\"===f?\"\":d||\"number\"!==typeof f||0===f||dg.hasOwnProperty(e)&&dg[e]?(\"\"+f).trim():f+\"px\";\"float\"===c&&(c=\"cssFloat\");d?a.setProperty(c,e):a[c]=e}}var gg=B({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});\nfunction hg(a,b,c){b&&(gg[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML?E(\"137\",a,c()):void 0),null!=b.dangerouslySetInnerHTML&&(null!=b.children?E(\"60\"):void 0,\"object\"===typeof b.dangerouslySetInnerHTML&&\"__html\"in b.dangerouslySetInnerHTML?void 0:E(\"61\")),null!=b.style&&\"object\"!==typeof b.style?E(\"62\",c()):void 0)}\nfunction ig(a,b){if(-1===a.indexOf(\"-\"))return\"string\"===typeof b.is;switch(a){case \"annotation-xml\":case \"color-profile\":case \"font-face\":case \"font-face-src\":case \"font-face-uri\":case \"font-face-format\":case \"font-face-name\":case \"missing-glyph\":return!1;default:return!0}}var jg=Yf.html,kg=C.thatReturns(\"\");\nfunction lg(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Hd(a);b=Sa[b];for(var d=0;d<b.length;d++){var e=b[d];c.hasOwnProperty(e)&&c[e]||(\"topScroll\"===e?wd(\"topScroll\",\"scroll\",a):\"topFocus\"===e||\"topBlur\"===e?(wd(\"topFocus\",\"focus\",a),wd(\"topBlur\",\"blur\",a),c.topBlur=!0,c.topFocus=!0):\"topCancel\"===e?(yc(\"cancel\",!0)&&wd(\"topCancel\",\"cancel\",a),c.topCancel=!0):\"topClose\"===e?(yc(\"close\",!0)&&wd(\"topClose\",\"close\",a),c.topClose=!0):Dd.hasOwnProperty(e)&&U(e,Dd[e],a),c[e]=!0)}}\nvar mg={topAbort:\"abort\",topCanPlay:\"canplay\",topCanPlayThrough:\"canplaythrough\",topDurationChange:\"durationchange\",topEmptied:\"emptied\",topEncrypted:\"encrypted\",topEnded:\"ended\",topError:\"error\",topLoadedData:\"loadeddata\",topLoadedMetadata:\"loadedmetadata\",topLoadStart:\"loadstart\",topPause:\"pause\",topPlay:\"play\",topPlaying:\"playing\",topProgress:\"progress\",topRateChange:\"ratechange\",topSeeked:\"seeked\",topSeeking:\"seeking\",topStalled:\"stalled\",topSuspend:\"suspend\",topTimeUpdate:\"timeupdate\",topVolumeChange:\"volumechange\",\ntopWaiting:\"waiting\"};function ng(a,b,c,d){c=9===c.nodeType?c:c.ownerDocument;d===jg&&(d=Zf(a));d===jg?\"script\"===a?(a=c.createElement(\"div\"),a.innerHTML=\"\\x3cscript\\x3e\\x3c/script\\x3e\",a=a.removeChild(a.firstChild)):a=\"string\"===typeof b.is?c.createElement(a,{is:b.is}):c.createElement(a):a=c.createElementNS(d,a);return a}function og(a,b){return(9===b.nodeType?b:b.ownerDocument).createTextNode(a)}\nfunction pg(a,b,c,d){var e=ig(b,c);switch(b){case \"iframe\":case \"object\":U(\"topLoad\",\"load\",a);var f=c;break;case \"video\":case \"audio\":for(f in mg)mg.hasOwnProperty(f)&&U(f,mg[f],a);f=c;break;case \"source\":U(\"topError\",\"error\",a);f=c;break;case \"img\":case \"image\":U(\"topError\",\"error\",a);U(\"topLoad\",\"load\",a);f=c;break;case \"form\":U(\"topReset\",\"reset\",a);U(\"topSubmit\",\"submit\",a);f=c;break;case \"details\":U(\"topToggle\",\"toggle\",a);f=c;break;case \"input\":Mf(a,c);f=Lf(a,c);U(\"topInvalid\",\"invalid\",a);\nlg(d,\"onChange\");break;case \"option\":f=Rf(a,c);break;case \"select\":Tf(a,c);f=B({},c,{value:void 0});U(\"topInvalid\",\"invalid\",a);lg(d,\"onChange\");break;case \"textarea\":Vf(a,c);f=Uf(a,c);U(\"topInvalid\",\"invalid\",a);lg(d,\"onChange\");break;default:f=c}hg(b,f,kg);var g=f,h;for(h in g)if(g.hasOwnProperty(h)){var k=g[h];\"style\"===h?fg(a,k,kg):\"dangerouslySetInnerHTML\"===h?(k=k?k.__html:void 0,null!=k&&bg(a,k)):\"children\"===h?\"string\"===typeof k?(\"textarea\"!==b||\"\"!==k)&&cg(a,k):\"number\"===typeof k&&cg(a,\n\"\"+k):\"suppressContentEditableWarning\"!==h&&\"suppressHydrationWarning\"!==h&&\"autoFocus\"!==h&&(Ra.hasOwnProperty(h)?null!=k&&lg(d,h):e?Kf(a,h,k):null!=k&&If(a,h,k))}switch(b){case \"input\":Bc(a);Pf(a,c);break;case \"textarea\":Bc(a);Xf(a,c);break;case \"option\":null!=c.value&&a.setAttribute(\"value\",c.value);break;case \"select\":a.multiple=!!c.multiple;b=c.value;null!=b?Sf(a,!!c.multiple,b,!1):null!=c.defaultValue&&Sf(a,!!c.multiple,c.defaultValue,!0);break;default:\"function\"===typeof f.onClick&&(a.onclick=\nC)}}\nfunction sg(a,b,c,d,e){var f=null;switch(b){case \"input\":c=Lf(a,c);d=Lf(a,d);f=[];break;case \"option\":c=Rf(a,c);d=Rf(a,d);f=[];break;case \"select\":c=B({},c,{value:void 0});d=B({},d,{value:void 0});f=[];break;case \"textarea\":c=Uf(a,c);d=Uf(a,d);f=[];break;default:\"function\"!==typeof c.onClick&&\"function\"===typeof d.onClick&&(a.onclick=C)}hg(b,d,kg);var g,h;a=null;for(g in c)if(!d.hasOwnProperty(g)&&c.hasOwnProperty(g)&&null!=c[g])if(\"style\"===g)for(h in b=c[g],b)b.hasOwnProperty(h)&&(a||(a={}),a[h]=\n\"\");else\"dangerouslySetInnerHTML\"!==g&&\"children\"!==g&&\"suppressContentEditableWarning\"!==g&&\"suppressHydrationWarning\"!==g&&\"autoFocus\"!==g&&(Ra.hasOwnProperty(g)?f||(f=[]):(f=f||[]).push(g,null));for(g in d){var k=d[g];b=null!=c?c[g]:void 0;if(d.hasOwnProperty(g)&&k!==b&&(null!=k||null!=b))if(\"style\"===g)if(b){for(h in b)!b.hasOwnProperty(h)||k&&k.hasOwnProperty(h)||(a||(a={}),a[h]=\"\");for(h in k)k.hasOwnProperty(h)&&b[h]!==k[h]&&(a||(a={}),a[h]=k[h])}else a||(f||(f=[]),f.push(g,a)),a=k;else\"dangerouslySetInnerHTML\"===\ng?(k=k?k.__html:void 0,b=b?b.__html:void 0,null!=k&&b!==k&&(f=f||[]).push(g,\"\"+k)):\"children\"===g?b===k||\"string\"!==typeof k&&\"number\"!==typeof k||(f=f||[]).push(g,\"\"+k):\"suppressContentEditableWarning\"!==g&&\"suppressHydrationWarning\"!==g&&(Ra.hasOwnProperty(g)?(null!=k&&lg(e,g),f||b===k||(f=[])):(f=f||[]).push(g,k))}a&&(f=f||[]).push(\"style\",a);return f}\nfunction tg(a,b,c,d,e){\"input\"===c&&\"radio\"===e.type&&null!=e.name&&Nf(a,e);ig(c,d);d=ig(c,e);for(var f=0;f<b.length;f+=2){var g=b[f],h=b[f+1];\"style\"===g?fg(a,h,kg):\"dangerouslySetInnerHTML\"===g?bg(a,h):\"children\"===g?cg(a,h):d?null!=h?Kf(a,g,h):a.removeAttribute(g):null!=h?If(a,g,h):Jf(a,g)}switch(c){case \"input\":Of(a,e);break;case \"textarea\":Wf(a,e);break;case \"select\":a._wrapperState.initialValue=void 0,b=a._wrapperState.wasMultiple,a._wrapperState.wasMultiple=!!e.multiple,c=e.value,null!=c?Sf(a,\n!!e.multiple,c,!1):b!==!!e.multiple&&(null!=e.defaultValue?Sf(a,!!e.multiple,e.defaultValue,!0):Sf(a,!!e.multiple,e.multiple?[]:\"\",!1))}}\nfunction ug(a,b,c,d,e){switch(b){case \"iframe\":case \"object\":U(\"topLoad\",\"load\",a);break;case \"video\":case \"audio\":for(var f in mg)mg.hasOwnProperty(f)&&U(f,mg[f],a);break;case \"source\":U(\"topError\",\"error\",a);break;case \"img\":case \"image\":U(\"topError\",\"error\",a);U(\"topLoad\",\"load\",a);break;case \"form\":U(\"topReset\",\"reset\",a);U(\"topSubmit\",\"submit\",a);break;case \"details\":U(\"topToggle\",\"toggle\",a);break;case \"input\":Mf(a,c);U(\"topInvalid\",\"invalid\",a);lg(e,\"onChange\");break;case \"select\":Tf(a,c);\nU(\"topInvalid\",\"invalid\",a);lg(e,\"onChange\");break;case \"textarea\":Vf(a,c),U(\"topInvalid\",\"invalid\",a),lg(e,\"onChange\")}hg(b,c,kg);d=null;for(var g in c)c.hasOwnProperty(g)&&(f=c[g],\"children\"===g?\"string\"===typeof f?a.textContent!==f&&(d=[\"children\",f]):\"number\"===typeof f&&a.textContent!==\"\"+f&&(d=[\"children\",\"\"+f]):Ra.hasOwnProperty(g)&&null!=f&&lg(e,g));switch(b){case \"input\":Bc(a);Pf(a,c);break;case \"textarea\":Bc(a);Xf(a,c);break;case \"select\":case \"option\":break;default:\"function\"===typeof c.onClick&&\n(a.onclick=C)}return d}function vg(a,b){return a.nodeValue!==b}\nvar wg=Object.freeze({createElement:ng,createTextNode:og,setInitialProperties:pg,diffProperties:sg,updateProperties:tg,diffHydratedProperties:ug,diffHydratedText:vg,warnForUnmatchedText:function(){},warnForDeletedHydratableElement:function(){},warnForDeletedHydratableText:function(){},warnForInsertedHydratedElement:function(){},warnForInsertedHydratedText:function(){},restoreControlledState:function(a,b,c){switch(b){case \"input\":Of(a,c);b=c.name;if(\"radio\"===c.type&&null!=b){for(c=a;c.parentNode;)c=\nc.parentNode;c=c.querySelectorAll(\"input[name\\x3d\"+JSON.stringify(\"\"+b)+'][type\\x3d\"radio\"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=rb(d);e?void 0:E(\"90\");Cc(d);Of(d,e)}}}break;case \"textarea\":Wf(a,c);break;case \"select\":b=c.value,null!=b&&Sf(a,!!c.multiple,b,!1)}}});nc.injectFiberControlledHostComponent(wg);var xg=null,Mg=null;function Ng(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||\" react-mount-point-unstable \"!==a.nodeValue))}\nfunction Og(a){a=a?9===a.nodeType?a.documentElement:a.firstChild:null;return!(!a||1!==a.nodeType||!a.hasAttribute(\"data-reactroot\"))}\nvar Z=of({getRootHostContext:function(a){var b=a.nodeType;switch(b){case 9:case 11:a=(a=a.documentElement)?a.namespaceURI:$f(null,\"\");break;default:b=8===b?a.parentNode:a,a=b.namespaceURI||null,b=b.tagName,a=$f(a,b)}return a},getChildHostContext:function(a,b){return $f(a,b)},getPublicInstance:function(a){return a},prepareForCommit:function(){xg=td;var a=da();if(Kd(a)){if(\"selectionStart\"in a)var b={start:a.selectionStart,end:a.selectionEnd};else a:{var c=window.getSelection&&window.getSelection();\nif(c&&0!==c.rangeCount){b=c.anchorNode;var d=c.anchorOffset,e=c.focusNode;c=c.focusOffset;try{b.nodeType,e.nodeType}catch(z){b=null;break a}var f=0,g=-1,h=-1,k=0,q=0,v=a,y=null;b:for(;;){for(var u;;){v!==b||0!==d&&3!==v.nodeType||(g=f+d);v!==e||0!==c&&3!==v.nodeType||(h=f+c);3===v.nodeType&&(f+=v.nodeValue.length);if(null===(u=v.firstChild))break;y=v;v=u}for(;;){if(v===a)break b;y===b&&++k===d&&(g=f);y===e&&++q===c&&(h=f);if(null!==(u=v.nextSibling))break;v=y;y=v.parentNode}v=u}b=-1===g||-1===h?null:\n{start:g,end:h}}else b=null}b=b||{start:0,end:0}}else b=null;Mg={focusedElem:a,selectionRange:b};ud(!1)},resetAfterCommit:function(){var a=Mg,b=da(),c=a.focusedElem,d=a.selectionRange;if(b!==c&&fa(document.documentElement,c)){if(Kd(c))if(b=d.start,a=d.end,void 0===a&&(a=b),\"selectionStart\"in c)c.selectionStart=b,c.selectionEnd=Math.min(a,c.value.length);else if(window.getSelection){b=window.getSelection();var e=c[Eb()].length;a=Math.min(d.start,e);d=void 0===d.end?a:Math.min(d.end,e);!b.extend&&a>\nd&&(e=d,d=a,a=e);e=Jd(c,a);var f=Jd(c,d);if(e&&f&&(1!==b.rangeCount||b.anchorNode!==e.node||b.anchorOffset!==e.offset||b.focusNode!==f.node||b.focusOffset!==f.offset)){var g=document.createRange();g.setStart(e.node,e.offset);b.removeAllRanges();a>d?(b.addRange(g),b.extend(f.node,f.offset)):(g.setEnd(f.node,f.offset),b.addRange(g))}}b=[];for(a=c;a=a.parentNode;)1===a.nodeType&&b.push({element:a,left:a.scrollLeft,top:a.scrollTop});ia(c);for(c=0;c<b.length;c++)a=b[c],a.element.scrollLeft=a.left,a.element.scrollTop=\na.top}Mg=null;ud(xg);xg=null},createInstance:function(a,b,c,d,e){a=ng(a,b,c,d);a[Q]=e;a[ob]=b;return a},appendInitialChild:function(a,b){a.appendChild(b)},finalizeInitialChildren:function(a,b,c,d){pg(a,b,c,d);a:{switch(b){case \"button\":case \"input\":case \"select\":case \"textarea\":a=!!c.autoFocus;break a}a=!1}return a},prepareUpdate:function(a,b,c,d,e){return sg(a,b,c,d,e)},shouldSetTextContent:function(a,b){return\"textarea\"===a||\"string\"===typeof b.children||\"number\"===typeof b.children||\"object\"===\ntypeof b.dangerouslySetInnerHTML&&null!==b.dangerouslySetInnerHTML&&\"string\"===typeof b.dangerouslySetInnerHTML.__html},shouldDeprioritizeSubtree:function(a,b){return!!b.hidden},createTextInstance:function(a,b,c,d){a=og(a,b);a[Q]=d;return a},now:rf,mutation:{commitMount:function(a){a.focus()},commitUpdate:function(a,b,c,d,e){a[ob]=e;tg(a,b,c,d,e)},resetTextContent:function(a){a.textContent=\"\"},commitTextUpdate:function(a,b,c){a.nodeValue=c},appendChild:function(a,b){a.appendChild(b)},appendChildToContainer:function(a,\nb){8===a.nodeType?a.parentNode.insertBefore(b,a):a.appendChild(b)},insertBefore:function(a,b,c){a.insertBefore(b,c)},insertInContainerBefore:function(a,b,c){8===a.nodeType?a.parentNode.insertBefore(b,c):a.insertBefore(b,c)},removeChild:function(a,b){a.removeChild(b)},removeChildFromContainer:function(a,b){8===a.nodeType?a.parentNode.removeChild(b):a.removeChild(b)}},hydration:{canHydrateInstance:function(a,b){return 1!==a.nodeType||b.toLowerCase()!==a.nodeName.toLowerCase()?null:a},canHydrateTextInstance:function(a,\nb){return\"\"===b||3!==a.nodeType?null:a},getNextHydratableSibling:function(a){for(a=a.nextSibling;a&&1!==a.nodeType&&3!==a.nodeType;)a=a.nextSibling;return a},getFirstHydratableChild:function(a){for(a=a.firstChild;a&&1!==a.nodeType&&3!==a.nodeType;)a=a.nextSibling;return a},hydrateInstance:function(a,b,c,d,e,f){a[Q]=f;a[ob]=c;return ug(a,b,c,e,d)},hydrateTextInstance:function(a,b,c){a[Q]=c;return vg(a,b)},didNotMatchHydratedContainerTextInstance:function(){},didNotMatchHydratedTextInstance:function(){},\ndidNotHydrateContainerInstance:function(){},didNotHydrateInstance:function(){},didNotFindHydratableContainerInstance:function(){},didNotFindHydratableContainerTextInstance:function(){},didNotFindHydratableInstance:function(){},didNotFindHydratableTextInstance:function(){}},scheduleDeferredCallback:sf,cancelDeferredCallback:tf,useSyncScheduling:!0});rc=Z.batchedUpdates;\nfunction Pg(a,b,c,d,e){Ng(c)?void 0:E(\"200\");var f=c._reactRootContainer;if(f)Z.updateContainer(b,f,a,e);else{d=d||Og(c);if(!d)for(f=void 0;f=c.lastChild;)c.removeChild(f);var g=Z.createContainer(c,d);f=c._reactRootContainer=g;Z.unbatchedUpdates(function(){Z.updateContainer(b,g,a,e)})}return Z.getPublicRootInstance(f)}function Qg(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;Ng(b)?void 0:E(\"200\");return pf(a,b,null,c)}\nfunction Rg(a,b){this._reactRootContainer=Z.createContainer(a,b)}Rg.prototype.render=function(a,b){Z.updateContainer(a,this._reactRootContainer,null,b)};Rg.prototype.unmount=function(a){Z.updateContainer(null,this._reactRootContainer,null,a)};\nvar Sg={createPortal:Qg,findDOMNode:function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(b)return Z.findHostInstance(b);\"function\"===typeof a.render?E(\"188\"):E(\"213\",Object.keys(a))},hydrate:function(a,b,c){return Pg(null,a,b,!0,c)},render:function(a,b,c){return Pg(null,a,b,!1,c)},unstable_renderSubtreeIntoContainer:function(a,b,c,d){null==a||void 0===a._reactInternalFiber?E(\"38\"):void 0;return Pg(a,b,c,!1,d)},unmountComponentAtNode:function(a){Ng(a)?void 0:\nE(\"40\");return a._reactRootContainer?(Z.unbatchedUpdates(function(){Pg(null,null,a,!1,function(){a._reactRootContainer=null})}),!0):!1},unstable_createPortal:Qg,unstable_batchedUpdates:tc,unstable_deferredUpdates:Z.deferredUpdates,flushSync:Z.flushSync,__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:{EventPluginHub:mb,EventPluginRegistry:Va,EventPropagators:Cb,ReactControlledComponent:qc,ReactDOMComponentTree:sb,ReactDOMEventListener:xd}};\nZ.injectIntoDevTools({findFiberByHostInstance:pb,bundleType:0,version:\"16.2.0\",rendererPackageName:\"react-dom\"});var Tg=Object.freeze({default:Sg}),Ug=Tg&&Sg||Tg;module.exports=Ug[\"default\"]?Ug[\"default\"]:Ug;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2Nqcy9yZWFjdC1kb20ucHJvZHVjdGlvbi5taW4uanM/ZmNlMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjIuMFxuICogcmVhY3QtZG9tLnByb2R1Y3Rpb24ubWluLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuLypcbiBNb2Rlcm5penIgMy4wLjBwcmUgKEN1c3RvbSBCdWlsZCkgfCBNSVRcbiovXG4ndXNlIHN0cmljdCc7dmFyIGFhPXJlcXVpcmUoXCJyZWFjdFwiKSxsPXJlcXVpcmUoXCJmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudFwiKSxCPXJlcXVpcmUoXCJvYmplY3QtYXNzaWduXCIpLEM9cmVxdWlyZShcImZianMvbGliL2VtcHR5RnVuY3Rpb25cIiksYmE9cmVxdWlyZShcImZianMvbGliL0V2ZW50TGlzdGVuZXJcIiksZGE9cmVxdWlyZShcImZianMvbGliL2dldEFjdGl2ZUVsZW1lbnRcIiksZWE9cmVxdWlyZShcImZianMvbGliL3NoYWxsb3dFcXVhbFwiKSxmYT1yZXF1aXJlKFwiZmJqcy9saWIvY29udGFpbnNOb2RlXCIpLGlhPXJlcXVpcmUoXCJmYmpzL2xpYi9mb2N1c05vZGVcIiksRD1yZXF1aXJlKFwiZmJqcy9saWIvZW1wdHlPYmplY3RcIik7XG5mdW5jdGlvbiBFKGEpe2Zvcih2YXIgYj1hcmd1bWVudHMubGVuZ3RoLTEsYz1cIk1pbmlmaWVkIFJlYWN0IGVycm9yICNcIithK1wiOyB2aXNpdCBodHRwOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvZXJyb3ItZGVjb2Rlci5odG1sP2ludmFyaWFudFxceDNkXCIrYSxkPTA7ZDxiO2QrKyljKz1cIlxceDI2YXJnc1tdXFx4M2RcIitlbmNvZGVVUklDb21wb25lbnQoYXJndW1lbnRzW2QrMV0pO2I9RXJyb3IoYytcIiBmb3IgdGhlIGZ1bGwgbWVzc2FnZSBvciB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgZm9yIGZ1bGwgZXJyb3JzIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuXCIpO2IubmFtZT1cIkludmFyaWFudCBWaW9sYXRpb25cIjtiLmZyYW1lc1RvUG9wPTE7dGhyb3cgYjt9YWE/dm9pZCAwOkUoXCIyMjdcIik7XG52YXIgb2E9e2NoaWxkcmVuOiEwLGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiEwLGRlZmF1bHRWYWx1ZTohMCxkZWZhdWx0Q2hlY2tlZDohMCxpbm5lckhUTUw6ITAsc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nOiEwLHN1cHByZXNzSHlkcmF0aW9uV2FybmluZzohMCxzdHlsZTohMH07ZnVuY3Rpb24gcGEoYSxiKXtyZXR1cm4oYSZiKT09PWJ9XG52YXIgdGE9e01VU1RfVVNFX1BST1BFUlRZOjEsSEFTX0JPT0xFQU5fVkFMVUU6NCxIQVNfTlVNRVJJQ19WQUxVRTo4LEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFOjI0LEhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUU6MzIsSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFOjY0LGluamVjdERPTVByb3BlcnR5Q29uZmlnOmZ1bmN0aW9uKGEpe3ZhciBiPXRhLGM9YS5Qcm9wZXJ0aWVzfHx7fSxkPWEuRE9NQXR0cmlidXRlTmFtZXNwYWNlc3x8e30sZT1hLkRPTUF0dHJpYnV0ZU5hbWVzfHx7fTthPWEuRE9NTXV0YXRpb25NZXRob2RzfHx7fTtmb3IodmFyIGYgaW4gYyl7dWEuaGFzT3duUHJvcGVydHkoZik/RShcIjQ4XCIsZik6dm9pZCAwO3ZhciBnPWYudG9Mb3dlckNhc2UoKSxoPWNbZl07Zz17YXR0cmlidXRlTmFtZTpnLGF0dHJpYnV0ZU5hbWVzcGFjZTpudWxsLHByb3BlcnR5TmFtZTpmLG11dGF0aW9uTWV0aG9kOm51bGwsbXVzdFVzZVByb3BlcnR5OnBhKGgsYi5NVVNUX1VTRV9QUk9QRVJUWSksXG5oYXNCb29sZWFuVmFsdWU6cGEoaCxiLkhBU19CT09MRUFOX1ZBTFVFKSxoYXNOdW1lcmljVmFsdWU6cGEoaCxiLkhBU19OVU1FUklDX1ZBTFVFKSxoYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZTpwYShoLGIuSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUpLGhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWU6cGEoaCxiLkhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUUpLGhhc1N0cmluZ0Jvb2xlYW5WYWx1ZTpwYShoLGIuSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFKX07MT49Zy5oYXNCb29sZWFuVmFsdWUrZy5oYXNOdW1lcmljVmFsdWUrZy5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlP3ZvaWQgMDpFKFwiNTBcIixmKTtlLmhhc093blByb3BlcnR5KGYpJiYoZy5hdHRyaWJ1dGVOYW1lPWVbZl0pO2QuaGFzT3duUHJvcGVydHkoZikmJihnLmF0dHJpYnV0ZU5hbWVzcGFjZT1kW2ZdKTthLmhhc093blByb3BlcnR5KGYpJiYoZy5tdXRhdGlvbk1ldGhvZD1hW2ZdKTt1YVtmXT1nfX19LHVhPXt9O1xuZnVuY3Rpb24gdmEoYSxiKXtpZihvYS5oYXNPd25Qcm9wZXJ0eShhKXx8MjxhLmxlbmd0aCYmKFwib1wiPT09YVswXXx8XCJPXCI9PT1hWzBdKSYmKFwiblwiPT09YVsxXXx8XCJOXCI9PT1hWzFdKSlyZXR1cm4hMTtpZihudWxsPT09YilyZXR1cm4hMDtzd2l0Y2godHlwZW9mIGIpe2Nhc2UgXCJib29sZWFuXCI6cmV0dXJuIG9hLmhhc093blByb3BlcnR5KGEpP2E9ITA6KGI9d2EoYSkpP2E9Yi5oYXNCb29sZWFuVmFsdWV8fGIuaGFzU3RyaW5nQm9vbGVhblZhbHVlfHxiLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWU6KGE9YS50b0xvd2VyQ2FzZSgpLnNsaWNlKDAsNSksYT1cImRhdGEtXCI9PT1hfHxcImFyaWEtXCI9PT1hKSxhO2Nhc2UgXCJ1bmRlZmluZWRcIjpjYXNlIFwibnVtYmVyXCI6Y2FzZSBcInN0cmluZ1wiOmNhc2UgXCJvYmplY3RcIjpyZXR1cm4hMDtkZWZhdWx0OnJldHVybiExfX1mdW5jdGlvbiB3YShhKXtyZXR1cm4gdWEuaGFzT3duUHJvcGVydHkoYSk/dWFbYV06bnVsbH1cbnZhciB4YT10YSx5YT14YS5NVVNUX1VTRV9QUk9QRVJUWSxLPXhhLkhBU19CT09MRUFOX1ZBTFVFLHphPXhhLkhBU19OVU1FUklDX1ZBTFVFLEFhPXhhLkhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLEJhPXhhLkhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUUsQ2E9eGEuSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFLERhPXtQcm9wZXJ0aWVzOnthbGxvd0Z1bGxTY3JlZW46Syxhc3luYzpLLGF1dG9Gb2N1czpLLGF1dG9QbGF5OkssY2FwdHVyZTpCYSxjaGVja2VkOnlhfEssY29sczpBYSxjb250ZW50RWRpdGFibGU6Q2EsY29udHJvbHM6SyxcImRlZmF1bHRcIjpLLGRlZmVyOkssZGlzYWJsZWQ6Syxkb3dubG9hZDpCYSxkcmFnZ2FibGU6Q2EsZm9ybU5vVmFsaWRhdGU6SyxoaWRkZW46Syxsb29wOkssbXVsdGlwbGU6eWF8SyxtdXRlZDp5YXxLLG5vVmFsaWRhdGU6SyxvcGVuOksscGxheXNJbmxpbmU6SyxyZWFkT25seTpLLHJlcXVpcmVkOksscmV2ZXJzZWQ6Syxyb3dzOkFhLHJvd1NwYW46emEsXG5zY29wZWQ6SyxzZWFtbGVzczpLLHNlbGVjdGVkOnlhfEssc2l6ZTpBYSxzdGFydDp6YSxzcGFuOkFhLHNwZWxsQ2hlY2s6Q2Esc3R5bGU6MCx0YWJJbmRleDowLGl0ZW1TY29wZTpLLGFjY2VwdENoYXJzZXQ6MCxjbGFzc05hbWU6MCxodG1sRm9yOjAsaHR0cEVxdWl2OjAsdmFsdWU6Q2F9LERPTUF0dHJpYnV0ZU5hbWVzOnthY2NlcHRDaGFyc2V0OlwiYWNjZXB0LWNoYXJzZXRcIixjbGFzc05hbWU6XCJjbGFzc1wiLGh0bWxGb3I6XCJmb3JcIixodHRwRXF1aXY6XCJodHRwLWVxdWl2XCJ9LERPTU11dGF0aW9uTWV0aG9kczp7dmFsdWU6ZnVuY3Rpb24oYSxiKXtpZihudWxsPT1iKXJldHVybiBhLnJlbW92ZUF0dHJpYnV0ZShcInZhbHVlXCIpO1wibnVtYmVyXCIhPT1hLnR5cGV8fCExPT09YS5oYXNBdHRyaWJ1dGUoXCJ2YWx1ZVwiKT9hLnNldEF0dHJpYnV0ZShcInZhbHVlXCIsXCJcIitiKTphLnZhbGlkaXR5JiYhYS52YWxpZGl0eS5iYWRJbnB1dCYmYS5vd25lckRvY3VtZW50LmFjdGl2ZUVsZW1lbnQhPT1hJiZcbmEuc2V0QXR0cmlidXRlKFwidmFsdWVcIixcIlwiK2IpfX19LEVhPXhhLkhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRSxNPXt4bGluazpcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIix4bWw6XCJodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2VcIn0sR2E9e1Byb3BlcnRpZXM6e2F1dG9SZXZlcnNlOkVhLGV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQ6RWEscHJlc2VydmVBbHBoYTpFYX0sRE9NQXR0cmlidXRlTmFtZXM6e2F1dG9SZXZlcnNlOlwiYXV0b1JldmVyc2VcIixleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkOlwiZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZFwiLHByZXNlcnZlQWxwaGE6XCJwcmVzZXJ2ZUFscGhhXCJ9LERPTUF0dHJpYnV0ZU5hbWVzcGFjZXM6e3hsaW5rQWN0dWF0ZTpNLnhsaW5rLHhsaW5rQXJjcm9sZTpNLnhsaW5rLHhsaW5rSHJlZjpNLnhsaW5rLHhsaW5rUm9sZTpNLnhsaW5rLHhsaW5rU2hvdzpNLnhsaW5rLHhsaW5rVGl0bGU6TS54bGluayx4bGlua1R5cGU6TS54bGluayxcbnhtbEJhc2U6TS54bWwseG1sTGFuZzpNLnhtbCx4bWxTcGFjZTpNLnhtbH19LEhhPS9bXFwtXFw6XShbYS16XSkvZztmdW5jdGlvbiBJYShhKXtyZXR1cm4gYVsxXS50b1VwcGVyQ2FzZSgpfVxuXCJhY2NlbnQtaGVpZ2h0IGFsaWdubWVudC1iYXNlbGluZSBhcmFiaWMtZm9ybSBiYXNlbGluZS1zaGlmdCBjYXAtaGVpZ2h0IGNsaXAtcGF0aCBjbGlwLXJ1bGUgY29sb3ItaW50ZXJwb2xhdGlvbiBjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMgY29sb3ItcHJvZmlsZSBjb2xvci1yZW5kZXJpbmcgZG9taW5hbnQtYmFzZWxpbmUgZW5hYmxlLWJhY2tncm91bmQgZmlsbC1vcGFjaXR5IGZpbGwtcnVsZSBmbG9vZC1jb2xvciBmbG9vZC1vcGFjaXR5IGZvbnQtZmFtaWx5IGZvbnQtc2l6ZSBmb250LXNpemUtYWRqdXN0IGZvbnQtc3RyZXRjaCBmb250LXN0eWxlIGZvbnQtdmFyaWFudCBmb250LXdlaWdodCBnbHlwaC1uYW1lIGdseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWwgZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwgaG9yaXotYWR2LXggaG9yaXotb3JpZ2luLXggaW1hZ2UtcmVuZGVyaW5nIGxldHRlci1zcGFjaW5nIGxpZ2h0aW5nLWNvbG9yIG1hcmtlci1lbmQgbWFya2VyLW1pZCBtYXJrZXItc3RhcnQgb3ZlcmxpbmUtcG9zaXRpb24gb3ZlcmxpbmUtdGhpY2tuZXNzIHBhaW50LW9yZGVyIHBhbm9zZS0xIHBvaW50ZXItZXZlbnRzIHJlbmRlcmluZy1pbnRlbnQgc2hhcGUtcmVuZGVyaW5nIHN0b3AtY29sb3Igc3RvcC1vcGFjaXR5IHN0cmlrZXRocm91Z2gtcG9zaXRpb24gc3RyaWtldGhyb3VnaC10aGlja25lc3Mgc3Ryb2tlLWRhc2hhcnJheSBzdHJva2UtZGFzaG9mZnNldCBzdHJva2UtbGluZWNhcCBzdHJva2UtbGluZWpvaW4gc3Ryb2tlLW1pdGVybGltaXQgc3Ryb2tlLW9wYWNpdHkgc3Ryb2tlLXdpZHRoIHRleHQtYW5jaG9yIHRleHQtZGVjb3JhdGlvbiB0ZXh0LXJlbmRlcmluZyB1bmRlcmxpbmUtcG9zaXRpb24gdW5kZXJsaW5lLXRoaWNrbmVzcyB1bmljb2RlLWJpZGkgdW5pY29kZS1yYW5nZSB1bml0cy1wZXItZW0gdi1hbHBoYWJldGljIHYtaGFuZ2luZyB2LWlkZW9ncmFwaGljIHYtbWF0aGVtYXRpY2FsIHZlY3Rvci1lZmZlY3QgdmVydC1hZHYteSB2ZXJ0LW9yaWdpbi14IHZlcnQtb3JpZ2luLXkgd29yZC1zcGFjaW5nIHdyaXRpbmctbW9kZSB4LWhlaWdodCB4bGluazphY3R1YXRlIHhsaW5rOmFyY3JvbGUgeGxpbms6aHJlZiB4bGluazpyb2xlIHhsaW5rOnNob3cgeGxpbms6dGl0bGUgeGxpbms6dHlwZSB4bWw6YmFzZSB4bWxuczp4bGluayB4bWw6bGFuZyB4bWw6c3BhY2VcIi5zcGxpdChcIiBcIikuZm9yRWFjaChmdW5jdGlvbihhKXt2YXIgYj1hLnJlcGxhY2UoSGEsXG5JYSk7R2EuUHJvcGVydGllc1tiXT0wO0dhLkRPTUF0dHJpYnV0ZU5hbWVzW2JdPWF9KTt4YS5pbmplY3RET01Qcm9wZXJ0eUNvbmZpZyhEYSk7eGEuaW5qZWN0RE9NUHJvcGVydHlDb25maWcoR2EpO1xudmFyIFA9e19jYXVnaHRFcnJvcjpudWxsLF9oYXNDYXVnaHRFcnJvcjohMSxfcmV0aHJvd0Vycm9yOm51bGwsX2hhc1JldGhyb3dFcnJvcjohMSxpbmplY3Rpb246e2luamVjdEVycm9yVXRpbHM6ZnVuY3Rpb24oYSl7XCJmdW5jdGlvblwiIT09dHlwZW9mIGEuaW52b2tlR3VhcmRlZENhbGxiYWNrP0UoXCIxOTdcIik6dm9pZCAwO0phPWEuaW52b2tlR3VhcmRlZENhbGxiYWNrfX0saW52b2tlR3VhcmRlZENhbGxiYWNrOmZ1bmN0aW9uKGEsYixjLGQsZSxmLGcsaCxrKXtKYS5hcHBseShQLGFyZ3VtZW50cyl9LGludm9rZUd1YXJkZWRDYWxsYmFja0FuZENhdGNoRmlyc3RFcnJvcjpmdW5jdGlvbihhLGIsYyxkLGUsZixnLGgsayl7UC5pbnZva2VHdWFyZGVkQ2FsbGJhY2suYXBwbHkodGhpcyxhcmd1bWVudHMpO2lmKFAuaGFzQ2F1Z2h0RXJyb3IoKSl7dmFyIHE9UC5jbGVhckNhdWdodEVycm9yKCk7UC5faGFzUmV0aHJvd0Vycm9yfHwoUC5faGFzUmV0aHJvd0Vycm9yPSEwLFAuX3JldGhyb3dFcnJvcj1cbnEpfX0scmV0aHJvd0NhdWdodEVycm9yOmZ1bmN0aW9uKCl7cmV0dXJuIEthLmFwcGx5KFAsYXJndW1lbnRzKX0saGFzQ2F1Z2h0RXJyb3I6ZnVuY3Rpb24oKXtyZXR1cm4gUC5faGFzQ2F1Z2h0RXJyb3J9LGNsZWFyQ2F1Z2h0RXJyb3I6ZnVuY3Rpb24oKXtpZihQLl9oYXNDYXVnaHRFcnJvcil7dmFyIGE9UC5fY2F1Z2h0RXJyb3I7UC5fY2F1Z2h0RXJyb3I9bnVsbDtQLl9oYXNDYXVnaHRFcnJvcj0hMTtyZXR1cm4gYX1FKFwiMTk4XCIpfX07ZnVuY3Rpb24gSmEoYSxiLGMsZCxlLGYsZyxoLGspe1AuX2hhc0NhdWdodEVycm9yPSExO1AuX2NhdWdodEVycm9yPW51bGw7dmFyIHE9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDMpO3RyeXtiLmFwcGx5KGMscSl9Y2F0Y2godil7UC5fY2F1Z2h0RXJyb3I9dixQLl9oYXNDYXVnaHRFcnJvcj0hMH19XG5mdW5jdGlvbiBLYSgpe2lmKFAuX2hhc1JldGhyb3dFcnJvcil7dmFyIGE9UC5fcmV0aHJvd0Vycm9yO1AuX3JldGhyb3dFcnJvcj1udWxsO1AuX2hhc1JldGhyb3dFcnJvcj0hMTt0aHJvdyBhO319dmFyIExhPW51bGwsTWE9e307XG5mdW5jdGlvbiBOYSgpe2lmKExhKWZvcih2YXIgYSBpbiBNYSl7dmFyIGI9TWFbYV0sYz1MYS5pbmRleE9mKGEpOy0xPGM/dm9pZCAwOkUoXCI5NlwiLGEpO2lmKCFPYVtjXSl7Yi5leHRyYWN0RXZlbnRzP3ZvaWQgMDpFKFwiOTdcIixhKTtPYVtjXT1iO2M9Yi5ldmVudFR5cGVzO2Zvcih2YXIgZCBpbiBjKXt2YXIgZT12b2lkIDA7dmFyIGY9Y1tkXSxnPWIsaD1kO1BhLmhhc093blByb3BlcnR5KGgpP0UoXCI5OVwiLGgpOnZvaWQgMDtQYVtoXT1mO3ZhciBrPWYucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM7aWYoayl7Zm9yKGUgaW4gaylrLmhhc093blByb3BlcnR5KGUpJiZRYShrW2VdLGcsaCk7ZT0hMH1lbHNlIGYucmVnaXN0cmF0aW9uTmFtZT8oUWEoZi5yZWdpc3RyYXRpb25OYW1lLGcsaCksZT0hMCk6ZT0hMTtlP3ZvaWQgMDpFKFwiOThcIixkLGEpfX19fVxuZnVuY3Rpb24gUWEoYSxiLGMpe1JhW2FdP0UoXCIxMDBcIixhKTp2b2lkIDA7UmFbYV09YjtTYVthXT1iLmV2ZW50VHlwZXNbY10uZGVwZW5kZW5jaWVzfXZhciBPYT1bXSxQYT17fSxSYT17fSxTYT17fTtmdW5jdGlvbiBUYShhKXtMYT9FKFwiMTAxXCIpOnZvaWQgMDtMYT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhKTtOYSgpfWZ1bmN0aW9uIFVhKGEpe3ZhciBiPSExLGM7Zm9yKGMgaW4gYSlpZihhLmhhc093blByb3BlcnR5KGMpKXt2YXIgZD1hW2NdO01hLmhhc093blByb3BlcnR5KGMpJiZNYVtjXT09PWR8fChNYVtjXT9FKFwiMTAyXCIsYyk6dm9pZCAwLE1hW2NdPWQsYj0hMCl9YiYmTmEoKX1cbnZhciBWYT1PYmplY3QuZnJlZXplKHtwbHVnaW5zOk9hLGV2ZW50TmFtZURpc3BhdGNoQ29uZmlnczpQYSxyZWdpc3RyYXRpb25OYW1lTW9kdWxlczpSYSxyZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzOlNhLHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXM6bnVsbCxpbmplY3RFdmVudFBsdWdpbk9yZGVyOlRhLGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZTpVYX0pLFdhPW51bGwsWGE9bnVsbCxZYT1udWxsO2Z1bmN0aW9uIFphKGEsYixjLGQpe2I9YS50eXBlfHxcInVua25vd24tZXZlbnRcIjthLmN1cnJlbnRUYXJnZXQ9WWEoZCk7UC5pbnZva2VHdWFyZGVkQ2FsbGJhY2tBbmRDYXRjaEZpcnN0RXJyb3IoYixjLHZvaWQgMCxhKTthLmN1cnJlbnRUYXJnZXQ9bnVsbH1cbmZ1bmN0aW9uICRhKGEsYil7bnVsbD09Yj9FKFwiMzBcIik6dm9pZCAwO2lmKG51bGw9PWEpcmV0dXJuIGI7aWYoQXJyYXkuaXNBcnJheShhKSl7aWYoQXJyYXkuaXNBcnJheShiKSlyZXR1cm4gYS5wdXNoLmFwcGx5KGEsYiksYTthLnB1c2goYik7cmV0dXJuIGF9cmV0dXJuIEFycmF5LmlzQXJyYXkoYik/W2FdLmNvbmNhdChiKTpbYSxiXX1mdW5jdGlvbiBhYihhLGIsYyl7QXJyYXkuaXNBcnJheShhKT9hLmZvckVhY2goYixjKTphJiZiLmNhbGwoYyxhKX12YXIgYmI9bnVsbDtcbmZ1bmN0aW9uIGNiKGEsYil7aWYoYSl7dmFyIGM9YS5fZGlzcGF0Y2hMaXN0ZW5lcnMsZD1hLl9kaXNwYXRjaEluc3RhbmNlcztpZihBcnJheS5pc0FycmF5KGMpKWZvcih2YXIgZT0wO2U8Yy5sZW5ndGgmJiFhLmlzUHJvcGFnYXRpb25TdG9wcGVkKCk7ZSsrKVphKGEsYixjW2VdLGRbZV0pO2Vsc2UgYyYmWmEoYSxiLGMsZCk7YS5fZGlzcGF0Y2hMaXN0ZW5lcnM9bnVsbDthLl9kaXNwYXRjaEluc3RhbmNlcz1udWxsO2EuaXNQZXJzaXN0ZW50KCl8fGEuY29uc3RydWN0b3IucmVsZWFzZShhKX19ZnVuY3Rpb24gZGIoYSl7cmV0dXJuIGNiKGEsITApfWZ1bmN0aW9uIGdiKGEpe3JldHVybiBjYihhLCExKX12YXIgaGI9e2luamVjdEV2ZW50UGx1Z2luT3JkZXI6VGEsaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lOlVhfTtcbmZ1bmN0aW9uIGliKGEsYil7dmFyIGM9YS5zdGF0ZU5vZGU7aWYoIWMpcmV0dXJuIG51bGw7dmFyIGQ9V2EoYyk7aWYoIWQpcmV0dXJuIG51bGw7Yz1kW2JdO2E6c3dpdGNoKGIpe2Nhc2UgXCJvbkNsaWNrXCI6Y2FzZSBcIm9uQ2xpY2tDYXB0dXJlXCI6Y2FzZSBcIm9uRG91YmxlQ2xpY2tcIjpjYXNlIFwib25Eb3VibGVDbGlja0NhcHR1cmVcIjpjYXNlIFwib25Nb3VzZURvd25cIjpjYXNlIFwib25Nb3VzZURvd25DYXB0dXJlXCI6Y2FzZSBcIm9uTW91c2VNb3ZlXCI6Y2FzZSBcIm9uTW91c2VNb3ZlQ2FwdHVyZVwiOmNhc2UgXCJvbk1vdXNlVXBcIjpjYXNlIFwib25Nb3VzZVVwQ2FwdHVyZVwiOihkPSFkLmRpc2FibGVkKXx8KGE9YS50eXBlLGQ9IShcImJ1dHRvblwiPT09YXx8XCJpbnB1dFwiPT09YXx8XCJzZWxlY3RcIj09PWF8fFwidGV4dGFyZWFcIj09PWEpKTthPSFkO2JyZWFrIGE7ZGVmYXVsdDphPSExfWlmKGEpcmV0dXJuIG51bGw7YyYmXCJmdW5jdGlvblwiIT09dHlwZW9mIGM/RShcIjIzMVwiLGIsdHlwZW9mIGMpOnZvaWQgMDtcbnJldHVybiBjfWZ1bmN0aW9uIGpiKGEsYixjLGQpe2Zvcih2YXIgZSxmPTA7ZjxPYS5sZW5ndGg7ZisrKXt2YXIgZz1PYVtmXTtnJiYoZz1nLmV4dHJhY3RFdmVudHMoYSxiLGMsZCkpJiYoZT0kYShlLGcpKX1yZXR1cm4gZX1mdW5jdGlvbiBrYihhKXthJiYoYmI9JGEoYmIsYSkpfWZ1bmN0aW9uIGxiKGEpe3ZhciBiPWJiO2JiPW51bGw7YiYmKGE/YWIoYixkYik6YWIoYixnYiksYmI/RShcIjk1XCIpOnZvaWQgMCxQLnJldGhyb3dDYXVnaHRFcnJvcigpKX12YXIgbWI9T2JqZWN0LmZyZWV6ZSh7aW5qZWN0aW9uOmhiLGdldExpc3RlbmVyOmliLGV4dHJhY3RFdmVudHM6amIsZW5xdWV1ZUV2ZW50czprYixwcm9jZXNzRXZlbnRRdWV1ZTpsYn0pLG5iPU1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpLFE9XCJfX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSRcIituYixvYj1cIl9fcmVhY3RFdmVudEhhbmRsZXJzJFwiK25iO1xuZnVuY3Rpb24gcGIoYSl7aWYoYVtRXSlyZXR1cm4gYVtRXTtmb3IodmFyIGI9W107IWFbUV07KWlmKGIucHVzaChhKSxhLnBhcmVudE5vZGUpYT1hLnBhcmVudE5vZGU7ZWxzZSByZXR1cm4gbnVsbDt2YXIgYz12b2lkIDAsZD1hW1FdO2lmKDU9PT1kLnRhZ3x8Nj09PWQudGFnKXJldHVybiBkO2Zvcig7YSYmKGQ9YVtRXSk7YT1iLnBvcCgpKWM9ZDtyZXR1cm4gY31mdW5jdGlvbiBxYihhKXtpZig1PT09YS50YWd8fDY9PT1hLnRhZylyZXR1cm4gYS5zdGF0ZU5vZGU7RShcIjMzXCIpfWZ1bmN0aW9uIHJiKGEpe3JldHVybiBhW29iXXx8bnVsbH1cbnZhciBzYj1PYmplY3QuZnJlZXplKHtwcmVjYWNoZUZpYmVyTm9kZTpmdW5jdGlvbihhLGIpe2JbUV09YX0sZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGU6cGIsZ2V0SW5zdGFuY2VGcm9tTm9kZTpmdW5jdGlvbihhKXthPWFbUV07cmV0dXJuIWF8fDUhPT1hLnRhZyYmNiE9PWEudGFnP251bGw6YX0sZ2V0Tm9kZUZyb21JbnN0YW5jZTpxYixnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlOnJiLHVwZGF0ZUZpYmVyUHJvcHM6ZnVuY3Rpb24oYSxiKXthW29iXT1ifX0pO2Z1bmN0aW9uIHRiKGEpe2RvIGE9YVtcInJldHVyblwiXTt3aGlsZShhJiY1IT09YS50YWcpO3JldHVybiBhP2E6bnVsbH1mdW5jdGlvbiB1YihhLGIsYyl7Zm9yKHZhciBkPVtdO2E7KWQucHVzaChhKSxhPXRiKGEpO2ZvcihhPWQubGVuZ3RoOzA8YS0tOyliKGRbYV0sXCJjYXB0dXJlZFwiLGMpO2ZvcihhPTA7YTxkLmxlbmd0aDthKyspYihkW2FdLFwiYnViYmxlZFwiLGMpfVxuZnVuY3Rpb24gdmIoYSxiLGMpe2lmKGI9aWIoYSxjLmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzW2JdKSljLl9kaXNwYXRjaExpc3RlbmVycz0kYShjLl9kaXNwYXRjaExpc3RlbmVycyxiKSxjLl9kaXNwYXRjaEluc3RhbmNlcz0kYShjLl9kaXNwYXRjaEluc3RhbmNlcyxhKX1mdW5jdGlvbiB3YihhKXthJiZhLmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzJiZ1YihhLl90YXJnZXRJbnN0LHZiLGEpfWZ1bmN0aW9uIHhiKGEpe2lmKGEmJmEuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpe3ZhciBiPWEuX3RhcmdldEluc3Q7Yj1iP3RiKGIpOm51bGw7dWIoYix2YixhKX19XG5mdW5jdGlvbiB5YihhLGIsYyl7YSYmYyYmYy5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lJiYoYj1pYihhLGMuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkpJiYoYy5fZGlzcGF0Y2hMaXN0ZW5lcnM9JGEoYy5fZGlzcGF0Y2hMaXN0ZW5lcnMsYiksYy5fZGlzcGF0Y2hJbnN0YW5jZXM9JGEoYy5fZGlzcGF0Y2hJbnN0YW5jZXMsYSkpfWZ1bmN0aW9uIHpiKGEpe2EmJmEuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSYmeWIoYS5fdGFyZ2V0SW5zdCxudWxsLGEpfWZ1bmN0aW9uIEFiKGEpe2FiKGEsd2IpfVxuZnVuY3Rpb24gQmIoYSxiLGMsZCl7aWYoYyYmZClhOnt2YXIgZT1jO2Zvcih2YXIgZj1kLGc9MCxoPWU7aDtoPXRiKGgpKWcrKztoPTA7Zm9yKHZhciBrPWY7aztrPXRiKGspKWgrKztmb3IoOzA8Zy1oOyllPXRiKGUpLGctLTtmb3IoOzA8aC1nOylmPXRiKGYpLGgtLTtmb3IoO2ctLTspe2lmKGU9PT1mfHxlPT09Zi5hbHRlcm5hdGUpYnJlYWsgYTtlPXRiKGUpO2Y9dGIoZil9ZT1udWxsfWVsc2UgZT1udWxsO2Y9ZTtmb3IoZT1bXTtjJiZjIT09Zjspe2c9Yy5hbHRlcm5hdGU7aWYobnVsbCE9PWcmJmc9PT1mKWJyZWFrO2UucHVzaChjKTtjPXRiKGMpfWZvcihjPVtdO2QmJmQhPT1mOyl7Zz1kLmFsdGVybmF0ZTtpZihudWxsIT09ZyYmZz09PWYpYnJlYWs7Yy5wdXNoKGQpO2Q9dGIoZCl9Zm9yKGQ9MDtkPGUubGVuZ3RoO2QrKyl5YihlW2RdLFwiYnViYmxlZFwiLGEpO2ZvcihhPWMubGVuZ3RoOzA8YS0tOyl5YihjW2FdLFwiY2FwdHVyZWRcIixiKX1cbnZhciBDYj1PYmplY3QuZnJlZXplKHthY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzOkFiLGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0OmZ1bmN0aW9uKGEpe2FiKGEseGIpfSxhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXM6QmIsYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXM6ZnVuY3Rpb24oYSl7YWIoYSx6Yil9fSksRGI9bnVsbDtmdW5jdGlvbiBFYigpeyFEYiYmbC5jYW5Vc2VET00mJihEYj1cInRleHRDb250ZW50XCJpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ/XCJ0ZXh0Q29udGVudFwiOlwiaW5uZXJUZXh0XCIpO3JldHVybiBEYn12YXIgUz17X3Jvb3Q6bnVsbCxfc3RhcnRUZXh0Om51bGwsX2ZhbGxiYWNrVGV4dDpudWxsfTtcbmZ1bmN0aW9uIEZiKCl7aWYoUy5fZmFsbGJhY2tUZXh0KXJldHVybiBTLl9mYWxsYmFja1RleHQ7dmFyIGEsYj1TLl9zdGFydFRleHQsYz1iLmxlbmd0aCxkLGU9R2IoKSxmPWUubGVuZ3RoO2ZvcihhPTA7YTxjJiZiW2FdPT09ZVthXTthKyspO3ZhciBnPWMtYTtmb3IoZD0xO2Q8PWcmJmJbYy1kXT09PWVbZi1kXTtkKyspO1MuX2ZhbGxiYWNrVGV4dD1lLnNsaWNlKGEsMTxkPzEtZDp2b2lkIDApO3JldHVybiBTLl9mYWxsYmFja1RleHR9ZnVuY3Rpb24gR2IoKXtyZXR1cm5cInZhbHVlXCJpbiBTLl9yb290P1MuX3Jvb3QudmFsdWU6Uy5fcm9vdFtFYigpXX1cbnZhciBIYj1cImRpc3BhdGNoQ29uZmlnIF90YXJnZXRJbnN0IG5hdGl2ZUV2ZW50IGlzRGVmYXVsdFByZXZlbnRlZCBpc1Byb3BhZ2F0aW9uU3RvcHBlZCBfZGlzcGF0Y2hMaXN0ZW5lcnMgX2Rpc3BhdGNoSW5zdGFuY2VzXCIuc3BsaXQoXCIgXCIpLEliPXt0eXBlOm51bGwsdGFyZ2V0Om51bGwsY3VycmVudFRhcmdldDpDLnRoYXRSZXR1cm5zTnVsbCxldmVudFBoYXNlOm51bGwsYnViYmxlczpudWxsLGNhbmNlbGFibGU6bnVsbCx0aW1lU3RhbXA6ZnVuY3Rpb24oYSl7cmV0dXJuIGEudGltZVN0YW1wfHxEYXRlLm5vdygpfSxkZWZhdWx0UHJldmVudGVkOm51bGwsaXNUcnVzdGVkOm51bGx9O1xuZnVuY3Rpb24gVChhLGIsYyxkKXt0aGlzLmRpc3BhdGNoQ29uZmlnPWE7dGhpcy5fdGFyZ2V0SW5zdD1iO3RoaXMubmF0aXZlRXZlbnQ9YzthPXRoaXMuY29uc3RydWN0b3IuSW50ZXJmYWNlO2Zvcih2YXIgZSBpbiBhKWEuaGFzT3duUHJvcGVydHkoZSkmJigoYj1hW2VdKT90aGlzW2VdPWIoYyk6XCJ0YXJnZXRcIj09PWU/dGhpcy50YXJnZXQ9ZDp0aGlzW2VdPWNbZV0pO3RoaXMuaXNEZWZhdWx0UHJldmVudGVkPShudWxsIT1jLmRlZmF1bHRQcmV2ZW50ZWQ/Yy5kZWZhdWx0UHJldmVudGVkOiExPT09Yy5yZXR1cm5WYWx1ZSk/Qy50aGF0UmV0dXJuc1RydWU6Qy50aGF0UmV0dXJuc0ZhbHNlO3RoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQ9Qy50aGF0UmV0dXJuc0ZhbHNlO3JldHVybiB0aGlzfVxuQihULnByb3RvdHlwZSx7cHJldmVudERlZmF1bHQ6ZnVuY3Rpb24oKXt0aGlzLmRlZmF1bHRQcmV2ZW50ZWQ9ITA7dmFyIGE9dGhpcy5uYXRpdmVFdmVudDthJiYoYS5wcmV2ZW50RGVmYXVsdD9hLnByZXZlbnREZWZhdWx0KCk6XCJ1bmtub3duXCIhPT10eXBlb2YgYS5yZXR1cm5WYWx1ZSYmKGEucmV0dXJuVmFsdWU9ITEpLHRoaXMuaXNEZWZhdWx0UHJldmVudGVkPUMudGhhdFJldHVybnNUcnVlKX0sc3RvcFByb3BhZ2F0aW9uOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5uYXRpdmVFdmVudDthJiYoYS5zdG9wUHJvcGFnYXRpb24/YS5zdG9wUHJvcGFnYXRpb24oKTpcInVua25vd25cIiE9PXR5cGVvZiBhLmNhbmNlbEJ1YmJsZSYmKGEuY2FuY2VsQnViYmxlPSEwKSx0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkPUMudGhhdFJldHVybnNUcnVlKX0scGVyc2lzdDpmdW5jdGlvbigpe3RoaXMuaXNQZXJzaXN0ZW50PUMudGhhdFJldHVybnNUcnVlfSxpc1BlcnNpc3RlbnQ6Qy50aGF0UmV0dXJuc0ZhbHNlLFxuZGVzdHJ1Y3RvcjpmdW5jdGlvbigpe3ZhciBhPXRoaXMuY29uc3RydWN0b3IuSW50ZXJmYWNlLGI7Zm9yKGIgaW4gYSl0aGlzW2JdPW51bGw7Zm9yKGE9MDthPEhiLmxlbmd0aDthKyspdGhpc1tIYlthXV09bnVsbH19KTtULkludGVyZmFjZT1JYjtULmF1Z21lbnRDbGFzcz1mdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoKXt9Yy5wcm90b3R5cGU9dGhpcy5wcm90b3R5cGU7dmFyIGQ9bmV3IGM7QihkLGEucHJvdG90eXBlKTthLnByb3RvdHlwZT1kO2EucHJvdG90eXBlLmNvbnN0cnVjdG9yPWE7YS5JbnRlcmZhY2U9Qih7fSx0aGlzLkludGVyZmFjZSxiKTthLmF1Z21lbnRDbGFzcz10aGlzLmF1Z21lbnRDbGFzcztKYihhKX07SmIoVCk7ZnVuY3Rpb24gS2IoYSxiLGMsZCl7aWYodGhpcy5ldmVudFBvb2wubGVuZ3RoKXt2YXIgZT10aGlzLmV2ZW50UG9vbC5wb3AoKTt0aGlzLmNhbGwoZSxhLGIsYyxkKTtyZXR1cm4gZX1yZXR1cm4gbmV3IHRoaXMoYSxiLGMsZCl9XG5mdW5jdGlvbiBMYihhKXthIGluc3RhbmNlb2YgdGhpcz92b2lkIDA6RShcIjIyM1wiKTthLmRlc3RydWN0b3IoKTsxMD50aGlzLmV2ZW50UG9vbC5sZW5ndGgmJnRoaXMuZXZlbnRQb29sLnB1c2goYSl9ZnVuY3Rpb24gSmIoYSl7YS5ldmVudFBvb2w9W107YS5nZXRQb29sZWQ9S2I7YS5yZWxlYXNlPUxifWZ1bmN0aW9uIE1iKGEsYixjLGQpe3JldHVybiBULmNhbGwodGhpcyxhLGIsYyxkKX1ULmF1Z21lbnRDbGFzcyhNYix7ZGF0YTpudWxsfSk7ZnVuY3Rpb24gTmIoYSxiLGMsZCl7cmV0dXJuIFQuY2FsbCh0aGlzLGEsYixjLGQpfVQuYXVnbWVudENsYXNzKE5iLHtkYXRhOm51bGx9KTt2YXIgUGI9WzksMTMsMjcsMzJdLFZiPWwuY2FuVXNlRE9NJiZcIkNvbXBvc2l0aW9uRXZlbnRcImluIHdpbmRvdyxXYj1udWxsO2wuY2FuVXNlRE9NJiZcImRvY3VtZW50TW9kZVwiaW4gZG9jdW1lbnQmJihXYj1kb2N1bWVudC5kb2N1bWVudE1vZGUpO3ZhciBYYjtcbmlmKFhiPWwuY2FuVXNlRE9NJiZcIlRleHRFdmVudFwiaW4gd2luZG93JiYhV2Ipe3ZhciBZYj13aW5kb3cub3BlcmE7WGI9IShcIm9iamVjdFwiPT09dHlwZW9mIFliJiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgWWIudmVyc2lvbiYmMTI+PXBhcnNlSW50KFliLnZlcnNpb24oKSwxMCkpfVxudmFyIFpiPVhiLCRiPWwuY2FuVXNlRE9NJiYoIVZifHxXYiYmODxXYiYmMTE+PVdiKSxhYz1TdHJpbmcuZnJvbUNoYXJDb2RlKDMyKSxiYz17YmVmb3JlSW5wdXQ6e3BoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOntidWJibGVkOlwib25CZWZvcmVJbnB1dFwiLGNhcHR1cmVkOlwib25CZWZvcmVJbnB1dENhcHR1cmVcIn0sZGVwZW5kZW5jaWVzOltcInRvcENvbXBvc2l0aW9uRW5kXCIsXCJ0b3BLZXlQcmVzc1wiLFwidG9wVGV4dElucHV0XCIsXCJ0b3BQYXN0ZVwiXX0sY29tcG9zaXRpb25FbmQ6e3BoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOntidWJibGVkOlwib25Db21wb3NpdGlvbkVuZFwiLGNhcHR1cmVkOlwib25Db21wb3NpdGlvbkVuZENhcHR1cmVcIn0sZGVwZW5kZW5jaWVzOlwidG9wQmx1ciB0b3BDb21wb3NpdGlvbkVuZCB0b3BLZXlEb3duIHRvcEtleVByZXNzIHRvcEtleVVwIHRvcE1vdXNlRG93blwiLnNwbGl0KFwiIFwiKX0sY29tcG9zaXRpb25TdGFydDp7cGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6e2J1YmJsZWQ6XCJvbkNvbXBvc2l0aW9uU3RhcnRcIixcbmNhcHR1cmVkOlwib25Db21wb3NpdGlvblN0YXJ0Q2FwdHVyZVwifSxkZXBlbmRlbmNpZXM6XCJ0b3BCbHVyIHRvcENvbXBvc2l0aW9uU3RhcnQgdG9wS2V5RG93biB0b3BLZXlQcmVzcyB0b3BLZXlVcCB0b3BNb3VzZURvd25cIi5zcGxpdChcIiBcIil9LGNvbXBvc2l0aW9uVXBkYXRlOntwaGFzZWRSZWdpc3RyYXRpb25OYW1lczp7YnViYmxlZDpcIm9uQ29tcG9zaXRpb25VcGRhdGVcIixjYXB0dXJlZDpcIm9uQ29tcG9zaXRpb25VcGRhdGVDYXB0dXJlXCJ9LGRlcGVuZGVuY2llczpcInRvcEJsdXIgdG9wQ29tcG9zaXRpb25VcGRhdGUgdG9wS2V5RG93biB0b3BLZXlQcmVzcyB0b3BLZXlVcCB0b3BNb3VzZURvd25cIi5zcGxpdChcIiBcIil9fSxjYz0hMTtcbmZ1bmN0aW9uIGRjKGEsYil7c3dpdGNoKGEpe2Nhc2UgXCJ0b3BLZXlVcFwiOnJldHVybi0xIT09UGIuaW5kZXhPZihiLmtleUNvZGUpO2Nhc2UgXCJ0b3BLZXlEb3duXCI6cmV0dXJuIDIyOSE9PWIua2V5Q29kZTtjYXNlIFwidG9wS2V5UHJlc3NcIjpjYXNlIFwidG9wTW91c2VEb3duXCI6Y2FzZSBcInRvcEJsdXJcIjpyZXR1cm4hMDtkZWZhdWx0OnJldHVybiExfX1mdW5jdGlvbiBlYyhhKXthPWEuZGV0YWlsO3JldHVyblwib2JqZWN0XCI9PT10eXBlb2YgYSYmXCJkYXRhXCJpbiBhP2EuZGF0YTpudWxsfXZhciBmYz0hMTtmdW5jdGlvbiBnYyhhLGIpe3N3aXRjaChhKXtjYXNlIFwidG9wQ29tcG9zaXRpb25FbmRcIjpyZXR1cm4gZWMoYik7Y2FzZSBcInRvcEtleVByZXNzXCI6aWYoMzIhPT1iLndoaWNoKXJldHVybiBudWxsO2NjPSEwO3JldHVybiBhYztjYXNlIFwidG9wVGV4dElucHV0XCI6cmV0dXJuIGE9Yi5kYXRhLGE9PT1hYyYmY2M/bnVsbDphO2RlZmF1bHQ6cmV0dXJuIG51bGx9fVxuZnVuY3Rpb24gaGMoYSxiKXtpZihmYylyZXR1cm5cInRvcENvbXBvc2l0aW9uRW5kXCI9PT1hfHwhVmImJmRjKGEsYik/KGE9RmIoKSxTLl9yb290PW51bGwsUy5fc3RhcnRUZXh0PW51bGwsUy5fZmFsbGJhY2tUZXh0PW51bGwsZmM9ITEsYSk6bnVsbDtzd2l0Y2goYSl7Y2FzZSBcInRvcFBhc3RlXCI6cmV0dXJuIG51bGw7Y2FzZSBcInRvcEtleVByZXNzXCI6aWYoIShiLmN0cmxLZXl8fGIuYWx0S2V5fHxiLm1ldGFLZXkpfHxiLmN0cmxLZXkmJmIuYWx0S2V5KXtpZihiLmNoYXImJjE8Yi5jaGFyLmxlbmd0aClyZXR1cm4gYi5jaGFyO2lmKGIud2hpY2gpcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoYi53aGljaCl9cmV0dXJuIG51bGw7Y2FzZSBcInRvcENvbXBvc2l0aW9uRW5kXCI6cmV0dXJuICRiP251bGw6Yi5kYXRhO2RlZmF1bHQ6cmV0dXJuIG51bGx9fVxudmFyIGljPXtldmVudFR5cGVzOmJjLGV4dHJhY3RFdmVudHM6ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU7aWYoVmIpYjp7c3dpdGNoKGEpe2Nhc2UgXCJ0b3BDb21wb3NpdGlvblN0YXJ0XCI6dmFyIGY9YmMuY29tcG9zaXRpb25TdGFydDticmVhayBiO2Nhc2UgXCJ0b3BDb21wb3NpdGlvbkVuZFwiOmY9YmMuY29tcG9zaXRpb25FbmQ7YnJlYWsgYjtjYXNlIFwidG9wQ29tcG9zaXRpb25VcGRhdGVcIjpmPWJjLmNvbXBvc2l0aW9uVXBkYXRlO2JyZWFrIGJ9Zj12b2lkIDB9ZWxzZSBmYz9kYyhhLGMpJiYoZj1iYy5jb21wb3NpdGlvbkVuZCk6XCJ0b3BLZXlEb3duXCI9PT1hJiYyMjk9PT1jLmtleUNvZGUmJihmPWJjLmNvbXBvc2l0aW9uU3RhcnQpO2Y/KCRiJiYoZmN8fGYhPT1iYy5jb21wb3NpdGlvblN0YXJ0P2Y9PT1iYy5jb21wb3NpdGlvbkVuZCYmZmMmJihlPUZiKCkpOihTLl9yb290PWQsUy5fc3RhcnRUZXh0PUdiKCksZmM9ITApKSxmPU1iLmdldFBvb2xlZChmLGIsYyxkKSxlP2YuZGF0YT1cbmU6KGU9ZWMoYyksbnVsbCE9PWUmJihmLmRhdGE9ZSkpLEFiKGYpLGU9Zik6ZT1udWxsOyhhPVpiP2djKGEsYyk6aGMoYSxjKSk/KGI9TmIuZ2V0UG9vbGVkKGJjLmJlZm9yZUlucHV0LGIsYyxkKSxiLmRhdGE9YSxBYihiKSk6Yj1udWxsO3JldHVybltlLGJdfX0samM9bnVsbCxrYz1udWxsLGxjPW51bGw7ZnVuY3Rpb24gbWMoYSl7aWYoYT1YYShhKSl7amMmJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBqYy5yZXN0b3JlQ29udHJvbGxlZFN0YXRlP3ZvaWQgMDpFKFwiMTk0XCIpO3ZhciBiPVdhKGEuc3RhdGVOb2RlKTtqYy5yZXN0b3JlQ29udHJvbGxlZFN0YXRlKGEuc3RhdGVOb2RlLGEudHlwZSxiKX19dmFyIG5jPXtpbmplY3RGaWJlckNvbnRyb2xsZWRIb3N0Q29tcG9uZW50OmZ1bmN0aW9uKGEpe2pjPWF9fTtmdW5jdGlvbiBvYyhhKXtrYz9sYz9sYy5wdXNoKGEpOmxjPVthXTprYz1hfVxuZnVuY3Rpb24gcGMoKXtpZihrYyl7dmFyIGE9a2MsYj1sYztsYz1rYz1udWxsO21jKGEpO2lmKGIpZm9yKGE9MDthPGIubGVuZ3RoO2ErKyltYyhiW2FdKX19dmFyIHFjPU9iamVjdC5mcmVlemUoe2luamVjdGlvbjpuYyxlbnF1ZXVlU3RhdGVSZXN0b3JlOm9jLHJlc3RvcmVTdGF0ZUlmTmVlZGVkOnBjfSk7ZnVuY3Rpb24gcmMoYSxiKXtyZXR1cm4gYShiKX12YXIgc2M9ITE7ZnVuY3Rpb24gdGMoYSxiKXtpZihzYylyZXR1cm4gcmMoYSxiKTtzYz0hMDt0cnl7cmV0dXJuIHJjKGEsYil9ZmluYWxseXtzYz0hMSxwYygpfX12YXIgdWM9e2NvbG9yOiEwLGRhdGU6ITAsZGF0ZXRpbWU6ITAsXCJkYXRldGltZS1sb2NhbFwiOiEwLGVtYWlsOiEwLG1vbnRoOiEwLG51bWJlcjohMCxwYXNzd29yZDohMCxyYW5nZTohMCxzZWFyY2g6ITAsdGVsOiEwLHRleHQ6ITAsdGltZTohMCx1cmw6ITAsd2VlazohMH07XG5mdW5jdGlvbiB2YyhhKXt2YXIgYj1hJiZhLm5vZGVOYW1lJiZhLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuXCJpbnB1dFwiPT09Yj8hIXVjW2EudHlwZV06XCJ0ZXh0YXJlYVwiPT09Yj8hMDohMX1mdW5jdGlvbiB3YyhhKXthPWEudGFyZ2V0fHxhLnNyY0VsZW1lbnR8fHdpbmRvdzthLmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50JiYoYT1hLmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50KTtyZXR1cm4gMz09PWEubm9kZVR5cGU/YS5wYXJlbnROb2RlOmF9dmFyIHhjO2wuY2FuVXNlRE9NJiYoeGM9ZG9jdW1lbnQuaW1wbGVtZW50YXRpb24mJmRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUmJiEwIT09ZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZShcIlwiLFwiXCIpKTtcbmZ1bmN0aW9uIHljKGEsYil7aWYoIWwuY2FuVXNlRE9NfHxiJiYhKFwiYWRkRXZlbnRMaXN0ZW5lclwiaW4gZG9jdW1lbnQpKXJldHVybiExO2I9XCJvblwiK2E7dmFyIGM9YiBpbiBkb2N1bWVudDtjfHwoYz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLGMuc2V0QXR0cmlidXRlKGIsXCJyZXR1cm47XCIpLGM9XCJmdW5jdGlvblwiPT09dHlwZW9mIGNbYl0pOyFjJiZ4YyYmXCJ3aGVlbFwiPT09YSYmKGM9ZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZShcIkV2ZW50cy53aGVlbFwiLFwiMy4wXCIpKTtyZXR1cm4gY31mdW5jdGlvbiB6YyhhKXt2YXIgYj1hLnR5cGU7cmV0dXJuKGE9YS5ub2RlTmFtZSkmJlwiaW5wdXRcIj09PWEudG9Mb3dlckNhc2UoKSYmKFwiY2hlY2tib3hcIj09PWJ8fFwicmFkaW9cIj09PWIpfVxuZnVuY3Rpb24gQWMoYSl7dmFyIGI9emMoYSk/XCJjaGVja2VkXCI6XCJ2YWx1ZVwiLGM9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihhLmNvbnN0cnVjdG9yLnByb3RvdHlwZSxiKSxkPVwiXCIrYVtiXTtpZighYS5oYXNPd25Qcm9wZXJ0eShiKSYmXCJmdW5jdGlvblwiPT09dHlwZW9mIGMuZ2V0JiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgYy5zZXQpcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLGIse2VudW1lcmFibGU6Yy5lbnVtZXJhYmxlLGNvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYy5nZXQuY2FsbCh0aGlzKX0sc2V0OmZ1bmN0aW9uKGEpe2Q9XCJcIithO2Muc2V0LmNhbGwodGhpcyxhKX19KSx7Z2V0VmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gZH0sc2V0VmFsdWU6ZnVuY3Rpb24oYSl7ZD1cIlwiK2F9LHN0b3BUcmFja2luZzpmdW5jdGlvbigpe2EuX3ZhbHVlVHJhY2tlcj1udWxsO2RlbGV0ZSBhW2JdfX19XG5mdW5jdGlvbiBCYyhhKXthLl92YWx1ZVRyYWNrZXJ8fChhLl92YWx1ZVRyYWNrZXI9QWMoYSkpfWZ1bmN0aW9uIENjKGEpe2lmKCFhKXJldHVybiExO3ZhciBiPWEuX3ZhbHVlVHJhY2tlcjtpZighYilyZXR1cm4hMDt2YXIgYz1iLmdldFZhbHVlKCk7dmFyIGQ9XCJcIjthJiYoZD16YyhhKT9hLmNoZWNrZWQ/XCJ0cnVlXCI6XCJmYWxzZVwiOmEudmFsdWUpO2E9ZDtyZXR1cm4gYSE9PWM/KGIuc2V0VmFsdWUoYSksITApOiExfXZhciBEYz17Y2hhbmdlOntwaGFzZWRSZWdpc3RyYXRpb25OYW1lczp7YnViYmxlZDpcIm9uQ2hhbmdlXCIsY2FwdHVyZWQ6XCJvbkNoYW5nZUNhcHR1cmVcIn0sZGVwZW5kZW5jaWVzOlwidG9wQmx1ciB0b3BDaGFuZ2UgdG9wQ2xpY2sgdG9wRm9jdXMgdG9wSW5wdXQgdG9wS2V5RG93biB0b3BLZXlVcCB0b3BTZWxlY3Rpb25DaGFuZ2VcIi5zcGxpdChcIiBcIil9fTtcbmZ1bmN0aW9uIEVjKGEsYixjKXthPVQuZ2V0UG9vbGVkKERjLmNoYW5nZSxhLGIsYyk7YS50eXBlPVwiY2hhbmdlXCI7b2MoYyk7QWIoYSk7cmV0dXJuIGF9dmFyIEZjPW51bGwsR2M9bnVsbDtmdW5jdGlvbiBIYyhhKXtrYihhKTtsYighMSl9ZnVuY3Rpb24gSWMoYSl7dmFyIGI9cWIoYSk7aWYoQ2MoYikpcmV0dXJuIGF9ZnVuY3Rpb24gSmMoYSxiKXtpZihcInRvcENoYW5nZVwiPT09YSlyZXR1cm4gYn12YXIgS2M9ITE7bC5jYW5Vc2VET00mJihLYz15YyhcImlucHV0XCIpJiYoIWRvY3VtZW50LmRvY3VtZW50TW9kZXx8OTxkb2N1bWVudC5kb2N1bWVudE1vZGUpKTtmdW5jdGlvbiBMYygpe0ZjJiYoRmMuZGV0YWNoRXZlbnQoXCJvbnByb3BlcnR5Y2hhbmdlXCIsTWMpLEdjPUZjPW51bGwpfWZ1bmN0aW9uIE1jKGEpe1widmFsdWVcIj09PWEucHJvcGVydHlOYW1lJiZJYyhHYykmJihhPUVjKEdjLGEsd2MoYSkpLHRjKEhjLGEpKX1cbmZ1bmN0aW9uIE5jKGEsYixjKXtcInRvcEZvY3VzXCI9PT1hPyhMYygpLEZjPWIsR2M9YyxGYy5hdHRhY2hFdmVudChcIm9ucHJvcGVydHljaGFuZ2VcIixNYykpOlwidG9wQmx1clwiPT09YSYmTGMoKX1mdW5jdGlvbiBPYyhhKXtpZihcInRvcFNlbGVjdGlvbkNoYW5nZVwiPT09YXx8XCJ0b3BLZXlVcFwiPT09YXx8XCJ0b3BLZXlEb3duXCI9PT1hKXJldHVybiBJYyhHYyl9ZnVuY3Rpb24gUGMoYSxiKXtpZihcInRvcENsaWNrXCI9PT1hKXJldHVybiBJYyhiKX1mdW5jdGlvbiAkYyhhLGIpe2lmKFwidG9wSW5wdXRcIj09PWF8fFwidG9wQ2hhbmdlXCI9PT1hKXJldHVybiBJYyhiKX1cbnZhciBhZD17ZXZlbnRUeXBlczpEYyxfaXNJbnB1dEV2ZW50U3VwcG9ydGVkOktjLGV4dHJhY3RFdmVudHM6ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9Yj9xYihiKTp3aW5kb3csZj1lLm5vZGVOYW1lJiZlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7aWYoXCJzZWxlY3RcIj09PWZ8fFwiaW5wdXRcIj09PWYmJlwiZmlsZVwiPT09ZS50eXBlKXZhciBnPUpjO2Vsc2UgaWYodmMoZSkpaWYoS2MpZz0kYztlbHNle2c9T2M7dmFyIGg9TmN9ZWxzZSBmPWUubm9kZU5hbWUsIWZ8fFwiaW5wdXRcIiE9PWYudG9Mb3dlckNhc2UoKXx8XCJjaGVja2JveFwiIT09ZS50eXBlJiZcInJhZGlvXCIhPT1lLnR5cGV8fChnPVBjKTtpZihnJiYoZz1nKGEsYikpKXJldHVybiBFYyhnLGMsZCk7aCYmaChhLGUsYik7XCJ0b3BCbHVyXCI9PT1hJiZudWxsIT1iJiYoYT1iLl93cmFwcGVyU3RhdGV8fGUuX3dyYXBwZXJTdGF0ZSkmJmEuY29udHJvbGxlZCYmXCJudW1iZXJcIj09PWUudHlwZSYmKGE9XCJcIitlLnZhbHVlLGUuZ2V0QXR0cmlidXRlKFwidmFsdWVcIikhPT1cbmEmJmUuc2V0QXR0cmlidXRlKFwidmFsdWVcIixhKSl9fTtmdW5jdGlvbiBiZChhLGIsYyxkKXtyZXR1cm4gVC5jYWxsKHRoaXMsYSxiLGMsZCl9VC5hdWdtZW50Q2xhc3MoYmQse3ZpZXc6bnVsbCxkZXRhaWw6bnVsbH0pO3ZhciBjZD17QWx0OlwiYWx0S2V5XCIsQ29udHJvbDpcImN0cmxLZXlcIixNZXRhOlwibWV0YUtleVwiLFNoaWZ0Olwic2hpZnRLZXlcIn07ZnVuY3Rpb24gZGQoYSl7dmFyIGI9dGhpcy5uYXRpdmVFdmVudDtyZXR1cm4gYi5nZXRNb2RpZmllclN0YXRlP2IuZ2V0TW9kaWZpZXJTdGF0ZShhKTooYT1jZFthXSk/ISFiW2FdOiExfWZ1bmN0aW9uIGVkKCl7cmV0dXJuIGRkfWZ1bmN0aW9uIGZkKGEsYixjLGQpe3JldHVybiBULmNhbGwodGhpcyxhLGIsYyxkKX1cbmJkLmF1Z21lbnRDbGFzcyhmZCx7c2NyZWVuWDpudWxsLHNjcmVlblk6bnVsbCxjbGllbnRYOm51bGwsY2xpZW50WTpudWxsLHBhZ2VYOm51bGwscGFnZVk6bnVsbCxjdHJsS2V5Om51bGwsc2hpZnRLZXk6bnVsbCxhbHRLZXk6bnVsbCxtZXRhS2V5Om51bGwsZ2V0TW9kaWZpZXJTdGF0ZTplZCxidXR0b246bnVsbCxidXR0b25zOm51bGwscmVsYXRlZFRhcmdldDpmdW5jdGlvbihhKXtyZXR1cm4gYS5yZWxhdGVkVGFyZ2V0fHwoYS5mcm9tRWxlbWVudD09PWEuc3JjRWxlbWVudD9hLnRvRWxlbWVudDphLmZyb21FbGVtZW50KX19KTtcbnZhciBnZD17bW91c2VFbnRlcjp7cmVnaXN0cmF0aW9uTmFtZTpcIm9uTW91c2VFbnRlclwiLGRlcGVuZGVuY2llczpbXCJ0b3BNb3VzZU91dFwiLFwidG9wTW91c2VPdmVyXCJdfSxtb3VzZUxlYXZlOntyZWdpc3RyYXRpb25OYW1lOlwib25Nb3VzZUxlYXZlXCIsZGVwZW5kZW5jaWVzOltcInRvcE1vdXNlT3V0XCIsXCJ0b3BNb3VzZU92ZXJcIl19fSxoZD17ZXZlbnRUeXBlczpnZCxleHRyYWN0RXZlbnRzOmZ1bmN0aW9uKGEsYixjLGQpe2lmKFwidG9wTW91c2VPdmVyXCI9PT1hJiYoYy5yZWxhdGVkVGFyZ2V0fHxjLmZyb21FbGVtZW50KXx8XCJ0b3BNb3VzZU91dFwiIT09YSYmXCJ0b3BNb3VzZU92ZXJcIiE9PWEpcmV0dXJuIG51bGw7dmFyIGU9ZC53aW5kb3c9PT1kP2Q6KGU9ZC5vd25lckRvY3VtZW50KT9lLmRlZmF1bHRWaWV3fHxlLnBhcmVudFdpbmRvdzp3aW5kb3c7XCJ0b3BNb3VzZU91dFwiPT09YT8oYT1iLGI9KGI9Yy5yZWxhdGVkVGFyZ2V0fHxjLnRvRWxlbWVudCk/cGIoYik6bnVsbCk6YT1udWxsO2lmKGE9PT1cbmIpcmV0dXJuIG51bGw7dmFyIGY9bnVsbD09YT9lOnFiKGEpO2U9bnVsbD09Yj9lOnFiKGIpO3ZhciBnPWZkLmdldFBvb2xlZChnZC5tb3VzZUxlYXZlLGEsYyxkKTtnLnR5cGU9XCJtb3VzZWxlYXZlXCI7Zy50YXJnZXQ9ZjtnLnJlbGF0ZWRUYXJnZXQ9ZTtjPWZkLmdldFBvb2xlZChnZC5tb3VzZUVudGVyLGIsYyxkKTtjLnR5cGU9XCJtb3VzZWVudGVyXCI7Yy50YXJnZXQ9ZTtjLnJlbGF0ZWRUYXJnZXQ9ZjtCYihnLGMsYSxiKTtyZXR1cm5bZyxjXX19LGlkPWFhLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVELlJlYWN0Q3VycmVudE93bmVyO2Z1bmN0aW9uIGpkKGEpe2E9YS50eXBlO3JldHVyblwic3RyaW5nXCI9PT10eXBlb2YgYT9hOlwiZnVuY3Rpb25cIj09PXR5cGVvZiBhP2EuZGlzcGxheU5hbWV8fGEubmFtZTpudWxsfVxuZnVuY3Rpb24ga2QoYSl7dmFyIGI9YTtpZihhLmFsdGVybmF0ZSlmb3IoO2JbXCJyZXR1cm5cIl07KWI9YltcInJldHVyblwiXTtlbHNle2lmKDAhPT0oYi5lZmZlY3RUYWcmMikpcmV0dXJuIDE7Zm9yKDtiW1wicmV0dXJuXCJdOylpZihiPWJbXCJyZXR1cm5cIl0sMCE9PShiLmVmZmVjdFRhZyYyKSlyZXR1cm4gMX1yZXR1cm4gMz09PWIudGFnPzI6M31mdW5jdGlvbiBsZChhKXtyZXR1cm4oYT1hLl9yZWFjdEludGVybmFsRmliZXIpPzI9PT1rZChhKTohMX1mdW5jdGlvbiBtZChhKXsyIT09a2QoYSk/RShcIjE4OFwiKTp2b2lkIDB9XG5mdW5jdGlvbiBuZChhKXt2YXIgYj1hLmFsdGVybmF0ZTtpZighYilyZXR1cm4gYj1rZChhKSwzPT09Yj9FKFwiMTg4XCIpOnZvaWQgMCwxPT09Yj9udWxsOmE7Zm9yKHZhciBjPWEsZD1iOzspe3ZhciBlPWNbXCJyZXR1cm5cIl0sZj1lP2UuYWx0ZXJuYXRlOm51bGw7aWYoIWV8fCFmKWJyZWFrO2lmKGUuY2hpbGQ9PT1mLmNoaWxkKXtmb3IodmFyIGc9ZS5jaGlsZDtnOyl7aWYoZz09PWMpcmV0dXJuIG1kKGUpLGE7aWYoZz09PWQpcmV0dXJuIG1kKGUpLGI7Zz1nLnNpYmxpbmd9RShcIjE4OFwiKX1pZihjW1wicmV0dXJuXCJdIT09ZFtcInJldHVyblwiXSljPWUsZD1mO2Vsc2V7Zz0hMTtmb3IodmFyIGg9ZS5jaGlsZDtoOyl7aWYoaD09PWMpe2c9ITA7Yz1lO2Q9ZjticmVha31pZihoPT09ZCl7Zz0hMDtkPWU7Yz1mO2JyZWFrfWg9aC5zaWJsaW5nfWlmKCFnKXtmb3IoaD1mLmNoaWxkO2g7KXtpZihoPT09Yyl7Zz0hMDtjPWY7ZD1lO2JyZWFrfWlmKGg9PT1kKXtnPSEwO2Q9ZjtjPWU7YnJlYWt9aD1oLnNpYmxpbmd9Zz9cbnZvaWQgMDpFKFwiMTg5XCIpfX1jLmFsdGVybmF0ZSE9PWQ/RShcIjE5MFwiKTp2b2lkIDB9MyE9PWMudGFnP0UoXCIxODhcIik6dm9pZCAwO3JldHVybiBjLnN0YXRlTm9kZS5jdXJyZW50PT09Yz9hOmJ9ZnVuY3Rpb24gb2QoYSl7YT1uZChhKTtpZighYSlyZXR1cm4gbnVsbDtmb3IodmFyIGI9YTs7KXtpZig1PT09Yi50YWd8fDY9PT1iLnRhZylyZXR1cm4gYjtpZihiLmNoaWxkKWIuY2hpbGRbXCJyZXR1cm5cIl09YixiPWIuY2hpbGQ7ZWxzZXtpZihiPT09YSlicmVhaztmb3IoOyFiLnNpYmxpbmc7KXtpZighYltcInJldHVyblwiXXx8YltcInJldHVyblwiXT09PWEpcmV0dXJuIG51bGw7Yj1iW1wicmV0dXJuXCJdfWIuc2libGluZ1tcInJldHVyblwiXT1iW1wicmV0dXJuXCJdO2I9Yi5zaWJsaW5nfX1yZXR1cm4gbnVsbH1cbmZ1bmN0aW9uIHBkKGEpe2E9bmQoYSk7aWYoIWEpcmV0dXJuIG51bGw7Zm9yKHZhciBiPWE7Oyl7aWYoNT09PWIudGFnfHw2PT09Yi50YWcpcmV0dXJuIGI7aWYoYi5jaGlsZCYmNCE9PWIudGFnKWIuY2hpbGRbXCJyZXR1cm5cIl09YixiPWIuY2hpbGQ7ZWxzZXtpZihiPT09YSlicmVhaztmb3IoOyFiLnNpYmxpbmc7KXtpZighYltcInJldHVyblwiXXx8YltcInJldHVyblwiXT09PWEpcmV0dXJuIG51bGw7Yj1iW1wicmV0dXJuXCJdfWIuc2libGluZ1tcInJldHVyblwiXT1iW1wicmV0dXJuXCJdO2I9Yi5zaWJsaW5nfX1yZXR1cm4gbnVsbH12YXIgcWQ9W107XG5mdW5jdGlvbiByZChhKXt2YXIgYj1hLnRhcmdldEluc3Q7ZG97aWYoIWIpe2EuYW5jZXN0b3JzLnB1c2goYik7YnJlYWt9dmFyIGM7Zm9yKGM9YjtjW1wicmV0dXJuXCJdOyljPWNbXCJyZXR1cm5cIl07Yz0zIT09Yy50YWc/bnVsbDpjLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO2lmKCFjKWJyZWFrO2EuYW5jZXN0b3JzLnB1c2goYik7Yj1wYihjKX13aGlsZShiKTtmb3IoYz0wO2M8YS5hbmNlc3RvcnMubGVuZ3RoO2MrKyliPWEuYW5jZXN0b3JzW2NdLHNkKGEudG9wTGV2ZWxUeXBlLGIsYS5uYXRpdmVFdmVudCx3YyhhLm5hdGl2ZUV2ZW50KSl9dmFyIHRkPSEwLHNkPXZvaWQgMDtmdW5jdGlvbiB1ZChhKXt0ZD0hIWF9ZnVuY3Rpb24gVShhLGIsYyl7cmV0dXJuIGM/YmEubGlzdGVuKGMsYix2ZC5iaW5kKG51bGwsYSkpOm51bGx9ZnVuY3Rpb24gd2QoYSxiLGMpe3JldHVybiBjP2JhLmNhcHR1cmUoYyxiLHZkLmJpbmQobnVsbCxhKSk6bnVsbH1cbmZ1bmN0aW9uIHZkKGEsYil7aWYodGQpe3ZhciBjPXdjKGIpO2M9cGIoYyk7bnVsbD09PWN8fFwibnVtYmVyXCIhPT10eXBlb2YgYy50YWd8fDI9PT1rZChjKXx8KGM9bnVsbCk7aWYocWQubGVuZ3RoKXt2YXIgZD1xZC5wb3AoKTtkLnRvcExldmVsVHlwZT1hO2QubmF0aXZlRXZlbnQ9YjtkLnRhcmdldEluc3Q9YzthPWR9ZWxzZSBhPXt0b3BMZXZlbFR5cGU6YSxuYXRpdmVFdmVudDpiLHRhcmdldEluc3Q6YyxhbmNlc3RvcnM6W119O3RyeXt0YyhyZCxhKX1maW5hbGx5e2EudG9wTGV2ZWxUeXBlPW51bGwsYS5uYXRpdmVFdmVudD1udWxsLGEudGFyZ2V0SW5zdD1udWxsLGEuYW5jZXN0b3JzLmxlbmd0aD0wLDEwPnFkLmxlbmd0aCYmcWQucHVzaChhKX19fVxudmFyIHhkPU9iamVjdC5mcmVlemUoe2dldCBfZW5hYmxlZCgpe3JldHVybiB0ZH0sZ2V0IF9oYW5kbGVUb3BMZXZlbCgpe3JldHVybiBzZH0sc2V0SGFuZGxlVG9wTGV2ZWw6ZnVuY3Rpb24oYSl7c2Q9YX0sc2V0RW5hYmxlZDp1ZCxpc0VuYWJsZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGR9LHRyYXBCdWJibGVkRXZlbnQ6VSx0cmFwQ2FwdHVyZWRFdmVudDp3ZCxkaXNwYXRjaEV2ZW50OnZkfSk7ZnVuY3Rpb24geWQoYSxiKXt2YXIgYz17fTtjW2EudG9Mb3dlckNhc2UoKV09Yi50b0xvd2VyQ2FzZSgpO2NbXCJXZWJraXRcIithXT1cIndlYmtpdFwiK2I7Y1tcIk1velwiK2FdPVwibW96XCIrYjtjW1wibXNcIithXT1cIk1TXCIrYjtjW1wiT1wiK2FdPVwib1wiK2IudG9Mb3dlckNhc2UoKTtyZXR1cm4gY31cbnZhciB6ZD17YW5pbWF0aW9uZW5kOnlkKFwiQW5pbWF0aW9uXCIsXCJBbmltYXRpb25FbmRcIiksYW5pbWF0aW9uaXRlcmF0aW9uOnlkKFwiQW5pbWF0aW9uXCIsXCJBbmltYXRpb25JdGVyYXRpb25cIiksYW5pbWF0aW9uc3RhcnQ6eWQoXCJBbmltYXRpb25cIixcIkFuaW1hdGlvblN0YXJ0XCIpLHRyYW5zaXRpb25lbmQ6eWQoXCJUcmFuc2l0aW9uXCIsXCJUcmFuc2l0aW9uRW5kXCIpfSxBZD17fSxCZD17fTtsLmNhblVzZURPTSYmKEJkPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikuc3R5bGUsXCJBbmltYXRpb25FdmVudFwiaW4gd2luZG93fHwoZGVsZXRlIHpkLmFuaW1hdGlvbmVuZC5hbmltYXRpb24sZGVsZXRlIHpkLmFuaW1hdGlvbml0ZXJhdGlvbi5hbmltYXRpb24sZGVsZXRlIHpkLmFuaW1hdGlvbnN0YXJ0LmFuaW1hdGlvbiksXCJUcmFuc2l0aW9uRXZlbnRcImluIHdpbmRvd3x8ZGVsZXRlIHpkLnRyYW5zaXRpb25lbmQudHJhbnNpdGlvbik7XG5mdW5jdGlvbiBDZChhKXtpZihBZFthXSlyZXR1cm4gQWRbYV07aWYoIXpkW2FdKXJldHVybiBhO3ZhciBiPXpkW2FdLGM7Zm9yKGMgaW4gYilpZihiLmhhc093blByb3BlcnR5KGMpJiZjIGluIEJkKXJldHVybiBBZFthXT1iW2NdO3JldHVyblwiXCJ9XG52YXIgRGQ9e3RvcEFib3J0OlwiYWJvcnRcIix0b3BBbmltYXRpb25FbmQ6Q2QoXCJhbmltYXRpb25lbmRcIil8fFwiYW5pbWF0aW9uZW5kXCIsdG9wQW5pbWF0aW9uSXRlcmF0aW9uOkNkKFwiYW5pbWF0aW9uaXRlcmF0aW9uXCIpfHxcImFuaW1hdGlvbml0ZXJhdGlvblwiLHRvcEFuaW1hdGlvblN0YXJ0OkNkKFwiYW5pbWF0aW9uc3RhcnRcIil8fFwiYW5pbWF0aW9uc3RhcnRcIix0b3BCbHVyOlwiYmx1clwiLHRvcENhbmNlbDpcImNhbmNlbFwiLHRvcENhblBsYXk6XCJjYW5wbGF5XCIsdG9wQ2FuUGxheVRocm91Z2g6XCJjYW5wbGF5dGhyb3VnaFwiLHRvcENoYW5nZTpcImNoYW5nZVwiLHRvcENsaWNrOlwiY2xpY2tcIix0b3BDbG9zZTpcImNsb3NlXCIsdG9wQ29tcG9zaXRpb25FbmQ6XCJjb21wb3NpdGlvbmVuZFwiLHRvcENvbXBvc2l0aW9uU3RhcnQ6XCJjb21wb3NpdGlvbnN0YXJ0XCIsdG9wQ29tcG9zaXRpb25VcGRhdGU6XCJjb21wb3NpdGlvbnVwZGF0ZVwiLHRvcENvbnRleHRNZW51OlwiY29udGV4dG1lbnVcIix0b3BDb3B5OlwiY29weVwiLFxudG9wQ3V0OlwiY3V0XCIsdG9wRG91YmxlQ2xpY2s6XCJkYmxjbGlja1wiLHRvcERyYWc6XCJkcmFnXCIsdG9wRHJhZ0VuZDpcImRyYWdlbmRcIix0b3BEcmFnRW50ZXI6XCJkcmFnZW50ZXJcIix0b3BEcmFnRXhpdDpcImRyYWdleGl0XCIsdG9wRHJhZ0xlYXZlOlwiZHJhZ2xlYXZlXCIsdG9wRHJhZ092ZXI6XCJkcmFnb3ZlclwiLHRvcERyYWdTdGFydDpcImRyYWdzdGFydFwiLHRvcERyb3A6XCJkcm9wXCIsdG9wRHVyYXRpb25DaGFuZ2U6XCJkdXJhdGlvbmNoYW5nZVwiLHRvcEVtcHRpZWQ6XCJlbXB0aWVkXCIsdG9wRW5jcnlwdGVkOlwiZW5jcnlwdGVkXCIsdG9wRW5kZWQ6XCJlbmRlZFwiLHRvcEVycm9yOlwiZXJyb3JcIix0b3BGb2N1czpcImZvY3VzXCIsdG9wSW5wdXQ6XCJpbnB1dFwiLHRvcEtleURvd246XCJrZXlkb3duXCIsdG9wS2V5UHJlc3M6XCJrZXlwcmVzc1wiLHRvcEtleVVwOlwia2V5dXBcIix0b3BMb2FkZWREYXRhOlwibG9hZGVkZGF0YVwiLHRvcExvYWQ6XCJsb2FkXCIsdG9wTG9hZGVkTWV0YWRhdGE6XCJsb2FkZWRtZXRhZGF0YVwiLHRvcExvYWRTdGFydDpcImxvYWRzdGFydFwiLFxudG9wTW91c2VEb3duOlwibW91c2Vkb3duXCIsdG9wTW91c2VNb3ZlOlwibW91c2Vtb3ZlXCIsdG9wTW91c2VPdXQ6XCJtb3VzZW91dFwiLHRvcE1vdXNlT3ZlcjpcIm1vdXNlb3ZlclwiLHRvcE1vdXNlVXA6XCJtb3VzZXVwXCIsdG9wUGFzdGU6XCJwYXN0ZVwiLHRvcFBhdXNlOlwicGF1c2VcIix0b3BQbGF5OlwicGxheVwiLHRvcFBsYXlpbmc6XCJwbGF5aW5nXCIsdG9wUHJvZ3Jlc3M6XCJwcm9ncmVzc1wiLHRvcFJhdGVDaGFuZ2U6XCJyYXRlY2hhbmdlXCIsdG9wU2Nyb2xsOlwic2Nyb2xsXCIsdG9wU2Vla2VkOlwic2Vla2VkXCIsdG9wU2Vla2luZzpcInNlZWtpbmdcIix0b3BTZWxlY3Rpb25DaGFuZ2U6XCJzZWxlY3Rpb25jaGFuZ2VcIix0b3BTdGFsbGVkOlwic3RhbGxlZFwiLHRvcFN1c3BlbmQ6XCJzdXNwZW5kXCIsdG9wVGV4dElucHV0OlwidGV4dElucHV0XCIsdG9wVGltZVVwZGF0ZTpcInRpbWV1cGRhdGVcIix0b3BUb2dnbGU6XCJ0b2dnbGVcIix0b3BUb3VjaENhbmNlbDpcInRvdWNoY2FuY2VsXCIsdG9wVG91Y2hFbmQ6XCJ0b3VjaGVuZFwiLHRvcFRvdWNoTW92ZTpcInRvdWNobW92ZVwiLFxudG9wVG91Y2hTdGFydDpcInRvdWNoc3RhcnRcIix0b3BUcmFuc2l0aW9uRW5kOkNkKFwidHJhbnNpdGlvbmVuZFwiKXx8XCJ0cmFuc2l0aW9uZW5kXCIsdG9wVm9sdW1lQ2hhbmdlOlwidm9sdW1lY2hhbmdlXCIsdG9wV2FpdGluZzpcIndhaXRpbmdcIix0b3BXaGVlbDpcIndoZWVsXCJ9LEVkPXt9LEZkPTAsR2Q9XCJfcmVhY3RMaXN0ZW5lcnNJRFwiKyhcIlwiK01hdGgucmFuZG9tKCkpLnNsaWNlKDIpO2Z1bmN0aW9uIEhkKGEpe09iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhLEdkKXx8KGFbR2RdPUZkKyssRWRbYVtHZF1dPXt9KTtyZXR1cm4gRWRbYVtHZF1dfWZ1bmN0aW9uIElkKGEpe2Zvcig7YSYmYS5maXJzdENoaWxkOylhPWEuZmlyc3RDaGlsZDtyZXR1cm4gYX1cbmZ1bmN0aW9uIEpkKGEsYil7dmFyIGM9SWQoYSk7YT0wO2Zvcih2YXIgZDtjOyl7aWYoMz09PWMubm9kZVR5cGUpe2Q9YStjLnRleHRDb250ZW50Lmxlbmd0aDtpZihhPD1iJiZkPj1iKXJldHVybntub2RlOmMsb2Zmc2V0OmItYX07YT1kfWE6e2Zvcig7Yzspe2lmKGMubmV4dFNpYmxpbmcpe2M9Yy5uZXh0U2libGluZzticmVhayBhfWM9Yy5wYXJlbnROb2RlfWM9dm9pZCAwfWM9SWQoYyl9fWZ1bmN0aW9uIEtkKGEpe3ZhciBiPWEmJmEubm9kZU5hbWUmJmEubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtyZXR1cm4gYiYmKFwiaW5wdXRcIj09PWImJlwidGV4dFwiPT09YS50eXBlfHxcInRleHRhcmVhXCI9PT1ifHxcInRydWVcIj09PWEuY29udGVudEVkaXRhYmxlKX1cbnZhciBMZD1sLmNhblVzZURPTSYmXCJkb2N1bWVudE1vZGVcImluIGRvY3VtZW50JiYxMT49ZG9jdW1lbnQuZG9jdW1lbnRNb2RlLE1kPXtzZWxlY3Q6e3BoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOntidWJibGVkOlwib25TZWxlY3RcIixjYXB0dXJlZDpcIm9uU2VsZWN0Q2FwdHVyZVwifSxkZXBlbmRlbmNpZXM6XCJ0b3BCbHVyIHRvcENvbnRleHRNZW51IHRvcEZvY3VzIHRvcEtleURvd24gdG9wS2V5VXAgdG9wTW91c2VEb3duIHRvcE1vdXNlVXAgdG9wU2VsZWN0aW9uQ2hhbmdlXCIuc3BsaXQoXCIgXCIpfX0sTmQ9bnVsbCxPZD1udWxsLFBkPW51bGwsUWQ9ITE7XG5mdW5jdGlvbiBSZChhLGIpe2lmKFFkfHxudWxsPT1OZHx8TmQhPT1kYSgpKXJldHVybiBudWxsO3ZhciBjPU5kO1wic2VsZWN0aW9uU3RhcnRcImluIGMmJktkKGMpP2M9e3N0YXJ0OmMuc2VsZWN0aW9uU3RhcnQsZW5kOmMuc2VsZWN0aW9uRW5kfTp3aW5kb3cuZ2V0U2VsZWN0aW9uPyhjPXdpbmRvdy5nZXRTZWxlY3Rpb24oKSxjPXthbmNob3JOb2RlOmMuYW5jaG9yTm9kZSxhbmNob3JPZmZzZXQ6Yy5hbmNob3JPZmZzZXQsZm9jdXNOb2RlOmMuZm9jdXNOb2RlLGZvY3VzT2Zmc2V0OmMuZm9jdXNPZmZzZXR9KTpjPXZvaWQgMDtyZXR1cm4gUGQmJmVhKFBkLGMpP251bGw6KFBkPWMsYT1ULmdldFBvb2xlZChNZC5zZWxlY3QsT2QsYSxiKSxhLnR5cGU9XCJzZWxlY3RcIixhLnRhcmdldD1OZCxBYihhKSxhKX1cbnZhciBTZD17ZXZlbnRUeXBlczpNZCxleHRyYWN0RXZlbnRzOmZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPWQud2luZG93PT09ZD9kLmRvY3VtZW50Ojk9PT1kLm5vZGVUeXBlP2Q6ZC5vd25lckRvY3VtZW50LGY7aWYoIShmPSFlKSl7YTp7ZT1IZChlKTtmPVNhLm9uU2VsZWN0O2Zvcih2YXIgZz0wO2c8Zi5sZW5ndGg7ZysrKXt2YXIgaD1mW2ddO2lmKCFlLmhhc093blByb3BlcnR5KGgpfHwhZVtoXSl7ZT0hMTticmVhayBhfX1lPSEwfWY9IWV9aWYoZilyZXR1cm4gbnVsbDtlPWI/cWIoYik6d2luZG93O3N3aXRjaChhKXtjYXNlIFwidG9wRm9jdXNcIjppZih2YyhlKXx8XCJ0cnVlXCI9PT1lLmNvbnRlbnRFZGl0YWJsZSlOZD1lLE9kPWIsUGQ9bnVsbDticmVhaztjYXNlIFwidG9wQmx1clwiOlBkPU9kPU5kPW51bGw7YnJlYWs7Y2FzZSBcInRvcE1vdXNlRG93blwiOlFkPSEwO2JyZWFrO2Nhc2UgXCJ0b3BDb250ZXh0TWVudVwiOmNhc2UgXCJ0b3BNb3VzZVVwXCI6cmV0dXJuIFFkPSExLFJkKGMsZCk7Y2FzZSBcInRvcFNlbGVjdGlvbkNoYW5nZVwiOmlmKExkKWJyZWFrO1xuY2FzZSBcInRvcEtleURvd25cIjpjYXNlIFwidG9wS2V5VXBcIjpyZXR1cm4gUmQoYyxkKX1yZXR1cm4gbnVsbH19O2Z1bmN0aW9uIFRkKGEsYixjLGQpe3JldHVybiBULmNhbGwodGhpcyxhLGIsYyxkKX1ULmF1Z21lbnRDbGFzcyhUZCx7YW5pbWF0aW9uTmFtZTpudWxsLGVsYXBzZWRUaW1lOm51bGwscHNldWRvRWxlbWVudDpudWxsfSk7ZnVuY3Rpb24gVWQoYSxiLGMsZCl7cmV0dXJuIFQuY2FsbCh0aGlzLGEsYixjLGQpfVQuYXVnbWVudENsYXNzKFVkLHtjbGlwYm9hcmREYXRhOmZ1bmN0aW9uKGEpe3JldHVyblwiY2xpcGJvYXJkRGF0YVwiaW4gYT9hLmNsaXBib2FyZERhdGE6d2luZG93LmNsaXBib2FyZERhdGF9fSk7ZnVuY3Rpb24gVmQoYSxiLGMsZCl7cmV0dXJuIFQuY2FsbCh0aGlzLGEsYixjLGQpfWJkLmF1Z21lbnRDbGFzcyhWZCx7cmVsYXRlZFRhcmdldDpudWxsfSk7XG5mdW5jdGlvbiBXZChhKXt2YXIgYj1hLmtleUNvZGU7XCJjaGFyQ29kZVwiaW4gYT8oYT1hLmNoYXJDb2RlLDA9PT1hJiYxMz09PWImJihhPTEzKSk6YT1iO3JldHVybiAzMjw9YXx8MTM9PT1hP2E6MH1cbnZhciBYZD17RXNjOlwiRXNjYXBlXCIsU3BhY2ViYXI6XCIgXCIsTGVmdDpcIkFycm93TGVmdFwiLFVwOlwiQXJyb3dVcFwiLFJpZ2h0OlwiQXJyb3dSaWdodFwiLERvd246XCJBcnJvd0Rvd25cIixEZWw6XCJEZWxldGVcIixXaW46XCJPU1wiLE1lbnU6XCJDb250ZXh0TWVudVwiLEFwcHM6XCJDb250ZXh0TWVudVwiLFNjcm9sbDpcIlNjcm9sbExvY2tcIixNb3pQcmludGFibGVLZXk6XCJVbmlkZW50aWZpZWRcIn0sWWQ9ezg6XCJCYWNrc3BhY2VcIiw5OlwiVGFiXCIsMTI6XCJDbGVhclwiLDEzOlwiRW50ZXJcIiwxNjpcIlNoaWZ0XCIsMTc6XCJDb250cm9sXCIsMTg6XCJBbHRcIiwxOTpcIlBhdXNlXCIsMjA6XCJDYXBzTG9ja1wiLDI3OlwiRXNjYXBlXCIsMzI6XCIgXCIsMzM6XCJQYWdlVXBcIiwzNDpcIlBhZ2VEb3duXCIsMzU6XCJFbmRcIiwzNjpcIkhvbWVcIiwzNzpcIkFycm93TGVmdFwiLDM4OlwiQXJyb3dVcFwiLDM5OlwiQXJyb3dSaWdodFwiLDQwOlwiQXJyb3dEb3duXCIsNDU6XCJJbnNlcnRcIiw0NjpcIkRlbGV0ZVwiLDExMjpcIkYxXCIsMTEzOlwiRjJcIiwxMTQ6XCJGM1wiLDExNTpcIkY0XCIsXG4xMTY6XCJGNVwiLDExNzpcIkY2XCIsMTE4OlwiRjdcIiwxMTk6XCJGOFwiLDEyMDpcIkY5XCIsMTIxOlwiRjEwXCIsMTIyOlwiRjExXCIsMTIzOlwiRjEyXCIsMTQ0OlwiTnVtTG9ja1wiLDE0NTpcIlNjcm9sbExvY2tcIiwyMjQ6XCJNZXRhXCJ9O2Z1bmN0aW9uIFpkKGEsYixjLGQpe3JldHVybiBULmNhbGwodGhpcyxhLGIsYyxkKX1cbmJkLmF1Z21lbnRDbGFzcyhaZCx7a2V5OmZ1bmN0aW9uKGEpe2lmKGEua2V5KXt2YXIgYj1YZFthLmtleV18fGEua2V5O2lmKFwiVW5pZGVudGlmaWVkXCIhPT1iKXJldHVybiBifXJldHVyblwia2V5cHJlc3NcIj09PWEudHlwZT8oYT1XZChhKSwxMz09PWE/XCJFbnRlclwiOlN0cmluZy5mcm9tQ2hhckNvZGUoYSkpOlwia2V5ZG93blwiPT09YS50eXBlfHxcImtleXVwXCI9PT1hLnR5cGU/WWRbYS5rZXlDb2RlXXx8XCJVbmlkZW50aWZpZWRcIjpcIlwifSxsb2NhdGlvbjpudWxsLGN0cmxLZXk6bnVsbCxzaGlmdEtleTpudWxsLGFsdEtleTpudWxsLG1ldGFLZXk6bnVsbCxyZXBlYXQ6bnVsbCxsb2NhbGU6bnVsbCxnZXRNb2RpZmllclN0YXRlOmVkLGNoYXJDb2RlOmZ1bmN0aW9uKGEpe3JldHVyblwia2V5cHJlc3NcIj09PWEudHlwZT9XZChhKTowfSxrZXlDb2RlOmZ1bmN0aW9uKGEpe3JldHVyblwia2V5ZG93blwiPT09YS50eXBlfHxcImtleXVwXCI9PT1hLnR5cGU/YS5rZXlDb2RlOjB9LHdoaWNoOmZ1bmN0aW9uKGEpe3JldHVyblwia2V5cHJlc3NcIj09PVxuYS50eXBlP1dkKGEpOlwia2V5ZG93blwiPT09YS50eXBlfHxcImtleXVwXCI9PT1hLnR5cGU/YS5rZXlDb2RlOjB9fSk7ZnVuY3Rpb24gJGQoYSxiLGMsZCl7cmV0dXJuIFQuY2FsbCh0aGlzLGEsYixjLGQpfWZkLmF1Z21lbnRDbGFzcygkZCx7ZGF0YVRyYW5zZmVyOm51bGx9KTtmdW5jdGlvbiBhZShhLGIsYyxkKXtyZXR1cm4gVC5jYWxsKHRoaXMsYSxiLGMsZCl9YmQuYXVnbWVudENsYXNzKGFlLHt0b3VjaGVzOm51bGwsdGFyZ2V0VG91Y2hlczpudWxsLGNoYW5nZWRUb3VjaGVzOm51bGwsYWx0S2V5Om51bGwsbWV0YUtleTpudWxsLGN0cmxLZXk6bnVsbCxzaGlmdEtleTpudWxsLGdldE1vZGlmaWVyU3RhdGU6ZWR9KTtmdW5jdGlvbiBiZShhLGIsYyxkKXtyZXR1cm4gVC5jYWxsKHRoaXMsYSxiLGMsZCl9VC5hdWdtZW50Q2xhc3MoYmUse3Byb3BlcnR5TmFtZTpudWxsLGVsYXBzZWRUaW1lOm51bGwscHNldWRvRWxlbWVudDpudWxsfSk7XG5mdW5jdGlvbiBjZShhLGIsYyxkKXtyZXR1cm4gVC5jYWxsKHRoaXMsYSxiLGMsZCl9ZmQuYXVnbWVudENsYXNzKGNlLHtkZWx0YVg6ZnVuY3Rpb24oYSl7cmV0dXJuXCJkZWx0YVhcImluIGE/YS5kZWx0YVg6XCJ3aGVlbERlbHRhWFwiaW4gYT8tYS53aGVlbERlbHRhWDowfSxkZWx0YVk6ZnVuY3Rpb24oYSl7cmV0dXJuXCJkZWx0YVlcImluIGE/YS5kZWx0YVk6XCJ3aGVlbERlbHRhWVwiaW4gYT8tYS53aGVlbERlbHRhWTpcIndoZWVsRGVsdGFcImluIGE/LWEud2hlZWxEZWx0YTowfSxkZWx0YVo6bnVsbCxkZWx0YU1vZGU6bnVsbH0pO3ZhciBkZT17fSxlZT17fTtcblwiYWJvcnQgYW5pbWF0aW9uRW5kIGFuaW1hdGlvbkl0ZXJhdGlvbiBhbmltYXRpb25TdGFydCBibHVyIGNhbmNlbCBjYW5QbGF5IGNhblBsYXlUaHJvdWdoIGNsaWNrIGNsb3NlIGNvbnRleHRNZW51IGNvcHkgY3V0IGRvdWJsZUNsaWNrIGRyYWcgZHJhZ0VuZCBkcmFnRW50ZXIgZHJhZ0V4aXQgZHJhZ0xlYXZlIGRyYWdPdmVyIGRyYWdTdGFydCBkcm9wIGR1cmF0aW9uQ2hhbmdlIGVtcHRpZWQgZW5jcnlwdGVkIGVuZGVkIGVycm9yIGZvY3VzIGlucHV0IGludmFsaWQga2V5RG93biBrZXlQcmVzcyBrZXlVcCBsb2FkIGxvYWRlZERhdGEgbG9hZGVkTWV0YWRhdGEgbG9hZFN0YXJ0IG1vdXNlRG93biBtb3VzZU1vdmUgbW91c2VPdXQgbW91c2VPdmVyIG1vdXNlVXAgcGFzdGUgcGF1c2UgcGxheSBwbGF5aW5nIHByb2dyZXNzIHJhdGVDaGFuZ2UgcmVzZXQgc2Nyb2xsIHNlZWtlZCBzZWVraW5nIHN0YWxsZWQgc3VibWl0IHN1c3BlbmQgdGltZVVwZGF0ZSB0b2dnbGUgdG91Y2hDYW5jZWwgdG91Y2hFbmQgdG91Y2hNb3ZlIHRvdWNoU3RhcnQgdHJhbnNpdGlvbkVuZCB2b2x1bWVDaGFuZ2Ugd2FpdGluZyB3aGVlbFwiLnNwbGl0KFwiIFwiKS5mb3JFYWNoKGZ1bmN0aW9uKGEpe3ZhciBiPWFbMF0udG9VcHBlckNhc2UoKStcbmEuc2xpY2UoMSksYz1cIm9uXCIrYjtiPVwidG9wXCIrYjtjPXtwaGFzZWRSZWdpc3RyYXRpb25OYW1lczp7YnViYmxlZDpjLGNhcHR1cmVkOmMrXCJDYXB0dXJlXCJ9LGRlcGVuZGVuY2llczpbYl19O2RlW2FdPWM7ZWVbYl09Y30pO1xudmFyIGZlPXtldmVudFR5cGVzOmRlLGV4dHJhY3RFdmVudHM6ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9ZWVbYV07aWYoIWUpcmV0dXJuIG51bGw7c3dpdGNoKGEpe2Nhc2UgXCJ0b3BLZXlQcmVzc1wiOmlmKDA9PT1XZChjKSlyZXR1cm4gbnVsbDtjYXNlIFwidG9wS2V5RG93blwiOmNhc2UgXCJ0b3BLZXlVcFwiOmE9WmQ7YnJlYWs7Y2FzZSBcInRvcEJsdXJcIjpjYXNlIFwidG9wRm9jdXNcIjphPVZkO2JyZWFrO2Nhc2UgXCJ0b3BDbGlja1wiOmlmKDI9PT1jLmJ1dHRvbilyZXR1cm4gbnVsbDtjYXNlIFwidG9wRG91YmxlQ2xpY2tcIjpjYXNlIFwidG9wTW91c2VEb3duXCI6Y2FzZSBcInRvcE1vdXNlTW92ZVwiOmNhc2UgXCJ0b3BNb3VzZVVwXCI6Y2FzZSBcInRvcE1vdXNlT3V0XCI6Y2FzZSBcInRvcE1vdXNlT3ZlclwiOmNhc2UgXCJ0b3BDb250ZXh0TWVudVwiOmE9ZmQ7YnJlYWs7Y2FzZSBcInRvcERyYWdcIjpjYXNlIFwidG9wRHJhZ0VuZFwiOmNhc2UgXCJ0b3BEcmFnRW50ZXJcIjpjYXNlIFwidG9wRHJhZ0V4aXRcIjpjYXNlIFwidG9wRHJhZ0xlYXZlXCI6Y2FzZSBcInRvcERyYWdPdmVyXCI6Y2FzZSBcInRvcERyYWdTdGFydFwiOmNhc2UgXCJ0b3BEcm9wXCI6YT1cbiRkO2JyZWFrO2Nhc2UgXCJ0b3BUb3VjaENhbmNlbFwiOmNhc2UgXCJ0b3BUb3VjaEVuZFwiOmNhc2UgXCJ0b3BUb3VjaE1vdmVcIjpjYXNlIFwidG9wVG91Y2hTdGFydFwiOmE9YWU7YnJlYWs7Y2FzZSBcInRvcEFuaW1hdGlvbkVuZFwiOmNhc2UgXCJ0b3BBbmltYXRpb25JdGVyYXRpb25cIjpjYXNlIFwidG9wQW5pbWF0aW9uU3RhcnRcIjphPVRkO2JyZWFrO2Nhc2UgXCJ0b3BUcmFuc2l0aW9uRW5kXCI6YT1iZTticmVhaztjYXNlIFwidG9wU2Nyb2xsXCI6YT1iZDticmVhaztjYXNlIFwidG9wV2hlZWxcIjphPWNlO2JyZWFrO2Nhc2UgXCJ0b3BDb3B5XCI6Y2FzZSBcInRvcEN1dFwiOmNhc2UgXCJ0b3BQYXN0ZVwiOmE9VWQ7YnJlYWs7ZGVmYXVsdDphPVR9Yj1hLmdldFBvb2xlZChlLGIsYyxkKTtBYihiKTtyZXR1cm4gYn19O3NkPWZ1bmN0aW9uKGEsYixjLGQpe2E9amIoYSxiLGMsZCk7a2IoYSk7bGIoITEpfTtoYi5pbmplY3RFdmVudFBsdWdpbk9yZGVyKFwiUmVzcG9uZGVyRXZlbnRQbHVnaW4gU2ltcGxlRXZlbnRQbHVnaW4gVGFwRXZlbnRQbHVnaW4gRW50ZXJMZWF2ZUV2ZW50UGx1Z2luIENoYW5nZUV2ZW50UGx1Z2luIFNlbGVjdEV2ZW50UGx1Z2luIEJlZm9yZUlucHV0RXZlbnRQbHVnaW5cIi5zcGxpdChcIiBcIikpO1xuV2E9c2IuZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZTtYYT1zYi5nZXRJbnN0YW5jZUZyb21Ob2RlO1lhPXNiLmdldE5vZGVGcm9tSW5zdGFuY2U7aGIuaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lKHtTaW1wbGVFdmVudFBsdWdpbjpmZSxFbnRlckxlYXZlRXZlbnRQbHVnaW46aGQsQ2hhbmdlRXZlbnRQbHVnaW46YWQsU2VsZWN0RXZlbnRQbHVnaW46U2QsQmVmb3JlSW5wdXRFdmVudFBsdWdpbjppY30pO3ZhciBnZT1bXSxoZT0tMTtmdW5jdGlvbiBWKGEpezA+aGV8fChhLmN1cnJlbnQ9Z2VbaGVdLGdlW2hlXT1udWxsLGhlLS0pfWZ1bmN0aW9uIFcoYSxiKXtoZSsrO2dlW2hlXT1hLmN1cnJlbnQ7YS5jdXJyZW50PWJ9bmV3IFNldDt2YXIgaWU9e2N1cnJlbnQ6RH0sWD17Y3VycmVudDohMX0samU9RDtmdW5jdGlvbiBrZShhKXtyZXR1cm4gbGUoYSk/amU6aWUuY3VycmVudH1cbmZ1bmN0aW9uIG1lKGEsYil7dmFyIGM9YS50eXBlLmNvbnRleHRUeXBlcztpZighYylyZXR1cm4gRDt2YXIgZD1hLnN0YXRlTm9kZTtpZihkJiZkLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQ9PT1iKXJldHVybiBkLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWFza2VkQ2hpbGRDb250ZXh0O3ZhciBlPXt9LGY7Zm9yKGYgaW4gYyllW2ZdPWJbZl07ZCYmKGE9YS5zdGF0ZU5vZGUsYS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0PWIsYS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dD1lKTtyZXR1cm4gZX1mdW5jdGlvbiBsZShhKXtyZXR1cm4gMj09PWEudGFnJiZudWxsIT1hLnR5cGUuY2hpbGRDb250ZXh0VHlwZXN9ZnVuY3Rpb24gbmUoYSl7bGUoYSkmJihWKFgsYSksVihpZSxhKSl9XG5mdW5jdGlvbiBvZShhLGIsYyl7bnVsbCE9aWUuY3Vyc29yP0UoXCIxNjhcIik6dm9pZCAwO1coaWUsYixhKTtXKFgsYyxhKX1mdW5jdGlvbiBwZShhLGIpe3ZhciBjPWEuc3RhdGVOb2RlLGQ9YS50eXBlLmNoaWxkQ29udGV4dFR5cGVzO2lmKFwiZnVuY3Rpb25cIiE9PXR5cGVvZiBjLmdldENoaWxkQ29udGV4dClyZXR1cm4gYjtjPWMuZ2V0Q2hpbGRDb250ZXh0KCk7Zm9yKHZhciBlIGluIGMpZSBpbiBkP3ZvaWQgMDpFKFwiMTA4XCIsamQoYSl8fFwiVW5rbm93blwiLGUpO3JldHVybiBCKHt9LGIsYyl9ZnVuY3Rpb24gcWUoYSl7aWYoIWxlKGEpKXJldHVybiExO3ZhciBiPWEuc3RhdGVOb2RlO2I9YiYmYi5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dHx8RDtqZT1pZS5jdXJyZW50O1coaWUsYixhKTtXKFgsWC5jdXJyZW50LGEpO3JldHVybiEwfVxuZnVuY3Rpb24gcmUoYSxiKXt2YXIgYz1hLnN0YXRlTm9kZTtjP3ZvaWQgMDpFKFwiMTY5XCIpO2lmKGIpe3ZhciBkPXBlKGEsamUpO2MuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQ9ZDtWKFgsYSk7VihpZSxhKTtXKGllLGQsYSl9ZWxzZSBWKFgsYSk7VyhYLGIsYSl9XG5mdW5jdGlvbiBZKGEsYixjKXt0aGlzLnRhZz1hO3RoaXMua2V5PWI7dGhpcy5zdGF0ZU5vZGU9dGhpcy50eXBlPW51bGw7dGhpcy5zaWJsaW5nPXRoaXMuY2hpbGQ9dGhpc1tcInJldHVyblwiXT1udWxsO3RoaXMuaW5kZXg9MDt0aGlzLm1lbW9pemVkU3RhdGU9dGhpcy51cGRhdGVRdWV1ZT10aGlzLm1lbW9pemVkUHJvcHM9dGhpcy5wZW5kaW5nUHJvcHM9dGhpcy5yZWY9bnVsbDt0aGlzLmludGVybmFsQ29udGV4dFRhZz1jO3RoaXMuZWZmZWN0VGFnPTA7dGhpcy5sYXN0RWZmZWN0PXRoaXMuZmlyc3RFZmZlY3Q9dGhpcy5uZXh0RWZmZWN0PW51bGw7dGhpcy5leHBpcmF0aW9uVGltZT0wO3RoaXMuYWx0ZXJuYXRlPW51bGx9XG5mdW5jdGlvbiBzZShhLGIsYyl7dmFyIGQ9YS5hbHRlcm5hdGU7bnVsbD09PWQ/KGQ9bmV3IFkoYS50YWcsYS5rZXksYS5pbnRlcm5hbENvbnRleHRUYWcpLGQudHlwZT1hLnR5cGUsZC5zdGF0ZU5vZGU9YS5zdGF0ZU5vZGUsZC5hbHRlcm5hdGU9YSxhLmFsdGVybmF0ZT1kKTooZC5lZmZlY3RUYWc9MCxkLm5leHRFZmZlY3Q9bnVsbCxkLmZpcnN0RWZmZWN0PW51bGwsZC5sYXN0RWZmZWN0PW51bGwpO2QuZXhwaXJhdGlvblRpbWU9YztkLnBlbmRpbmdQcm9wcz1iO2QuY2hpbGQ9YS5jaGlsZDtkLm1lbW9pemVkUHJvcHM9YS5tZW1vaXplZFByb3BzO2QubWVtb2l6ZWRTdGF0ZT1hLm1lbW9pemVkU3RhdGU7ZC51cGRhdGVRdWV1ZT1hLnVwZGF0ZVF1ZXVlO2Quc2libGluZz1hLnNpYmxpbmc7ZC5pbmRleD1hLmluZGV4O2QucmVmPWEucmVmO3JldHVybiBkfVxuZnVuY3Rpb24gdGUoYSxiLGMpe3ZhciBkPXZvaWQgMCxlPWEudHlwZSxmPWEua2V5O1wiZnVuY3Rpb25cIj09PXR5cGVvZiBlPyhkPWUucHJvdG90eXBlJiZlLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50P25ldyBZKDIsZixiKTpuZXcgWSgwLGYsYiksZC50eXBlPWUsZC5wZW5kaW5nUHJvcHM9YS5wcm9wcyk6XCJzdHJpbmdcIj09PXR5cGVvZiBlPyhkPW5ldyBZKDUsZixiKSxkLnR5cGU9ZSxkLnBlbmRpbmdQcm9wcz1hLnByb3BzKTpcIm9iamVjdFwiPT09dHlwZW9mIGUmJm51bGwhPT1lJiZcIm51bWJlclwiPT09dHlwZW9mIGUudGFnPyhkPWUsZC5wZW5kaW5nUHJvcHM9YS5wcm9wcyk6RShcIjEzMFwiLG51bGw9PWU/ZTp0eXBlb2YgZSxcIlwiKTtkLmV4cGlyYXRpb25UaW1lPWM7cmV0dXJuIGR9ZnVuY3Rpb24gdWUoYSxiLGMsZCl7Yj1uZXcgWSgxMCxkLGIpO2IucGVuZGluZ1Byb3BzPWE7Yi5leHBpcmF0aW9uVGltZT1jO3JldHVybiBifVxuZnVuY3Rpb24gdmUoYSxiLGMpe2I9bmV3IFkoNixudWxsLGIpO2IucGVuZGluZ1Byb3BzPWE7Yi5leHBpcmF0aW9uVGltZT1jO3JldHVybiBifWZ1bmN0aW9uIHdlKGEsYixjKXtiPW5ldyBZKDcsYS5rZXksYik7Yi50eXBlPWEuaGFuZGxlcjtiLnBlbmRpbmdQcm9wcz1hO2IuZXhwaXJhdGlvblRpbWU9YztyZXR1cm4gYn1mdW5jdGlvbiB4ZShhLGIsYyl7YT1uZXcgWSg5LG51bGwsYik7YS5leHBpcmF0aW9uVGltZT1jO3JldHVybiBhfWZ1bmN0aW9uIHllKGEsYixjKXtiPW5ldyBZKDQsYS5rZXksYik7Yi5wZW5kaW5nUHJvcHM9YS5jaGlsZHJlbnx8W107Yi5leHBpcmF0aW9uVGltZT1jO2Iuc3RhdGVOb2RlPXtjb250YWluZXJJbmZvOmEuY29udGFpbmVySW5mbyxwZW5kaW5nQ2hpbGRyZW46bnVsbCxpbXBsZW1lbnRhdGlvbjphLmltcGxlbWVudGF0aW9ufTtyZXR1cm4gYn12YXIgemU9bnVsbCxBZT1udWxsO1xuZnVuY3Rpb24gQmUoYSl7cmV0dXJuIGZ1bmN0aW9uKGIpe3RyeXtyZXR1cm4gYShiKX1jYXRjaChjKXt9fX1mdW5jdGlvbiBDZShhKXtpZihcInVuZGVmaW5lZFwiPT09dHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXylyZXR1cm4hMTt2YXIgYj1fX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX187aWYoYi5pc0Rpc2FibGVkfHwhYi5zdXBwb3J0c0ZpYmVyKXJldHVybiEwO3RyeXt2YXIgYz1iLmluamVjdChhKTt6ZT1CZShmdW5jdGlvbihhKXtyZXR1cm4gYi5vbkNvbW1pdEZpYmVyUm9vdChjLGEpfSk7QWU9QmUoZnVuY3Rpb24oYSl7cmV0dXJuIGIub25Db21taXRGaWJlclVubW91bnQoYyxhKX0pfWNhdGNoKGQpe31yZXR1cm4hMH1mdW5jdGlvbiBEZShhKXtcImZ1bmN0aW9uXCI9PT10eXBlb2YgemUmJnplKGEpfWZ1bmN0aW9uIEVlKGEpe1wiZnVuY3Rpb25cIj09PXR5cGVvZiBBZSYmQWUoYSl9XG5mdW5jdGlvbiBGZShhKXtyZXR1cm57YmFzZVN0YXRlOmEsZXhwaXJhdGlvblRpbWU6MCxmaXJzdDpudWxsLGxhc3Q6bnVsbCxjYWxsYmFja0xpc3Q6bnVsbCxoYXNGb3JjZVVwZGF0ZTohMSxpc0luaXRpYWxpemVkOiExfX1mdW5jdGlvbiBHZShhLGIpe251bGw9PT1hLmxhc3Q/YS5maXJzdD1hLmxhc3Q9YjooYS5sYXN0Lm5leHQ9YixhLmxhc3Q9Yik7aWYoMD09PWEuZXhwaXJhdGlvblRpbWV8fGEuZXhwaXJhdGlvblRpbWU+Yi5leHBpcmF0aW9uVGltZSlhLmV4cGlyYXRpb25UaW1lPWIuZXhwaXJhdGlvblRpbWV9XG5mdW5jdGlvbiBIZShhLGIpe3ZhciBjPWEuYWx0ZXJuYXRlLGQ9YS51cGRhdGVRdWV1ZTtudWxsPT09ZCYmKGQ9YS51cGRhdGVRdWV1ZT1GZShudWxsKSk7bnVsbCE9PWM/KGE9Yy51cGRhdGVRdWV1ZSxudWxsPT09YSYmKGE9Yy51cGRhdGVRdWV1ZT1GZShudWxsKSkpOmE9bnVsbDthPWEhPT1kP2E6bnVsbDtudWxsPT09YT9HZShkLGIpOm51bGw9PT1kLmxhc3R8fG51bGw9PT1hLmxhc3Q/KEdlKGQsYiksR2UoYSxiKSk6KEdlKGQsYiksYS5sYXN0PWIpfWZ1bmN0aW9uIEllKGEsYixjLGQpe2E9YS5wYXJ0aWFsU3RhdGU7cmV0dXJuXCJmdW5jdGlvblwiPT09dHlwZW9mIGE/YS5jYWxsKGIsYyxkKTphfVxuZnVuY3Rpb24gSmUoYSxiLGMsZCxlLGYpe251bGwhPT1hJiZhLnVwZGF0ZVF1ZXVlPT09YyYmKGM9Yi51cGRhdGVRdWV1ZT17YmFzZVN0YXRlOmMuYmFzZVN0YXRlLGV4cGlyYXRpb25UaW1lOmMuZXhwaXJhdGlvblRpbWUsZmlyc3Q6Yy5maXJzdCxsYXN0OmMubGFzdCxpc0luaXRpYWxpemVkOmMuaXNJbml0aWFsaXplZCxjYWxsYmFja0xpc3Q6bnVsbCxoYXNGb3JjZVVwZGF0ZTohMX0pO2MuZXhwaXJhdGlvblRpbWU9MDtjLmlzSW5pdGlhbGl6ZWQ/YT1jLmJhc2VTdGF0ZTooYT1jLmJhc2VTdGF0ZT1iLm1lbW9pemVkU3RhdGUsYy5pc0luaXRpYWxpemVkPSEwKTtmb3IodmFyIGc9ITAsaD1jLmZpcnN0LGs9ITE7bnVsbCE9PWg7KXt2YXIgcT1oLmV4cGlyYXRpb25UaW1lO2lmKHE+Zil7dmFyIHY9Yy5leHBpcmF0aW9uVGltZTtpZigwPT09dnx8dj5xKWMuZXhwaXJhdGlvblRpbWU9cTtrfHwoaz0hMCxjLmJhc2VTdGF0ZT1hKX1lbHNle2t8fChjLmZpcnN0PWgubmV4dCxudWxsPT09XG5jLmZpcnN0JiYoYy5sYXN0PW51bGwpKTtpZihoLmlzUmVwbGFjZSlhPUllKGgsZCxhLGUpLGc9ITA7ZWxzZSBpZihxPUllKGgsZCxhLGUpKWE9Zz9CKHt9LGEscSk6QihhLHEpLGc9ITE7aC5pc0ZvcmNlZCYmKGMuaGFzRm9yY2VVcGRhdGU9ITApO251bGwhPT1oLmNhbGxiYWNrJiYocT1jLmNhbGxiYWNrTGlzdCxudWxsPT09cSYmKHE9Yy5jYWxsYmFja0xpc3Q9W10pLHEucHVzaChoKSl9aD1oLm5leHR9bnVsbCE9PWMuY2FsbGJhY2tMaXN0P2IuZWZmZWN0VGFnfD0zMjpudWxsIT09Yy5maXJzdHx8Yy5oYXNGb3JjZVVwZGF0ZXx8KGIudXBkYXRlUXVldWU9bnVsbCk7a3x8KGMuYmFzZVN0YXRlPWEpO3JldHVybiBhfVxuZnVuY3Rpb24gS2UoYSxiKXt2YXIgYz1hLmNhbGxiYWNrTGlzdDtpZihudWxsIT09Yylmb3IoYS5jYWxsYmFja0xpc3Q9bnVsbCxhPTA7YTxjLmxlbmd0aDthKyspe3ZhciBkPWNbYV0sZT1kLmNhbGxiYWNrO2QuY2FsbGJhY2s9bnVsbDtcImZ1bmN0aW9uXCIhPT10eXBlb2YgZT9FKFwiMTkxXCIsZSk6dm9pZCAwO2UuY2FsbChiKX19XG5mdW5jdGlvbiBMZShhLGIsYyxkKXtmdW5jdGlvbiBlKGEsYil7Yi51cGRhdGVyPWY7YS5zdGF0ZU5vZGU9YjtiLl9yZWFjdEludGVybmFsRmliZXI9YX12YXIgZj17aXNNb3VudGVkOmxkLGVucXVldWVTZXRTdGF0ZTpmdW5jdGlvbihjLGQsZSl7Yz1jLl9yZWFjdEludGVybmFsRmliZXI7ZT12b2lkIDA9PT1lP251bGw6ZTt2YXIgZz1iKGMpO0hlKGMse2V4cGlyYXRpb25UaW1lOmcscGFydGlhbFN0YXRlOmQsY2FsbGJhY2s6ZSxpc1JlcGxhY2U6ITEsaXNGb3JjZWQ6ITEsbmV4dENhbGxiYWNrOm51bGwsbmV4dDpudWxsfSk7YShjLGcpfSxlbnF1ZXVlUmVwbGFjZVN0YXRlOmZ1bmN0aW9uKGMsZCxlKXtjPWMuX3JlYWN0SW50ZXJuYWxGaWJlcjtlPXZvaWQgMD09PWU/bnVsbDplO3ZhciBnPWIoYyk7SGUoYyx7ZXhwaXJhdGlvblRpbWU6ZyxwYXJ0aWFsU3RhdGU6ZCxjYWxsYmFjazplLGlzUmVwbGFjZTohMCxpc0ZvcmNlZDohMSxuZXh0Q2FsbGJhY2s6bnVsbCxuZXh0Om51bGx9KTtcbmEoYyxnKX0sZW5xdWV1ZUZvcmNlVXBkYXRlOmZ1bmN0aW9uKGMsZCl7Yz1jLl9yZWFjdEludGVybmFsRmliZXI7ZD12b2lkIDA9PT1kP251bGw6ZDt2YXIgZT1iKGMpO0hlKGMse2V4cGlyYXRpb25UaW1lOmUscGFydGlhbFN0YXRlOm51bGwsY2FsbGJhY2s6ZCxpc1JlcGxhY2U6ITEsaXNGb3JjZWQ6ITAsbmV4dENhbGxiYWNrOm51bGwsbmV4dDpudWxsfSk7YShjLGUpfX07cmV0dXJue2Fkb3B0Q2xhc3NJbnN0YW5jZTplLGNvbnN0cnVjdENsYXNzSW5zdGFuY2U6ZnVuY3Rpb24oYSxiKXt2YXIgYz1hLnR5cGUsZD1rZShhKSxmPTI9PT1hLnRhZyYmbnVsbCE9YS50eXBlLmNvbnRleHRUeXBlcyxnPWY/bWUoYSxkKTpEO2I9bmV3IGMoYixnKTtlKGEsYik7ZiYmKGE9YS5zdGF0ZU5vZGUsYS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0PWQsYS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dD1nKTtyZXR1cm4gYn0sbW91bnRDbGFzc0luc3RhbmNlOmZ1bmN0aW9uKGEsXG5iKXt2YXIgYz1hLmFsdGVybmF0ZSxkPWEuc3RhdGVOb2RlLGU9ZC5zdGF0ZXx8bnVsbCxnPWEucGVuZGluZ1Byb3BzO2c/dm9pZCAwOkUoXCIxNThcIik7dmFyIGg9a2UoYSk7ZC5wcm9wcz1nO2Quc3RhdGU9YS5tZW1vaXplZFN0YXRlPWU7ZC5yZWZzPUQ7ZC5jb250ZXh0PW1lKGEsaCk7bnVsbCE9YS50eXBlJiZudWxsIT1hLnR5cGUucHJvdG90eXBlJiYhMD09PWEudHlwZS5wcm90b3R5cGUudW5zdGFibGVfaXNBc3luY1JlYWN0Q29tcG9uZW50JiYoYS5pbnRlcm5hbENvbnRleHRUYWd8PTEpO1wiZnVuY3Rpb25cIj09PXR5cGVvZiBkLmNvbXBvbmVudFdpbGxNb3VudCYmKGU9ZC5zdGF0ZSxkLmNvbXBvbmVudFdpbGxNb3VudCgpLGUhPT1kLnN0YXRlJiZmLmVucXVldWVSZXBsYWNlU3RhdGUoZCxkLnN0YXRlLG51bGwpLGU9YS51cGRhdGVRdWV1ZSxudWxsIT09ZSYmKGQuc3RhdGU9SmUoYyxhLGUsZCxnLGIpKSk7XCJmdW5jdGlvblwiPT09dHlwZW9mIGQuY29tcG9uZW50RGlkTW91bnQmJihhLmVmZmVjdFRhZ3w9XG40KX0sdXBkYXRlQ2xhc3NJbnN0YW5jZTpmdW5jdGlvbihhLGIsZSl7dmFyIGc9Yi5zdGF0ZU5vZGU7Zy5wcm9wcz1iLm1lbW9pemVkUHJvcHM7Zy5zdGF0ZT1iLm1lbW9pemVkU3RhdGU7dmFyIGg9Yi5tZW1vaXplZFByb3BzLGs9Yi5wZW5kaW5nUHJvcHM7a3x8KGs9aCxudWxsPT1rP0UoXCIxNTlcIik6dm9pZCAwKTt2YXIgdT1nLmNvbnRleHQsej1rZShiKTt6PW1lKGIseik7XCJmdW5jdGlvblwiIT09dHlwZW9mIGcuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc3x8aD09PWsmJnU9PT16fHwodT1nLnN0YXRlLGcuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhrLHopLGcuc3RhdGUhPT11JiZmLmVucXVldWVSZXBsYWNlU3RhdGUoZyxnLnN0YXRlLG51bGwpKTt1PWIubWVtb2l6ZWRTdGF0ZTtlPW51bGwhPT1iLnVwZGF0ZVF1ZXVlP0plKGEsYixiLnVwZGF0ZVF1ZXVlLGcsayxlKTp1O2lmKCEoaCE9PWt8fHUhPT1lfHxYLmN1cnJlbnR8fG51bGwhPT1iLnVwZGF0ZVF1ZXVlJiZiLnVwZGF0ZVF1ZXVlLmhhc0ZvcmNlVXBkYXRlKSlyZXR1cm5cImZ1bmN0aW9uXCIhPT1cbnR5cGVvZiBnLmNvbXBvbmVudERpZFVwZGF0ZXx8aD09PWEubWVtb2l6ZWRQcm9wcyYmdT09PWEubWVtb2l6ZWRTdGF0ZXx8KGIuZWZmZWN0VGFnfD00KSwhMTt2YXIgRz1rO2lmKG51bGw9PT1ofHxudWxsIT09Yi51cGRhdGVRdWV1ZSYmYi51cGRhdGVRdWV1ZS5oYXNGb3JjZVVwZGF0ZSlHPSEwO2Vsc2V7dmFyIEk9Yi5zdGF0ZU5vZGUsTD1iLnR5cGU7Rz1cImZ1bmN0aW9uXCI9PT10eXBlb2YgSS5zaG91bGRDb21wb25lbnRVcGRhdGU/SS5zaG91bGRDb21wb25lbnRVcGRhdGUoRyxlLHopOkwucHJvdG90eXBlJiZMLnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudD8hZWEoaCxHKXx8IWVhKHUsZSk6ITB9Rz8oXCJmdW5jdGlvblwiPT09dHlwZW9mIGcuY29tcG9uZW50V2lsbFVwZGF0ZSYmZy5jb21wb25lbnRXaWxsVXBkYXRlKGssZSx6KSxcImZ1bmN0aW9uXCI9PT10eXBlb2YgZy5jb21wb25lbnREaWRVcGRhdGUmJihiLmVmZmVjdFRhZ3w9NCkpOihcImZ1bmN0aW9uXCIhPT10eXBlb2YgZy5jb21wb25lbnREaWRVcGRhdGV8fFxuaD09PWEubWVtb2l6ZWRQcm9wcyYmdT09PWEubWVtb2l6ZWRTdGF0ZXx8KGIuZWZmZWN0VGFnfD00KSxjKGIsayksZChiLGUpKTtnLnByb3BzPWs7Zy5zdGF0ZT1lO2cuY29udGV4dD16O3JldHVybiBHfX19dmFyIFFlPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBTeW1ib2wmJlN5bWJvbFtcImZvclwiXSxSZT1RZT9TeW1ib2xbXCJmb3JcIl0oXCJyZWFjdC5lbGVtZW50XCIpOjYwMTAzLFNlPVFlP1N5bWJvbFtcImZvclwiXShcInJlYWN0LmNhbGxcIik6NjAxMDQsVGU9UWU/U3ltYm9sW1wiZm9yXCJdKFwicmVhY3QucmV0dXJuXCIpOjYwMTA1LFVlPVFlP1N5bWJvbFtcImZvclwiXShcInJlYWN0LnBvcnRhbFwiKTo2MDEwNixWZT1RZT9TeW1ib2xbXCJmb3JcIl0oXCJyZWFjdC5mcmFnbWVudFwiKTo2MDEwNyxXZT1cImZ1bmN0aW9uXCI9PT10eXBlb2YgU3ltYm9sJiZTeW1ib2wuaXRlcmF0b3I7XG5mdW5jdGlvbiBYZShhKXtpZihudWxsPT09YXx8XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhKXJldHVybiBudWxsO2E9V2UmJmFbV2VdfHxhW1wiQEBpdGVyYXRvclwiXTtyZXR1cm5cImZ1bmN0aW9uXCI9PT10eXBlb2YgYT9hOm51bGx9dmFyIFllPUFycmF5LmlzQXJyYXk7XG5mdW5jdGlvbiBaZShhLGIpe3ZhciBjPWIucmVmO2lmKG51bGwhPT1jJiZcImZ1bmN0aW9uXCIhPT10eXBlb2YgYyl7aWYoYi5fb3duZXIpe2I9Yi5fb3duZXI7dmFyIGQ9dm9pZCAwO2ImJigyIT09Yi50YWc/RShcIjExMFwiKTp2b2lkIDAsZD1iLnN0YXRlTm9kZSk7ZD92b2lkIDA6RShcIjE0N1wiLGMpO3ZhciBlPVwiXCIrYztpZihudWxsIT09YSYmbnVsbCE9PWEucmVmJiZhLnJlZi5fc3RyaW5nUmVmPT09ZSlyZXR1cm4gYS5yZWY7YT1mdW5jdGlvbihhKXt2YXIgYj1kLnJlZnM9PT1EP2QucmVmcz17fTpkLnJlZnM7bnVsbD09PWE/ZGVsZXRlIGJbZV06YltlXT1hfTthLl9zdHJpbmdSZWY9ZTtyZXR1cm4gYX1cInN0cmluZ1wiIT09dHlwZW9mIGM/RShcIjE0OFwiKTp2b2lkIDA7Yi5fb3duZXI/dm9pZCAwOkUoXCIxNDlcIixjKX1yZXR1cm4gY31cbmZ1bmN0aW9uICRlKGEsYil7XCJ0ZXh0YXJlYVwiIT09YS50eXBlJiZFKFwiMzFcIixcIltvYmplY3QgT2JqZWN0XVwiPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGIpP1wib2JqZWN0IHdpdGgga2V5cyB7XCIrT2JqZWN0LmtleXMoYikuam9pbihcIiwgXCIpK1wifVwiOmIsXCJcIil9XG5mdW5jdGlvbiBhZihhKXtmdW5jdGlvbiBiKGIsYyl7aWYoYSl7dmFyIGQ9Yi5sYXN0RWZmZWN0O251bGwhPT1kPyhkLm5leHRFZmZlY3Q9YyxiLmxhc3RFZmZlY3Q9Yyk6Yi5maXJzdEVmZmVjdD1iLmxhc3RFZmZlY3Q9YztjLm5leHRFZmZlY3Q9bnVsbDtjLmVmZmVjdFRhZz04fX1mdW5jdGlvbiBjKGMsZCl7aWYoIWEpcmV0dXJuIG51bGw7Zm9yKDtudWxsIT09ZDspYihjLGQpLGQ9ZC5zaWJsaW5nO3JldHVybiBudWxsfWZ1bmN0aW9uIGQoYSxiKXtmb3IoYT1uZXcgTWFwO251bGwhPT1iOyludWxsIT09Yi5rZXk/YS5zZXQoYi5rZXksYik6YS5zZXQoYi5pbmRleCxiKSxiPWIuc2libGluZztyZXR1cm4gYX1mdW5jdGlvbiBlKGEsYixjKXthPXNlKGEsYixjKTthLmluZGV4PTA7YS5zaWJsaW5nPW51bGw7cmV0dXJuIGF9ZnVuY3Rpb24gZihiLGMsZCl7Yi5pbmRleD1kO2lmKCFhKXJldHVybiBjO2Q9Yi5hbHRlcm5hdGU7aWYobnVsbCE9PWQpcmV0dXJuIGQ9ZC5pbmRleCxkPGM/KGIuZWZmZWN0VGFnPVxuMixjKTpkO2IuZWZmZWN0VGFnPTI7cmV0dXJuIGN9ZnVuY3Rpb24gZyhiKXthJiZudWxsPT09Yi5hbHRlcm5hdGUmJihiLmVmZmVjdFRhZz0yKTtyZXR1cm4gYn1mdW5jdGlvbiBoKGEsYixjLGQpe2lmKG51bGw9PT1ifHw2IT09Yi50YWcpcmV0dXJuIGI9dmUoYyxhLmludGVybmFsQ29udGV4dFRhZyxkKSxiW1wicmV0dXJuXCJdPWEsYjtiPWUoYixjLGQpO2JbXCJyZXR1cm5cIl09YTtyZXR1cm4gYn1mdW5jdGlvbiBrKGEsYixjLGQpe2lmKG51bGwhPT1iJiZiLnR5cGU9PT1jLnR5cGUpcmV0dXJuIGQ9ZShiLGMucHJvcHMsZCksZC5yZWY9WmUoYixjKSxkW1wicmV0dXJuXCJdPWEsZDtkPXRlKGMsYS5pbnRlcm5hbENvbnRleHRUYWcsZCk7ZC5yZWY9WmUoYixjKTtkW1wicmV0dXJuXCJdPWE7cmV0dXJuIGR9ZnVuY3Rpb24gcShhLGIsYyxkKXtpZihudWxsPT09Ynx8NyE9PWIudGFnKXJldHVybiBiPXdlKGMsYS5pbnRlcm5hbENvbnRleHRUYWcsZCksYltcInJldHVyblwiXT1hLGI7Yj1lKGIsYyxkKTtcbmJbXCJyZXR1cm5cIl09YTtyZXR1cm4gYn1mdW5jdGlvbiB2KGEsYixjLGQpe2lmKG51bGw9PT1ifHw5IT09Yi50YWcpcmV0dXJuIGI9eGUoYyxhLmludGVybmFsQ29udGV4dFRhZyxkKSxiLnR5cGU9Yy52YWx1ZSxiW1wicmV0dXJuXCJdPWEsYjtiPWUoYixudWxsLGQpO2IudHlwZT1jLnZhbHVlO2JbXCJyZXR1cm5cIl09YTtyZXR1cm4gYn1mdW5jdGlvbiB5KGEsYixjLGQpe2lmKG51bGw9PT1ifHw0IT09Yi50YWd8fGIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8hPT1jLmNvbnRhaW5lckluZm98fGIuc3RhdGVOb2RlLmltcGxlbWVudGF0aW9uIT09Yy5pbXBsZW1lbnRhdGlvbilyZXR1cm4gYj15ZShjLGEuaW50ZXJuYWxDb250ZXh0VGFnLGQpLGJbXCJyZXR1cm5cIl09YSxiO2I9ZShiLGMuY2hpbGRyZW58fFtdLGQpO2JbXCJyZXR1cm5cIl09YTtyZXR1cm4gYn1mdW5jdGlvbiB1KGEsYixjLGQsZil7aWYobnVsbD09PWJ8fDEwIT09Yi50YWcpcmV0dXJuIGI9dWUoYyxhLmludGVybmFsQ29udGV4dFRhZyxcbmQsZiksYltcInJldHVyblwiXT1hLGI7Yj1lKGIsYyxkKTtiW1wicmV0dXJuXCJdPWE7cmV0dXJuIGJ9ZnVuY3Rpb24geihhLGIsYyl7aWYoXCJzdHJpbmdcIj09PXR5cGVvZiBifHxcIm51bWJlclwiPT09dHlwZW9mIGIpcmV0dXJuIGI9dmUoXCJcIitiLGEuaW50ZXJuYWxDb250ZXh0VGFnLGMpLGJbXCJyZXR1cm5cIl09YSxiO2lmKFwib2JqZWN0XCI9PT10eXBlb2YgYiYmbnVsbCE9PWIpe3N3aXRjaChiLiQkdHlwZW9mKXtjYXNlIFJlOmlmKGIudHlwZT09PVZlKXJldHVybiBiPXVlKGIucHJvcHMuY2hpbGRyZW4sYS5pbnRlcm5hbENvbnRleHRUYWcsYyxiLmtleSksYltcInJldHVyblwiXT1hLGI7Yz10ZShiLGEuaW50ZXJuYWxDb250ZXh0VGFnLGMpO2MucmVmPVplKG51bGwsYik7Y1tcInJldHVyblwiXT1hO3JldHVybiBjO2Nhc2UgU2U6cmV0dXJuIGI9d2UoYixhLmludGVybmFsQ29udGV4dFRhZyxjKSxiW1wicmV0dXJuXCJdPWEsYjtjYXNlIFRlOnJldHVybiBjPXhlKGIsYS5pbnRlcm5hbENvbnRleHRUYWcsXG5jKSxjLnR5cGU9Yi52YWx1ZSxjW1wicmV0dXJuXCJdPWEsYztjYXNlIFVlOnJldHVybiBiPXllKGIsYS5pbnRlcm5hbENvbnRleHRUYWcsYyksYltcInJldHVyblwiXT1hLGJ9aWYoWWUoYil8fFhlKGIpKXJldHVybiBiPXVlKGIsYS5pbnRlcm5hbENvbnRleHRUYWcsYyxudWxsKSxiW1wicmV0dXJuXCJdPWEsYjskZShhLGIpfXJldHVybiBudWxsfWZ1bmN0aW9uIEcoYSxiLGMsZCl7dmFyIGU9bnVsbCE9PWI/Yi5rZXk6bnVsbDtpZihcInN0cmluZ1wiPT09dHlwZW9mIGN8fFwibnVtYmVyXCI9PT10eXBlb2YgYylyZXR1cm4gbnVsbCE9PWU/bnVsbDpoKGEsYixcIlwiK2MsZCk7aWYoXCJvYmplY3RcIj09PXR5cGVvZiBjJiZudWxsIT09Yyl7c3dpdGNoKGMuJCR0eXBlb2Ype2Nhc2UgUmU6cmV0dXJuIGMua2V5PT09ZT9jLnR5cGU9PT1WZT91KGEsYixjLnByb3BzLmNoaWxkcmVuLGQsZSk6ayhhLGIsYyxkKTpudWxsO2Nhc2UgU2U6cmV0dXJuIGMua2V5PT09ZT9xKGEsYixjLGQpOm51bGw7Y2FzZSBUZTpyZXR1cm4gbnVsbD09PVxuZT92KGEsYixjLGQpOm51bGw7Y2FzZSBVZTpyZXR1cm4gYy5rZXk9PT1lP3koYSxiLGMsZCk6bnVsbH1pZihZZShjKXx8WGUoYykpcmV0dXJuIG51bGwhPT1lP251bGw6dShhLGIsYyxkLG51bGwpOyRlKGEsYyl9cmV0dXJuIG51bGx9ZnVuY3Rpb24gSShhLGIsYyxkLGUpe2lmKFwic3RyaW5nXCI9PT10eXBlb2YgZHx8XCJudW1iZXJcIj09PXR5cGVvZiBkKXJldHVybiBhPWEuZ2V0KGMpfHxudWxsLGgoYixhLFwiXCIrZCxlKTtpZihcIm9iamVjdFwiPT09dHlwZW9mIGQmJm51bGwhPT1kKXtzd2l0Y2goZC4kJHR5cGVvZil7Y2FzZSBSZTpyZXR1cm4gYT1hLmdldChudWxsPT09ZC5rZXk/YzpkLmtleSl8fG51bGwsZC50eXBlPT09VmU/dShiLGEsZC5wcm9wcy5jaGlsZHJlbixlLGQua2V5KTprKGIsYSxkLGUpO2Nhc2UgU2U6cmV0dXJuIGE9YS5nZXQobnVsbD09PWQua2V5P2M6ZC5rZXkpfHxudWxsLHEoYixhLGQsZSk7Y2FzZSBUZTpyZXR1cm4gYT1hLmdldChjKXx8bnVsbCx2KGIsYSxkLGUpO2Nhc2UgVWU6cmV0dXJuIGE9XG5hLmdldChudWxsPT09ZC5rZXk/YzpkLmtleSl8fG51bGwseShiLGEsZCxlKX1pZihZZShkKXx8WGUoZCkpcmV0dXJuIGE9YS5nZXQoYyl8fG51bGwsdShiLGEsZCxlLG51bGwpOyRlKGIsZCl9cmV0dXJuIG51bGx9ZnVuY3Rpb24gTChlLGcsbSxBKXtmb3IodmFyIGg9bnVsbCxyPW51bGwsbj1nLHc9Zz0wLGs9bnVsbDtudWxsIT09biYmdzxtLmxlbmd0aDt3Kyspe24uaW5kZXg+dz8oaz1uLG49bnVsbCk6az1uLnNpYmxpbmc7dmFyIHg9RyhlLG4sbVt3XSxBKTtpZihudWxsPT09eCl7bnVsbD09PW4mJihuPWspO2JyZWFrfWEmJm4mJm51bGw9PT14LmFsdGVybmF0ZSYmYihlLG4pO2c9Zih4LGcsdyk7bnVsbD09PXI/aD14OnIuc2libGluZz14O3I9eDtuPWt9aWYodz09PW0ubGVuZ3RoKXJldHVybiBjKGUsbiksaDtpZihudWxsPT09bil7Zm9yKDt3PG0ubGVuZ3RoO3crKylpZihuPXooZSxtW3ddLEEpKWc9ZihuLGcsdyksbnVsbD09PXI/aD1uOnIuc2libGluZz1uLHI9bjtyZXR1cm4gaH1mb3Iobj1cbmQoZSxuKTt3PG0ubGVuZ3RoO3crKylpZihrPUkobixlLHcsbVt3XSxBKSl7aWYoYSYmbnVsbCE9PWsuYWx0ZXJuYXRlKW5bXCJkZWxldGVcIl0obnVsbD09PWsua2V5P3c6ay5rZXkpO2c9ZihrLGcsdyk7bnVsbD09PXI/aD1rOnIuc2libGluZz1rO3I9a31hJiZuLmZvckVhY2goZnVuY3Rpb24oYSl7cmV0dXJuIGIoZSxhKX0pO3JldHVybiBofWZ1bmN0aW9uIE4oZSxnLG0sQSl7dmFyIGg9WGUobSk7XCJmdW5jdGlvblwiIT09dHlwZW9mIGg/RShcIjE1MFwiKTp2b2lkIDA7bT1oLmNhbGwobSk7bnVsbD09bT9FKFwiMTUxXCIpOnZvaWQgMDtmb3IodmFyIHI9aD1udWxsLG49Zyx3PWc9MCxrPW51bGwseD1tLm5leHQoKTtudWxsIT09biYmIXguZG9uZTt3KysseD1tLm5leHQoKSl7bi5pbmRleD53PyhrPW4sbj1udWxsKTprPW4uc2libGluZzt2YXIgSj1HKGUsbix4LnZhbHVlLEEpO2lmKG51bGw9PT1KKXtufHwobj1rKTticmVha31hJiZuJiZudWxsPT09Si5hbHRlcm5hdGUmJmIoZSxuKTtnPWYoSixcbmcsdyk7bnVsbD09PXI/aD1KOnIuc2libGluZz1KO3I9SjtuPWt9aWYoeC5kb25lKXJldHVybiBjKGUsbiksaDtpZihudWxsPT09bil7Zm9yKDsheC5kb25lO3crKyx4PW0ubmV4dCgpKXg9eihlLHgudmFsdWUsQSksbnVsbCE9PXgmJihnPWYoeCxnLHcpLG51bGw9PT1yP2g9eDpyLnNpYmxpbmc9eCxyPXgpO3JldHVybiBofWZvcihuPWQoZSxuKTsheC5kb25lO3crKyx4PW0ubmV4dCgpKWlmKHg9SShuLGUsdyx4LnZhbHVlLEEpLG51bGwhPT14KXtpZihhJiZudWxsIT09eC5hbHRlcm5hdGUpbltcImRlbGV0ZVwiXShudWxsPT09eC5rZXk/dzp4LmtleSk7Zz1mKHgsZyx3KTtudWxsPT09cj9oPXg6ci5zaWJsaW5nPXg7cj14fWEmJm4uZm9yRWFjaChmdW5jdGlvbihhKXtyZXR1cm4gYihlLGEpfSk7cmV0dXJuIGh9cmV0dXJuIGZ1bmN0aW9uKGEsZCxmLGgpe1wib2JqZWN0XCI9PT10eXBlb2YgZiYmbnVsbCE9PWYmJmYudHlwZT09PVZlJiZudWxsPT09Zi5rZXkmJihmPWYucHJvcHMuY2hpbGRyZW4pO1xudmFyIG09XCJvYmplY3RcIj09PXR5cGVvZiBmJiZudWxsIT09ZjtpZihtKXN3aXRjaChmLiQkdHlwZW9mKXtjYXNlIFJlOmE6e3ZhciByPWYua2V5O2ZvcihtPWQ7bnVsbCE9PW07KXtpZihtLmtleT09PXIpaWYoMTA9PT1tLnRhZz9mLnR5cGU9PT1WZTptLnR5cGU9PT1mLnR5cGUpe2MoYSxtLnNpYmxpbmcpO2Q9ZShtLGYudHlwZT09PVZlP2YucHJvcHMuY2hpbGRyZW46Zi5wcm9wcyxoKTtkLnJlZj1aZShtLGYpO2RbXCJyZXR1cm5cIl09YTthPWQ7YnJlYWsgYX1lbHNle2MoYSxtKTticmVha31lbHNlIGIoYSxtKTttPW0uc2libGluZ31mLnR5cGU9PT1WZT8oZD11ZShmLnByb3BzLmNoaWxkcmVuLGEuaW50ZXJuYWxDb250ZXh0VGFnLGgsZi5rZXkpLGRbXCJyZXR1cm5cIl09YSxhPWQpOihoPXRlKGYsYS5pbnRlcm5hbENvbnRleHRUYWcsaCksaC5yZWY9WmUoZCxmKSxoW1wicmV0dXJuXCJdPWEsYT1oKX1yZXR1cm4gZyhhKTtjYXNlIFNlOmE6e2ZvcihtPWYua2V5O251bGwhPT1kOyl7aWYoZC5rZXk9PT1cbm0paWYoNz09PWQudGFnKXtjKGEsZC5zaWJsaW5nKTtkPWUoZCxmLGgpO2RbXCJyZXR1cm5cIl09YTthPWQ7YnJlYWsgYX1lbHNle2MoYSxkKTticmVha31lbHNlIGIoYSxkKTtkPWQuc2libGluZ31kPXdlKGYsYS5pbnRlcm5hbENvbnRleHRUYWcsaCk7ZFtcInJldHVyblwiXT1hO2E9ZH1yZXR1cm4gZyhhKTtjYXNlIFRlOmE6e2lmKG51bGwhPT1kKWlmKDk9PT1kLnRhZyl7YyhhLGQuc2libGluZyk7ZD1lKGQsbnVsbCxoKTtkLnR5cGU9Zi52YWx1ZTtkW1wicmV0dXJuXCJdPWE7YT1kO2JyZWFrIGF9ZWxzZSBjKGEsZCk7ZD14ZShmLGEuaW50ZXJuYWxDb250ZXh0VGFnLGgpO2QudHlwZT1mLnZhbHVlO2RbXCJyZXR1cm5cIl09YTthPWR9cmV0dXJuIGcoYSk7Y2FzZSBVZTphOntmb3IobT1mLmtleTtudWxsIT09ZDspe2lmKGQua2V5PT09bSlpZig0PT09ZC50YWcmJmQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm89PT1mLmNvbnRhaW5lckluZm8mJmQuc3RhdGVOb2RlLmltcGxlbWVudGF0aW9uPT09XG5mLmltcGxlbWVudGF0aW9uKXtjKGEsZC5zaWJsaW5nKTtkPWUoZCxmLmNoaWxkcmVufHxbXSxoKTtkW1wicmV0dXJuXCJdPWE7YT1kO2JyZWFrIGF9ZWxzZXtjKGEsZCk7YnJlYWt9ZWxzZSBiKGEsZCk7ZD1kLnNpYmxpbmd9ZD15ZShmLGEuaW50ZXJuYWxDb250ZXh0VGFnLGgpO2RbXCJyZXR1cm5cIl09YTthPWR9cmV0dXJuIGcoYSl9aWYoXCJzdHJpbmdcIj09PXR5cGVvZiBmfHxcIm51bWJlclwiPT09dHlwZW9mIGYpcmV0dXJuIGY9XCJcIitmLG51bGwhPT1kJiY2PT09ZC50YWc/KGMoYSxkLnNpYmxpbmcpLGQ9ZShkLGYsaCkpOihjKGEsZCksZD12ZShmLGEuaW50ZXJuYWxDb250ZXh0VGFnLGgpKSxkW1wicmV0dXJuXCJdPWEsYT1kLGcoYSk7aWYoWWUoZikpcmV0dXJuIEwoYSxkLGYsaCk7aWYoWGUoZikpcmV0dXJuIE4oYSxkLGYsaCk7bSYmJGUoYSxmKTtpZihcInVuZGVmaW5lZFwiPT09dHlwZW9mIGYpc3dpdGNoKGEudGFnKXtjYXNlIDI6Y2FzZSAxOmg9YS50eXBlLEUoXCIxNTJcIixoLmRpc3BsYXlOYW1lfHxcbmgubmFtZXx8XCJDb21wb25lbnRcIil9cmV0dXJuIGMoYSxkKX19dmFyIGJmPWFmKCEwKSxjZj1hZighMSk7XG5mdW5jdGlvbiBkZihhLGIsYyxkLGUpe2Z1bmN0aW9uIGYoYSxiLGMpe3ZhciBkPWIuZXhwaXJhdGlvblRpbWU7Yi5jaGlsZD1udWxsPT09YT9jZihiLG51bGwsYyxkKTpiZihiLGEuY2hpbGQsYyxkKX1mdW5jdGlvbiBnKGEsYil7dmFyIGM9Yi5yZWY7bnVsbD09PWN8fGEmJmEucmVmPT09Y3x8KGIuZWZmZWN0VGFnfD0xMjgpfWZ1bmN0aW9uIGgoYSxiLGMsZCl7ZyhhLGIpO2lmKCFjKXJldHVybiBkJiZyZShiLCExKSxxKGEsYik7Yz1iLnN0YXRlTm9kZTtpZC5jdXJyZW50PWI7dmFyIGU9Yy5yZW5kZXIoKTtiLmVmZmVjdFRhZ3w9MTtmKGEsYixlKTtiLm1lbW9pemVkU3RhdGU9Yy5zdGF0ZTtiLm1lbW9pemVkUHJvcHM9Yy5wcm9wcztkJiZyZShiLCEwKTtyZXR1cm4gYi5jaGlsZH1mdW5jdGlvbiBrKGEpe3ZhciBiPWEuc3RhdGVOb2RlO2IucGVuZGluZ0NvbnRleHQ/b2UoYSxiLnBlbmRpbmdDb250ZXh0LGIucGVuZGluZ0NvbnRleHQhPT1iLmNvbnRleHQpOmIuY29udGV4dCYmb2UoYSxcbmIuY29udGV4dCwhMSk7SShhLGIuY29udGFpbmVySW5mbyl9ZnVuY3Rpb24gcShhLGIpe251bGwhPT1hJiZiLmNoaWxkIT09YS5jaGlsZD9FKFwiMTUzXCIpOnZvaWQgMDtpZihudWxsIT09Yi5jaGlsZCl7YT1iLmNoaWxkO3ZhciBjPXNlKGEsYS5wZW5kaW5nUHJvcHMsYS5leHBpcmF0aW9uVGltZSk7Yi5jaGlsZD1jO2ZvcihjW1wicmV0dXJuXCJdPWI7bnVsbCE9PWEuc2libGluZzspYT1hLnNpYmxpbmcsYz1jLnNpYmxpbmc9c2UoYSxhLnBlbmRpbmdQcm9wcyxhLmV4cGlyYXRpb25UaW1lKSxjW1wicmV0dXJuXCJdPWI7Yy5zaWJsaW5nPW51bGx9cmV0dXJuIGIuY2hpbGR9ZnVuY3Rpb24gdihhLGIpe3N3aXRjaChiLnRhZyl7Y2FzZSAzOmsoYik7YnJlYWs7Y2FzZSAyOnFlKGIpO2JyZWFrO2Nhc2UgNDpJKGIsYi5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyl9cmV0dXJuIG51bGx9dmFyIHk9YS5zaG91bGRTZXRUZXh0Q29udGVudCx1PWEudXNlU3luY1NjaGVkdWxpbmcsej1hLnNob3VsZERlcHJpb3JpdGl6ZVN1YnRyZWUsXG5HPWIucHVzaEhvc3RDb250ZXh0LEk9Yi5wdXNoSG9zdENvbnRhaW5lcixMPWMuZW50ZXJIeWRyYXRpb25TdGF0ZSxOPWMucmVzZXRIeWRyYXRpb25TdGF0ZSxKPWMudHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2U7YT1MZShkLGUsZnVuY3Rpb24oYSxiKXthLm1lbW9pemVkUHJvcHM9Yn0sZnVuY3Rpb24oYSxiKXthLm1lbW9pemVkU3RhdGU9Yn0pO3ZhciB3PWEuYWRvcHRDbGFzc0luc3RhbmNlLG09YS5jb25zdHJ1Y3RDbGFzc0luc3RhbmNlLEE9YS5tb3VudENsYXNzSW5zdGFuY2UsT2I9YS51cGRhdGVDbGFzc0luc3RhbmNlO3JldHVybntiZWdpbldvcms6ZnVuY3Rpb24oYSxiLGMpe2lmKDA9PT1iLmV4cGlyYXRpb25UaW1lfHxiLmV4cGlyYXRpb25UaW1lPmMpcmV0dXJuIHYoYSxiKTtzd2l0Y2goYi50YWcpe2Nhc2UgMDpudWxsIT09YT9FKFwiMTU1XCIpOnZvaWQgMDt2YXIgZD1iLnR5cGUsZT1iLnBlbmRpbmdQcm9wcyxyPWtlKGIpO3I9bWUoYixyKTtkPWQoZSxyKTtiLmVmZmVjdFRhZ3w9XG4xO1wib2JqZWN0XCI9PT10eXBlb2YgZCYmbnVsbCE9PWQmJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBkLnJlbmRlcj8oYi50YWc9MixlPXFlKGIpLHcoYixkKSxBKGIsYyksYj1oKGEsYiwhMCxlKSk6KGIudGFnPTEsZihhLGIsZCksYi5tZW1vaXplZFByb3BzPWUsYj1iLmNoaWxkKTtyZXR1cm4gYjtjYXNlIDE6YTp7ZT1iLnR5cGU7Yz1iLnBlbmRpbmdQcm9wcztkPWIubWVtb2l6ZWRQcm9wcztpZihYLmN1cnJlbnQpbnVsbD09PWMmJihjPWQpO2Vsc2UgaWYobnVsbD09PWN8fGQ9PT1jKXtiPXEoYSxiKTticmVhayBhfWQ9a2UoYik7ZD1tZShiLGQpO2U9ZShjLGQpO2IuZWZmZWN0VGFnfD0xO2YoYSxiLGUpO2IubWVtb2l6ZWRQcm9wcz1jO2I9Yi5jaGlsZH1yZXR1cm4gYjtjYXNlIDI6cmV0dXJuIGU9cWUoYiksZD12b2lkIDAsbnVsbD09PWE/Yi5zdGF0ZU5vZGU/RShcIjE1M1wiKToobShiLGIucGVuZGluZ1Byb3BzKSxBKGIsYyksZD0hMCk6ZD1PYihhLGIsYyksaChhLGIsZCxlKTtjYXNlIDM6cmV0dXJuIGsoYiksXG5lPWIudXBkYXRlUXVldWUsbnVsbCE9PWU/KGQ9Yi5tZW1vaXplZFN0YXRlLGU9SmUoYSxiLGUsbnVsbCxudWxsLGMpLGQ9PT1lPyhOKCksYj1xKGEsYikpOihkPWUuZWxlbWVudCxyPWIuc3RhdGVOb2RlLChudWxsPT09YXx8bnVsbD09PWEuY2hpbGQpJiZyLmh5ZHJhdGUmJkwoYik/KGIuZWZmZWN0VGFnfD0yLGIuY2hpbGQ9Y2YoYixudWxsLGQsYykpOihOKCksZihhLGIsZCkpLGIubWVtb2l6ZWRTdGF0ZT1lLGI9Yi5jaGlsZCkpOihOKCksYj1xKGEsYikpLGI7Y2FzZSA1OkcoYik7bnVsbD09PWEmJkooYik7ZT1iLnR5cGU7dmFyIG49Yi5tZW1vaXplZFByb3BzO2Q9Yi5wZW5kaW5nUHJvcHM7bnVsbD09PWQmJihkPW4sbnVsbD09PWQ/RShcIjE1NFwiKTp2b2lkIDApO3I9bnVsbCE9PWE/YS5tZW1vaXplZFByb3BzOm51bGw7WC5jdXJyZW50fHxudWxsIT09ZCYmbiE9PWQ/KG49ZC5jaGlsZHJlbix5KGUsZCk/bj1udWxsOnImJnkoZSxyKSYmKGIuZWZmZWN0VGFnfD0xNiksZyhhLGIpLFxuMjE0NzQ4MzY0NyE9PWMmJiF1JiZ6KGUsZCk/KGIuZXhwaXJhdGlvblRpbWU9MjE0NzQ4MzY0NyxiPW51bGwpOihmKGEsYixuKSxiLm1lbW9pemVkUHJvcHM9ZCxiPWIuY2hpbGQpKTpiPXEoYSxiKTtyZXR1cm4gYjtjYXNlIDY6cmV0dXJuIG51bGw9PT1hJiZKKGIpLGE9Yi5wZW5kaW5nUHJvcHMsbnVsbD09PWEmJihhPWIubWVtb2l6ZWRQcm9wcyksYi5tZW1vaXplZFByb3BzPWEsbnVsbDtjYXNlIDg6Yi50YWc9NztjYXNlIDc6ZT1iLnBlbmRpbmdQcm9wcztpZihYLmN1cnJlbnQpbnVsbD09PWUmJihlPWEmJmEubWVtb2l6ZWRQcm9wcyxudWxsPT09ZT9FKFwiMTU0XCIpOnZvaWQgMCk7ZWxzZSBpZihudWxsPT09ZXx8Yi5tZW1vaXplZFByb3BzPT09ZSllPWIubWVtb2l6ZWRQcm9wcztkPWUuY2hpbGRyZW47Yi5zdGF0ZU5vZGU9bnVsbD09PWE/Y2YoYixiLnN0YXRlTm9kZSxkLGMpOmJmKGIsYi5zdGF0ZU5vZGUsZCxjKTtiLm1lbW9pemVkUHJvcHM9ZTtyZXR1cm4gYi5zdGF0ZU5vZGU7XG5jYXNlIDk6cmV0dXJuIG51bGw7Y2FzZSA0OmE6e0koYixiLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtlPWIucGVuZGluZ1Byb3BzO2lmKFguY3VycmVudCludWxsPT09ZSYmKGU9YSYmYS5tZW1vaXplZFByb3BzLG51bGw9PWU/RShcIjE1NFwiKTp2b2lkIDApO2Vsc2UgaWYobnVsbD09PWV8fGIubWVtb2l6ZWRQcm9wcz09PWUpe2I9cShhLGIpO2JyZWFrIGF9bnVsbD09PWE/Yi5jaGlsZD1iZihiLG51bGwsZSxjKTpmKGEsYixlKTtiLm1lbW9pemVkUHJvcHM9ZTtiPWIuY2hpbGR9cmV0dXJuIGI7Y2FzZSAxMDphOntjPWIucGVuZGluZ1Byb3BzO2lmKFguY3VycmVudCludWxsPT09YyYmKGM9Yi5tZW1vaXplZFByb3BzKTtlbHNlIGlmKG51bGw9PT1jfHxiLm1lbW9pemVkUHJvcHM9PT1jKXtiPXEoYSxiKTticmVhayBhfWYoYSxiLGMpO2IubWVtb2l6ZWRQcm9wcz1jO2I9Yi5jaGlsZH1yZXR1cm4gYjtkZWZhdWx0OkUoXCIxNTZcIil9fSxiZWdpbkZhaWxlZFdvcms6ZnVuY3Rpb24oYSxiLFxuYyl7c3dpdGNoKGIudGFnKXtjYXNlIDI6cWUoYik7YnJlYWs7Y2FzZSAzOmsoYik7YnJlYWs7ZGVmYXVsdDpFKFwiMTU3XCIpfWIuZWZmZWN0VGFnfD02NDtudWxsPT09YT9iLmNoaWxkPW51bGw6Yi5jaGlsZCE9PWEuY2hpbGQmJihiLmNoaWxkPWEuY2hpbGQpO2lmKDA9PT1iLmV4cGlyYXRpb25UaW1lfHxiLmV4cGlyYXRpb25UaW1lPmMpcmV0dXJuIHYoYSxiKTtiLmZpcnN0RWZmZWN0PW51bGw7Yi5sYXN0RWZmZWN0PW51bGw7Yi5jaGlsZD1udWxsPT09YT9jZihiLG51bGwsbnVsbCxjKTpiZihiLGEuY2hpbGQsbnVsbCxjKTsyPT09Yi50YWcmJihhPWIuc3RhdGVOb2RlLGIubWVtb2l6ZWRQcm9wcz1hLnByb3BzLGIubWVtb2l6ZWRTdGF0ZT1hLnN0YXRlKTtyZXR1cm4gYi5jaGlsZH19fVxuZnVuY3Rpb24gZWYoYSxiLGMpe2Z1bmN0aW9uIGQoYSl7YS5lZmZlY3RUYWd8PTR9dmFyIGU9YS5jcmVhdGVJbnN0YW5jZSxmPWEuY3JlYXRlVGV4dEluc3RhbmNlLGc9YS5hcHBlbmRJbml0aWFsQ2hpbGQsaD1hLmZpbmFsaXplSW5pdGlhbENoaWxkcmVuLGs9YS5wcmVwYXJlVXBkYXRlLHE9YS5wZXJzaXN0ZW5jZSx2PWIuZ2V0Um9vdEhvc3RDb250YWluZXIseT1iLnBvcEhvc3RDb250ZXh0LHU9Yi5nZXRIb3N0Q29udGV4dCx6PWIucG9wSG9zdENvbnRhaW5lcixHPWMucHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSxJPWMucHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UsTD1jLnBvcEh5ZHJhdGlvblN0YXRlLE49dm9pZCAwLEo9dm9pZCAwLHc9dm9pZCAwO2EubXV0YXRpb24/KE49ZnVuY3Rpb24oKXt9LEo9ZnVuY3Rpb24oYSxiLGMpeyhiLnVwZGF0ZVF1ZXVlPWMpJiZkKGIpfSx3PWZ1bmN0aW9uKGEsYixjLGUpe2MhPT1lJiZkKGIpfSk6cT9FKFwiMjM1XCIpOkUoXCIyMzZcIik7XG5yZXR1cm57Y29tcGxldGVXb3JrOmZ1bmN0aW9uKGEsYixjKXt2YXIgbT1iLnBlbmRpbmdQcm9wcztpZihudWxsPT09bSltPWIubWVtb2l6ZWRQcm9wcztlbHNlIGlmKDIxNDc0ODM2NDchPT1iLmV4cGlyYXRpb25UaW1lfHwyMTQ3NDgzNjQ3PT09YyliLnBlbmRpbmdQcm9wcz1udWxsO3N3aXRjaChiLnRhZyl7Y2FzZSAxOnJldHVybiBudWxsO2Nhc2UgMjpyZXR1cm4gbmUoYiksbnVsbDtjYXNlIDM6eihiKTtWKFgsYik7VihpZSxiKTttPWIuc3RhdGVOb2RlO20ucGVuZGluZ0NvbnRleHQmJihtLmNvbnRleHQ9bS5wZW5kaW5nQ29udGV4dCxtLnBlbmRpbmdDb250ZXh0PW51bGwpO2lmKG51bGw9PT1hfHxudWxsPT09YS5jaGlsZClMKGIpLGIuZWZmZWN0VGFnJj0tMztOKGIpO3JldHVybiBudWxsO2Nhc2UgNTp5KGIpO2M9digpO3ZhciBBPWIudHlwZTtpZihudWxsIT09YSYmbnVsbCE9Yi5zdGF0ZU5vZGUpe3ZhciBwPWEubWVtb2l6ZWRQcm9wcyxxPWIuc3RhdGVOb2RlLHg9dSgpO3E9XG5rKHEsQSxwLG0sYyx4KTtKKGEsYixxLEEscCxtLGMpO2EucmVmIT09Yi5yZWYmJihiLmVmZmVjdFRhZ3w9MTI4KX1lbHNle2lmKCFtKXJldHVybiBudWxsPT09Yi5zdGF0ZU5vZGU/RShcIjE2NlwiKTp2b2lkIDAsbnVsbDthPXUoKTtpZihMKGIpKUcoYixjLGEpJiZkKGIpO2Vsc2V7YT1lKEEsbSxjLGEsYik7YTpmb3IocD1iLmNoaWxkO251bGwhPT1wOyl7aWYoNT09PXAudGFnfHw2PT09cC50YWcpZyhhLHAuc3RhdGVOb2RlKTtlbHNlIGlmKDQhPT1wLnRhZyYmbnVsbCE9PXAuY2hpbGQpe3AuY2hpbGRbXCJyZXR1cm5cIl09cDtwPXAuY2hpbGQ7Y29udGludWV9aWYocD09PWIpYnJlYWs7Zm9yKDtudWxsPT09cC5zaWJsaW5nOyl7aWYobnVsbD09PXBbXCJyZXR1cm5cIl18fHBbXCJyZXR1cm5cIl09PT1iKWJyZWFrIGE7cD1wW1wicmV0dXJuXCJdfXAuc2libGluZ1tcInJldHVyblwiXT1wW1wicmV0dXJuXCJdO3A9cC5zaWJsaW5nfWgoYSxBLG0sYykmJmQoYik7Yi5zdGF0ZU5vZGU9YX1udWxsIT09Yi5yZWYmJlxuKGIuZWZmZWN0VGFnfD0xMjgpfXJldHVybiBudWxsO2Nhc2UgNjppZihhJiZudWxsIT1iLnN0YXRlTm9kZSl3KGEsYixhLm1lbW9pemVkUHJvcHMsbSk7ZWxzZXtpZihcInN0cmluZ1wiIT09dHlwZW9mIG0pcmV0dXJuIG51bGw9PT1iLnN0YXRlTm9kZT9FKFwiMTY2XCIpOnZvaWQgMCxudWxsO2E9digpO2M9dSgpO0woYik/SShiKSYmZChiKTpiLnN0YXRlTm9kZT1mKG0sYSxjLGIpfXJldHVybiBudWxsO2Nhc2UgNzoobT1iLm1lbW9pemVkUHJvcHMpP3ZvaWQgMDpFKFwiMTY1XCIpO2IudGFnPTg7QT1bXTthOmZvcigocD1iLnN0YXRlTm9kZSkmJihwW1wicmV0dXJuXCJdPWIpO251bGwhPT1wOyl7aWYoNT09PXAudGFnfHw2PT09cC50YWd8fDQ9PT1wLnRhZylFKFwiMjQ3XCIpO2Vsc2UgaWYoOT09PXAudGFnKUEucHVzaChwLnR5cGUpO2Vsc2UgaWYobnVsbCE9PXAuY2hpbGQpe3AuY2hpbGRbXCJyZXR1cm5cIl09cDtwPXAuY2hpbGQ7Y29udGludWV9Zm9yKDtudWxsPT09cC5zaWJsaW5nOyl7aWYobnVsbD09PVxucFtcInJldHVyblwiXXx8cFtcInJldHVyblwiXT09PWIpYnJlYWsgYTtwPXBbXCJyZXR1cm5cIl19cC5zaWJsaW5nW1wicmV0dXJuXCJdPXBbXCJyZXR1cm5cIl07cD1wLnNpYmxpbmd9cD1tLmhhbmRsZXI7bT1wKG0ucHJvcHMsQSk7Yi5jaGlsZD1iZihiLG51bGwhPT1hP2EuY2hpbGQ6bnVsbCxtLGMpO3JldHVybiBiLmNoaWxkO2Nhc2UgODpyZXR1cm4gYi50YWc9NyxudWxsO2Nhc2UgOTpyZXR1cm4gbnVsbDtjYXNlIDEwOnJldHVybiBudWxsO2Nhc2UgNDpyZXR1cm4geihiKSxOKGIpLG51bGw7Y2FzZSAwOkUoXCIxNjdcIik7ZGVmYXVsdDpFKFwiMTU2XCIpfX19fVxuZnVuY3Rpb24gZmYoYSxiKXtmdW5jdGlvbiBjKGEpe3ZhciBjPWEucmVmO2lmKG51bGwhPT1jKXRyeXtjKG51bGwpfWNhdGNoKEEpe2IoYSxBKX19ZnVuY3Rpb24gZChhKXtcImZ1bmN0aW9uXCI9PT10eXBlb2YgRWUmJkVlKGEpO3N3aXRjaChhLnRhZyl7Y2FzZSAyOmMoYSk7dmFyIGQ9YS5zdGF0ZU5vZGU7aWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIGQuY29tcG9uZW50V2lsbFVubW91bnQpdHJ5e2QucHJvcHM9YS5tZW1vaXplZFByb3BzLGQuc3RhdGU9YS5tZW1vaXplZFN0YXRlLGQuY29tcG9uZW50V2lsbFVubW91bnQoKX1jYXRjaChBKXtiKGEsQSl9YnJlYWs7Y2FzZSA1OmMoYSk7YnJlYWs7Y2FzZSA3OmUoYS5zdGF0ZU5vZGUpO2JyZWFrO2Nhc2UgNDprJiZnKGEpfX1mdW5jdGlvbiBlKGEpe2Zvcih2YXIgYj1hOzspaWYoZChiKSxudWxsPT09Yi5jaGlsZHx8ayYmND09PWIudGFnKXtpZihiPT09YSlicmVhaztmb3IoO251bGw9PT1iLnNpYmxpbmc7KXtpZihudWxsPT09YltcInJldHVyblwiXXx8XG5iW1wicmV0dXJuXCJdPT09YSlyZXR1cm47Yj1iW1wicmV0dXJuXCJdfWIuc2libGluZ1tcInJldHVyblwiXT1iW1wicmV0dXJuXCJdO2I9Yi5zaWJsaW5nfWVsc2UgYi5jaGlsZFtcInJldHVyblwiXT1iLGI9Yi5jaGlsZH1mdW5jdGlvbiBmKGEpe3JldHVybiA1PT09YS50YWd8fDM9PT1hLnRhZ3x8ND09PWEudGFnfWZ1bmN0aW9uIGcoYSl7Zm9yKHZhciBiPWEsYz0hMSxmPXZvaWQgMCxnPXZvaWQgMDs7KXtpZighYyl7Yz1iW1wicmV0dXJuXCJdO2E6Zm9yKDs7KXtudWxsPT09Yz9FKFwiMTYwXCIpOnZvaWQgMDtzd2l0Y2goYy50YWcpe2Nhc2UgNTpmPWMuc3RhdGVOb2RlO2c9ITE7YnJlYWsgYTtjYXNlIDM6Zj1jLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO2c9ITA7YnJlYWsgYTtjYXNlIDQ6Zj1jLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO2c9ITA7YnJlYWsgYX1jPWNbXCJyZXR1cm5cIl19Yz0hMH1pZig1PT09Yi50YWd8fDY9PT1iLnRhZyllKGIpLGc/SihmLGIuc3RhdGVOb2RlKTpOKGYsYi5zdGF0ZU5vZGUpO1xuZWxzZSBpZig0PT09Yi50YWc/Zj1iLnN0YXRlTm9kZS5jb250YWluZXJJbmZvOmQoYiksbnVsbCE9PWIuY2hpbGQpe2IuY2hpbGRbXCJyZXR1cm5cIl09YjtiPWIuY2hpbGQ7Y29udGludWV9aWYoYj09PWEpYnJlYWs7Zm9yKDtudWxsPT09Yi5zaWJsaW5nOyl7aWYobnVsbD09PWJbXCJyZXR1cm5cIl18fGJbXCJyZXR1cm5cIl09PT1hKXJldHVybjtiPWJbXCJyZXR1cm5cIl07ND09PWIudGFnJiYoYz0hMSl9Yi5zaWJsaW5nW1wicmV0dXJuXCJdPWJbXCJyZXR1cm5cIl07Yj1iLnNpYmxpbmd9fXZhciBoPWEuZ2V0UHVibGljSW5zdGFuY2Usaz1hLm11dGF0aW9uO2E9YS5wZXJzaXN0ZW5jZTtrfHwoYT9FKFwiMjM1XCIpOkUoXCIyMzZcIikpO3ZhciBxPWsuY29tbWl0TW91bnQsdj1rLmNvbW1pdFVwZGF0ZSx5PWsucmVzZXRUZXh0Q29udGVudCx1PWsuY29tbWl0VGV4dFVwZGF0ZSx6PWsuYXBwZW5kQ2hpbGQsRz1rLmFwcGVuZENoaWxkVG9Db250YWluZXIsST1rLmluc2VydEJlZm9yZSxMPWsuaW5zZXJ0SW5Db250YWluZXJCZWZvcmUsXG5OPWsucmVtb3ZlQ2hpbGQsSj1rLnJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcjtyZXR1cm57Y29tbWl0UmVzZXRUZXh0Q29udGVudDpmdW5jdGlvbihhKXt5KGEuc3RhdGVOb2RlKX0sY29tbWl0UGxhY2VtZW50OmZ1bmN0aW9uKGEpe2E6e2Zvcih2YXIgYj1hW1wicmV0dXJuXCJdO251bGwhPT1iOyl7aWYoZihiKSl7dmFyIGM9YjticmVhayBhfWI9YltcInJldHVyblwiXX1FKFwiMTYwXCIpO2M9dm9pZCAwfXZhciBkPWI9dm9pZCAwO3N3aXRjaChjLnRhZyl7Y2FzZSA1OmI9Yy5zdGF0ZU5vZGU7ZD0hMTticmVhaztjYXNlIDM6Yj1jLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO2Q9ITA7YnJlYWs7Y2FzZSA0OmI9Yy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztkPSEwO2JyZWFrO2RlZmF1bHQ6RShcIjE2MVwiKX1jLmVmZmVjdFRhZyYxNiYmKHkoYiksYy5lZmZlY3RUYWcmPS0xNyk7YTpiOmZvcihjPWE7Oyl7Zm9yKDtudWxsPT09Yy5zaWJsaW5nOyl7aWYobnVsbD09PWNbXCJyZXR1cm5cIl18fGYoY1tcInJldHVyblwiXSkpe2M9XG5udWxsO2JyZWFrIGF9Yz1jW1wicmV0dXJuXCJdfWMuc2libGluZ1tcInJldHVyblwiXT1jW1wicmV0dXJuXCJdO2ZvcihjPWMuc2libGluZzs1IT09Yy50YWcmJjYhPT1jLnRhZzspe2lmKGMuZWZmZWN0VGFnJjIpY29udGludWUgYjtpZihudWxsPT09Yy5jaGlsZHx8ND09PWMudGFnKWNvbnRpbnVlIGI7ZWxzZSBjLmNoaWxkW1wicmV0dXJuXCJdPWMsYz1jLmNoaWxkfWlmKCEoYy5lZmZlY3RUYWcmMikpe2M9Yy5zdGF0ZU5vZGU7YnJlYWsgYX19Zm9yKHZhciBlPWE7Oyl7aWYoNT09PWUudGFnfHw2PT09ZS50YWcpYz9kP0woYixlLnN0YXRlTm9kZSxjKTpJKGIsZS5zdGF0ZU5vZGUsYyk6ZD9HKGIsZS5zdGF0ZU5vZGUpOnooYixlLnN0YXRlTm9kZSk7ZWxzZSBpZig0IT09ZS50YWcmJm51bGwhPT1lLmNoaWxkKXtlLmNoaWxkW1wicmV0dXJuXCJdPWU7ZT1lLmNoaWxkO2NvbnRpbnVlfWlmKGU9PT1hKWJyZWFrO2Zvcig7bnVsbD09PWUuc2libGluZzspe2lmKG51bGw9PT1lW1wicmV0dXJuXCJdfHxlW1wicmV0dXJuXCJdPT09XG5hKXJldHVybjtlPWVbXCJyZXR1cm5cIl19ZS5zaWJsaW5nW1wicmV0dXJuXCJdPWVbXCJyZXR1cm5cIl07ZT1lLnNpYmxpbmd9fSxjb21taXREZWxldGlvbjpmdW5jdGlvbihhKXtnKGEpO2FbXCJyZXR1cm5cIl09bnVsbDthLmNoaWxkPW51bGw7YS5hbHRlcm5hdGUmJihhLmFsdGVybmF0ZS5jaGlsZD1udWxsLGEuYWx0ZXJuYXRlW1wicmV0dXJuXCJdPW51bGwpfSxjb21taXRXb3JrOmZ1bmN0aW9uKGEsYil7c3dpdGNoKGIudGFnKXtjYXNlIDI6YnJlYWs7Y2FzZSA1OnZhciBjPWIuc3RhdGVOb2RlO2lmKG51bGwhPWMpe3ZhciBkPWIubWVtb2l6ZWRQcm9wczthPW51bGwhPT1hP2EubWVtb2l6ZWRQcm9wczpkO3ZhciBlPWIudHlwZSxmPWIudXBkYXRlUXVldWU7Yi51cGRhdGVRdWV1ZT1udWxsO251bGwhPT1mJiZ2KGMsZixlLGEsZCxiKX1icmVhaztjYXNlIDY6bnVsbD09PWIuc3RhdGVOb2RlP0UoXCIxNjJcIik6dm9pZCAwO2M9Yi5tZW1vaXplZFByb3BzO3UoYi5zdGF0ZU5vZGUsbnVsbCE9PWE/YS5tZW1vaXplZFByb3BzOlxuYyxjKTticmVhaztjYXNlIDM6YnJlYWs7ZGVmYXVsdDpFKFwiMTYzXCIpfX0sY29tbWl0TGlmZUN5Y2xlczpmdW5jdGlvbihhLGIpe3N3aXRjaChiLnRhZyl7Y2FzZSAyOnZhciBjPWIuc3RhdGVOb2RlO2lmKGIuZWZmZWN0VGFnJjQpaWYobnVsbD09PWEpYy5wcm9wcz1iLm1lbW9pemVkUHJvcHMsYy5zdGF0ZT1iLm1lbW9pemVkU3RhdGUsYy5jb21wb25lbnREaWRNb3VudCgpO2Vsc2V7dmFyIGQ9YS5tZW1vaXplZFByb3BzO2E9YS5tZW1vaXplZFN0YXRlO2MucHJvcHM9Yi5tZW1vaXplZFByb3BzO2Muc3RhdGU9Yi5tZW1vaXplZFN0YXRlO2MuY29tcG9uZW50RGlkVXBkYXRlKGQsYSl9Yj1iLnVwZGF0ZVF1ZXVlO251bGwhPT1iJiZLZShiLGMpO2JyZWFrO2Nhc2UgMzpjPWIudXBkYXRlUXVldWU7bnVsbCE9PWMmJktlKGMsbnVsbCE9PWIuY2hpbGQ/Yi5jaGlsZC5zdGF0ZU5vZGU6bnVsbCk7YnJlYWs7Y2FzZSA1OmM9Yi5zdGF0ZU5vZGU7bnVsbD09PWEmJmIuZWZmZWN0VGFnJjQmJnEoYyxcbmIudHlwZSxiLm1lbW9pemVkUHJvcHMsYik7YnJlYWs7Y2FzZSA2OmJyZWFrO2Nhc2UgNDpicmVhaztkZWZhdWx0OkUoXCIxNjNcIil9fSxjb21taXRBdHRhY2hSZWY6ZnVuY3Rpb24oYSl7dmFyIGI9YS5yZWY7aWYobnVsbCE9PWIpe3ZhciBjPWEuc3RhdGVOb2RlO3N3aXRjaChhLnRhZyl7Y2FzZSA1OmIoaChjKSk7YnJlYWs7ZGVmYXVsdDpiKGMpfX19LGNvbW1pdERldGFjaFJlZjpmdW5jdGlvbihhKXthPWEucmVmO251bGwhPT1hJiZhKG51bGwpfX19dmFyIGdmPXt9O1xuZnVuY3Rpb24gaGYoYSl7ZnVuY3Rpb24gYihhKXthPT09Z2Y/RShcIjE3NFwiKTp2b2lkIDA7cmV0dXJuIGF9dmFyIGM9YS5nZXRDaGlsZEhvc3RDb250ZXh0LGQ9YS5nZXRSb290SG9zdENvbnRleHQsZT17Y3VycmVudDpnZn0sZj17Y3VycmVudDpnZn0sZz17Y3VycmVudDpnZn07cmV0dXJue2dldEhvc3RDb250ZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIGIoZS5jdXJyZW50KX0sZ2V0Um9vdEhvc3RDb250YWluZXI6ZnVuY3Rpb24oKXtyZXR1cm4gYihnLmN1cnJlbnQpfSxwb3BIb3N0Q29udGFpbmVyOmZ1bmN0aW9uKGEpe1YoZSxhKTtWKGYsYSk7VihnLGEpfSxwb3BIb3N0Q29udGV4dDpmdW5jdGlvbihhKXtmLmN1cnJlbnQ9PT1hJiYoVihlLGEpLFYoZixhKSl9LHB1c2hIb3N0Q29udGFpbmVyOmZ1bmN0aW9uKGEsYil7VyhnLGIsYSk7Yj1kKGIpO1coZixhLGEpO1coZSxiLGEpfSxwdXNoSG9zdENvbnRleHQ6ZnVuY3Rpb24oYSl7dmFyIGQ9YihnLmN1cnJlbnQpLGg9YihlLmN1cnJlbnQpO1xuZD1jKGgsYS50eXBlLGQpO2ghPT1kJiYoVyhmLGEsYSksVyhlLGQsYSkpfSxyZXNldEhvc3RDb250YWluZXI6ZnVuY3Rpb24oKXtlLmN1cnJlbnQ9Z2Y7Zy5jdXJyZW50PWdmfX19XG5mdW5jdGlvbiBqZihhKXtmdW5jdGlvbiBiKGEsYil7dmFyIGM9bmV3IFkoNSxudWxsLDApO2MudHlwZT1cIkRFTEVURURcIjtjLnN0YXRlTm9kZT1iO2NbXCJyZXR1cm5cIl09YTtjLmVmZmVjdFRhZz04O251bGwhPT1hLmxhc3RFZmZlY3Q/KGEubGFzdEVmZmVjdC5uZXh0RWZmZWN0PWMsYS5sYXN0RWZmZWN0PWMpOmEuZmlyc3RFZmZlY3Q9YS5sYXN0RWZmZWN0PWN9ZnVuY3Rpb24gYyhhLGIpe3N3aXRjaChhLnRhZyl7Y2FzZSA1OnJldHVybiBiPWYoYixhLnR5cGUsYS5wZW5kaW5nUHJvcHMpLG51bGwhPT1iPyhhLnN0YXRlTm9kZT1iLCEwKTohMTtjYXNlIDY6cmV0dXJuIGI9ZyhiLGEucGVuZGluZ1Byb3BzKSxudWxsIT09Yj8oYS5zdGF0ZU5vZGU9YiwhMCk6ITE7ZGVmYXVsdDpyZXR1cm4hMX19ZnVuY3Rpb24gZChhKXtmb3IoYT1hW1wicmV0dXJuXCJdO251bGwhPT1hJiY1IT09YS50YWcmJjMhPT1hLnRhZzspYT1hW1wicmV0dXJuXCJdO3k9YX12YXIgZT1hLnNob3VsZFNldFRleHRDb250ZW50O1xuYT1hLmh5ZHJhdGlvbjtpZighYSlyZXR1cm57ZW50ZXJIeWRyYXRpb25TdGF0ZTpmdW5jdGlvbigpe3JldHVybiExfSxyZXNldEh5ZHJhdGlvblN0YXRlOmZ1bmN0aW9uKCl7fSx0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZTpmdW5jdGlvbigpe30scHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZTpmdW5jdGlvbigpe0UoXCIxNzVcIil9LHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlOmZ1bmN0aW9uKCl7RShcIjE3NlwiKX0scG9wSHlkcmF0aW9uU3RhdGU6ZnVuY3Rpb24oKXtyZXR1cm4hMX19O3ZhciBmPWEuY2FuSHlkcmF0ZUluc3RhbmNlLGc9YS5jYW5IeWRyYXRlVGV4dEluc3RhbmNlLGg9YS5nZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcsaz1hLmdldEZpcnN0SHlkcmF0YWJsZUNoaWxkLHE9YS5oeWRyYXRlSW5zdGFuY2Usdj1hLmh5ZHJhdGVUZXh0SW5zdGFuY2UseT1udWxsLHU9bnVsbCx6PSExO3JldHVybntlbnRlckh5ZHJhdGlvblN0YXRlOmZ1bmN0aW9uKGEpe3U9XG5rKGEuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO3k9YTtyZXR1cm4gej0hMH0scmVzZXRIeWRyYXRpb25TdGF0ZTpmdW5jdGlvbigpe3U9eT1udWxsO3o9ITF9LHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlOmZ1bmN0aW9uKGEpe2lmKHope3ZhciBkPXU7aWYoZCl7aWYoIWMoYSxkKSl7ZD1oKGQpO2lmKCFkfHwhYyhhLGQpKXthLmVmZmVjdFRhZ3w9Mjt6PSExO3k9YTtyZXR1cm59Yih5LHUpfXk9YTt1PWsoZCl9ZWxzZSBhLmVmZmVjdFRhZ3w9Mix6PSExLHk9YX19LHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2U6ZnVuY3Rpb24oYSxiLGMpe2I9cShhLnN0YXRlTm9kZSxhLnR5cGUsYS5tZW1vaXplZFByb3BzLGIsYyxhKTthLnVwZGF0ZVF1ZXVlPWI7cmV0dXJuIG51bGwhPT1iPyEwOiExfSxwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZTpmdW5jdGlvbihhKXtyZXR1cm4gdihhLnN0YXRlTm9kZSxhLm1lbW9pemVkUHJvcHMsYSl9LHBvcEh5ZHJhdGlvblN0YXRlOmZ1bmN0aW9uKGEpe2lmKGEhPT1cbnkpcmV0dXJuITE7aWYoIXopcmV0dXJuIGQoYSksej0hMCwhMTt2YXIgYz1hLnR5cGU7aWYoNSE9PWEudGFnfHxcImhlYWRcIiE9PWMmJlwiYm9keVwiIT09YyYmIWUoYyxhLm1lbW9pemVkUHJvcHMpKWZvcihjPXU7YzspYihhLGMpLGM9aChjKTtkKGEpO3U9eT9oKGEuc3RhdGVOb2RlKTpudWxsO3JldHVybiEwfX19XG5mdW5jdGlvbiBrZihhKXtmdW5jdGlvbiBiKGEpe1FiPWphPSEwO3ZhciBiPWEuc3RhdGVOb2RlO2IuY3VycmVudD09PWE/RShcIjE3N1wiKTp2b2lkIDA7Yi5pc1JlYWR5Rm9yQ29tbWl0PSExO2lkLmN1cnJlbnQ9bnVsbDtpZigxPGEuZWZmZWN0VGFnKWlmKG51bGwhPT1hLmxhc3RFZmZlY3Qpe2EubGFzdEVmZmVjdC5uZXh0RWZmZWN0PWE7dmFyIGM9YS5maXJzdEVmZmVjdH1lbHNlIGM9YTtlbHNlIGM9YS5maXJzdEVmZmVjdDt5ZygpO2Zvcih0PWM7bnVsbCE9PXQ7KXt2YXIgZD0hMSxlPXZvaWQgMDt0cnl7Zm9yKDtudWxsIT09dDspe3ZhciBmPXQuZWZmZWN0VGFnO2YmMTYmJnpnKHQpO2lmKGYmMTI4KXt2YXIgZz10LmFsdGVybmF0ZTtudWxsIT09ZyYmQWcoZyl9c3dpdGNoKGYmLTI0Mil7Y2FzZSAyOk5lKHQpO3QuZWZmZWN0VGFnJj0tMzticmVhaztjYXNlIDY6TmUodCk7dC5lZmZlY3RUYWcmPS0zO09lKHQuYWx0ZXJuYXRlLHQpO2JyZWFrO2Nhc2UgNDpPZSh0LmFsdGVybmF0ZSxcbnQpO2JyZWFrO2Nhc2UgODpTYz0hMCxCZyh0KSxTYz0hMX10PXQubmV4dEVmZmVjdH19Y2F0Y2goVGMpe2Q9ITAsZT1UY31kJiYobnVsbD09PXQ/RShcIjE3OFwiKTp2b2lkIDAsaCh0LGUpLG51bGwhPT10JiYodD10Lm5leHRFZmZlY3QpKX1DZygpO2IuY3VycmVudD1hO2Zvcih0PWM7bnVsbCE9PXQ7KXtjPSExO2Q9dm9pZCAwO3RyeXtmb3IoO251bGwhPT10Oyl7dmFyIGs9dC5lZmZlY3RUYWc7ayYzNiYmRGcodC5hbHRlcm5hdGUsdCk7ayYxMjgmJkVnKHQpO2lmKGsmNjQpc3dpdGNoKGU9dCxmPXZvaWQgMCxudWxsIT09UiYmKGY9Ui5nZXQoZSksUltcImRlbGV0ZVwiXShlKSxudWxsPT1mJiZudWxsIT09ZS5hbHRlcm5hdGUmJihlPWUuYWx0ZXJuYXRlLGY9Ui5nZXQoZSksUltcImRlbGV0ZVwiXShlKSkpLG51bGw9PWY/RShcIjE4NFwiKTp2b2lkIDAsZS50YWcpe2Nhc2UgMjplLnN0YXRlTm9kZS5jb21wb25lbnREaWRDYXRjaChmLmVycm9yLHtjb21wb25lbnRTdGFjazpmLmNvbXBvbmVudFN0YWNrfSk7XG5icmVhaztjYXNlIDM6bnVsbD09PWNhJiYoY2E9Zi5lcnJvcik7YnJlYWs7ZGVmYXVsdDpFKFwiMTU3XCIpfXZhciBRYz10Lm5leHRFZmZlY3Q7dC5uZXh0RWZmZWN0PW51bGw7dD1RY319Y2F0Y2goVGMpe2M9ITAsZD1UY31jJiYobnVsbD09PXQ/RShcIjE3OFwiKTp2b2lkIDAsaCh0LGQpLG51bGwhPT10JiYodD10Lm5leHRFZmZlY3QpKX1qYT1RYj0hMTtcImZ1bmN0aW9uXCI9PT10eXBlb2YgRGUmJkRlKGEuc3RhdGVOb2RlKTtoYSYmKGhhLmZvckVhY2goRyksaGE9bnVsbCk7bnVsbCE9PWNhJiYoYT1jYSxjYT1udWxsLE9iKGEpKTtiPWIuY3VycmVudC5leHBpcmF0aW9uVGltZTswPT09YiYmKHFhPVI9bnVsbCk7cmV0dXJuIGJ9ZnVuY3Rpb24gYyhhKXtmb3IoOzspe3ZhciBiPUZnKGEuYWx0ZXJuYXRlLGEsSCksYz1hW1wicmV0dXJuXCJdLGQ9YS5zaWJsaW5nO3ZhciBlPWE7aWYoMjE0NzQ4MzY0Nz09PUh8fDIxNDc0ODM2NDchPT1lLmV4cGlyYXRpb25UaW1lKXtpZigyIT09ZS50YWcmJjMhPT1cbmUudGFnKXZhciBmPTA7ZWxzZSBmPWUudXBkYXRlUXVldWUsZj1udWxsPT09Zj8wOmYuZXhwaXJhdGlvblRpbWU7Zm9yKHZhciBnPWUuY2hpbGQ7bnVsbCE9PWc7KTAhPT1nLmV4cGlyYXRpb25UaW1lJiYoMD09PWZ8fGY+Zy5leHBpcmF0aW9uVGltZSkmJihmPWcuZXhwaXJhdGlvblRpbWUpLGc9Zy5zaWJsaW5nO2UuZXhwaXJhdGlvblRpbWU9Zn1pZihudWxsIT09YilyZXR1cm4gYjtudWxsIT09YyYmKG51bGw9PT1jLmZpcnN0RWZmZWN0JiYoYy5maXJzdEVmZmVjdD1hLmZpcnN0RWZmZWN0KSxudWxsIT09YS5sYXN0RWZmZWN0JiYobnVsbCE9PWMubGFzdEVmZmVjdCYmKGMubGFzdEVmZmVjdC5uZXh0RWZmZWN0PWEuZmlyc3RFZmZlY3QpLGMubGFzdEVmZmVjdD1hLmxhc3RFZmZlY3QpLDE8YS5lZmZlY3RUYWcmJihudWxsIT09Yy5sYXN0RWZmZWN0P2MubGFzdEVmZmVjdC5uZXh0RWZmZWN0PWE6Yy5maXJzdEVmZmVjdD1hLGMubGFzdEVmZmVjdD1hKSk7aWYobnVsbCE9PWQpcmV0dXJuIGQ7XG5pZihudWxsIT09YylhPWM7ZWxzZXthLnN0YXRlTm9kZS5pc1JlYWR5Rm9yQ29tbWl0PSEwO2JyZWFrfX1yZXR1cm4gbnVsbH1mdW5jdGlvbiBkKGEpe3ZhciBiPXJnKGEuYWx0ZXJuYXRlLGEsSCk7bnVsbD09PWImJihiPWMoYSkpO2lkLmN1cnJlbnQ9bnVsbDtyZXR1cm4gYn1mdW5jdGlvbiBlKGEpe3ZhciBiPUdnKGEuYWx0ZXJuYXRlLGEsSCk7bnVsbD09PWImJihiPWMoYSkpO2lkLmN1cnJlbnQ9bnVsbDtyZXR1cm4gYn1mdW5jdGlvbiBmKGEpe2lmKG51bGwhPT1SKXtpZighKDA9PT1IfHxIPmEpKWlmKEg8PVVjKWZvcig7bnVsbCE9PUY7KUY9ayhGKT9lKEYpOmQoRik7ZWxzZSBmb3IoO251bGwhPT1GJiYhQSgpOylGPWsoRik/ZShGKTpkKEYpfWVsc2UgaWYoISgwPT09SHx8SD5hKSlpZihIPD1VYylmb3IoO251bGwhPT1GOylGPWQoRik7ZWxzZSBmb3IoO251bGwhPT1GJiYhQSgpOylGPWQoRil9ZnVuY3Rpb24gZyhhLGIpe2phP0UoXCIyNDNcIik6dm9pZCAwO2phPSEwO2EuaXNSZWFkeUZvckNvbW1pdD1cbiExO2lmKGEhPT1yYXx8YiE9PUh8fG51bGw9PT1GKXtmb3IoOy0xPGhlOylnZVtoZV09bnVsbCxoZS0tO2plPUQ7aWUuY3VycmVudD1EO1guY3VycmVudD0hMTt4KCk7cmE9YTtIPWI7Rj1zZShyYS5jdXJyZW50LG51bGwsYil9dmFyIGM9ITEsZD1udWxsO3RyeXtmKGIpfWNhdGNoKFJjKXtjPSEwLGQ9UmN9Zm9yKDtjOyl7aWYoZWIpe2NhPWQ7YnJlYWt9dmFyIGc9RjtpZihudWxsPT09ZyllYj0hMDtlbHNle3ZhciBrPWgoZyxkKTtudWxsPT09az9FKFwiMTgzXCIpOnZvaWQgMDtpZighZWIpe3RyeXtjPWs7ZD1iO2ZvcihrPWM7bnVsbCE9PWc7KXtzd2l0Y2goZy50YWcpe2Nhc2UgMjpuZShnKTticmVhaztjYXNlIDU6cWcoZyk7YnJlYWs7Y2FzZSAzOnAoZyk7YnJlYWs7Y2FzZSA0OnAoZyl9aWYoZz09PWt8fGcuYWx0ZXJuYXRlPT09aylicmVhaztnPWdbXCJyZXR1cm5cIl19Rj1lKGMpO2YoZCl9Y2F0Y2goUmMpe2M9ITA7ZD1SYztjb250aW51ZX1icmVha319fWI9Y2E7ZWI9amE9ITE7Y2E9XG5udWxsO251bGwhPT1iJiZPYihiKTtyZXR1cm4gYS5pc1JlYWR5Rm9yQ29tbWl0P2EuY3VycmVudC5hbHRlcm5hdGU6bnVsbH1mdW5jdGlvbiBoKGEsYil7dmFyIGM9aWQuY3VycmVudD1udWxsLGQ9ITEsZT0hMSxmPW51bGw7aWYoMz09PWEudGFnKWM9YSxxKGEpJiYoZWI9ITApO2Vsc2UgZm9yKHZhciBnPWFbXCJyZXR1cm5cIl07bnVsbCE9PWcmJm51bGw9PT1jOyl7Mj09PWcudGFnP1wiZnVuY3Rpb25cIj09PXR5cGVvZiBnLnN0YXRlTm9kZS5jb21wb25lbnREaWRDYXRjaCYmKGQ9ITAsZj1qZChnKSxjPWcsZT0hMCk6Mz09PWcudGFnJiYoYz1nKTtpZihxKGcpKXtpZihTY3x8bnVsbCE9PWhhJiYoaGEuaGFzKGcpfHxudWxsIT09Zy5hbHRlcm5hdGUmJmhhLmhhcyhnLmFsdGVybmF0ZSkpKXJldHVybiBudWxsO2M9bnVsbDtlPSExfWc9Z1tcInJldHVyblwiXX1pZihudWxsIT09Yyl7bnVsbD09PXFhJiYocWE9bmV3IFNldCk7cWEuYWRkKGMpO3ZhciBoPVwiXCI7Zz1hO2Rve2E6c3dpdGNoKGcudGFnKXtjYXNlIDA6Y2FzZSAxOmNhc2UgMjpjYXNlIDU6dmFyIGs9XG5nLl9kZWJ1Z093bmVyLFFjPWcuX2RlYnVnU291cmNlO3ZhciBtPWpkKGcpO3ZhciBuPW51bGw7ayYmKG49amQoaykpO2s9UWM7bT1cIlxcbiAgICBpbiBcIisobXx8XCJVbmtub3duXCIpKyhrP1wiIChhdCBcIitrLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sXCJcIikrXCI6XCIray5saW5lTnVtYmVyK1wiKVwiOm4/XCIgKGNyZWF0ZWQgYnkgXCIrbitcIilcIjpcIlwiKTticmVhayBhO2RlZmF1bHQ6bT1cIlwifWgrPW07Zz1nW1wicmV0dXJuXCJdfXdoaWxlKGcpO2c9aDthPWpkKGEpO251bGw9PT1SJiYoUj1uZXcgTWFwKTtiPXtjb21wb25lbnROYW1lOmEsY29tcG9uZW50U3RhY2s6ZyxlcnJvcjpiLGVycm9yQm91bmRhcnk6ZD9jLnN0YXRlTm9kZTpudWxsLGVycm9yQm91bmRhcnlGb3VuZDpkLGVycm9yQm91bmRhcnlOYW1lOmYsd2lsbFJldHJ5OmV9O1Iuc2V0KGMsYik7dHJ5e3ZhciBwPWIuZXJyb3I7cCYmcC5zdXBwcmVzc1JlYWN0RXJyb3JMb2dnaW5nfHxjb25zb2xlLmVycm9yKHApfWNhdGNoKFZjKXtWYyYmXG5WYy5zdXBwcmVzc1JlYWN0RXJyb3JMb2dnaW5nfHxjb25zb2xlLmVycm9yKFZjKX1RYj8obnVsbD09PWhhJiYoaGE9bmV3IFNldCksaGEuYWRkKGMpKTpHKGMpO3JldHVybiBjfW51bGw9PT1jYSYmKGNhPWIpO3JldHVybiBudWxsfWZ1bmN0aW9uIGsoYSl7cmV0dXJuIG51bGwhPT1SJiYoUi5oYXMoYSl8fG51bGwhPT1hLmFsdGVybmF0ZSYmUi5oYXMoYS5hbHRlcm5hdGUpKX1mdW5jdGlvbiBxKGEpe3JldHVybiBudWxsIT09cWEmJihxYS5oYXMoYSl8fG51bGwhPT1hLmFsdGVybmF0ZSYmcWEuaGFzKGEuYWx0ZXJuYXRlKSl9ZnVuY3Rpb24gdigpe3JldHVybiAyMCooKChJKCkrMTAwKS8yMHwwKSsxKX1mdW5jdGlvbiB5KGEpe3JldHVybiAwIT09a2E/a2E6amE/UWI/MTpIOiFIZ3x8YS5pbnRlcm5hbENvbnRleHRUYWcmMT92KCk6MX1mdW5jdGlvbiB1KGEsYil7cmV0dXJuIHooYSxiLCExKX1mdW5jdGlvbiB6KGEsYil7Zm9yKDtudWxsIT09YTspe2lmKDA9PT1hLmV4cGlyYXRpb25UaW1lfHxcbmEuZXhwaXJhdGlvblRpbWU+YilhLmV4cGlyYXRpb25UaW1lPWI7bnVsbCE9PWEuYWx0ZXJuYXRlJiYoMD09PWEuYWx0ZXJuYXRlLmV4cGlyYXRpb25UaW1lfHxhLmFsdGVybmF0ZS5leHBpcmF0aW9uVGltZT5iKSYmKGEuYWx0ZXJuYXRlLmV4cGlyYXRpb25UaW1lPWIpO2lmKG51bGw9PT1hW1wicmV0dXJuXCJdKWlmKDM9PT1hLnRhZyl7dmFyIGM9YS5zdGF0ZU5vZGU7IWphJiZjPT09cmEmJmI8SCYmKEY9cmE9bnVsbCxIPTApO3ZhciBkPWMsZT1iO1JiPklnJiZFKFwiMTg1XCIpO2lmKG51bGw9PT1kLm5leHRTY2hlZHVsZWRSb290KWQucmVtYWluaW5nRXhwaXJhdGlvblRpbWU9ZSxudWxsPT09Tz8oc2E9Tz1kLGQubmV4dFNjaGVkdWxlZFJvb3Q9ZCk6KE89Ty5uZXh0U2NoZWR1bGVkUm9vdD1kLE8ubmV4dFNjaGVkdWxlZFJvb3Q9c2EpO2Vsc2V7dmFyIGY9ZC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZTtpZigwPT09Znx8ZTxmKWQucmVtYWluaW5nRXhwaXJhdGlvblRpbWU9ZX1GYXx8KGxhP1xuU2ImJihtYT1kLG5hPTEsbShtYSxuYSkpOjE9PT1lP3coMSxudWxsKTpMKGUpKTshamEmJmM9PT1yYSYmYjxIJiYoRj1yYT1udWxsLEg9MCl9ZWxzZSBicmVhazthPWFbXCJyZXR1cm5cIl19fWZ1bmN0aW9uIEcoYSl7eihhLDEsITApfWZ1bmN0aW9uIEkoKXtyZXR1cm4gVWM9KChXYygpLVBlKS8xMHwwKSsyfWZ1bmN0aW9uIEwoYSl7aWYoMCE9PVRiKXtpZihhPlRiKXJldHVybjtKZyhYYyl9dmFyIGI9V2MoKS1QZTtUYj1hO1hjPUtnKEose3RpbWVvdXQ6MTAqKGEtMiktYn0pfWZ1bmN0aW9uIE4oKXt2YXIgYT0wLGI9bnVsbDtpZihudWxsIT09Tylmb3IodmFyIGM9TyxkPXNhO251bGwhPT1kOyl7dmFyIGU9ZC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZTtpZigwPT09ZSl7bnVsbD09PWN8fG51bGw9PT1PP0UoXCIyNDRcIik6dm9pZCAwO2lmKGQ9PT1kLm5leHRTY2hlZHVsZWRSb290KXtzYT1PPWQubmV4dFNjaGVkdWxlZFJvb3Q9bnVsbDticmVha31lbHNlIGlmKGQ9PT1zYSlzYT1lPWQubmV4dFNjaGVkdWxlZFJvb3QsXG5PLm5leHRTY2hlZHVsZWRSb290PWUsZC5uZXh0U2NoZWR1bGVkUm9vdD1udWxsO2Vsc2UgaWYoZD09PU8pe089YztPLm5leHRTY2hlZHVsZWRSb290PXNhO2QubmV4dFNjaGVkdWxlZFJvb3Q9bnVsbDticmVha31lbHNlIGMubmV4dFNjaGVkdWxlZFJvb3Q9ZC5uZXh0U2NoZWR1bGVkUm9vdCxkLm5leHRTY2hlZHVsZWRSb290PW51bGw7ZD1jLm5leHRTY2hlZHVsZWRSb290fWVsc2V7aWYoMD09PWF8fGU8YSlhPWUsYj1kO2lmKGQ9PT1PKWJyZWFrO2M9ZDtkPWQubmV4dFNjaGVkdWxlZFJvb3R9fWM9bWE7bnVsbCE9PWMmJmM9PT1iP1JiKys6UmI9MDttYT1iO25hPWF9ZnVuY3Rpb24gSihhKXt3KDAsYSl9ZnVuY3Rpb24gdyhhLGIpe2ZiPWI7Zm9yKE4oKTtudWxsIT09bWEmJjAhPT1uYSYmKDA9PT1hfHxuYTw9YSkmJiFZYzspbShtYSxuYSksTigpO251bGwhPT1mYiYmKFRiPTAsWGM9LTEpOzAhPT1uYSYmTChuYSk7ZmI9bnVsbDtZYz0hMTtSYj0wO2lmKFViKXRocm93IGE9WmMsWmM9XG5udWxsLFViPSExLGE7fWZ1bmN0aW9uIG0oYSxjKXtGYT9FKFwiMjQ1XCIpOnZvaWQgMDtGYT0hMDtpZihjPD1JKCkpe3ZhciBkPWEuZmluaXNoZWRXb3JrO251bGwhPT1kPyhhLmZpbmlzaGVkV29yaz1udWxsLGEucmVtYWluaW5nRXhwaXJhdGlvblRpbWU9YihkKSk6KGEuZmluaXNoZWRXb3JrPW51bGwsZD1nKGEsYyksbnVsbCE9PWQmJihhLnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lPWIoZCkpKX1lbHNlIGQ9YS5maW5pc2hlZFdvcmssbnVsbCE9PWQ/KGEuZmluaXNoZWRXb3JrPW51bGwsYS5yZW1haW5pbmdFeHBpcmF0aW9uVGltZT1iKGQpKTooYS5maW5pc2hlZFdvcms9bnVsbCxkPWcoYSxjKSxudWxsIT09ZCYmKEEoKT9hLmZpbmlzaGVkV29yaz1kOmEucmVtYWluaW5nRXhwaXJhdGlvblRpbWU9YihkKSkpO0ZhPSExfWZ1bmN0aW9uIEEoKXtyZXR1cm4gbnVsbD09PWZifHxmYi50aW1lUmVtYWluaW5nKCk+TGc/ITE6WWM9ITB9ZnVuY3Rpb24gT2IoYSl7bnVsbD09PW1hP0UoXCIyNDZcIik6XG52b2lkIDA7bWEucmVtYWluaW5nRXhwaXJhdGlvblRpbWU9MDtVYnx8KFViPSEwLFpjPWEpfXZhciByPWhmKGEpLG49amYoYSkscD1yLnBvcEhvc3RDb250YWluZXIscWc9ci5wb3BIb3N0Q29udGV4dCx4PXIucmVzZXRIb3N0Q29udGFpbmVyLE1lPWRmKGEscixuLHUseSkscmc9TWUuYmVnaW5Xb3JrLEdnPU1lLmJlZ2luRmFpbGVkV29yayxGZz1lZihhLHIsbikuY29tcGxldGVXb3JrO3I9ZmYoYSxoKTt2YXIgemc9ci5jb21taXRSZXNldFRleHRDb250ZW50LE5lPXIuY29tbWl0UGxhY2VtZW50LEJnPXIuY29tbWl0RGVsZXRpb24sT2U9ci5jb21taXRXb3JrLERnPXIuY29tbWl0TGlmZUN5Y2xlcyxFZz1yLmNvbW1pdEF0dGFjaFJlZixBZz1yLmNvbW1pdERldGFjaFJlZixXYz1hLm5vdyxLZz1hLnNjaGVkdWxlRGVmZXJyZWRDYWxsYmFjayxKZz1hLmNhbmNlbERlZmVycmVkQ2FsbGJhY2ssSGc9YS51c2VTeW5jU2NoZWR1bGluZyx5Zz1hLnByZXBhcmVGb3JDb21taXQsQ2c9YS5yZXNldEFmdGVyQ29tbWl0LFxuUGU9V2MoKSxVYz0yLGthPTAsamE9ITEsRj1udWxsLHJhPW51bGwsSD0wLHQ9bnVsbCxSPW51bGwscWE9bnVsbCxoYT1udWxsLGNhPW51bGwsZWI9ITEsUWI9ITEsU2M9ITEsc2E9bnVsbCxPPW51bGwsVGI9MCxYYz0tMSxGYT0hMSxtYT1udWxsLG5hPTAsWWM9ITEsVWI9ITEsWmM9bnVsbCxmYj1udWxsLGxhPSExLFNiPSExLElnPTFFMyxSYj0wLExnPTE7cmV0dXJue2NvbXB1dGVBc3luY0V4cGlyYXRpb246dixjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyOnksc2NoZWR1bGVXb3JrOnUsYmF0Y2hlZFVwZGF0ZXM6ZnVuY3Rpb24oYSxiKXt2YXIgYz1sYTtsYT0hMDt0cnl7cmV0dXJuIGEoYil9ZmluYWxseXsobGE9Yyl8fEZhfHx3KDEsbnVsbCl9fSx1bmJhdGNoZWRVcGRhdGVzOmZ1bmN0aW9uKGEpe2lmKGxhJiYhU2Ipe1NiPSEwO3RyeXtyZXR1cm4gYSgpfWZpbmFsbHl7U2I9ITF9fXJldHVybiBhKCl9LGZsdXNoU3luYzpmdW5jdGlvbihhKXt2YXIgYj1sYTtsYT0hMDt0cnl7YTp7dmFyIGM9XG5rYTtrYT0xO3RyeXt2YXIgZD1hKCk7YnJlYWsgYX1maW5hbGx5e2thPWN9ZD12b2lkIDB9cmV0dXJuIGR9ZmluYWxseXtsYT1iLEZhP0UoXCIxODdcIik6dm9pZCAwLHcoMSxudWxsKX19LGRlZmVycmVkVXBkYXRlczpmdW5jdGlvbihhKXt2YXIgYj1rYTtrYT12KCk7dHJ5e3JldHVybiBhKCl9ZmluYWxseXtrYT1ifX19fVxuZnVuY3Rpb24gbGYoYSl7ZnVuY3Rpb24gYihhKXthPW9kKGEpO3JldHVybiBudWxsPT09YT9udWxsOmEuc3RhdGVOb2RlfXZhciBjPWEuZ2V0UHVibGljSW5zdGFuY2U7YT1rZihhKTt2YXIgZD1hLmNvbXB1dGVBc3luY0V4cGlyYXRpb24sZT1hLmNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIsZj1hLnNjaGVkdWxlV29yaztyZXR1cm57Y3JlYXRlQ29udGFpbmVyOmZ1bmN0aW9uKGEsYil7dmFyIGM9bmV3IFkoMyxudWxsLDApO2E9e2N1cnJlbnQ6Yyxjb250YWluZXJJbmZvOmEscGVuZGluZ0NoaWxkcmVuOm51bGwscmVtYWluaW5nRXhwaXJhdGlvblRpbWU6MCxpc1JlYWR5Rm9yQ29tbWl0OiExLGZpbmlzaGVkV29yazpudWxsLGNvbnRleHQ6bnVsbCxwZW5kaW5nQ29udGV4dDpudWxsLGh5ZHJhdGU6YixuZXh0U2NoZWR1bGVkUm9vdDpudWxsfTtyZXR1cm4gYy5zdGF0ZU5vZGU9YX0sdXBkYXRlQ29udGFpbmVyOmZ1bmN0aW9uKGEsYixjLHEpe3ZhciBnPWIuY3VycmVudDtpZihjKXtjPVxuYy5fcmVhY3RJbnRlcm5hbEZpYmVyO3ZhciBoO2I6ezI9PT1rZChjKSYmMj09PWMudGFnP3ZvaWQgMDpFKFwiMTcwXCIpO2ZvcihoPWM7MyE9PWgudGFnOyl7aWYobGUoaCkpe2g9aC5zdGF0ZU5vZGUuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQ7YnJlYWsgYn0oaD1oW1wicmV0dXJuXCJdKT92b2lkIDA6RShcIjE3MVwiKX1oPWguc3RhdGVOb2RlLmNvbnRleHR9Yz1sZShjKT9wZShjLGgpOmh9ZWxzZSBjPUQ7bnVsbD09PWIuY29udGV4dD9iLmNvbnRleHQ9YzpiLnBlbmRpbmdDb250ZXh0PWM7Yj1xO2I9dm9pZCAwPT09Yj9udWxsOmI7cT1udWxsIT1hJiZudWxsIT1hLnR5cGUmJm51bGwhPWEudHlwZS5wcm90b3R5cGUmJiEwPT09YS50eXBlLnByb3RvdHlwZS51bnN0YWJsZV9pc0FzeW5jUmVhY3RDb21wb25lbnQ/ZCgpOmUoZyk7SGUoZyx7ZXhwaXJhdGlvblRpbWU6cSxwYXJ0aWFsU3RhdGU6e2VsZW1lbnQ6YX0sY2FsbGJhY2s6Yixpc1JlcGxhY2U6ITEsaXNGb3JjZWQ6ITEsXG5uZXh0Q2FsbGJhY2s6bnVsbCxuZXh0Om51bGx9KTtmKGcscSl9LGJhdGNoZWRVcGRhdGVzOmEuYmF0Y2hlZFVwZGF0ZXMsdW5iYXRjaGVkVXBkYXRlczphLnVuYmF0Y2hlZFVwZGF0ZXMsZGVmZXJyZWRVcGRhdGVzOmEuZGVmZXJyZWRVcGRhdGVzLGZsdXNoU3luYzphLmZsdXNoU3luYyxnZXRQdWJsaWNSb290SW5zdGFuY2U6ZnVuY3Rpb24oYSl7YT1hLmN1cnJlbnQ7aWYoIWEuY2hpbGQpcmV0dXJuIG51bGw7c3dpdGNoKGEuY2hpbGQudGFnKXtjYXNlIDU6cmV0dXJuIGMoYS5jaGlsZC5zdGF0ZU5vZGUpO2RlZmF1bHQ6cmV0dXJuIGEuY2hpbGQuc3RhdGVOb2RlfX0sZmluZEhvc3RJbnN0YW5jZTpiLGZpbmRIb3N0SW5zdGFuY2VXaXRoTm9Qb3J0YWxzOmZ1bmN0aW9uKGEpe2E9cGQoYSk7cmV0dXJuIG51bGw9PT1hP251bGw6YS5zdGF0ZU5vZGV9LGluamVjdEludG9EZXZUb29sczpmdW5jdGlvbihhKXt2YXIgYz1hLmZpbmRGaWJlckJ5SG9zdEluc3RhbmNlO3JldHVybiBDZShCKHt9LFxuYSx7ZmluZEhvc3RJbnN0YW5jZUJ5RmliZXI6ZnVuY3Rpb24oYSl7cmV0dXJuIGIoYSl9LGZpbmRGaWJlckJ5SG9zdEluc3RhbmNlOmZ1bmN0aW9uKGEpe3JldHVybiBjP2MoYSk6bnVsbH19KSl9fX12YXIgbWY9T2JqZWN0LmZyZWV6ZSh7ZGVmYXVsdDpsZn0pLG5mPW1mJiZsZnx8bWYsb2Y9bmZbXCJkZWZhdWx0XCJdP25mW1wiZGVmYXVsdFwiXTpuZjtmdW5jdGlvbiBwZihhLGIsYyl7dmFyIGQ9Mzxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbM10/YXJndW1lbnRzWzNdOm51bGw7cmV0dXJueyQkdHlwZW9mOlVlLGtleTpudWxsPT1kP251bGw6XCJcIitkLGNoaWxkcmVuOmEsY29udGFpbmVySW5mbzpiLGltcGxlbWVudGF0aW9uOmN9fXZhciBxZj1cIm9iamVjdFwiPT09dHlwZW9mIHBlcmZvcm1hbmNlJiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgcGVyZm9ybWFuY2Uubm93LHJmPXZvaWQgMDtyZj1xZj9mdW5jdGlvbigpe3JldHVybiBwZXJmb3JtYW5jZS5ub3coKX06ZnVuY3Rpb24oKXtyZXR1cm4gRGF0ZS5ub3coKX07XG52YXIgc2Y9dm9pZCAwLHRmPXZvaWQgMDtcbmlmKGwuY2FuVXNlRE9NKWlmKFwiZnVuY3Rpb25cIiE9PXR5cGVvZiByZXF1ZXN0SWRsZUNhbGxiYWNrfHxcImZ1bmN0aW9uXCIhPT10eXBlb2YgY2FuY2VsSWRsZUNhbGxiYWNrKXt2YXIgdWY9bnVsbCx2Zj0hMSx3Zj0tMSx4Zj0hMSx5Zj0wLHpmPTMzLEFmPTMzLEJmO0JmPXFmP3tkaWRUaW1lb3V0OiExLHRpbWVSZW1haW5pbmc6ZnVuY3Rpb24oKXt2YXIgYT15Zi1wZXJmb3JtYW5jZS5ub3coKTtyZXR1cm4gMDxhP2E6MH19OntkaWRUaW1lb3V0OiExLHRpbWVSZW1haW5pbmc6ZnVuY3Rpb24oKXt2YXIgYT15Zi1EYXRlLm5vdygpO3JldHVybiAwPGE/YTowfX07dmFyIENmPVwiX19yZWFjdElkbGVDYWxsYmFjayRcIitNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTt3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIixmdW5jdGlvbihhKXtpZihhLnNvdXJjZT09PXdpbmRvdyYmYS5kYXRhPT09Q2Ype3ZmPSExO2E9cmYoKTtpZigwPj15Zi1hKWlmKC0xIT09d2YmJndmPD1cbmEpQmYuZGlkVGltZW91dD0hMDtlbHNle3hmfHwoeGY9ITAscmVxdWVzdEFuaW1hdGlvbkZyYW1lKERmKSk7cmV0dXJufWVsc2UgQmYuZGlkVGltZW91dD0hMTt3Zj0tMTthPXVmO3VmPW51bGw7bnVsbCE9PWEmJmEoQmYpfX0sITEpO3ZhciBEZj1mdW5jdGlvbihhKXt4Zj0hMTt2YXIgYj1hLXlmK0FmO2I8QWYmJnpmPEFmPyg4PmImJihiPTgpLEFmPWI8emY/emY6Yik6emY9Yjt5Zj1hK0FmO3ZmfHwodmY9ITAsd2luZG93LnBvc3RNZXNzYWdlKENmLFwiKlwiKSl9O3NmPWZ1bmN0aW9uKGEsYil7dWY9YTtudWxsIT1iJiZcIm51bWJlclwiPT09dHlwZW9mIGIudGltZW91dCYmKHdmPXJmKCkrYi50aW1lb3V0KTt4Znx8KHhmPSEwLHJlcXVlc3RBbmltYXRpb25GcmFtZShEZikpO3JldHVybiAwfTt0Zj1mdW5jdGlvbigpe3VmPW51bGw7dmY9ITE7d2Y9LTF9fWVsc2Ugc2Y9d2luZG93LnJlcXVlc3RJZGxlQ2FsbGJhY2ssdGY9d2luZG93LmNhbmNlbElkbGVDYWxsYmFjaztlbHNlIHNmPWZ1bmN0aW9uKGEpe3JldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7YSh7dGltZVJlbWFpbmluZzpmdW5jdGlvbigpe3JldHVybiBJbmZpbml0eX19KX0pfSxcbnRmPWZ1bmN0aW9uKGEpe2NsZWFyVGltZW91dChhKX07dmFyIEVmPS9eWzpBLVpfYS16XFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2XFx1MDBGOC1cXHUwMkZGXFx1MDM3MC1cXHUwMzdEXFx1MDM3Ri1cXHUxRkZGXFx1MjAwQy1cXHUyMDBEXFx1MjA3MC1cXHUyMThGXFx1MkMwMC1cXHUyRkVGXFx1MzAwMS1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkZEXVs6QS1aX2EtelxcdTAwQzAtXFx1MDBENlxcdTAwRDgtXFx1MDBGNlxcdTAwRjgtXFx1MDJGRlxcdTAzNzAtXFx1MDM3RFxcdTAzN0YtXFx1MUZGRlxcdTIwMEMtXFx1MjAwRFxcdTIwNzAtXFx1MjE4RlxcdTJDMDAtXFx1MkZFRlxcdTMwMDEtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZGRFxcLS4wLTlcXHUwMEI3XFx1MDMwMC1cXHUwMzZGXFx1MjAzRi1cXHUyMDQwXSokLyxGZj17fSxHZj17fTtcbmZ1bmN0aW9uIEhmKGEpe2lmKEdmLmhhc093blByb3BlcnR5KGEpKXJldHVybiEwO2lmKEZmLmhhc093blByb3BlcnR5KGEpKXJldHVybiExO2lmKEVmLnRlc3QoYSkpcmV0dXJuIEdmW2FdPSEwO0ZmW2FdPSEwO3JldHVybiExfVxuZnVuY3Rpb24gSWYoYSxiLGMpe3ZhciBkPXdhKGIpO2lmKGQmJnZhKGIsYykpe3ZhciBlPWQubXV0YXRpb25NZXRob2Q7ZT9lKGEsYyk6bnVsbD09Y3x8ZC5oYXNCb29sZWFuVmFsdWUmJiFjfHxkLmhhc051bWVyaWNWYWx1ZSYmaXNOYU4oYyl8fGQuaGFzUG9zaXRpdmVOdW1lcmljVmFsdWUmJjE+Y3x8ZC5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlJiYhMT09PWM/SmYoYSxiKTpkLm11c3RVc2VQcm9wZXJ0eT9hW2QucHJvcGVydHlOYW1lXT1jOihiPWQuYXR0cmlidXRlTmFtZSwoZT1kLmF0dHJpYnV0ZU5hbWVzcGFjZSk/YS5zZXRBdHRyaWJ1dGVOUyhlLGIsXCJcIitjKTpkLmhhc0Jvb2xlYW5WYWx1ZXx8ZC5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlJiYhMD09PWM/YS5zZXRBdHRyaWJ1dGUoYixcIlwiKTphLnNldEF0dHJpYnV0ZShiLFwiXCIrYykpfWVsc2UgS2YoYSxiLHZhKGIsYyk/YzpudWxsKX1cbmZ1bmN0aW9uIEtmKGEsYixjKXtIZihiKSYmKG51bGw9PWM/YS5yZW1vdmVBdHRyaWJ1dGUoYik6YS5zZXRBdHRyaWJ1dGUoYixcIlwiK2MpKX1mdW5jdGlvbiBKZihhLGIpe3ZhciBjPXdhKGIpO2M/KGI9Yy5tdXRhdGlvbk1ldGhvZCk/YihhLHZvaWQgMCk6Yy5tdXN0VXNlUHJvcGVydHk/YVtjLnByb3BlcnR5TmFtZV09Yy5oYXNCb29sZWFuVmFsdWU/ITE6XCJcIjphLnJlbW92ZUF0dHJpYnV0ZShjLmF0dHJpYnV0ZU5hbWUpOmEucmVtb3ZlQXR0cmlidXRlKGIpfVxuZnVuY3Rpb24gTGYoYSxiKXt2YXIgYz1iLnZhbHVlLGQ9Yi5jaGVja2VkO3JldHVybiBCKHt0eXBlOnZvaWQgMCxzdGVwOnZvaWQgMCxtaW46dm9pZCAwLG1heDp2b2lkIDB9LGIse2RlZmF1bHRDaGVja2VkOnZvaWQgMCxkZWZhdWx0VmFsdWU6dm9pZCAwLHZhbHVlOm51bGwhPWM/YzphLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlLGNoZWNrZWQ6bnVsbCE9ZD9kOmEuX3dyYXBwZXJTdGF0ZS5pbml0aWFsQ2hlY2tlZH0pfWZ1bmN0aW9uIE1mKGEsYil7dmFyIGM9Yi5kZWZhdWx0VmFsdWU7YS5fd3JhcHBlclN0YXRlPXtpbml0aWFsQ2hlY2tlZDpudWxsIT1iLmNoZWNrZWQ/Yi5jaGVja2VkOmIuZGVmYXVsdENoZWNrZWQsaW5pdGlhbFZhbHVlOm51bGwhPWIudmFsdWU/Yi52YWx1ZTpjLGNvbnRyb2xsZWQ6XCJjaGVja2JveFwiPT09Yi50eXBlfHxcInJhZGlvXCI9PT1iLnR5cGU/bnVsbCE9Yi5jaGVja2VkOm51bGwhPWIudmFsdWV9fVxuZnVuY3Rpb24gTmYoYSxiKXtiPWIuY2hlY2tlZDtudWxsIT1iJiZJZihhLFwiY2hlY2tlZFwiLGIpfWZ1bmN0aW9uIE9mKGEsYil7TmYoYSxiKTt2YXIgYz1iLnZhbHVlO2lmKG51bGwhPWMpaWYoMD09PWMmJlwiXCI9PT1hLnZhbHVlKWEudmFsdWU9XCIwXCI7ZWxzZSBpZihcIm51bWJlclwiPT09Yi50eXBlKXtpZihiPXBhcnNlRmxvYXQoYS52YWx1ZSl8fDAsYyE9Ynx8Yz09YiYmYS52YWx1ZSE9YylhLnZhbHVlPVwiXCIrY31lbHNlIGEudmFsdWUhPT1cIlwiK2MmJihhLnZhbHVlPVwiXCIrYyk7ZWxzZSBudWxsPT1iLnZhbHVlJiZudWxsIT1iLmRlZmF1bHRWYWx1ZSYmYS5kZWZhdWx0VmFsdWUhPT1cIlwiK2IuZGVmYXVsdFZhbHVlJiYoYS5kZWZhdWx0VmFsdWU9XCJcIitiLmRlZmF1bHRWYWx1ZSksbnVsbD09Yi5jaGVja2VkJiZudWxsIT1iLmRlZmF1bHRDaGVja2VkJiYoYS5kZWZhdWx0Q2hlY2tlZD0hIWIuZGVmYXVsdENoZWNrZWQpfVxuZnVuY3Rpb24gUGYoYSxiKXtzd2l0Y2goYi50eXBlKXtjYXNlIFwic3VibWl0XCI6Y2FzZSBcInJlc2V0XCI6YnJlYWs7Y2FzZSBcImNvbG9yXCI6Y2FzZSBcImRhdGVcIjpjYXNlIFwiZGF0ZXRpbWVcIjpjYXNlIFwiZGF0ZXRpbWUtbG9jYWxcIjpjYXNlIFwibW9udGhcIjpjYXNlIFwidGltZVwiOmNhc2UgXCJ3ZWVrXCI6YS52YWx1ZT1cIlwiO2EudmFsdWU9YS5kZWZhdWx0VmFsdWU7YnJlYWs7ZGVmYXVsdDphLnZhbHVlPWEudmFsdWV9Yj1hLm5hbWU7XCJcIiE9PWImJihhLm5hbWU9XCJcIik7YS5kZWZhdWx0Q2hlY2tlZD0hYS5kZWZhdWx0Q2hlY2tlZDthLmRlZmF1bHRDaGVja2VkPSFhLmRlZmF1bHRDaGVja2VkO1wiXCIhPT1iJiYoYS5uYW1lPWIpfWZ1bmN0aW9uIFFmKGEpe3ZhciBiPVwiXCI7YWEuQ2hpbGRyZW4uZm9yRWFjaChhLGZ1bmN0aW9uKGEpe251bGw9PWF8fFwic3RyaW5nXCIhPT10eXBlb2YgYSYmXCJudW1iZXJcIiE9PXR5cGVvZiBhfHwoYis9YSl9KTtyZXR1cm4gYn1cbmZ1bmN0aW9uIFJmKGEsYil7YT1CKHtjaGlsZHJlbjp2b2lkIDB9LGIpO2lmKGI9UWYoYi5jaGlsZHJlbikpYS5jaGlsZHJlbj1iO3JldHVybiBhfWZ1bmN0aW9uIFNmKGEsYixjLGQpe2E9YS5vcHRpb25zO2lmKGIpe2I9e307Zm9yKHZhciBlPTA7ZTxjLmxlbmd0aDtlKyspYltcIiRcIitjW2VdXT0hMDtmb3IoYz0wO2M8YS5sZW5ndGg7YysrKWU9Yi5oYXNPd25Qcm9wZXJ0eShcIiRcIithW2NdLnZhbHVlKSxhW2NdLnNlbGVjdGVkIT09ZSYmKGFbY10uc2VsZWN0ZWQ9ZSksZSYmZCYmKGFbY10uZGVmYXVsdFNlbGVjdGVkPSEwKX1lbHNle2M9XCJcIitjO2I9bnVsbDtmb3IoZT0wO2U8YS5sZW5ndGg7ZSsrKXtpZihhW2VdLnZhbHVlPT09Yyl7YVtlXS5zZWxlY3RlZD0hMDtkJiYoYVtlXS5kZWZhdWx0U2VsZWN0ZWQ9ITApO3JldHVybn1udWxsIT09Ynx8YVtlXS5kaXNhYmxlZHx8KGI9YVtlXSl9bnVsbCE9PWImJihiLnNlbGVjdGVkPSEwKX19XG5mdW5jdGlvbiBUZihhLGIpe3ZhciBjPWIudmFsdWU7YS5fd3JhcHBlclN0YXRlPXtpbml0aWFsVmFsdWU6bnVsbCE9Yz9jOmIuZGVmYXVsdFZhbHVlLHdhc011bHRpcGxlOiEhYi5tdWx0aXBsZX19ZnVuY3Rpb24gVWYoYSxiKXtudWxsIT1iLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MP0UoXCI5MVwiKTp2b2lkIDA7cmV0dXJuIEIoe30sYix7dmFsdWU6dm9pZCAwLGRlZmF1bHRWYWx1ZTp2b2lkIDAsY2hpbGRyZW46XCJcIithLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlfSl9ZnVuY3Rpb24gVmYoYSxiKXt2YXIgYz1iLnZhbHVlO251bGw9PWMmJihjPWIuZGVmYXVsdFZhbHVlLGI9Yi5jaGlsZHJlbixudWxsIT1iJiYobnVsbCE9Yz9FKFwiOTJcIik6dm9pZCAwLEFycmF5LmlzQXJyYXkoYikmJigxPj1iLmxlbmd0aD92b2lkIDA6RShcIjkzXCIpLGI9YlswXSksYz1cIlwiK2IpLG51bGw9PWMmJihjPVwiXCIpKTthLl93cmFwcGVyU3RhdGU9e2luaXRpYWxWYWx1ZTpcIlwiK2N9fVxuZnVuY3Rpb24gV2YoYSxiKXt2YXIgYz1iLnZhbHVlO251bGwhPWMmJihjPVwiXCIrYyxjIT09YS52YWx1ZSYmKGEudmFsdWU9YyksbnVsbD09Yi5kZWZhdWx0VmFsdWUmJihhLmRlZmF1bHRWYWx1ZT1jKSk7bnVsbCE9Yi5kZWZhdWx0VmFsdWUmJihhLmRlZmF1bHRWYWx1ZT1iLmRlZmF1bHRWYWx1ZSl9ZnVuY3Rpb24gWGYoYSl7dmFyIGI9YS50ZXh0Q29udGVudDtiPT09YS5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSYmKGEudmFsdWU9Yil9dmFyIFlmPXtodG1sOlwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiLG1hdGhtbDpcImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIixzdmc6XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wifTtcbmZ1bmN0aW9uIFpmKGEpe3N3aXRjaChhKXtjYXNlIFwic3ZnXCI6cmV0dXJuXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiO2Nhc2UgXCJtYXRoXCI6cmV0dXJuXCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MXCI7ZGVmYXVsdDpyZXR1cm5cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIn19ZnVuY3Rpb24gJGYoYSxiKXtyZXR1cm4gbnVsbD09YXx8XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCI9PT1hP1pmKGIpOlwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj09PWEmJlwiZm9yZWlnbk9iamVjdFwiPT09Yj9cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIjphfVxudmFyIGFnPXZvaWQgMCxiZz1mdW5jdGlvbihhKXtyZXR1cm5cInVuZGVmaW5lZFwiIT09dHlwZW9mIE1TQXBwJiZNU0FwcC5leGVjVW5zYWZlTG9jYWxGdW5jdGlvbj9mdW5jdGlvbihiLGMsZCxlKXtNU0FwcC5leGVjVW5zYWZlTG9jYWxGdW5jdGlvbihmdW5jdGlvbigpe3JldHVybiBhKGIsYyxkLGUpfSl9OmF9KGZ1bmN0aW9uKGEsYil7aWYoYS5uYW1lc3BhY2VVUkkhPT1ZZi5zdmd8fFwiaW5uZXJIVE1MXCJpbiBhKWEuaW5uZXJIVE1MPWI7ZWxzZXthZz1hZ3x8ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTthZy5pbm5lckhUTUw9XCJcXHgzY3N2Z1xceDNlXCIrYitcIlxceDNjL3N2Z1xceDNlXCI7Zm9yKGI9YWcuZmlyc3RDaGlsZDthLmZpcnN0Q2hpbGQ7KWEucmVtb3ZlQ2hpbGQoYS5maXJzdENoaWxkKTtmb3IoO2IuZmlyc3RDaGlsZDspYS5hcHBlbmRDaGlsZChiLmZpcnN0Q2hpbGQpfX0pO1xuZnVuY3Rpb24gY2coYSxiKXtpZihiKXt2YXIgYz1hLmZpcnN0Q2hpbGQ7aWYoYyYmYz09PWEubGFzdENoaWxkJiYzPT09Yy5ub2RlVHlwZSl7Yy5ub2RlVmFsdWU9YjtyZXR1cm59fWEudGV4dENvbnRlbnQ9Yn1cbnZhciBkZz17YW5pbWF0aW9uSXRlcmF0aW9uQ291bnQ6ITAsYm9yZGVySW1hZ2VPdXRzZXQ6ITAsYm9yZGVySW1hZ2VTbGljZTohMCxib3JkZXJJbWFnZVdpZHRoOiEwLGJveEZsZXg6ITAsYm94RmxleEdyb3VwOiEwLGJveE9yZGluYWxHcm91cDohMCxjb2x1bW5Db3VudDohMCxjb2x1bW5zOiEwLGZsZXg6ITAsZmxleEdyb3c6ITAsZmxleFBvc2l0aXZlOiEwLGZsZXhTaHJpbms6ITAsZmxleE5lZ2F0aXZlOiEwLGZsZXhPcmRlcjohMCxncmlkUm93OiEwLGdyaWRSb3dFbmQ6ITAsZ3JpZFJvd1NwYW46ITAsZ3JpZFJvd1N0YXJ0OiEwLGdyaWRDb2x1bW46ITAsZ3JpZENvbHVtbkVuZDohMCxncmlkQ29sdW1uU3BhbjohMCxncmlkQ29sdW1uU3RhcnQ6ITAsZm9udFdlaWdodDohMCxsaW5lQ2xhbXA6ITAsbGluZUhlaWdodDohMCxvcGFjaXR5OiEwLG9yZGVyOiEwLG9ycGhhbnM6ITAsdGFiU2l6ZTohMCx3aWRvd3M6ITAsekluZGV4OiEwLHpvb206ITAsZmlsbE9wYWNpdHk6ITAsZmxvb2RPcGFjaXR5OiEwLFxuc3RvcE9wYWNpdHk6ITAsc3Ryb2tlRGFzaGFycmF5OiEwLHN0cm9rZURhc2hvZmZzZXQ6ITAsc3Ryb2tlTWl0ZXJsaW1pdDohMCxzdHJva2VPcGFjaXR5OiEwLHN0cm9rZVdpZHRoOiEwfSxlZz1bXCJXZWJraXRcIixcIm1zXCIsXCJNb3pcIixcIk9cIl07T2JqZWN0LmtleXMoZGcpLmZvckVhY2goZnVuY3Rpb24oYSl7ZWcuZm9yRWFjaChmdW5jdGlvbihiKXtiPWIrYS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSthLnN1YnN0cmluZygxKTtkZ1tiXT1kZ1thXX0pfSk7XG5mdW5jdGlvbiBmZyhhLGIpe2E9YS5zdHlsZTtmb3IodmFyIGMgaW4gYilpZihiLmhhc093blByb3BlcnR5KGMpKXt2YXIgZD0wPT09Yy5pbmRleE9mKFwiLS1cIik7dmFyIGU9Yzt2YXIgZj1iW2NdO2U9bnVsbD09Znx8XCJib29sZWFuXCI9PT10eXBlb2YgZnx8XCJcIj09PWY/XCJcIjpkfHxcIm51bWJlclwiIT09dHlwZW9mIGZ8fDA9PT1mfHxkZy5oYXNPd25Qcm9wZXJ0eShlKSYmZGdbZV0/KFwiXCIrZikudHJpbSgpOmYrXCJweFwiO1wiZmxvYXRcIj09PWMmJihjPVwiY3NzRmxvYXRcIik7ZD9hLnNldFByb3BlcnR5KGMsZSk6YVtjXT1lfX12YXIgZ2c9Qih7bWVudWl0ZW06ITB9LHthcmVhOiEwLGJhc2U6ITAsYnI6ITAsY29sOiEwLGVtYmVkOiEwLGhyOiEwLGltZzohMCxpbnB1dDohMCxrZXlnZW46ITAsbGluazohMCxtZXRhOiEwLHBhcmFtOiEwLHNvdXJjZTohMCx0cmFjazohMCx3YnI6ITB9KTtcbmZ1bmN0aW9uIGhnKGEsYixjKXtiJiYoZ2dbYV0mJihudWxsIT1iLmNoaWxkcmVufHxudWxsIT1iLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MP0UoXCIxMzdcIixhLGMoKSk6dm9pZCAwKSxudWxsIT1iLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MJiYobnVsbCE9Yi5jaGlsZHJlbj9FKFwiNjBcIik6dm9pZCAwLFwib2JqZWN0XCI9PT10eXBlb2YgYi5kYW5nZXJvdXNseVNldElubmVySFRNTCYmXCJfX2h0bWxcImluIGIuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw/dm9pZCAwOkUoXCI2MVwiKSksbnVsbCE9Yi5zdHlsZSYmXCJvYmplY3RcIiE9PXR5cGVvZiBiLnN0eWxlP0UoXCI2MlwiLGMoKSk6dm9pZCAwKX1cbmZ1bmN0aW9uIGlnKGEsYil7aWYoLTE9PT1hLmluZGV4T2YoXCItXCIpKXJldHVyblwic3RyaW5nXCI9PT10eXBlb2YgYi5pcztzd2l0Y2goYSl7Y2FzZSBcImFubm90YXRpb24teG1sXCI6Y2FzZSBcImNvbG9yLXByb2ZpbGVcIjpjYXNlIFwiZm9udC1mYWNlXCI6Y2FzZSBcImZvbnQtZmFjZS1zcmNcIjpjYXNlIFwiZm9udC1mYWNlLXVyaVwiOmNhc2UgXCJmb250LWZhY2UtZm9ybWF0XCI6Y2FzZSBcImZvbnQtZmFjZS1uYW1lXCI6Y2FzZSBcIm1pc3NpbmctZ2x5cGhcIjpyZXR1cm4hMTtkZWZhdWx0OnJldHVybiEwfX12YXIgamc9WWYuaHRtbCxrZz1DLnRoYXRSZXR1cm5zKFwiXCIpO1xuZnVuY3Rpb24gbGcoYSxiKXthPTk9PT1hLm5vZGVUeXBlfHwxMT09PWEubm9kZVR5cGU/YTphLm93bmVyRG9jdW1lbnQ7dmFyIGM9SGQoYSk7Yj1TYVtiXTtmb3IodmFyIGQ9MDtkPGIubGVuZ3RoO2QrKyl7dmFyIGU9YltkXTtjLmhhc093blByb3BlcnR5KGUpJiZjW2VdfHwoXCJ0b3BTY3JvbGxcIj09PWU/d2QoXCJ0b3BTY3JvbGxcIixcInNjcm9sbFwiLGEpOlwidG9wRm9jdXNcIj09PWV8fFwidG9wQmx1clwiPT09ZT8od2QoXCJ0b3BGb2N1c1wiLFwiZm9jdXNcIixhKSx3ZChcInRvcEJsdXJcIixcImJsdXJcIixhKSxjLnRvcEJsdXI9ITAsYy50b3BGb2N1cz0hMCk6XCJ0b3BDYW5jZWxcIj09PWU/KHljKFwiY2FuY2VsXCIsITApJiZ3ZChcInRvcENhbmNlbFwiLFwiY2FuY2VsXCIsYSksYy50b3BDYW5jZWw9ITApOlwidG9wQ2xvc2VcIj09PWU/KHljKFwiY2xvc2VcIiwhMCkmJndkKFwidG9wQ2xvc2VcIixcImNsb3NlXCIsYSksYy50b3BDbG9zZT0hMCk6RGQuaGFzT3duUHJvcGVydHkoZSkmJlUoZSxEZFtlXSxhKSxjW2VdPSEwKX19XG52YXIgbWc9e3RvcEFib3J0OlwiYWJvcnRcIix0b3BDYW5QbGF5OlwiY2FucGxheVwiLHRvcENhblBsYXlUaHJvdWdoOlwiY2FucGxheXRocm91Z2hcIix0b3BEdXJhdGlvbkNoYW5nZTpcImR1cmF0aW9uY2hhbmdlXCIsdG9wRW1wdGllZDpcImVtcHRpZWRcIix0b3BFbmNyeXB0ZWQ6XCJlbmNyeXB0ZWRcIix0b3BFbmRlZDpcImVuZGVkXCIsdG9wRXJyb3I6XCJlcnJvclwiLHRvcExvYWRlZERhdGE6XCJsb2FkZWRkYXRhXCIsdG9wTG9hZGVkTWV0YWRhdGE6XCJsb2FkZWRtZXRhZGF0YVwiLHRvcExvYWRTdGFydDpcImxvYWRzdGFydFwiLHRvcFBhdXNlOlwicGF1c2VcIix0b3BQbGF5OlwicGxheVwiLHRvcFBsYXlpbmc6XCJwbGF5aW5nXCIsdG9wUHJvZ3Jlc3M6XCJwcm9ncmVzc1wiLHRvcFJhdGVDaGFuZ2U6XCJyYXRlY2hhbmdlXCIsdG9wU2Vla2VkOlwic2Vla2VkXCIsdG9wU2Vla2luZzpcInNlZWtpbmdcIix0b3BTdGFsbGVkOlwic3RhbGxlZFwiLHRvcFN1c3BlbmQ6XCJzdXNwZW5kXCIsdG9wVGltZVVwZGF0ZTpcInRpbWV1cGRhdGVcIix0b3BWb2x1bWVDaGFuZ2U6XCJ2b2x1bWVjaGFuZ2VcIixcbnRvcFdhaXRpbmc6XCJ3YWl0aW5nXCJ9O2Z1bmN0aW9uIG5nKGEsYixjLGQpe2M9OT09PWMubm9kZVR5cGU/YzpjLm93bmVyRG9jdW1lbnQ7ZD09PWpnJiYoZD1aZihhKSk7ZD09PWpnP1wic2NyaXB0XCI9PT1hPyhhPWMuY3JlYXRlRWxlbWVudChcImRpdlwiKSxhLmlubmVySFRNTD1cIlxceDNjc2NyaXB0XFx4M2VcXHgzYy9zY3JpcHRcXHgzZVwiLGE9YS5yZW1vdmVDaGlsZChhLmZpcnN0Q2hpbGQpKTphPVwic3RyaW5nXCI9PT10eXBlb2YgYi5pcz9jLmNyZWF0ZUVsZW1lbnQoYSx7aXM6Yi5pc30pOmMuY3JlYXRlRWxlbWVudChhKTphPWMuY3JlYXRlRWxlbWVudE5TKGQsYSk7cmV0dXJuIGF9ZnVuY3Rpb24gb2coYSxiKXtyZXR1cm4oOT09PWIubm9kZVR5cGU/YjpiLm93bmVyRG9jdW1lbnQpLmNyZWF0ZVRleHROb2RlKGEpfVxuZnVuY3Rpb24gcGcoYSxiLGMsZCl7dmFyIGU9aWcoYixjKTtzd2l0Y2goYil7Y2FzZSBcImlmcmFtZVwiOmNhc2UgXCJvYmplY3RcIjpVKFwidG9wTG9hZFwiLFwibG9hZFwiLGEpO3ZhciBmPWM7YnJlYWs7Y2FzZSBcInZpZGVvXCI6Y2FzZSBcImF1ZGlvXCI6Zm9yKGYgaW4gbWcpbWcuaGFzT3duUHJvcGVydHkoZikmJlUoZixtZ1tmXSxhKTtmPWM7YnJlYWs7Y2FzZSBcInNvdXJjZVwiOlUoXCJ0b3BFcnJvclwiLFwiZXJyb3JcIixhKTtmPWM7YnJlYWs7Y2FzZSBcImltZ1wiOmNhc2UgXCJpbWFnZVwiOlUoXCJ0b3BFcnJvclwiLFwiZXJyb3JcIixhKTtVKFwidG9wTG9hZFwiLFwibG9hZFwiLGEpO2Y9YzticmVhaztjYXNlIFwiZm9ybVwiOlUoXCJ0b3BSZXNldFwiLFwicmVzZXRcIixhKTtVKFwidG9wU3VibWl0XCIsXCJzdWJtaXRcIixhKTtmPWM7YnJlYWs7Y2FzZSBcImRldGFpbHNcIjpVKFwidG9wVG9nZ2xlXCIsXCJ0b2dnbGVcIixhKTtmPWM7YnJlYWs7Y2FzZSBcImlucHV0XCI6TWYoYSxjKTtmPUxmKGEsYyk7VShcInRvcEludmFsaWRcIixcImludmFsaWRcIixhKTtcbmxnKGQsXCJvbkNoYW5nZVwiKTticmVhaztjYXNlIFwib3B0aW9uXCI6Zj1SZihhLGMpO2JyZWFrO2Nhc2UgXCJzZWxlY3RcIjpUZihhLGMpO2Y9Qih7fSxjLHt2YWx1ZTp2b2lkIDB9KTtVKFwidG9wSW52YWxpZFwiLFwiaW52YWxpZFwiLGEpO2xnKGQsXCJvbkNoYW5nZVwiKTticmVhaztjYXNlIFwidGV4dGFyZWFcIjpWZihhLGMpO2Y9VWYoYSxjKTtVKFwidG9wSW52YWxpZFwiLFwiaW52YWxpZFwiLGEpO2xnKGQsXCJvbkNoYW5nZVwiKTticmVhaztkZWZhdWx0OmY9Y31oZyhiLGYsa2cpO3ZhciBnPWYsaDtmb3IoaCBpbiBnKWlmKGcuaGFzT3duUHJvcGVydHkoaCkpe3ZhciBrPWdbaF07XCJzdHlsZVwiPT09aD9mZyhhLGssa2cpOlwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIj09PWg/KGs9az9rLl9faHRtbDp2b2lkIDAsbnVsbCE9ayYmYmcoYSxrKSk6XCJjaGlsZHJlblwiPT09aD9cInN0cmluZ1wiPT09dHlwZW9mIGs/KFwidGV4dGFyZWFcIiE9PWJ8fFwiXCIhPT1rKSYmY2coYSxrKTpcIm51bWJlclwiPT09dHlwZW9mIGsmJmNnKGEsXG5cIlwiK2spOlwic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nXCIhPT1oJiZcInN1cHByZXNzSHlkcmF0aW9uV2FybmluZ1wiIT09aCYmXCJhdXRvRm9jdXNcIiE9PWgmJihSYS5oYXNPd25Qcm9wZXJ0eShoKT9udWxsIT1rJiZsZyhkLGgpOmU/S2YoYSxoLGspOm51bGwhPWsmJklmKGEsaCxrKSl9c3dpdGNoKGIpe2Nhc2UgXCJpbnB1dFwiOkJjKGEpO1BmKGEsYyk7YnJlYWs7Y2FzZSBcInRleHRhcmVhXCI6QmMoYSk7WGYoYSxjKTticmVhaztjYXNlIFwib3B0aW9uXCI6bnVsbCE9Yy52YWx1ZSYmYS5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiLGMudmFsdWUpO2JyZWFrO2Nhc2UgXCJzZWxlY3RcIjphLm11bHRpcGxlPSEhYy5tdWx0aXBsZTtiPWMudmFsdWU7bnVsbCE9Yj9TZihhLCEhYy5tdWx0aXBsZSxiLCExKTpudWxsIT1jLmRlZmF1bHRWYWx1ZSYmU2YoYSwhIWMubXVsdGlwbGUsYy5kZWZhdWx0VmFsdWUsITApO2JyZWFrO2RlZmF1bHQ6XCJmdW5jdGlvblwiPT09dHlwZW9mIGYub25DbGljayYmKGEub25jbGljaz1cbkMpfX1cbmZ1bmN0aW9uIHNnKGEsYixjLGQsZSl7dmFyIGY9bnVsbDtzd2l0Y2goYil7Y2FzZSBcImlucHV0XCI6Yz1MZihhLGMpO2Q9TGYoYSxkKTtmPVtdO2JyZWFrO2Nhc2UgXCJvcHRpb25cIjpjPVJmKGEsYyk7ZD1SZihhLGQpO2Y9W107YnJlYWs7Y2FzZSBcInNlbGVjdFwiOmM9Qih7fSxjLHt2YWx1ZTp2b2lkIDB9KTtkPUIoe30sZCx7dmFsdWU6dm9pZCAwfSk7Zj1bXTticmVhaztjYXNlIFwidGV4dGFyZWFcIjpjPVVmKGEsYyk7ZD1VZihhLGQpO2Y9W107YnJlYWs7ZGVmYXVsdDpcImZ1bmN0aW9uXCIhPT10eXBlb2YgYy5vbkNsaWNrJiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgZC5vbkNsaWNrJiYoYS5vbmNsaWNrPUMpfWhnKGIsZCxrZyk7dmFyIGcsaDthPW51bGw7Zm9yKGcgaW4gYylpZighZC5oYXNPd25Qcm9wZXJ0eShnKSYmYy5oYXNPd25Qcm9wZXJ0eShnKSYmbnVsbCE9Y1tnXSlpZihcInN0eWxlXCI9PT1nKWZvcihoIGluIGI9Y1tnXSxiKWIuaGFzT3duUHJvcGVydHkoaCkmJihhfHwoYT17fSksYVtoXT1cblwiXCIpO2Vsc2VcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCIhPT1nJiZcImNoaWxkcmVuXCIhPT1nJiZcInN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZ1wiIT09ZyYmXCJzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmdcIiE9PWcmJlwiYXV0b0ZvY3VzXCIhPT1nJiYoUmEuaGFzT3duUHJvcGVydHkoZyk/Znx8KGY9W10pOihmPWZ8fFtdKS5wdXNoKGcsbnVsbCkpO2ZvcihnIGluIGQpe3ZhciBrPWRbZ107Yj1udWxsIT1jP2NbZ106dm9pZCAwO2lmKGQuaGFzT3duUHJvcGVydHkoZykmJmshPT1iJiYobnVsbCE9a3x8bnVsbCE9YikpaWYoXCJzdHlsZVwiPT09ZylpZihiKXtmb3IoaCBpbiBiKSFiLmhhc093blByb3BlcnR5KGgpfHxrJiZrLmhhc093blByb3BlcnR5KGgpfHwoYXx8KGE9e30pLGFbaF09XCJcIik7Zm9yKGggaW4gaylrLmhhc093blByb3BlcnR5KGgpJiZiW2hdIT09a1toXSYmKGF8fChhPXt9KSxhW2hdPWtbaF0pfWVsc2UgYXx8KGZ8fChmPVtdKSxmLnB1c2goZyxhKSksYT1rO2Vsc2VcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI9PT1cbmc/KGs9az9rLl9faHRtbDp2b2lkIDAsYj1iP2IuX19odG1sOnZvaWQgMCxudWxsIT1rJiZiIT09ayYmKGY9Znx8W10pLnB1c2goZyxcIlwiK2spKTpcImNoaWxkcmVuXCI9PT1nP2I9PT1rfHxcInN0cmluZ1wiIT09dHlwZW9mIGsmJlwibnVtYmVyXCIhPT10eXBlb2Yga3x8KGY9Znx8W10pLnB1c2goZyxcIlwiK2spOlwic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nXCIhPT1nJiZcInN1cHByZXNzSHlkcmF0aW9uV2FybmluZ1wiIT09ZyYmKFJhLmhhc093blByb3BlcnR5KGcpPyhudWxsIT1rJiZsZyhlLGcpLGZ8fGI9PT1rfHwoZj1bXSkpOihmPWZ8fFtdKS5wdXNoKGcsaykpfWEmJihmPWZ8fFtdKS5wdXNoKFwic3R5bGVcIixhKTtyZXR1cm4gZn1cbmZ1bmN0aW9uIHRnKGEsYixjLGQsZSl7XCJpbnB1dFwiPT09YyYmXCJyYWRpb1wiPT09ZS50eXBlJiZudWxsIT1lLm5hbWUmJk5mKGEsZSk7aWcoYyxkKTtkPWlnKGMsZSk7Zm9yKHZhciBmPTA7ZjxiLmxlbmd0aDtmKz0yKXt2YXIgZz1iW2ZdLGg9YltmKzFdO1wic3R5bGVcIj09PWc/ZmcoYSxoLGtnKTpcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI9PT1nP2JnKGEsaCk6XCJjaGlsZHJlblwiPT09Zz9jZyhhLGgpOmQ/bnVsbCE9aD9LZihhLGcsaCk6YS5yZW1vdmVBdHRyaWJ1dGUoZyk6bnVsbCE9aD9JZihhLGcsaCk6SmYoYSxnKX1zd2l0Y2goYyl7Y2FzZSBcImlucHV0XCI6T2YoYSxlKTticmVhaztjYXNlIFwidGV4dGFyZWFcIjpXZihhLGUpO2JyZWFrO2Nhc2UgXCJzZWxlY3RcIjphLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlPXZvaWQgMCxiPWEuX3dyYXBwZXJTdGF0ZS53YXNNdWx0aXBsZSxhLl93cmFwcGVyU3RhdGUud2FzTXVsdGlwbGU9ISFlLm11bHRpcGxlLGM9ZS52YWx1ZSxudWxsIT1jP1NmKGEsXG4hIWUubXVsdGlwbGUsYywhMSk6YiE9PSEhZS5tdWx0aXBsZSYmKG51bGwhPWUuZGVmYXVsdFZhbHVlP1NmKGEsISFlLm11bHRpcGxlLGUuZGVmYXVsdFZhbHVlLCEwKTpTZihhLCEhZS5tdWx0aXBsZSxlLm11bHRpcGxlP1tdOlwiXCIsITEpKX19XG5mdW5jdGlvbiB1ZyhhLGIsYyxkLGUpe3N3aXRjaChiKXtjYXNlIFwiaWZyYW1lXCI6Y2FzZSBcIm9iamVjdFwiOlUoXCJ0b3BMb2FkXCIsXCJsb2FkXCIsYSk7YnJlYWs7Y2FzZSBcInZpZGVvXCI6Y2FzZSBcImF1ZGlvXCI6Zm9yKHZhciBmIGluIG1nKW1nLmhhc093blByb3BlcnR5KGYpJiZVKGYsbWdbZl0sYSk7YnJlYWs7Y2FzZSBcInNvdXJjZVwiOlUoXCJ0b3BFcnJvclwiLFwiZXJyb3JcIixhKTticmVhaztjYXNlIFwiaW1nXCI6Y2FzZSBcImltYWdlXCI6VShcInRvcEVycm9yXCIsXCJlcnJvclwiLGEpO1UoXCJ0b3BMb2FkXCIsXCJsb2FkXCIsYSk7YnJlYWs7Y2FzZSBcImZvcm1cIjpVKFwidG9wUmVzZXRcIixcInJlc2V0XCIsYSk7VShcInRvcFN1Ym1pdFwiLFwic3VibWl0XCIsYSk7YnJlYWs7Y2FzZSBcImRldGFpbHNcIjpVKFwidG9wVG9nZ2xlXCIsXCJ0b2dnbGVcIixhKTticmVhaztjYXNlIFwiaW5wdXRcIjpNZihhLGMpO1UoXCJ0b3BJbnZhbGlkXCIsXCJpbnZhbGlkXCIsYSk7bGcoZSxcIm9uQ2hhbmdlXCIpO2JyZWFrO2Nhc2UgXCJzZWxlY3RcIjpUZihhLGMpO1xuVShcInRvcEludmFsaWRcIixcImludmFsaWRcIixhKTtsZyhlLFwib25DaGFuZ2VcIik7YnJlYWs7Y2FzZSBcInRleHRhcmVhXCI6VmYoYSxjKSxVKFwidG9wSW52YWxpZFwiLFwiaW52YWxpZFwiLGEpLGxnKGUsXCJvbkNoYW5nZVwiKX1oZyhiLGMsa2cpO2Q9bnVsbDtmb3IodmFyIGcgaW4gYyljLmhhc093blByb3BlcnR5KGcpJiYoZj1jW2ddLFwiY2hpbGRyZW5cIj09PWc/XCJzdHJpbmdcIj09PXR5cGVvZiBmP2EudGV4dENvbnRlbnQhPT1mJiYoZD1bXCJjaGlsZHJlblwiLGZdKTpcIm51bWJlclwiPT09dHlwZW9mIGYmJmEudGV4dENvbnRlbnQhPT1cIlwiK2YmJihkPVtcImNoaWxkcmVuXCIsXCJcIitmXSk6UmEuaGFzT3duUHJvcGVydHkoZykmJm51bGwhPWYmJmxnKGUsZykpO3N3aXRjaChiKXtjYXNlIFwiaW5wdXRcIjpCYyhhKTtQZihhLGMpO2JyZWFrO2Nhc2UgXCJ0ZXh0YXJlYVwiOkJjKGEpO1hmKGEsYyk7YnJlYWs7Y2FzZSBcInNlbGVjdFwiOmNhc2UgXCJvcHRpb25cIjpicmVhaztkZWZhdWx0OlwiZnVuY3Rpb25cIj09PXR5cGVvZiBjLm9uQ2xpY2smJlxuKGEub25jbGljaz1DKX1yZXR1cm4gZH1mdW5jdGlvbiB2ZyhhLGIpe3JldHVybiBhLm5vZGVWYWx1ZSE9PWJ9XG52YXIgd2c9T2JqZWN0LmZyZWV6ZSh7Y3JlYXRlRWxlbWVudDpuZyxjcmVhdGVUZXh0Tm9kZTpvZyxzZXRJbml0aWFsUHJvcGVydGllczpwZyxkaWZmUHJvcGVydGllczpzZyx1cGRhdGVQcm9wZXJ0aWVzOnRnLGRpZmZIeWRyYXRlZFByb3BlcnRpZXM6dWcsZGlmZkh5ZHJhdGVkVGV4dDp2Zyx3YXJuRm9yVW5tYXRjaGVkVGV4dDpmdW5jdGlvbigpe30sd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudDpmdW5jdGlvbigpe30sd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dDpmdW5jdGlvbigpe30sd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50OmZ1bmN0aW9uKCl7fSx3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQ6ZnVuY3Rpb24oKXt9LHJlc3RvcmVDb250cm9sbGVkU3RhdGU6ZnVuY3Rpb24oYSxiLGMpe3N3aXRjaChiKXtjYXNlIFwiaW5wdXRcIjpPZihhLGMpO2I9Yy5uYW1lO2lmKFwicmFkaW9cIj09PWMudHlwZSYmbnVsbCE9Yil7Zm9yKGM9YTtjLnBhcmVudE5vZGU7KWM9XG5jLnBhcmVudE5vZGU7Yz1jLnF1ZXJ5U2VsZWN0b3JBbGwoXCJpbnB1dFtuYW1lXFx4M2RcIitKU09OLnN0cmluZ2lmeShcIlwiK2IpKyddW3R5cGVcXHgzZFwicmFkaW9cIl0nKTtmb3IoYj0wO2I8Yy5sZW5ndGg7YisrKXt2YXIgZD1jW2JdO2lmKGQhPT1hJiZkLmZvcm09PT1hLmZvcm0pe3ZhciBlPXJiKGQpO2U/dm9pZCAwOkUoXCI5MFwiKTtDYyhkKTtPZihkLGUpfX19YnJlYWs7Y2FzZSBcInRleHRhcmVhXCI6V2YoYSxjKTticmVhaztjYXNlIFwic2VsZWN0XCI6Yj1jLnZhbHVlLG51bGwhPWImJlNmKGEsISFjLm11bHRpcGxlLGIsITEpfX19KTtuYy5pbmplY3RGaWJlckNvbnRyb2xsZWRIb3N0Q29tcG9uZW50KHdnKTt2YXIgeGc9bnVsbCxNZz1udWxsO2Z1bmN0aW9uIE5nKGEpe3JldHVybiEoIWF8fDEhPT1hLm5vZGVUeXBlJiY5IT09YS5ub2RlVHlwZSYmMTEhPT1hLm5vZGVUeXBlJiYoOCE9PWEubm9kZVR5cGV8fFwiIHJlYWN0LW1vdW50LXBvaW50LXVuc3RhYmxlIFwiIT09YS5ub2RlVmFsdWUpKX1cbmZ1bmN0aW9uIE9nKGEpe2E9YT85PT09YS5ub2RlVHlwZT9hLmRvY3VtZW50RWxlbWVudDphLmZpcnN0Q2hpbGQ6bnVsbDtyZXR1cm4hKCFhfHwxIT09YS5ub2RlVHlwZXx8IWEuaGFzQXR0cmlidXRlKFwiZGF0YS1yZWFjdHJvb3RcIikpfVxudmFyIFo9b2Yoe2dldFJvb3RIb3N0Q29udGV4dDpmdW5jdGlvbihhKXt2YXIgYj1hLm5vZGVUeXBlO3N3aXRjaChiKXtjYXNlIDk6Y2FzZSAxMTphPShhPWEuZG9jdW1lbnRFbGVtZW50KT9hLm5hbWVzcGFjZVVSSTokZihudWxsLFwiXCIpO2JyZWFrO2RlZmF1bHQ6Yj04PT09Yj9hLnBhcmVudE5vZGU6YSxhPWIubmFtZXNwYWNlVVJJfHxudWxsLGI9Yi50YWdOYW1lLGE9JGYoYSxiKX1yZXR1cm4gYX0sZ2V0Q2hpbGRIb3N0Q29udGV4dDpmdW5jdGlvbihhLGIpe3JldHVybiAkZihhLGIpfSxnZXRQdWJsaWNJbnN0YW5jZTpmdW5jdGlvbihhKXtyZXR1cm4gYX0scHJlcGFyZUZvckNvbW1pdDpmdW5jdGlvbigpe3hnPXRkO3ZhciBhPWRhKCk7aWYoS2QoYSkpe2lmKFwic2VsZWN0aW9uU3RhcnRcImluIGEpdmFyIGI9e3N0YXJ0OmEuc2VsZWN0aW9uU3RhcnQsZW5kOmEuc2VsZWN0aW9uRW5kfTtlbHNlIGE6e3ZhciBjPXdpbmRvdy5nZXRTZWxlY3Rpb24mJndpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbmlmKGMmJjAhPT1jLnJhbmdlQ291bnQpe2I9Yy5hbmNob3JOb2RlO3ZhciBkPWMuYW5jaG9yT2Zmc2V0LGU9Yy5mb2N1c05vZGU7Yz1jLmZvY3VzT2Zmc2V0O3RyeXtiLm5vZGVUeXBlLGUubm9kZVR5cGV9Y2F0Y2goeil7Yj1udWxsO2JyZWFrIGF9dmFyIGY9MCxnPS0xLGg9LTEsaz0wLHE9MCx2PWEseT1udWxsO2I6Zm9yKDs7KXtmb3IodmFyIHU7Oyl7diE9PWJ8fDAhPT1kJiYzIT09di5ub2RlVHlwZXx8KGc9ZitkKTt2IT09ZXx8MCE9PWMmJjMhPT12Lm5vZGVUeXBlfHwoaD1mK2MpOzM9PT12Lm5vZGVUeXBlJiYoZis9di5ub2RlVmFsdWUubGVuZ3RoKTtpZihudWxsPT09KHU9di5maXJzdENoaWxkKSlicmVhazt5PXY7dj11fWZvcig7Oyl7aWYodj09PWEpYnJlYWsgYjt5PT09YiYmKytrPT09ZCYmKGc9Zik7eT09PWUmJisrcT09PWMmJihoPWYpO2lmKG51bGwhPT0odT12Lm5leHRTaWJsaW5nKSlicmVhazt2PXk7eT12LnBhcmVudE5vZGV9dj11fWI9LTE9PT1nfHwtMT09PWg/bnVsbDpcbntzdGFydDpnLGVuZDpofX1lbHNlIGI9bnVsbH1iPWJ8fHtzdGFydDowLGVuZDowfX1lbHNlIGI9bnVsbDtNZz17Zm9jdXNlZEVsZW06YSxzZWxlY3Rpb25SYW5nZTpifTt1ZCghMSl9LHJlc2V0QWZ0ZXJDb21taXQ6ZnVuY3Rpb24oKXt2YXIgYT1NZyxiPWRhKCksYz1hLmZvY3VzZWRFbGVtLGQ9YS5zZWxlY3Rpb25SYW5nZTtpZihiIT09YyYmZmEoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LGMpKXtpZihLZChjKSlpZihiPWQuc3RhcnQsYT1kLmVuZCx2b2lkIDA9PT1hJiYoYT1iKSxcInNlbGVjdGlvblN0YXJ0XCJpbiBjKWMuc2VsZWN0aW9uU3RhcnQ9YixjLnNlbGVjdGlvbkVuZD1NYXRoLm1pbihhLGMudmFsdWUubGVuZ3RoKTtlbHNlIGlmKHdpbmRvdy5nZXRTZWxlY3Rpb24pe2I9d2luZG93LmdldFNlbGVjdGlvbigpO3ZhciBlPWNbRWIoKV0ubGVuZ3RoO2E9TWF0aC5taW4oZC5zdGFydCxlKTtkPXZvaWQgMD09PWQuZW5kP2E6TWF0aC5taW4oZC5lbmQsZSk7IWIuZXh0ZW5kJiZhPlxuZCYmKGU9ZCxkPWEsYT1lKTtlPUpkKGMsYSk7dmFyIGY9SmQoYyxkKTtpZihlJiZmJiYoMSE9PWIucmFuZ2VDb3VudHx8Yi5hbmNob3JOb2RlIT09ZS5ub2RlfHxiLmFuY2hvck9mZnNldCE9PWUub2Zmc2V0fHxiLmZvY3VzTm9kZSE9PWYubm9kZXx8Yi5mb2N1c09mZnNldCE9PWYub2Zmc2V0KSl7dmFyIGc9ZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtnLnNldFN0YXJ0KGUubm9kZSxlLm9mZnNldCk7Yi5yZW1vdmVBbGxSYW5nZXMoKTthPmQ/KGIuYWRkUmFuZ2UoZyksYi5leHRlbmQoZi5ub2RlLGYub2Zmc2V0KSk6KGcuc2V0RW5kKGYubm9kZSxmLm9mZnNldCksYi5hZGRSYW5nZShnKSl9fWI9W107Zm9yKGE9YzthPWEucGFyZW50Tm9kZTspMT09PWEubm9kZVR5cGUmJmIucHVzaCh7ZWxlbWVudDphLGxlZnQ6YS5zY3JvbGxMZWZ0LHRvcDphLnNjcm9sbFRvcH0pO2lhKGMpO2ZvcihjPTA7YzxiLmxlbmd0aDtjKyspYT1iW2NdLGEuZWxlbWVudC5zY3JvbGxMZWZ0PWEubGVmdCxhLmVsZW1lbnQuc2Nyb2xsVG9wPVxuYS50b3B9TWc9bnVsbDt1ZCh4Zyk7eGc9bnVsbH0sY3JlYXRlSW5zdGFuY2U6ZnVuY3Rpb24oYSxiLGMsZCxlKXthPW5nKGEsYixjLGQpO2FbUV09ZTthW29iXT1iO3JldHVybiBhfSxhcHBlbmRJbml0aWFsQ2hpbGQ6ZnVuY3Rpb24oYSxiKXthLmFwcGVuZENoaWxkKGIpfSxmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbjpmdW5jdGlvbihhLGIsYyxkKXtwZyhhLGIsYyxkKTthOntzd2l0Y2goYil7Y2FzZSBcImJ1dHRvblwiOmNhc2UgXCJpbnB1dFwiOmNhc2UgXCJzZWxlY3RcIjpjYXNlIFwidGV4dGFyZWFcIjphPSEhYy5hdXRvRm9jdXM7YnJlYWsgYX1hPSExfXJldHVybiBhfSxwcmVwYXJlVXBkYXRlOmZ1bmN0aW9uKGEsYixjLGQsZSl7cmV0dXJuIHNnKGEsYixjLGQsZSl9LHNob3VsZFNldFRleHRDb250ZW50OmZ1bmN0aW9uKGEsYil7cmV0dXJuXCJ0ZXh0YXJlYVwiPT09YXx8XCJzdHJpbmdcIj09PXR5cGVvZiBiLmNoaWxkcmVufHxcIm51bWJlclwiPT09dHlwZW9mIGIuY2hpbGRyZW58fFwib2JqZWN0XCI9PT1cbnR5cGVvZiBiLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MJiZudWxsIT09Yi5kYW5nZXJvdXNseVNldElubmVySFRNTCYmXCJzdHJpbmdcIj09PXR5cGVvZiBiLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MLl9faHRtbH0sc2hvdWxkRGVwcmlvcml0aXplU3VidHJlZTpmdW5jdGlvbihhLGIpe3JldHVybiEhYi5oaWRkZW59LGNyZWF0ZVRleHRJbnN0YW5jZTpmdW5jdGlvbihhLGIsYyxkKXthPW9nKGEsYik7YVtRXT1kO3JldHVybiBhfSxub3c6cmYsbXV0YXRpb246e2NvbW1pdE1vdW50OmZ1bmN0aW9uKGEpe2EuZm9jdXMoKX0sY29tbWl0VXBkYXRlOmZ1bmN0aW9uKGEsYixjLGQsZSl7YVtvYl09ZTt0ZyhhLGIsYyxkLGUpfSxyZXNldFRleHRDb250ZW50OmZ1bmN0aW9uKGEpe2EudGV4dENvbnRlbnQ9XCJcIn0sY29tbWl0VGV4dFVwZGF0ZTpmdW5jdGlvbihhLGIsYyl7YS5ub2RlVmFsdWU9Y30sYXBwZW5kQ2hpbGQ6ZnVuY3Rpb24oYSxiKXthLmFwcGVuZENoaWxkKGIpfSxhcHBlbmRDaGlsZFRvQ29udGFpbmVyOmZ1bmN0aW9uKGEsXG5iKXs4PT09YS5ub2RlVHlwZT9hLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGIsYSk6YS5hcHBlbmRDaGlsZChiKX0saW5zZXJ0QmVmb3JlOmZ1bmN0aW9uKGEsYixjKXthLmluc2VydEJlZm9yZShiLGMpfSxpbnNlcnRJbkNvbnRhaW5lckJlZm9yZTpmdW5jdGlvbihhLGIsYyl7OD09PWEubm9kZVR5cGU/YS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShiLGMpOmEuaW5zZXJ0QmVmb3JlKGIsYyl9LHJlbW92ZUNoaWxkOmZ1bmN0aW9uKGEsYil7YS5yZW1vdmVDaGlsZChiKX0scmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyOmZ1bmN0aW9uKGEsYil7OD09PWEubm9kZVR5cGU/YS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGIpOmEucmVtb3ZlQ2hpbGQoYil9fSxoeWRyYXRpb246e2Nhbkh5ZHJhdGVJbnN0YW5jZTpmdW5jdGlvbihhLGIpe3JldHVybiAxIT09YS5ub2RlVHlwZXx8Yi50b0xvd2VyQ2FzZSgpIT09YS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpP251bGw6YX0sY2FuSHlkcmF0ZVRleHRJbnN0YW5jZTpmdW5jdGlvbihhLFxuYil7cmV0dXJuXCJcIj09PWJ8fDMhPT1hLm5vZGVUeXBlP251bGw6YX0sZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nOmZ1bmN0aW9uKGEpe2ZvcihhPWEubmV4dFNpYmxpbmc7YSYmMSE9PWEubm9kZVR5cGUmJjMhPT1hLm5vZGVUeXBlOylhPWEubmV4dFNpYmxpbmc7cmV0dXJuIGF9LGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkOmZ1bmN0aW9uKGEpe2ZvcihhPWEuZmlyc3RDaGlsZDthJiYxIT09YS5ub2RlVHlwZSYmMyE9PWEubm9kZVR5cGU7KWE9YS5uZXh0U2libGluZztyZXR1cm4gYX0saHlkcmF0ZUluc3RhbmNlOmZ1bmN0aW9uKGEsYixjLGQsZSxmKXthW1FdPWY7YVtvYl09YztyZXR1cm4gdWcoYSxiLGMsZSxkKX0saHlkcmF0ZVRleHRJbnN0YW5jZTpmdW5jdGlvbihhLGIsYyl7YVtRXT1jO3JldHVybiB2ZyhhLGIpfSxkaWROb3RNYXRjaEh5ZHJhdGVkQ29udGFpbmVyVGV4dEluc3RhbmNlOmZ1bmN0aW9uKCl7fSxkaWROb3RNYXRjaEh5ZHJhdGVkVGV4dEluc3RhbmNlOmZ1bmN0aW9uKCl7fSxcbmRpZE5vdEh5ZHJhdGVDb250YWluZXJJbnN0YW5jZTpmdW5jdGlvbigpe30sZGlkTm90SHlkcmF0ZUluc3RhbmNlOmZ1bmN0aW9uKCl7fSxkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lckluc3RhbmNlOmZ1bmN0aW9uKCl7fSxkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lclRleHRJbnN0YW5jZTpmdW5jdGlvbigpe30sZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZTpmdW5jdGlvbigpe30sZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2U6ZnVuY3Rpb24oKXt9fSxzY2hlZHVsZURlZmVycmVkQ2FsbGJhY2s6c2YsY2FuY2VsRGVmZXJyZWRDYWxsYmFjazp0Zix1c2VTeW5jU2NoZWR1bGluZzohMH0pO3JjPVouYmF0Y2hlZFVwZGF0ZXM7XG5mdW5jdGlvbiBQZyhhLGIsYyxkLGUpe05nKGMpP3ZvaWQgMDpFKFwiMjAwXCIpO3ZhciBmPWMuX3JlYWN0Um9vdENvbnRhaW5lcjtpZihmKVoudXBkYXRlQ29udGFpbmVyKGIsZixhLGUpO2Vsc2V7ZD1kfHxPZyhjKTtpZighZClmb3IoZj12b2lkIDA7Zj1jLmxhc3RDaGlsZDspYy5yZW1vdmVDaGlsZChmKTt2YXIgZz1aLmNyZWF0ZUNvbnRhaW5lcihjLGQpO2Y9Yy5fcmVhY3RSb290Q29udGFpbmVyPWc7Wi51bmJhdGNoZWRVcGRhdGVzKGZ1bmN0aW9uKCl7Wi51cGRhdGVDb250YWluZXIoYixnLGEsZSl9KX1yZXR1cm4gWi5nZXRQdWJsaWNSb290SW5zdGFuY2UoZil9ZnVuY3Rpb24gUWcoYSxiKXt2YXIgYz0yPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06bnVsbDtOZyhiKT92b2lkIDA6RShcIjIwMFwiKTtyZXR1cm4gcGYoYSxiLG51bGwsYyl9XG5mdW5jdGlvbiBSZyhhLGIpe3RoaXMuX3JlYWN0Um9vdENvbnRhaW5lcj1aLmNyZWF0ZUNvbnRhaW5lcihhLGIpfVJnLnByb3RvdHlwZS5yZW5kZXI9ZnVuY3Rpb24oYSxiKXtaLnVwZGF0ZUNvbnRhaW5lcihhLHRoaXMuX3JlYWN0Um9vdENvbnRhaW5lcixudWxsLGIpfTtSZy5wcm90b3R5cGUudW5tb3VudD1mdW5jdGlvbihhKXtaLnVwZGF0ZUNvbnRhaW5lcihudWxsLHRoaXMuX3JlYWN0Um9vdENvbnRhaW5lcixudWxsLGEpfTtcbnZhciBTZz17Y3JlYXRlUG9ydGFsOlFnLGZpbmRET01Ob2RlOmZ1bmN0aW9uKGEpe2lmKG51bGw9PWEpcmV0dXJuIG51bGw7aWYoMT09PWEubm9kZVR5cGUpcmV0dXJuIGE7dmFyIGI9YS5fcmVhY3RJbnRlcm5hbEZpYmVyO2lmKGIpcmV0dXJuIFouZmluZEhvc3RJbnN0YW5jZShiKTtcImZ1bmN0aW9uXCI9PT10eXBlb2YgYS5yZW5kZXI/RShcIjE4OFwiKTpFKFwiMjEzXCIsT2JqZWN0LmtleXMoYSkpfSxoeWRyYXRlOmZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gUGcobnVsbCxhLGIsITAsYyl9LHJlbmRlcjpmdW5jdGlvbihhLGIsYyl7cmV0dXJuIFBnKG51bGwsYSxiLCExLGMpfSx1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjpmdW5jdGlvbihhLGIsYyxkKXtudWxsPT1hfHx2b2lkIDA9PT1hLl9yZWFjdEludGVybmFsRmliZXI/RShcIjM4XCIpOnZvaWQgMDtyZXR1cm4gUGcoYSxiLGMsITEsZCl9LHVubW91bnRDb21wb25lbnRBdE5vZGU6ZnVuY3Rpb24oYSl7TmcoYSk/dm9pZCAwOlxuRShcIjQwXCIpO3JldHVybiBhLl9yZWFjdFJvb3RDb250YWluZXI/KFoudW5iYXRjaGVkVXBkYXRlcyhmdW5jdGlvbigpe1BnKG51bGwsbnVsbCxhLCExLGZ1bmN0aW9uKCl7YS5fcmVhY3RSb290Q29udGFpbmVyPW51bGx9KX0pLCEwKTohMX0sdW5zdGFibGVfY3JlYXRlUG9ydGFsOlFnLHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzOnRjLHVuc3RhYmxlX2RlZmVycmVkVXBkYXRlczpaLmRlZmVycmVkVXBkYXRlcyxmbHVzaFN5bmM6Wi5mbHVzaFN5bmMsX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ6e0V2ZW50UGx1Z2luSHViOm1iLEV2ZW50UGx1Z2luUmVnaXN0cnk6VmEsRXZlbnRQcm9wYWdhdG9yczpDYixSZWFjdENvbnRyb2xsZWRDb21wb25lbnQ6cWMsUmVhY3RET01Db21wb25lbnRUcmVlOnNiLFJlYWN0RE9NRXZlbnRMaXN0ZW5lcjp4ZH19O1xuWi5pbmplY3RJbnRvRGV2VG9vbHMoe2ZpbmRGaWJlckJ5SG9zdEluc3RhbmNlOnBiLGJ1bmRsZVR5cGU6MCx2ZXJzaW9uOlwiMTYuMi4wXCIscmVuZGVyZXJQYWNrYWdlTmFtZTpcInJlYWN0LWRvbVwifSk7dmFyIFRnPU9iamVjdC5mcmVlemUoe2RlZmF1bHQ6U2d9KSxVZz1UZyYmU2d8fFRnO21vZHVsZS5leHBvcnRzPVVnW1wiZGVmYXVsdFwiXT9VZ1tcImRlZmF1bHRcIl06VWc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vY2pzL3JlYWN0LWRvbS5wcm9kdWN0aW9uLm1pbi5qc1xuLy8gbW9kdWxlIGlkID0gMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///26\n");

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\n\nvar isNode = __webpack_require__(28);\n\n/**\n * @param {*} object The object to check.\n * @return {boolean} Whether or not the object is a DOM text node.\n */\nfunction isTextNode(object) {\n  return isNode(object) && object.nodeType == 3;\n}\n\nmodule.exports = isTextNode;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaXNUZXh0Tm9kZS5qcz9iOGVkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBpc05vZGUgPSByZXF1aXJlKCcuL2lzTm9kZScpO1xuXG4vKipcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgb2JqZWN0IGlzIGEgRE9NIHRleHQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gaXNUZXh0Tm9kZShvYmplY3QpIHtcbiAgcmV0dXJuIGlzTm9kZShvYmplY3QpICYmIG9iamVjdC5ub2RlVHlwZSA9PSAzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVGV4dE5vZGU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaXNUZXh0Tm9kZS5qc1xuLy8gbW9kdWxlIGlkID0gMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///27\n");

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\n\n/**\n * @param {*} object The object to check.\n * @return {boolean} Whether or not the object is a DOM node.\n */\nfunction isNode(object) {\n  var doc = object ? object.ownerDocument || object : document;\n  var defaultView = doc.defaultView || window;\n  return !!(object && (typeof defaultView.Node === 'function' ? object instanceof defaultView.Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));\n}\n\nmodule.exports = isNode;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaXNOb2RlLmpzPzdmNjQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIG9iamVjdCBpcyBhIERPTSBub2RlLlxuICovXG5mdW5jdGlvbiBpc05vZGUob2JqZWN0KSB7XG4gIHZhciBkb2MgPSBvYmplY3QgPyBvYmplY3Qub3duZXJEb2N1bWVudCB8fCBvYmplY3QgOiBkb2N1bWVudDtcbiAgdmFyIGRlZmF1bHRWaWV3ID0gZG9jLmRlZmF1bHRWaWV3IHx8IHdpbmRvdztcbiAgcmV0dXJuICEhKG9iamVjdCAmJiAodHlwZW9mIGRlZmF1bHRWaWV3Lk5vZGUgPT09ICdmdW5jdGlvbicgPyBvYmplY3QgaW5zdGFuY2VvZiBkZWZhdWx0Vmlldy5Ob2RlIDogdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iamVjdC5ub2RlVHlwZSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIG9iamVjdC5ub2RlTmFtZSA9PT0gJ3N0cmluZycpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc05vZGU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaXNOb2RlLmpzXG4vLyBtb2R1bGUgaWQgPSAyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///28\n");

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {/** @license React v16.2.0\n * react-dom.development.js\n *\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(1);\nvar invariant = __webpack_require__(4);\nvar warning = __webpack_require__(6);\nvar ExecutionEnvironment = __webpack_require__(10);\nvar _assign = __webpack_require__(3);\nvar emptyFunction = __webpack_require__(2);\nvar EventListener = __webpack_require__(11);\nvar getActiveElement = __webpack_require__(12);\nvar shallowEqual = __webpack_require__(13);\nvar containsNode = __webpack_require__(14);\nvar focusNode = __webpack_require__(15);\nvar emptyObject = __webpack_require__(5);\nvar checkPropTypes = __webpack_require__(7);\nvar hyphenateStyleName = __webpack_require__(30);\nvar camelizeStyleName = __webpack_require__(32);\n\n/**\n * WARNING: DO NOT manually require this module.\n * This is a replacement for `invariant(...)` used by the error code system\n * and will _only_ be required by the corresponding babel pass.\n * It always throws.\n */\n\n!React ? invariant(false, 'ReactDOM was loaded before React. Make sure you load the React package before loading ReactDOM.') : void 0;\n\n// These attributes should be all lowercase to allow for\n// case insensitive checks\nvar RESERVED_PROPS = {\n  children: true,\n  dangerouslySetInnerHTML: true,\n  defaultValue: true,\n  defaultChecked: true,\n  innerHTML: true,\n  suppressContentEditableWarning: true,\n  suppressHydrationWarning: true,\n  style: true\n};\n\nfunction checkMask(value, bitmask) {\n  return (value & bitmask) === bitmask;\n}\n\nvar DOMPropertyInjection = {\n  /**\n   * Mapping from normalized, camelcased property names to a configuration that\n   * specifies how the associated DOM property should be accessed or rendered.\n   */\n  MUST_USE_PROPERTY: 0x1,\n  HAS_BOOLEAN_VALUE: 0x4,\n  HAS_NUMERIC_VALUE: 0x8,\n  HAS_POSITIVE_NUMERIC_VALUE: 0x10 | 0x8,\n  HAS_OVERLOADED_BOOLEAN_VALUE: 0x20,\n  HAS_STRING_BOOLEAN_VALUE: 0x40,\n\n  /**\n   * Inject some specialized knowledge about the DOM. This takes a config object\n   * with the following properties:\n   *\n   * Properties: object mapping DOM property name to one of the\n   * DOMPropertyInjection constants or null. If your attribute isn't in here,\n   * it won't get written to the DOM.\n   *\n   * DOMAttributeNames: object mapping React attribute name to the DOM\n   * attribute name. Attribute names not specified use the **lowercase**\n   * normalized name.\n   *\n   * DOMAttributeNamespaces: object mapping React attribute name to the DOM\n   * attribute namespace URL. (Attribute names not specified use no namespace.)\n   *\n   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.\n   * Property names not specified use the normalized name.\n   *\n   * DOMMutationMethods: Properties that require special mutation methods. If\n   * `value` is undefined, the mutation method should unset the property.\n   *\n   * @param {object} domPropertyConfig the config as described above.\n   */\n  injectDOMPropertyConfig: function (domPropertyConfig) {\n    var Injection = DOMPropertyInjection;\n    var Properties = domPropertyConfig.Properties || {};\n    var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};\n    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};\n    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};\n\n    for (var propName in Properties) {\n      !!properties.hasOwnProperty(propName) ? invariant(false, \"injectDOMPropertyConfig(...): You're trying to inject DOM property '%s' which has already been injected. You may be accidentally injecting the same DOM property config twice, or you may be injecting two configs that have conflicting property names.\", propName) : void 0;\n\n      var lowerCased = propName.toLowerCase();\n      var propConfig = Properties[propName];\n\n      var propertyInfo = {\n        attributeName: lowerCased,\n        attributeNamespace: null,\n        propertyName: propName,\n        mutationMethod: null,\n\n        mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),\n        hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),\n        hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),\n        hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),\n        hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE),\n        hasStringBooleanValue: checkMask(propConfig, Injection.HAS_STRING_BOOLEAN_VALUE)\n      };\n      !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ? invariant(false, \"DOMProperty: Value can be one of boolean, overloaded boolean, or numeric value, but not a combination: %s\", propName) : void 0;\n\n      if (DOMAttributeNames.hasOwnProperty(propName)) {\n        var attributeName = DOMAttributeNames[propName];\n\n        propertyInfo.attributeName = attributeName;\n      }\n\n      if (DOMAttributeNamespaces.hasOwnProperty(propName)) {\n        propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];\n      }\n\n      if (DOMMutationMethods.hasOwnProperty(propName)) {\n        propertyInfo.mutationMethod = DOMMutationMethods[propName];\n      }\n\n      // Downcase references to whitelist properties to check for membership\n      // without case-sensitivity. This allows the whitelist to pick up\n      // `allowfullscreen`, which should be written using the property configuration\n      // for `allowFullscreen`\n      properties[propName] = propertyInfo;\n    }\n  }\n};\n\n/* eslint-disable max-len */\nvar ATTRIBUTE_NAME_START_CHAR = \":A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\";\n/* eslint-enable max-len */\nvar ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + \"\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040\";\n\n\nvar ROOT_ATTRIBUTE_NAME = 'data-reactroot';\n\n/**\n * Map from property \"standard name\" to an object with info about how to set\n * the property in the DOM. Each object contains:\n *\n * attributeName:\n *   Used when rendering markup or with `*Attribute()`.\n * attributeNamespace\n * propertyName:\n *   Used on DOM node instances. (This includes properties that mutate due to\n *   external factors.)\n * mutationMethod:\n *   If non-null, used instead of the property or `setAttribute()` after\n *   initial render.\n * mustUseProperty:\n *   Whether the property must be accessed and mutated as an object property.\n * hasBooleanValue:\n *   Whether the property should be removed when set to a falsey value.\n * hasNumericValue:\n *   Whether the property must be numeric or parse as a numeric and should be\n *   removed when set to a falsey value.\n * hasPositiveNumericValue:\n *   Whether the property must be positive numeric or parse as a positive\n *   numeric and should be removed when set to a falsey value.\n * hasOverloadedBooleanValue:\n *   Whether the property can be used as a flag as well as with a value.\n *   Removed when strictly equal to false; present without a value when\n *   strictly equal to true; present with a value otherwise.\n */\nvar properties = {};\n\n/**\n * Checks whether a property name is a writeable attribute.\n * @method\n */\nfunction shouldSetAttribute(name, value) {\n  if (isReservedProp(name)) {\n    return false;\n  }\n  if (name.length > 2 && (name[0] === 'o' || name[0] === 'O') && (name[1] === 'n' || name[1] === 'N')) {\n    return false;\n  }\n  if (value === null) {\n    return true;\n  }\n  switch (typeof value) {\n    case 'boolean':\n      return shouldAttributeAcceptBooleanValue(name);\n    case 'undefined':\n    case 'number':\n    case 'string':\n    case 'object':\n      return true;\n    default:\n      // function, symbol\n      return false;\n  }\n}\n\nfunction getPropertyInfo(name) {\n  return properties.hasOwnProperty(name) ? properties[name] : null;\n}\n\nfunction shouldAttributeAcceptBooleanValue(name) {\n  if (isReservedProp(name)) {\n    return true;\n  }\n  var propertyInfo = getPropertyInfo(name);\n  if (propertyInfo) {\n    return propertyInfo.hasBooleanValue || propertyInfo.hasStringBooleanValue || propertyInfo.hasOverloadedBooleanValue;\n  }\n  var prefix = name.toLowerCase().slice(0, 5);\n  return prefix === 'data-' || prefix === 'aria-';\n}\n\n/**\n * Checks to see if a property name is within the list of properties\n * reserved for internal React operations. These properties should\n * not be set on an HTML element.\n *\n * @private\n * @param {string} name\n * @return {boolean} If the name is within reserved props\n */\nfunction isReservedProp(name) {\n  return RESERVED_PROPS.hasOwnProperty(name);\n}\n\nvar injection = DOMPropertyInjection;\n\nvar MUST_USE_PROPERTY = injection.MUST_USE_PROPERTY;\nvar HAS_BOOLEAN_VALUE = injection.HAS_BOOLEAN_VALUE;\nvar HAS_NUMERIC_VALUE = injection.HAS_NUMERIC_VALUE;\nvar HAS_POSITIVE_NUMERIC_VALUE = injection.HAS_POSITIVE_NUMERIC_VALUE;\nvar HAS_OVERLOADED_BOOLEAN_VALUE = injection.HAS_OVERLOADED_BOOLEAN_VALUE;\nvar HAS_STRING_BOOLEAN_VALUE = injection.HAS_STRING_BOOLEAN_VALUE;\n\nvar HTMLDOMPropertyConfig = {\n  // When adding attributes to this list, be sure to also add them to\n  // the `possibleStandardNames` module to ensure casing and incorrect\n  // name warnings.\n  Properties: {\n    allowFullScreen: HAS_BOOLEAN_VALUE,\n    // specifies target context for links with `preload` type\n    async: HAS_BOOLEAN_VALUE,\n    // Note: there is a special case that prevents it from being written to the DOM\n    // on the client side because the browsers are inconsistent. Instead we call focus().\n    autoFocus: HAS_BOOLEAN_VALUE,\n    autoPlay: HAS_BOOLEAN_VALUE,\n    capture: HAS_OVERLOADED_BOOLEAN_VALUE,\n    checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,\n    cols: HAS_POSITIVE_NUMERIC_VALUE,\n    contentEditable: HAS_STRING_BOOLEAN_VALUE,\n    controls: HAS_BOOLEAN_VALUE,\n    'default': HAS_BOOLEAN_VALUE,\n    defer: HAS_BOOLEAN_VALUE,\n    disabled: HAS_BOOLEAN_VALUE,\n    download: HAS_OVERLOADED_BOOLEAN_VALUE,\n    draggable: HAS_STRING_BOOLEAN_VALUE,\n    formNoValidate: HAS_BOOLEAN_VALUE,\n    hidden: HAS_BOOLEAN_VALUE,\n    loop: HAS_BOOLEAN_VALUE,\n    // Caution; `option.selected` is not updated if `select.multiple` is\n    // disabled with `removeAttribute`.\n    multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,\n    muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,\n    noValidate: HAS_BOOLEAN_VALUE,\n    open: HAS_BOOLEAN_VALUE,\n    playsInline: HAS_BOOLEAN_VALUE,\n    readOnly: HAS_BOOLEAN_VALUE,\n    required: HAS_BOOLEAN_VALUE,\n    reversed: HAS_BOOLEAN_VALUE,\n    rows: HAS_POSITIVE_NUMERIC_VALUE,\n    rowSpan: HAS_NUMERIC_VALUE,\n    scoped: HAS_BOOLEAN_VALUE,\n    seamless: HAS_BOOLEAN_VALUE,\n    selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,\n    size: HAS_POSITIVE_NUMERIC_VALUE,\n    start: HAS_NUMERIC_VALUE,\n    // support for projecting regular DOM Elements via V1 named slots ( shadow dom )\n    span: HAS_POSITIVE_NUMERIC_VALUE,\n    spellCheck: HAS_STRING_BOOLEAN_VALUE,\n    // Style must be explicitly set in the attribute list. React components\n    // expect a style object\n    style: 0,\n    // Keep it in the whitelist because it is case-sensitive for SVG.\n    tabIndex: 0,\n    // itemScope is for for Microdata support.\n    // See http://schema.org/docs/gs.html\n    itemScope: HAS_BOOLEAN_VALUE,\n    // These attributes must stay in the white-list because they have\n    // different attribute names (see DOMAttributeNames below)\n    acceptCharset: 0,\n    className: 0,\n    htmlFor: 0,\n    httpEquiv: 0,\n    // Attributes with mutation methods must be specified in the whitelist\n    // Set the string boolean flag to allow the behavior\n    value: HAS_STRING_BOOLEAN_VALUE\n  },\n  DOMAttributeNames: {\n    acceptCharset: 'accept-charset',\n    className: 'class',\n    htmlFor: 'for',\n    httpEquiv: 'http-equiv'\n  },\n  DOMMutationMethods: {\n    value: function (node, value) {\n      if (value == null) {\n        return node.removeAttribute('value');\n      }\n\n      // Number inputs get special treatment due to some edge cases in\n      // Chrome. Let everything else assign the value attribute as normal.\n      // https://github.com/facebook/react/issues/7253#issuecomment-236074326\n      if (node.type !== 'number' || node.hasAttribute('value') === false) {\n        node.setAttribute('value', '' + value);\n      } else if (node.validity && !node.validity.badInput && node.ownerDocument.activeElement !== node) {\n        // Don't assign an attribute if validation reports bad\n        // input. Chrome will clear the value. Additionally, don't\n        // operate on inputs that have focus, otherwise Chrome might\n        // strip off trailing decimal places and cause the user's\n        // cursor position to jump to the beginning of the input.\n        //\n        // In ReactDOMInput, we have an onBlur event that will trigger\n        // this function again when focus is lost.\n        node.setAttribute('value', '' + value);\n      }\n    }\n  }\n};\n\nvar HAS_STRING_BOOLEAN_VALUE$1 = injection.HAS_STRING_BOOLEAN_VALUE;\n\n\nvar NS = {\n  xlink: 'http://www.w3.org/1999/xlink',\n  xml: 'http://www.w3.org/XML/1998/namespace'\n};\n\n/**\n * This is a list of all SVG attributes that need special casing,\n * namespacing, or boolean value assignment.\n *\n * When adding attributes to this list, be sure to also add them to\n * the `possibleStandardNames` module to ensure casing and incorrect\n * name warnings.\n *\n * SVG Attributes List:\n * https://www.w3.org/TR/SVG/attindex.html\n * SMIL Spec:\n * https://www.w3.org/TR/smil\n */\nvar ATTRS = ['accent-height', 'alignment-baseline', 'arabic-form', 'baseline-shift', 'cap-height', 'clip-path', 'clip-rule', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'dominant-baseline', 'enable-background', 'fill-opacity', 'fill-rule', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'glyph-name', 'glyph-orientation-horizontal', 'glyph-orientation-vertical', 'horiz-adv-x', 'horiz-origin-x', 'image-rendering', 'letter-spacing', 'lighting-color', 'marker-end', 'marker-mid', 'marker-start', 'overline-position', 'overline-thickness', 'paint-order', 'panose-1', 'pointer-events', 'rendering-intent', 'shape-rendering', 'stop-color', 'stop-opacity', 'strikethrough-position', 'strikethrough-thickness', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke-width', 'text-anchor', 'text-decoration', 'text-rendering', 'underline-position', 'underline-thickness', 'unicode-bidi', 'unicode-range', 'units-per-em', 'v-alphabetic', 'v-hanging', 'v-ideographic', 'v-mathematical', 'vector-effect', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'word-spacing', 'writing-mode', 'x-height', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xmlns:xlink', 'xml:lang', 'xml:space'];\n\nvar SVGDOMPropertyConfig = {\n  Properties: {\n    autoReverse: HAS_STRING_BOOLEAN_VALUE$1,\n    externalResourcesRequired: HAS_STRING_BOOLEAN_VALUE$1,\n    preserveAlpha: HAS_STRING_BOOLEAN_VALUE$1\n  },\n  DOMAttributeNames: {\n    autoReverse: 'autoReverse',\n    externalResourcesRequired: 'externalResourcesRequired',\n    preserveAlpha: 'preserveAlpha'\n  },\n  DOMAttributeNamespaces: {\n    xlinkActuate: NS.xlink,\n    xlinkArcrole: NS.xlink,\n    xlinkHref: NS.xlink,\n    xlinkRole: NS.xlink,\n    xlinkShow: NS.xlink,\n    xlinkTitle: NS.xlink,\n    xlinkType: NS.xlink,\n    xmlBase: NS.xml,\n    xmlLang: NS.xml,\n    xmlSpace: NS.xml\n  }\n};\n\nvar CAMELIZE = /[\\-\\:]([a-z])/g;\nvar capitalize = function (token) {\n  return token[1].toUpperCase();\n};\n\nATTRS.forEach(function (original) {\n  var reactName = original.replace(CAMELIZE, capitalize);\n\n  SVGDOMPropertyConfig.Properties[reactName] = 0;\n  SVGDOMPropertyConfig.DOMAttributeNames[reactName] = original;\n});\n\ninjection.injectDOMPropertyConfig(HTMLDOMPropertyConfig);\ninjection.injectDOMPropertyConfig(SVGDOMPropertyConfig);\n\nvar ReactErrorUtils = {\n  // Used by Fiber to simulate a try-catch.\n  _caughtError: null,\n  _hasCaughtError: false,\n\n  // Used by event system to capture/rethrow the first error.\n  _rethrowError: null,\n  _hasRethrowError: false,\n\n  injection: {\n    injectErrorUtils: function (injectedErrorUtils) {\n      !(typeof injectedErrorUtils.invokeGuardedCallback === 'function') ? invariant(false, 'Injected invokeGuardedCallback() must be a function.') : void 0;\n      invokeGuardedCallback = injectedErrorUtils.invokeGuardedCallback;\n    }\n  },\n\n  /**\n   * Call a function while guarding against errors that happens within it.\n   * Returns an error if it throws, otherwise null.\n   *\n   * In production, this is implemented using a try-catch. The reason we don't\n   * use a try-catch directly is so that we can swap out a different\n   * implementation in DEV mode.\n   *\n   * @param {String} name of the guard to use for logging or debugging\n   * @param {Function} func The function to invoke\n   * @param {*} context The context to use when calling the function\n   * @param {...*} args Arguments for function\n   */\n  invokeGuardedCallback: function (name, func, context, a, b, c, d, e, f) {\n    invokeGuardedCallback.apply(ReactErrorUtils, arguments);\n  },\n\n  /**\n   * Same as invokeGuardedCallback, but instead of returning an error, it stores\n   * it in a global so it can be rethrown by `rethrowCaughtError` later.\n   * TODO: See if _caughtError and _rethrowError can be unified.\n   *\n   * @param {String} name of the guard to use for logging or debugging\n   * @param {Function} func The function to invoke\n   * @param {*} context The context to use when calling the function\n   * @param {...*} args Arguments for function\n   */\n  invokeGuardedCallbackAndCatchFirstError: function (name, func, context, a, b, c, d, e, f) {\n    ReactErrorUtils.invokeGuardedCallback.apply(this, arguments);\n    if (ReactErrorUtils.hasCaughtError()) {\n      var error = ReactErrorUtils.clearCaughtError();\n      if (!ReactErrorUtils._hasRethrowError) {\n        ReactErrorUtils._hasRethrowError = true;\n        ReactErrorUtils._rethrowError = error;\n      }\n    }\n  },\n\n  /**\n   * During execution of guarded functions we will capture the first error which\n   * we will rethrow to be handled by the top level error handler.\n   */\n  rethrowCaughtError: function () {\n    return rethrowCaughtError.apply(ReactErrorUtils, arguments);\n  },\n\n  hasCaughtError: function () {\n    return ReactErrorUtils._hasCaughtError;\n  },\n\n  clearCaughtError: function () {\n    if (ReactErrorUtils._hasCaughtError) {\n      var error = ReactErrorUtils._caughtError;\n      ReactErrorUtils._caughtError = null;\n      ReactErrorUtils._hasCaughtError = false;\n      return error;\n    } else {\n      invariant(false, 'clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.');\n    }\n  }\n};\n\nvar invokeGuardedCallback = function (name, func, context, a, b, c, d, e, f) {\n  ReactErrorUtils._hasCaughtError = false;\n  ReactErrorUtils._caughtError = null;\n  var funcArgs = Array.prototype.slice.call(arguments, 3);\n  try {\n    func.apply(context, funcArgs);\n  } catch (error) {\n    ReactErrorUtils._caughtError = error;\n    ReactErrorUtils._hasCaughtError = true;\n  }\n};\n\n{\n  // In DEV mode, we swap out invokeGuardedCallback for a special version\n  // that plays more nicely with the browser's DevTools. The idea is to preserve\n  // \"Pause on exceptions\" behavior. Because React wraps all user-provided\n  // functions in invokeGuardedCallback, and the production version of\n  // invokeGuardedCallback uses a try-catch, all user exceptions are treated\n  // like caught exceptions, and the DevTools won't pause unless the developer\n  // takes the extra step of enabling pause on caught exceptions. This is\n  // untintuitive, though, because even though React has caught the error, from\n  // the developer's perspective, the error is uncaught.\n  //\n  // To preserve the expected \"Pause on exceptions\" behavior, we don't use a\n  // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake\n  // DOM node, and call the user-provided callback from inside an event handler\n  // for that fake event. If the callback throws, the error is \"captured\" using\n  // a global event handler. But because the error happens in a different\n  // event loop context, it does not interrupt the normal program flow.\n  // Effectively, this gives us try-catch behavior without actually using\n  // try-catch. Neat!\n\n  // Check that the browser supports the APIs we need to implement our special\n  // DEV version of invokeGuardedCallback\n  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {\n    var fakeNode = document.createElement('react');\n\n    var invokeGuardedCallbackDev = function (name, func, context, a, b, c, d, e, f) {\n      // Keeps track of whether the user-provided callback threw an error. We\n      // set this to true at the beginning, then set it to false right after\n      // calling the function. If the function errors, `didError` will never be\n      // set to false. This strategy works even if the browser is flaky and\n      // fails to call our global error handler, because it doesn't rely on\n      // the error event at all.\n      var didError = true;\n\n      // Create an event handler for our fake event. We will synchronously\n      // dispatch our fake event using `dispatchEvent`. Inside the handler, we\n      // call the user-provided callback.\n      var funcArgs = Array.prototype.slice.call(arguments, 3);\n      function callCallback() {\n        // We immediately remove the callback from event listeners so that\n        // nested `invokeGuardedCallback` calls do not clash. Otherwise, a\n        // nested call would trigger the fake event handlers of any call higher\n        // in the stack.\n        fakeNode.removeEventListener(evtType, callCallback, false);\n        func.apply(context, funcArgs);\n        didError = false;\n      }\n\n      // Create a global error event handler. We use this to capture the value\n      // that was thrown. It's possible that this error handler will fire more\n      // than once; for example, if non-React code also calls `dispatchEvent`\n      // and a handler for that event throws. We should be resilient to most of\n      // those cases. Even if our error event handler fires more than once, the\n      // last error event is always used. If the callback actually does error,\n      // we know that the last error event is the correct one, because it's not\n      // possible for anything else to have happened in between our callback\n      // erroring and the code that follows the `dispatchEvent` call below. If\n      // the callback doesn't error, but the error event was fired, we know to\n      // ignore it because `didError` will be false, as described above.\n      var error = void 0;\n      // Use this to track whether the error event is ever called.\n      var didSetError = false;\n      var isCrossOriginError = false;\n\n      function onError(event) {\n        error = event.error;\n        didSetError = true;\n        if (error === null && event.colno === 0 && event.lineno === 0) {\n          isCrossOriginError = true;\n        }\n      }\n\n      // Create a fake event type.\n      var evtType = 'react-' + (name ? name : 'invokeguardedcallback');\n\n      // Attach our event handlers\n      window.addEventListener('error', onError);\n      fakeNode.addEventListener(evtType, callCallback, false);\n\n      // Synchronously dispatch our fake event. If the user-provided function\n      // errors, it will trigger our global error handler.\n      var evt = document.createEvent('Event');\n      evt.initEvent(evtType, false, false);\n      fakeNode.dispatchEvent(evt);\n\n      if (didError) {\n        if (!didSetError) {\n          // The callback errored, but the error event never fired.\n          error = new Error('An error was thrown inside one of your components, but React ' + \"doesn't know what it was. This is likely due to browser \" + 'flakiness. React does its best to preserve the \"Pause on ' + 'exceptions\" behavior of the DevTools, which requires some ' + \"DEV-mode only tricks. It's possible that these don't work in \" + 'your browser. Try triggering the error in production mode, ' + 'or switching to a modern browser. If you suspect that this is ' + 'actually an issue with React, please file an issue.');\n        } else if (isCrossOriginError) {\n          error = new Error(\"A cross-origin error was thrown. React doesn't have access to \" + 'the actual error object in development. ' + 'See https://fb.me/react-crossorigin-error for more information.');\n        }\n        ReactErrorUtils._hasCaughtError = true;\n        ReactErrorUtils._caughtError = error;\n      } else {\n        ReactErrorUtils._hasCaughtError = false;\n        ReactErrorUtils._caughtError = null;\n      }\n\n      // Remove our event listeners\n      window.removeEventListener('error', onError);\n    };\n\n    invokeGuardedCallback = invokeGuardedCallbackDev;\n  }\n}\n\nvar rethrowCaughtError = function () {\n  if (ReactErrorUtils._hasRethrowError) {\n    var error = ReactErrorUtils._rethrowError;\n    ReactErrorUtils._rethrowError = null;\n    ReactErrorUtils._hasRethrowError = false;\n    throw error;\n  }\n};\n\n/**\n * Injectable ordering of event plugins.\n */\nvar eventPluginOrder = null;\n\n/**\n * Injectable mapping from names to event plugin modules.\n */\nvar namesToPlugins = {};\n\n/**\n * Recomputes the plugin list using the injected plugins and plugin ordering.\n *\n * @private\n */\nfunction recomputePluginOrdering() {\n  if (!eventPluginOrder) {\n    // Wait until an `eventPluginOrder` is injected.\n    return;\n  }\n  for (var pluginName in namesToPlugins) {\n    var pluginModule = namesToPlugins[pluginName];\n    var pluginIndex = eventPluginOrder.indexOf(pluginName);\n    !(pluginIndex > -1) ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.', pluginName) : void 0;\n    if (plugins[pluginIndex]) {\n      continue;\n    }\n    !pluginModule.extractEvents ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.', pluginName) : void 0;\n    plugins[pluginIndex] = pluginModule;\n    var publishedEvents = pluginModule.eventTypes;\n    for (var eventName in publishedEvents) {\n      !publishEventForPlugin(publishedEvents[eventName], pluginModule, eventName) ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : void 0;\n    }\n  }\n}\n\n/**\n * Publishes an event so that it can be dispatched by the supplied plugin.\n *\n * @param {object} dispatchConfig Dispatch configuration for the event.\n * @param {object} PluginModule Plugin publishing the event.\n * @return {boolean} True if the event was successfully published.\n * @private\n */\nfunction publishEventForPlugin(dispatchConfig, pluginModule, eventName) {\n  !!eventNameDispatchConfigs.hasOwnProperty(eventName) ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.', eventName) : void 0;\n  eventNameDispatchConfigs[eventName] = dispatchConfig;\n\n  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;\n  if (phasedRegistrationNames) {\n    for (var phaseName in phasedRegistrationNames) {\n      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {\n        var phasedRegistrationName = phasedRegistrationNames[phaseName];\n        publishRegistrationName(phasedRegistrationName, pluginModule, eventName);\n      }\n    }\n    return true;\n  } else if (dispatchConfig.registrationName) {\n    publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Publishes a registration name that is used to identify dispatched events.\n *\n * @param {string} registrationName Registration name to add.\n * @param {object} PluginModule Plugin publishing the event.\n * @private\n */\nfunction publishRegistrationName(registrationName, pluginModule, eventName) {\n  !!registrationNameModules[registrationName] ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.', registrationName) : void 0;\n  registrationNameModules[registrationName] = pluginModule;\n  registrationNameDependencies[registrationName] = pluginModule.eventTypes[eventName].dependencies;\n\n  {\n    var lowerCasedName = registrationName.toLowerCase();\n    possibleRegistrationNames[lowerCasedName] = registrationName;\n\n    if (registrationName === 'onDoubleClick') {\n      possibleRegistrationNames.ondblclick = registrationName;\n    }\n  }\n}\n\n/**\n * Registers plugins so that they can extract and dispatch events.\n *\n * @see {EventPluginHub}\n */\n\n/**\n * Ordered list of injected plugins.\n */\nvar plugins = [];\n\n/**\n * Mapping from event name to dispatch config\n */\nvar eventNameDispatchConfigs = {};\n\n/**\n * Mapping from registration name to plugin module\n */\nvar registrationNameModules = {};\n\n/**\n * Mapping from registration name to event name\n */\nvar registrationNameDependencies = {};\n\n/**\n * Mapping from lowercase registration names to the properly cased version,\n * used to warn in the case of missing event handlers. Available\n * only in true.\n * @type {Object}\n */\nvar possibleRegistrationNames = {};\n// Trust the developer to only use possibleRegistrationNames in true\n\n/**\n * Injects an ordering of plugins (by plugin name). This allows the ordering\n * to be decoupled from injection of the actual plugins so that ordering is\n * always deterministic regardless of packaging, on-the-fly injection, etc.\n *\n * @param {array} InjectedEventPluginOrder\n * @internal\n * @see {EventPluginHub.injection.injectEventPluginOrder}\n */\nfunction injectEventPluginOrder(injectedEventPluginOrder) {\n  !!eventPluginOrder ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.') : void 0;\n  // Clone the ordering so it cannot be dynamically mutated.\n  eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);\n  recomputePluginOrdering();\n}\n\n/**\n * Injects plugins to be used by `EventPluginHub`. The plugin names must be\n * in the ordering injected by `injectEventPluginOrder`.\n *\n * Plugins can be injected as part of page initialization or on-the-fly.\n *\n * @param {object} injectedNamesToPlugins Map from names to plugin modules.\n * @internal\n * @see {EventPluginHub.injection.injectEventPluginsByName}\n */\nfunction injectEventPluginsByName(injectedNamesToPlugins) {\n  var isOrderingDirty = false;\n  for (var pluginName in injectedNamesToPlugins) {\n    if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {\n      continue;\n    }\n    var pluginModule = injectedNamesToPlugins[pluginName];\n    if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {\n      !!namesToPlugins[pluginName] ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.', pluginName) : void 0;\n      namesToPlugins[pluginName] = pluginModule;\n      isOrderingDirty = true;\n    }\n  }\n  if (isOrderingDirty) {\n    recomputePluginOrdering();\n  }\n}\n\nvar EventPluginRegistry = Object.freeze({\n\tplugins: plugins,\n\teventNameDispatchConfigs: eventNameDispatchConfigs,\n\tregistrationNameModules: registrationNameModules,\n\tregistrationNameDependencies: registrationNameDependencies,\n\tpossibleRegistrationNames: possibleRegistrationNames,\n\tinjectEventPluginOrder: injectEventPluginOrder,\n\tinjectEventPluginsByName: injectEventPluginsByName\n});\n\nvar getFiberCurrentPropsFromNode = null;\nvar getInstanceFromNode = null;\nvar getNodeFromInstance = null;\n\nvar injection$2 = {\n  injectComponentTree: function (Injected) {\n    getFiberCurrentPropsFromNode = Injected.getFiberCurrentPropsFromNode;\n    getInstanceFromNode = Injected.getInstanceFromNode;\n    getNodeFromInstance = Injected.getNodeFromInstance;\n\n    {\n      warning(getNodeFromInstance && getInstanceFromNode, 'EventPluginUtils.injection.injectComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.');\n    }\n  }\n};\n\n\n\n\n\n\nvar validateEventDispatches;\n{\n  validateEventDispatches = function (event) {\n    var dispatchListeners = event._dispatchListeners;\n    var dispatchInstances = event._dispatchInstances;\n\n    var listenersIsArr = Array.isArray(dispatchListeners);\n    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;\n\n    var instancesIsArr = Array.isArray(dispatchInstances);\n    var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;\n\n    warning(instancesIsArr === listenersIsArr && instancesLen === listenersLen, 'EventPluginUtils: Invalid `event`.');\n  };\n}\n\n/**\n * Dispatch the event to the listener.\n * @param {SyntheticEvent} event SyntheticEvent to handle\n * @param {boolean} simulated If the event is simulated (changes exn behavior)\n * @param {function} listener Application-level callback\n * @param {*} inst Internal component instance\n */\nfunction executeDispatch(event, simulated, listener, inst) {\n  var type = event.type || 'unknown-event';\n  event.currentTarget = getNodeFromInstance(inst);\n  ReactErrorUtils.invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);\n  event.currentTarget = null;\n}\n\n/**\n * Standard/simple iteration through an event's collected dispatches.\n */\nfunction executeDispatchesInOrder(event, simulated) {\n  var dispatchListeners = event._dispatchListeners;\n  var dispatchInstances = event._dispatchInstances;\n  {\n    validateEventDispatches(event);\n  }\n  if (Array.isArray(dispatchListeners)) {\n    for (var i = 0; i < dispatchListeners.length; i++) {\n      if (event.isPropagationStopped()) {\n        break;\n      }\n      // Listeners and Instances are two parallel arrays that are always in sync.\n      executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]);\n    }\n  } else if (dispatchListeners) {\n    executeDispatch(event, simulated, dispatchListeners, dispatchInstances);\n  }\n  event._dispatchListeners = null;\n  event._dispatchInstances = null;\n}\n\n/**\n * @see executeDispatchesInOrderStopAtTrueImpl\n */\n\n\n/**\n * Execution of a \"direct\" dispatch - there must be at most one dispatch\n * accumulated on the event or it is considered an error. It doesn't really make\n * sense for an event with multiple dispatches (bubbled) to keep track of the\n * return values at each dispatch execution, but it does tend to make sense when\n * dealing with \"direct\" dispatches.\n *\n * @return {*} The return value of executing the single dispatch.\n */\n\n\n/**\n * @param {SyntheticEvent} event\n * @return {boolean} True iff number of dispatches accumulated is greater than 0.\n */\n\n/**\n * Accumulates items that must not be null or undefined into the first one. This\n * is used to conserve memory by avoiding array allocations, and thus sacrifices\n * API cleanness. Since `current` can be null before being passed in and not\n * null after this function, make sure to assign it back to `current`:\n *\n * `a = accumulateInto(a, b);`\n *\n * This API should be sparingly used. Try `accumulate` for something cleaner.\n *\n * @return {*|array<*>} An accumulation of items.\n */\n\nfunction accumulateInto(current, next) {\n  !(next != null) ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : void 0;\n\n  if (current == null) {\n    return next;\n  }\n\n  // Both are not empty. Warning: Never call x.concat(y) when you are not\n  // certain that x is an Array (x could be a string with concat method).\n  if (Array.isArray(current)) {\n    if (Array.isArray(next)) {\n      current.push.apply(current, next);\n      return current;\n    }\n    current.push(next);\n    return current;\n  }\n\n  if (Array.isArray(next)) {\n    // A bit too dangerous to mutate `next`.\n    return [current].concat(next);\n  }\n\n  return [current, next];\n}\n\n/**\n * @param {array} arr an \"accumulation\" of items which is either an Array or\n * a single item. Useful when paired with the `accumulate` module. This is a\n * simple utility that allows us to reason about a collection of items, but\n * handling the case when there is exactly one item (and we do not need to\n * allocate an array).\n * @param {function} cb Callback invoked with each element or a collection.\n * @param {?} [scope] Scope used as `this` in a callback.\n */\nfunction forEachAccumulated(arr, cb, scope) {\n  if (Array.isArray(arr)) {\n    arr.forEach(cb, scope);\n  } else if (arr) {\n    cb.call(scope, arr);\n  }\n}\n\n/**\n * Internal queue of events that have accumulated their dispatches and are\n * waiting to have their dispatches executed.\n */\nvar eventQueue = null;\n\n/**\n * Dispatches an event and releases it back into the pool, unless persistent.\n *\n * @param {?object} event Synthetic event to be dispatched.\n * @param {boolean} simulated If the event is simulated (changes exn behavior)\n * @private\n */\nvar executeDispatchesAndRelease = function (event, simulated) {\n  if (event) {\n    executeDispatchesInOrder(event, simulated);\n\n    if (!event.isPersistent()) {\n      event.constructor.release(event);\n    }\n  }\n};\nvar executeDispatchesAndReleaseSimulated = function (e) {\n  return executeDispatchesAndRelease(e, true);\n};\nvar executeDispatchesAndReleaseTopLevel = function (e) {\n  return executeDispatchesAndRelease(e, false);\n};\n\nfunction isInteractive(tag) {\n  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';\n}\n\nfunction shouldPreventMouseEvent(name, type, props) {\n  switch (name) {\n    case 'onClick':\n    case 'onClickCapture':\n    case 'onDoubleClick':\n    case 'onDoubleClickCapture':\n    case 'onMouseDown':\n    case 'onMouseDownCapture':\n    case 'onMouseMove':\n    case 'onMouseMoveCapture':\n    case 'onMouseUp':\n    case 'onMouseUpCapture':\n      return !!(props.disabled && isInteractive(type));\n    default:\n      return false;\n  }\n}\n\n/**\n * This is a unified interface for event plugins to be installed and configured.\n *\n * Event plugins can implement the following properties:\n *\n *   `extractEvents` {function(string, DOMEventTarget, string, object): *}\n *     Required. When a top-level event is fired, this method is expected to\n *     extract synthetic events that will in turn be queued and dispatched.\n *\n *   `eventTypes` {object}\n *     Optional, plugins that fire events must publish a mapping of registration\n *     names that are used to register listeners. Values of this mapping must\n *     be objects that contain `registrationName` or `phasedRegistrationNames`.\n *\n *   `executeDispatch` {function(object, function, string)}\n *     Optional, allows plugins to override how an event gets dispatched. By\n *     default, the listener is simply invoked.\n *\n * Each plugin that is injected into `EventsPluginHub` is immediately operable.\n *\n * @public\n */\n\n/**\n * Methods for injecting dependencies.\n */\nvar injection$1 = {\n  /**\n   * @param {array} InjectedEventPluginOrder\n   * @public\n   */\n  injectEventPluginOrder: injectEventPluginOrder,\n\n  /**\n   * @param {object} injectedNamesToPlugins Map from names to plugin modules.\n   */\n  injectEventPluginsByName: injectEventPluginsByName\n};\n\n/**\n * @param {object} inst The instance, which is the source of events.\n * @param {string} registrationName Name of listener (e.g. `onClick`).\n * @return {?function} The stored callback.\n */\nfunction getListener(inst, registrationName) {\n  var listener;\n\n  // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not\n  // live here; needs to be moved to a better place soon\n  var stateNode = inst.stateNode;\n  if (!stateNode) {\n    // Work in progress (ex: onload events in incremental mode).\n    return null;\n  }\n  var props = getFiberCurrentPropsFromNode(stateNode);\n  if (!props) {\n    // Work in progress.\n    return null;\n  }\n  listener = props[registrationName];\n  if (shouldPreventMouseEvent(registrationName, inst.type, props)) {\n    return null;\n  }\n  !(!listener || typeof listener === 'function') ? invariant(false, 'Expected `%s` listener to be a function, instead got a value of `%s` type.', registrationName, typeof listener) : void 0;\n  return listener;\n}\n\n/**\n * Allows registered plugins an opportunity to extract events from top-level\n * native browser events.\n *\n * @return {*} An accumulation of synthetic events.\n * @internal\n */\nfunction extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n  var events;\n  for (var i = 0; i < plugins.length; i++) {\n    // Not every plugin in the ordering may be loaded at runtime.\n    var possiblePlugin = plugins[i];\n    if (possiblePlugin) {\n      var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);\n      if (extractedEvents) {\n        events = accumulateInto(events, extractedEvents);\n      }\n    }\n  }\n  return events;\n}\n\n/**\n * Enqueues a synthetic event that should be dispatched when\n * `processEventQueue` is invoked.\n *\n * @param {*} events An accumulation of synthetic events.\n * @internal\n */\nfunction enqueueEvents(events) {\n  if (events) {\n    eventQueue = accumulateInto(eventQueue, events);\n  }\n}\n\n/**\n * Dispatches all synthetic events on the event queue.\n *\n * @internal\n */\nfunction processEventQueue(simulated) {\n  // Set `eventQueue` to null before processing it so that we can tell if more\n  // events get enqueued while processing.\n  var processingEventQueue = eventQueue;\n  eventQueue = null;\n\n  if (!processingEventQueue) {\n    return;\n  }\n\n  if (simulated) {\n    forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);\n  } else {\n    forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);\n  }\n  !!eventQueue ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.') : void 0;\n  // This would be a good time to rethrow if any of the event handlers threw.\n  ReactErrorUtils.rethrowCaughtError();\n}\n\nvar EventPluginHub = Object.freeze({\n\tinjection: injection$1,\n\tgetListener: getListener,\n\textractEvents: extractEvents,\n\tenqueueEvents: enqueueEvents,\n\tprocessEventQueue: processEventQueue\n});\n\nvar IndeterminateComponent = 0; // Before we know whether it is functional or class\nvar FunctionalComponent = 1;\nvar ClassComponent = 2;\nvar HostRoot = 3; // Root of a host tree. Could be nested inside another node.\nvar HostPortal = 4; // A subtree. Could be an entry point to a different renderer.\nvar HostComponent = 5;\nvar HostText = 6;\nvar CallComponent = 7;\nvar CallHandlerPhase = 8;\nvar ReturnComponent = 9;\nvar Fragment = 10;\n\nvar randomKey = Math.random().toString(36).slice(2);\nvar internalInstanceKey = '__reactInternalInstance$' + randomKey;\nvar internalEventHandlersKey = '__reactEventHandlers$' + randomKey;\n\nfunction precacheFiberNode$1(hostInst, node) {\n  node[internalInstanceKey] = hostInst;\n}\n\n/**\n * Given a DOM node, return the closest ReactDOMComponent or\n * ReactDOMTextComponent instance ancestor.\n */\nfunction getClosestInstanceFromNode(node) {\n  if (node[internalInstanceKey]) {\n    return node[internalInstanceKey];\n  }\n\n  // Walk up the tree until we find an ancestor whose instance we have cached.\n  var parents = [];\n  while (!node[internalInstanceKey]) {\n    parents.push(node);\n    if (node.parentNode) {\n      node = node.parentNode;\n    } else {\n      // Top of the tree. This node must not be part of a React tree (or is\n      // unmounted, potentially).\n      return null;\n    }\n  }\n\n  var closest = void 0;\n  var inst = node[internalInstanceKey];\n  if (inst.tag === HostComponent || inst.tag === HostText) {\n    // In Fiber, this will always be the deepest root.\n    return inst;\n  }\n  for (; node && (inst = node[internalInstanceKey]); node = parents.pop()) {\n    closest = inst;\n  }\n\n  return closest;\n}\n\n/**\n * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent\n * instance, or null if the node was not rendered by this React.\n */\nfunction getInstanceFromNode$1(node) {\n  var inst = node[internalInstanceKey];\n  if (inst) {\n    if (inst.tag === HostComponent || inst.tag === HostText) {\n      return inst;\n    } else {\n      return null;\n    }\n  }\n  return null;\n}\n\n/**\n * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding\n * DOM node.\n */\nfunction getNodeFromInstance$1(inst) {\n  if (inst.tag === HostComponent || inst.tag === HostText) {\n    // In Fiber this, is just the state node right now. We assume it will be\n    // a host component or host text.\n    return inst.stateNode;\n  }\n\n  // Without this first invariant, passing a non-DOM-component triggers the next\n  // invariant for a missing parent, which is super confusing.\n  invariant(false, 'getNodeFromInstance: Invalid argument.');\n}\n\nfunction getFiberCurrentPropsFromNode$1(node) {\n  return node[internalEventHandlersKey] || null;\n}\n\nfunction updateFiberProps$1(node, props) {\n  node[internalEventHandlersKey] = props;\n}\n\nvar ReactDOMComponentTree = Object.freeze({\n\tprecacheFiberNode: precacheFiberNode$1,\n\tgetClosestInstanceFromNode: getClosestInstanceFromNode,\n\tgetInstanceFromNode: getInstanceFromNode$1,\n\tgetNodeFromInstance: getNodeFromInstance$1,\n\tgetFiberCurrentPropsFromNode: getFiberCurrentPropsFromNode$1,\n\tupdateFiberProps: updateFiberProps$1\n});\n\nfunction getParent(inst) {\n  do {\n    inst = inst['return'];\n    // TODO: If this is a HostRoot we might want to bail out.\n    // That is depending on if we want nested subtrees (layers) to bubble\n    // events to their parent. We could also go through parentNode on the\n    // host node but that wouldn't work for React Native and doesn't let us\n    // do the portal feature.\n  } while (inst && inst.tag !== HostComponent);\n  if (inst) {\n    return inst;\n  }\n  return null;\n}\n\n/**\n * Return the lowest common ancestor of A and B, or null if they are in\n * different trees.\n */\nfunction getLowestCommonAncestor(instA, instB) {\n  var depthA = 0;\n  for (var tempA = instA; tempA; tempA = getParent(tempA)) {\n    depthA++;\n  }\n  var depthB = 0;\n  for (var tempB = instB; tempB; tempB = getParent(tempB)) {\n    depthB++;\n  }\n\n  // If A is deeper, crawl up.\n  while (depthA - depthB > 0) {\n    instA = getParent(instA);\n    depthA--;\n  }\n\n  // If B is deeper, crawl up.\n  while (depthB - depthA > 0) {\n    instB = getParent(instB);\n    depthB--;\n  }\n\n  // Walk in lockstep until we find a match.\n  var depth = depthA;\n  while (depth--) {\n    if (instA === instB || instA === instB.alternate) {\n      return instA;\n    }\n    instA = getParent(instA);\n    instB = getParent(instB);\n  }\n  return null;\n}\n\n/**\n * Return if A is an ancestor of B.\n */\n\n\n/**\n * Return the parent instance of the passed-in instance.\n */\nfunction getParentInstance(inst) {\n  return getParent(inst);\n}\n\n/**\n * Simulates the traversal of a two-phase, capture/bubble event dispatch.\n */\nfunction traverseTwoPhase(inst, fn, arg) {\n  var path = [];\n  while (inst) {\n    path.push(inst);\n    inst = getParent(inst);\n  }\n  var i;\n  for (i = path.length; i-- > 0;) {\n    fn(path[i], 'captured', arg);\n  }\n  for (i = 0; i < path.length; i++) {\n    fn(path[i], 'bubbled', arg);\n  }\n}\n\n/**\n * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that\n * should would receive a `mouseEnter` or `mouseLeave` event.\n *\n * Does not invoke the callback on the nearest common ancestor because nothing\n * \"entered\" or \"left\" that element.\n */\nfunction traverseEnterLeave(from, to, fn, argFrom, argTo) {\n  var common = from && to ? getLowestCommonAncestor(from, to) : null;\n  var pathFrom = [];\n  while (true) {\n    if (!from) {\n      break;\n    }\n    if (from === common) {\n      break;\n    }\n    var alternate = from.alternate;\n    if (alternate !== null && alternate === common) {\n      break;\n    }\n    pathFrom.push(from);\n    from = getParent(from);\n  }\n  var pathTo = [];\n  while (true) {\n    if (!to) {\n      break;\n    }\n    if (to === common) {\n      break;\n    }\n    var _alternate = to.alternate;\n    if (_alternate !== null && _alternate === common) {\n      break;\n    }\n    pathTo.push(to);\n    to = getParent(to);\n  }\n  for (var i = 0; i < pathFrom.length; i++) {\n    fn(pathFrom[i], 'bubbled', argFrom);\n  }\n  for (var _i = pathTo.length; _i-- > 0;) {\n    fn(pathTo[_i], 'captured', argTo);\n  }\n}\n\n/**\n * Some event types have a notion of different registration names for different\n * \"phases\" of propagation. This finds listeners by a given phase.\n */\nfunction listenerAtPhase(inst, event, propagationPhase) {\n  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];\n  return getListener(inst, registrationName);\n}\n\n/**\n * A small set of propagation patterns, each of which will accept a small amount\n * of information, and generate a set of \"dispatch ready event objects\" - which\n * are sets of events that have already been annotated with a set of dispatched\n * listener functions/ids. The API is designed this way to discourage these\n * propagation strategies from actually executing the dispatches, since we\n * always want to collect the entire set of dispatches before executing even a\n * single one.\n */\n\n/**\n * Tags a `SyntheticEvent` with dispatched listeners. Creating this function\n * here, allows us to not have to bind or create functions for each event.\n * Mutating the event's members allows us to not have to create a wrapping\n * \"dispatch\" object that pairs the event with the listener.\n */\nfunction accumulateDirectionalDispatches(inst, phase, event) {\n  {\n    warning(inst, 'Dispatching inst must not be null');\n  }\n  var listener = listenerAtPhase(inst, event, phase);\n  if (listener) {\n    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n  }\n}\n\n/**\n * Collect dispatches (must be entirely collected before dispatching - see unit\n * tests). Lazily allocate the array to conserve memory.  We must loop through\n * each event and perform the traversal for each one. We cannot perform a\n * single traversal for the entire collection of events because each event may\n * have a different target.\n */\nfunction accumulateTwoPhaseDispatchesSingle(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);\n  }\n}\n\n/**\n * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.\n */\nfunction accumulateTwoPhaseDispatchesSingleSkipTarget(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    var targetInst = event._targetInst;\n    var parentInst = targetInst ? getParentInstance(targetInst) : null;\n    traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);\n  }\n}\n\n/**\n * Accumulates without regard to direction, does not look for phased\n * registration names. Same as `accumulateDirectDispatchesSingle` but without\n * requiring that the `dispatchMarker` be the same as the dispatched ID.\n */\nfunction accumulateDispatches(inst, ignoredDirection, event) {\n  if (inst && event && event.dispatchConfig.registrationName) {\n    var registrationName = event.dispatchConfig.registrationName;\n    var listener = getListener(inst, registrationName);\n    if (listener) {\n      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n    }\n  }\n}\n\n/**\n * Accumulates dispatches on an `SyntheticEvent`, but only for the\n * `dispatchMarker`.\n * @param {SyntheticEvent} event\n */\nfunction accumulateDirectDispatchesSingle(event) {\n  if (event && event.dispatchConfig.registrationName) {\n    accumulateDispatches(event._targetInst, null, event);\n  }\n}\n\nfunction accumulateTwoPhaseDispatches(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);\n}\n\nfunction accumulateTwoPhaseDispatchesSkipTarget(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);\n}\n\nfunction accumulateEnterLeaveDispatches(leave, enter, from, to) {\n  traverseEnterLeave(from, to, accumulateDispatches, leave, enter);\n}\n\nfunction accumulateDirectDispatches(events) {\n  forEachAccumulated(events, accumulateDirectDispatchesSingle);\n}\n\nvar EventPropagators = Object.freeze({\n\taccumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,\n\taccumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,\n\taccumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches,\n\taccumulateDirectDispatches: accumulateDirectDispatches\n});\n\nvar contentKey = null;\n\n/**\n * Gets the key used to access text content on a DOM node.\n *\n * @return {?string} Key used to access text content.\n * @internal\n */\nfunction getTextContentAccessor() {\n  if (!contentKey && ExecutionEnvironment.canUseDOM) {\n    // Prefer textContent to innerText because many browsers support both but\n    // SVG <text> elements don't support innerText even when <div> does.\n    contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';\n  }\n  return contentKey;\n}\n\n/**\n * This helper object stores information about text content of a target node,\n * allowing comparison of content before and after a given event.\n *\n * Identify the node where selection currently begins, then observe\n * both its text content and its current position in the DOM. Since the\n * browser may natively replace the target node during composition, we can\n * use its position to find its replacement.\n *\n *\n */\nvar compositionState = {\n  _root: null,\n  _startText: null,\n  _fallbackText: null\n};\n\nfunction initialize(nativeEventTarget) {\n  compositionState._root = nativeEventTarget;\n  compositionState._startText = getText();\n  return true;\n}\n\nfunction reset() {\n  compositionState._root = null;\n  compositionState._startText = null;\n  compositionState._fallbackText = null;\n}\n\nfunction getData() {\n  if (compositionState._fallbackText) {\n    return compositionState._fallbackText;\n  }\n\n  var start;\n  var startValue = compositionState._startText;\n  var startLength = startValue.length;\n  var end;\n  var endValue = getText();\n  var endLength = endValue.length;\n\n  for (start = 0; start < startLength; start++) {\n    if (startValue[start] !== endValue[start]) {\n      break;\n    }\n  }\n\n  var minEnd = startLength - start;\n  for (end = 1; end <= minEnd; end++) {\n    if (startValue[startLength - end] !== endValue[endLength - end]) {\n      break;\n    }\n  }\n\n  var sliceTail = end > 1 ? 1 - end : undefined;\n  compositionState._fallbackText = endValue.slice(start, sliceTail);\n  return compositionState._fallbackText;\n}\n\nfunction getText() {\n  if ('value' in compositionState._root) {\n    return compositionState._root.value;\n  }\n  return compositionState._root[getTextContentAccessor()];\n}\n\n/* eslint valid-typeof: 0 */\n\nvar didWarnForAddedNewProperty = false;\nvar isProxySupported = typeof Proxy === 'function';\nvar EVENT_POOL_SIZE = 10;\n\nvar shouldBeReleasedProperties = ['dispatchConfig', '_targetInst', 'nativeEvent', 'isDefaultPrevented', 'isPropagationStopped', '_dispatchListeners', '_dispatchInstances'];\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar EventInterface = {\n  type: null,\n  target: null,\n  // currentTarget is set when dispatching; no use in copying it here\n  currentTarget: emptyFunction.thatReturnsNull,\n  eventPhase: null,\n  bubbles: null,\n  cancelable: null,\n  timeStamp: function (event) {\n    return event.timeStamp || Date.now();\n  },\n  defaultPrevented: null,\n  isTrusted: null\n};\n\n/**\n * Synthetic events are dispatched by event plugins, typically in response to a\n * top-level event delegation handler.\n *\n * These systems should generally use pooling to reduce the frequency of garbage\n * collection. The system should check `isPersistent` to determine whether the\n * event should be released into the pool after being dispatched. Users that\n * need a persisted event should invoke `persist`.\n *\n * Synthetic events (and subclasses) implement the DOM Level 3 Events API by\n * normalizing browser quirks. Subclasses do not necessarily have to implement a\n * DOM interface; custom application-specific events can also subclass this.\n *\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {*} targetInst Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @param {DOMEventTarget} nativeEventTarget Target node.\n */\nfunction SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {\n  {\n    // these have a getter/setter for warnings\n    delete this.nativeEvent;\n    delete this.preventDefault;\n    delete this.stopPropagation;\n  }\n\n  this.dispatchConfig = dispatchConfig;\n  this._targetInst = targetInst;\n  this.nativeEvent = nativeEvent;\n\n  var Interface = this.constructor.Interface;\n  for (var propName in Interface) {\n    if (!Interface.hasOwnProperty(propName)) {\n      continue;\n    }\n    {\n      delete this[propName]; // this has a getter/setter for warnings\n    }\n    var normalize = Interface[propName];\n    if (normalize) {\n      this[propName] = normalize(nativeEvent);\n    } else {\n      if (propName === 'target') {\n        this.target = nativeEventTarget;\n      } else {\n        this[propName] = nativeEvent[propName];\n      }\n    }\n  }\n\n  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;\n  if (defaultPrevented) {\n    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;\n  } else {\n    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;\n  }\n  this.isPropagationStopped = emptyFunction.thatReturnsFalse;\n  return this;\n}\n\n_assign(SyntheticEvent.prototype, {\n  preventDefault: function () {\n    this.defaultPrevented = true;\n    var event = this.nativeEvent;\n    if (!event) {\n      return;\n    }\n\n    if (event.preventDefault) {\n      event.preventDefault();\n    } else if (typeof event.returnValue !== 'unknown') {\n      event.returnValue = false;\n    }\n    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;\n  },\n\n  stopPropagation: function () {\n    var event = this.nativeEvent;\n    if (!event) {\n      return;\n    }\n\n    if (event.stopPropagation) {\n      event.stopPropagation();\n    } else if (typeof event.cancelBubble !== 'unknown') {\n      // The ChangeEventPlugin registers a \"propertychange\" event for\n      // IE. This event does not support bubbling or cancelling, and\n      // any references to cancelBubble throw \"Member not found\".  A\n      // typeof check of \"unknown\" circumvents this issue (and is also\n      // IE specific).\n      event.cancelBubble = true;\n    }\n\n    this.isPropagationStopped = emptyFunction.thatReturnsTrue;\n  },\n\n  /**\n   * We release all dispatched `SyntheticEvent`s after each event loop, adding\n   * them back into the pool. This allows a way to hold onto a reference that\n   * won't be added back into the pool.\n   */\n  persist: function () {\n    this.isPersistent = emptyFunction.thatReturnsTrue;\n  },\n\n  /**\n   * Checks if this event should be released back into the pool.\n   *\n   * @return {boolean} True if this should not be released, false otherwise.\n   */\n  isPersistent: emptyFunction.thatReturnsFalse,\n\n  /**\n   * `PooledClass` looks for `destructor` on each instance it releases.\n   */\n  destructor: function () {\n    var Interface = this.constructor.Interface;\n    for (var propName in Interface) {\n      {\n        Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));\n      }\n    }\n    for (var i = 0; i < shouldBeReleasedProperties.length; i++) {\n      this[shouldBeReleasedProperties[i]] = null;\n    }\n    {\n      Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));\n      Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', emptyFunction));\n      Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', emptyFunction));\n    }\n  }\n});\n\nSyntheticEvent.Interface = EventInterface;\n\n/**\n * Helper to reduce boilerplate when creating subclasses.\n *\n * @param {function} Class\n * @param {?object} Interface\n */\nSyntheticEvent.augmentClass = function (Class, Interface) {\n  var Super = this;\n\n  var E = function () {};\n  E.prototype = Super.prototype;\n  var prototype = new E();\n\n  _assign(prototype, Class.prototype);\n  Class.prototype = prototype;\n  Class.prototype.constructor = Class;\n\n  Class.Interface = _assign({}, Super.Interface, Interface);\n  Class.augmentClass = Super.augmentClass;\n  addEventPoolingTo(Class);\n};\n\n/** Proxying after everything set on SyntheticEvent\n * to resolve Proxy issue on some WebKit browsers\n * in which some Event properties are set to undefined (GH#10010)\n */\n{\n  if (isProxySupported) {\n    /*eslint-disable no-func-assign */\n    SyntheticEvent = new Proxy(SyntheticEvent, {\n      construct: function (target, args) {\n        return this.apply(target, Object.create(target.prototype), args);\n      },\n      apply: function (constructor, that, args) {\n        return new Proxy(constructor.apply(that, args), {\n          set: function (target, prop, value) {\n            if (prop !== 'isPersistent' && !target.constructor.Interface.hasOwnProperty(prop) && shouldBeReleasedProperties.indexOf(prop) === -1) {\n              warning(didWarnForAddedNewProperty || target.isPersistent(), \"This synthetic event is reused for performance reasons. If you're \" + \"seeing this, you're adding a new property in the synthetic event object. \" + 'The property is never released. See ' + 'https://fb.me/react-event-pooling for more information.');\n              didWarnForAddedNewProperty = true;\n            }\n            target[prop] = value;\n            return true;\n          }\n        });\n      }\n    });\n    /*eslint-enable no-func-assign */\n  }\n}\n\naddEventPoolingTo(SyntheticEvent);\n\n/**\n * Helper to nullify syntheticEvent instance properties when destructing\n *\n * @param {String} propName\n * @param {?object} getVal\n * @return {object} defineProperty object\n */\nfunction getPooledWarningPropertyDefinition(propName, getVal) {\n  var isFunction = typeof getVal === 'function';\n  return {\n    configurable: true,\n    set: set,\n    get: get\n  };\n\n  function set(val) {\n    var action = isFunction ? 'setting the method' : 'setting the property';\n    warn(action, 'This is effectively a no-op');\n    return val;\n  }\n\n  function get() {\n    var action = isFunction ? 'accessing the method' : 'accessing the property';\n    var result = isFunction ? 'This is a no-op function' : 'This is set to null';\n    warn(action, result);\n    return getVal;\n  }\n\n  function warn(action, result) {\n    var warningCondition = false;\n    warning(warningCondition, \"This synthetic event is reused for performance reasons. If you're seeing this, \" + \"you're %s `%s` on a released/nullified synthetic event. %s. \" + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result);\n  }\n}\n\nfunction getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {\n  var EventConstructor = this;\n  if (EventConstructor.eventPool.length) {\n    var instance = EventConstructor.eventPool.pop();\n    EventConstructor.call(instance, dispatchConfig, targetInst, nativeEvent, nativeInst);\n    return instance;\n  }\n  return new EventConstructor(dispatchConfig, targetInst, nativeEvent, nativeInst);\n}\n\nfunction releasePooledEvent(event) {\n  var EventConstructor = this;\n  !(event instanceof EventConstructor) ? invariant(false, 'Trying to release an event instance  into a pool of a different type.') : void 0;\n  event.destructor();\n  if (EventConstructor.eventPool.length < EVENT_POOL_SIZE) {\n    EventConstructor.eventPool.push(event);\n  }\n}\n\nfunction addEventPoolingTo(EventConstructor) {\n  EventConstructor.eventPool = [];\n  EventConstructor.getPooled = getPooledEvent;\n  EventConstructor.release = releasePooledEvent;\n}\n\nvar SyntheticEvent$1 = SyntheticEvent;\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents\n */\nvar CompositionEventInterface = {\n  data: null\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticEvent}\n */\nfunction SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n  return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n}\n\nSyntheticEvent$1.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105\n *      /#events-inputevents\n */\nvar InputEventInterface = {\n  data: null\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticEvent}\n */\nfunction SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n  return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n}\n\nSyntheticEvent$1.augmentClass(SyntheticInputEvent, InputEventInterface);\n\nvar END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space\nvar START_KEYCODE = 229;\n\nvar canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;\n\nvar documentMode = null;\nif (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {\n  documentMode = document.documentMode;\n}\n\n// Webkit offers a very useful `textInput` event that can be used to\n// directly represent `beforeInput`. The IE `textinput` event is not as\n// useful, so we don't use it.\nvar canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();\n\n// In IE9+, we have access to composition events, but the data supplied\n// by the native compositionend event may be incorrect. Japanese ideographic\n// spaces, for instance (\\u3000) are not recorded correctly.\nvar useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);\n\n/**\n * Opera <= 12 includes TextEvent in window, but does not fire\n * text input events. Rely on keypress instead.\n */\nfunction isPresto() {\n  var opera = window.opera;\n  return typeof opera === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;\n}\n\nvar SPACEBAR_CODE = 32;\nvar SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);\n\n// Events and their corresponding property names.\nvar eventTypes = {\n  beforeInput: {\n    phasedRegistrationNames: {\n      bubbled: 'onBeforeInput',\n      captured: 'onBeforeInputCapture'\n    },\n    dependencies: ['topCompositionEnd', 'topKeyPress', 'topTextInput', 'topPaste']\n  },\n  compositionEnd: {\n    phasedRegistrationNames: {\n      bubbled: 'onCompositionEnd',\n      captured: 'onCompositionEndCapture'\n    },\n    dependencies: ['topBlur', 'topCompositionEnd', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']\n  },\n  compositionStart: {\n    phasedRegistrationNames: {\n      bubbled: 'onCompositionStart',\n      captured: 'onCompositionStartCapture'\n    },\n    dependencies: ['topBlur', 'topCompositionStart', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']\n  },\n  compositionUpdate: {\n    phasedRegistrationNames: {\n      bubbled: 'onCompositionUpdate',\n      captured: 'onCompositionUpdateCapture'\n    },\n    dependencies: ['topBlur', 'topCompositionUpdate', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']\n  }\n};\n\n// Track whether we've ever handled a keypress on the space key.\nvar hasSpaceKeypress = false;\n\n/**\n * Return whether a native keypress event is assumed to be a command.\n * This is required because Firefox fires `keypress` events for key commands\n * (cut, copy, select-all, etc.) even though no character is inserted.\n */\nfunction isKeypressCommand(nativeEvent) {\n  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&\n  // ctrlKey && altKey is equivalent to AltGr, and is not a command.\n  !(nativeEvent.ctrlKey && nativeEvent.altKey);\n}\n\n/**\n * Translate native top level events into event types.\n *\n * @param {string} topLevelType\n * @return {object}\n */\nfunction getCompositionEventType(topLevelType) {\n  switch (topLevelType) {\n    case 'topCompositionStart':\n      return eventTypes.compositionStart;\n    case 'topCompositionEnd':\n      return eventTypes.compositionEnd;\n    case 'topCompositionUpdate':\n      return eventTypes.compositionUpdate;\n  }\n}\n\n/**\n * Does our fallback best-guess model think this event signifies that\n * composition has begun?\n *\n * @param {string} topLevelType\n * @param {object} nativeEvent\n * @return {boolean}\n */\nfunction isFallbackCompositionStart(topLevelType, nativeEvent) {\n  return topLevelType === 'topKeyDown' && nativeEvent.keyCode === START_KEYCODE;\n}\n\n/**\n * Does our fallback mode think that this event is the end of composition?\n *\n * @param {string} topLevelType\n * @param {object} nativeEvent\n * @return {boolean}\n */\nfunction isFallbackCompositionEnd(topLevelType, nativeEvent) {\n  switch (topLevelType) {\n    case 'topKeyUp':\n      // Command keys insert or clear IME input.\n      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;\n    case 'topKeyDown':\n      // Expect IME keyCode on each keydown. If we get any other\n      // code we must have exited earlier.\n      return nativeEvent.keyCode !== START_KEYCODE;\n    case 'topKeyPress':\n    case 'topMouseDown':\n    case 'topBlur':\n      // Events are not possible without cancelling IME.\n      return true;\n    default:\n      return false;\n  }\n}\n\n/**\n * Google Input Tools provides composition data via a CustomEvent,\n * with the `data` property populated in the `detail` object. If this\n * is available on the event object, use it. If not, this is a plain\n * composition event and we have nothing special to extract.\n *\n * @param {object} nativeEvent\n * @return {?string}\n */\nfunction getDataFromCustomEvent(nativeEvent) {\n  var detail = nativeEvent.detail;\n  if (typeof detail === 'object' && 'data' in detail) {\n    return detail.data;\n  }\n  return null;\n}\n\n// Track the current IME composition status, if any.\nvar isComposing = false;\n\n/**\n * @return {?object} A SyntheticCompositionEvent.\n */\nfunction extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n  var eventType;\n  var fallbackData;\n\n  if (canUseCompositionEvent) {\n    eventType = getCompositionEventType(topLevelType);\n  } else if (!isComposing) {\n    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {\n      eventType = eventTypes.compositionStart;\n    }\n  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {\n    eventType = eventTypes.compositionEnd;\n  }\n\n  if (!eventType) {\n    return null;\n  }\n\n  if (useFallbackCompositionData) {\n    // The current composition is stored statically and must not be\n    // overwritten while composition continues.\n    if (!isComposing && eventType === eventTypes.compositionStart) {\n      isComposing = initialize(nativeEventTarget);\n    } else if (eventType === eventTypes.compositionEnd) {\n      if (isComposing) {\n        fallbackData = getData();\n      }\n    }\n  }\n\n  var event = SyntheticCompositionEvent.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);\n\n  if (fallbackData) {\n    // Inject data generated from fallback path into the synthetic event.\n    // This matches the property of native CompositionEventInterface.\n    event.data = fallbackData;\n  } else {\n    var customData = getDataFromCustomEvent(nativeEvent);\n    if (customData !== null) {\n      event.data = customData;\n    }\n  }\n\n  accumulateTwoPhaseDispatches(event);\n  return event;\n}\n\n/**\n * @param {TopLevelTypes} topLevelType Record from `BrowserEventConstants`.\n * @param {object} nativeEvent Native browser event.\n * @return {?string} The string corresponding to this `beforeInput` event.\n */\nfunction getNativeBeforeInputChars(topLevelType, nativeEvent) {\n  switch (topLevelType) {\n    case 'topCompositionEnd':\n      return getDataFromCustomEvent(nativeEvent);\n    case 'topKeyPress':\n      /**\n       * If native `textInput` events are available, our goal is to make\n       * use of them. However, there is a special case: the spacebar key.\n       * In Webkit, preventing default on a spacebar `textInput` event\n       * cancels character insertion, but it *also* causes the browser\n       * to fall back to its default spacebar behavior of scrolling the\n       * page.\n       *\n       * Tracking at:\n       * https://code.google.com/p/chromium/issues/detail?id=355103\n       *\n       * To avoid this issue, use the keypress event as if no `textInput`\n       * event is available.\n       */\n      var which = nativeEvent.which;\n      if (which !== SPACEBAR_CODE) {\n        return null;\n      }\n\n      hasSpaceKeypress = true;\n      return SPACEBAR_CHAR;\n\n    case 'topTextInput':\n      // Record the characters to be added to the DOM.\n      var chars = nativeEvent.data;\n\n      // If it's a spacebar character, assume that we have already handled\n      // it at the keypress level and bail immediately. Android Chrome\n      // doesn't give us keycodes, so we need to blacklist it.\n      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {\n        return null;\n      }\n\n      return chars;\n\n    default:\n      // For other native event types, do nothing.\n      return null;\n  }\n}\n\n/**\n * For browsers that do not provide the `textInput` event, extract the\n * appropriate string to use for SyntheticInputEvent.\n *\n * @param {string} topLevelType Record from `BrowserEventConstants`.\n * @param {object} nativeEvent Native browser event.\n * @return {?string} The fallback string for this `beforeInput` event.\n */\nfunction getFallbackBeforeInputChars(topLevelType, nativeEvent) {\n  // If we are currently composing (IME) and using a fallback to do so,\n  // try to extract the composed characters from the fallback object.\n  // If composition event is available, we extract a string only at\n  // compositionevent, otherwise extract it at fallback events.\n  if (isComposing) {\n    if (topLevelType === 'topCompositionEnd' || !canUseCompositionEvent && isFallbackCompositionEnd(topLevelType, nativeEvent)) {\n      var chars = getData();\n      reset();\n      isComposing = false;\n      return chars;\n    }\n    return null;\n  }\n\n  switch (topLevelType) {\n    case 'topPaste':\n      // If a paste event occurs after a keypress, throw out the input\n      // chars. Paste events should not lead to BeforeInput events.\n      return null;\n    case 'topKeyPress':\n      /**\n       * As of v27, Firefox may fire keypress events even when no character\n       * will be inserted. A few possibilities:\n       *\n       * - `which` is `0`. Arrow keys, Esc key, etc.\n       *\n       * - `which` is the pressed key code, but no char is available.\n       *   Ex: 'AltGr + d` in Polish. There is no modified character for\n       *   this key combination and no character is inserted into the\n       *   document, but FF fires the keypress for char code `100` anyway.\n       *   No `input` event will occur.\n       *\n       * - `which` is the pressed key code, but a command combination is\n       *   being used. Ex: `Cmd+C`. No character is inserted, and no\n       *   `input` event will occur.\n       */\n      if (!isKeypressCommand(nativeEvent)) {\n        // IE fires the `keypress` event when a user types an emoji via\n        // Touch keyboard of Windows.  In such a case, the `char` property\n        // holds an emoji character like `\\uD83D\\uDE0A`.  Because its length\n        // is 2, the property `which` does not represent an emoji correctly.\n        // In such a case, we directly return the `char` property instead of\n        // using `which`.\n        if (nativeEvent.char && nativeEvent.char.length > 1) {\n          return nativeEvent.char;\n        } else if (nativeEvent.which) {\n          return String.fromCharCode(nativeEvent.which);\n        }\n      }\n      return null;\n    case 'topCompositionEnd':\n      return useFallbackCompositionData ? null : nativeEvent.data;\n    default:\n      return null;\n  }\n}\n\n/**\n * Extract a SyntheticInputEvent for `beforeInput`, based on either native\n * `textInput` or fallback behavior.\n *\n * @return {?object} A SyntheticInputEvent.\n */\nfunction extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n  var chars;\n\n  if (canUseTextInputEvent) {\n    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);\n  } else {\n    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);\n  }\n\n  // If no characters are being inserted, no BeforeInput event should\n  // be fired.\n  if (!chars) {\n    return null;\n  }\n\n  var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, targetInst, nativeEvent, nativeEventTarget);\n\n  event.data = chars;\n  accumulateTwoPhaseDispatches(event);\n  return event;\n}\n\n/**\n * Create an `onBeforeInput` event to match\n * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.\n *\n * This event plugin is based on the native `textInput` event\n * available in Chrome, Safari, Opera, and IE. This event fires after\n * `onKeyPress` and `onCompositionEnd`, but before `onInput`.\n *\n * `beforeInput` is spec'd but not implemented in any browsers, and\n * the `input` event does not provide any useful information about what has\n * actually been added, contrary to the spec. Thus, `textInput` is the best\n * available event to identify the characters that have actually been inserted\n * into the target node.\n *\n * This plugin is also responsible for emitting `composition` events, thus\n * allowing us to share composition fallback code for both `beforeInput` and\n * `composition` event types.\n */\nvar BeforeInputEventPlugin = {\n  eventTypes: eventTypes,\n\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    return [extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget)];\n  }\n};\n\n// Use to restore controlled state after a change event has fired.\n\nvar fiberHostComponent = null;\n\nvar ReactControlledComponentInjection = {\n  injectFiberControlledHostComponent: function (hostComponentImpl) {\n    // The fiber implementation doesn't use dynamic dispatch so we need to\n    // inject the implementation.\n    fiberHostComponent = hostComponentImpl;\n  }\n};\n\nvar restoreTarget = null;\nvar restoreQueue = null;\n\nfunction restoreStateOfTarget(target) {\n  // We perform this translation at the end of the event loop so that we\n  // always receive the correct fiber here\n  var internalInstance = getInstanceFromNode(target);\n  if (!internalInstance) {\n    // Unmounted\n    return;\n  }\n  !(fiberHostComponent && typeof fiberHostComponent.restoreControlledState === 'function') ? invariant(false, 'Fiber needs to be injected to handle a fiber target for controlled events. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n  var props = getFiberCurrentPropsFromNode(internalInstance.stateNode);\n  fiberHostComponent.restoreControlledState(internalInstance.stateNode, internalInstance.type, props);\n}\n\nvar injection$3 = ReactControlledComponentInjection;\n\nfunction enqueueStateRestore(target) {\n  if (restoreTarget) {\n    if (restoreQueue) {\n      restoreQueue.push(target);\n    } else {\n      restoreQueue = [target];\n    }\n  } else {\n    restoreTarget = target;\n  }\n}\n\nfunction restoreStateIfNeeded() {\n  if (!restoreTarget) {\n    return;\n  }\n  var target = restoreTarget;\n  var queuedTargets = restoreQueue;\n  restoreTarget = null;\n  restoreQueue = null;\n\n  restoreStateOfTarget(target);\n  if (queuedTargets) {\n    for (var i = 0; i < queuedTargets.length; i++) {\n      restoreStateOfTarget(queuedTargets[i]);\n    }\n  }\n}\n\nvar ReactControlledComponent = Object.freeze({\n\tinjection: injection$3,\n\tenqueueStateRestore: enqueueStateRestore,\n\trestoreStateIfNeeded: restoreStateIfNeeded\n});\n\n// Used as a way to call batchedUpdates when we don't have a reference to\n// the renderer. Such as when we're dispatching events or if third party\n// libraries need to call batchedUpdates. Eventually, this API will go away when\n// everything is batched by default. We'll then have a similar API to opt-out of\n// scheduled work and instead do synchronous work.\n\n// Defaults\nvar fiberBatchedUpdates = function (fn, bookkeeping) {\n  return fn(bookkeeping);\n};\n\nvar isNestingBatched = false;\nfunction batchedUpdates(fn, bookkeeping) {\n  if (isNestingBatched) {\n    // If we are currently inside another batch, we need to wait until it\n    // fully completes before restoring state. Therefore, we add the target to\n    // a queue of work.\n    return fiberBatchedUpdates(fn, bookkeeping);\n  }\n  isNestingBatched = true;\n  try {\n    return fiberBatchedUpdates(fn, bookkeeping);\n  } finally {\n    // Here we wait until all updates have propagated, which is important\n    // when using controlled components within layers:\n    // https://github.com/facebook/react/issues/1698\n    // Then we restore state of any controlled component.\n    isNestingBatched = false;\n    restoreStateIfNeeded();\n  }\n}\n\nvar ReactGenericBatchingInjection = {\n  injectFiberBatchedUpdates: function (_batchedUpdates) {\n    fiberBatchedUpdates = _batchedUpdates;\n  }\n};\n\nvar injection$4 = ReactGenericBatchingInjection;\n\n/**\n * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary\n */\nvar supportedInputTypes = {\n  color: true,\n  date: true,\n  datetime: true,\n  'datetime-local': true,\n  email: true,\n  month: true,\n  number: true,\n  password: true,\n  range: true,\n  search: true,\n  tel: true,\n  text: true,\n  time: true,\n  url: true,\n  week: true\n};\n\nfunction isTextInputElement(elem) {\n  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();\n\n  if (nodeName === 'input') {\n    return !!supportedInputTypes[elem.type];\n  }\n\n  if (nodeName === 'textarea') {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * HTML nodeType values that represent the type of the node\n */\n\nvar ELEMENT_NODE = 1;\nvar TEXT_NODE = 3;\nvar COMMENT_NODE = 8;\nvar DOCUMENT_NODE = 9;\nvar DOCUMENT_FRAGMENT_NODE = 11;\n\n/**\n * Gets the target node from a native browser event by accounting for\n * inconsistencies in browser DOM APIs.\n *\n * @param {object} nativeEvent Native browser event.\n * @return {DOMEventTarget} Target node.\n */\nfunction getEventTarget(nativeEvent) {\n  var target = nativeEvent.target || nativeEvent.srcElement || window;\n\n  // Normalize SVG <use> element events #4963\n  if (target.correspondingUseElement) {\n    target = target.correspondingUseElement;\n  }\n\n  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).\n  // @see http://www.quirksmode.org/js/events_properties.html\n  return target.nodeType === TEXT_NODE ? target.parentNode : target;\n}\n\nvar useHasFeature;\nif (ExecutionEnvironment.canUseDOM) {\n  useHasFeature = document.implementation && document.implementation.hasFeature &&\n  // always returns true in newer browsers as per the standard.\n  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature\n  document.implementation.hasFeature('', '') !== true;\n}\n\n/**\n * Checks if an event is supported in the current execution environment.\n *\n * NOTE: This will not work correctly for non-generic events such as `change`,\n * `reset`, `load`, `error`, and `select`.\n *\n * Borrows from Modernizr.\n *\n * @param {string} eventNameSuffix Event name, e.g. \"click\".\n * @param {?boolean} capture Check if the capture phase is supported.\n * @return {boolean} True if the event is supported.\n * @internal\n * @license Modernizr 3.0.0pre (Custom Build) | MIT\n */\nfunction isEventSupported(eventNameSuffix, capture) {\n  if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {\n    return false;\n  }\n\n  var eventName = 'on' + eventNameSuffix;\n  var isSupported = eventName in document;\n\n  if (!isSupported) {\n    var element = document.createElement('div');\n    element.setAttribute(eventName, 'return;');\n    isSupported = typeof element[eventName] === 'function';\n  }\n\n  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {\n    // This is the only way to test support for the `wheel` event in IE9+.\n    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');\n  }\n\n  return isSupported;\n}\n\nfunction isCheckable(elem) {\n  var type = elem.type;\n  var nodeName = elem.nodeName;\n  return nodeName && nodeName.toLowerCase() === 'input' && (type === 'checkbox' || type === 'radio');\n}\n\nfunction getTracker(node) {\n  return node._valueTracker;\n}\n\nfunction detachTracker(node) {\n  node._valueTracker = null;\n}\n\nfunction getValueFromNode(node) {\n  var value = '';\n  if (!node) {\n    return value;\n  }\n\n  if (isCheckable(node)) {\n    value = node.checked ? 'true' : 'false';\n  } else {\n    value = node.value;\n  }\n\n  return value;\n}\n\nfunction trackValueOnNode(node) {\n  var valueField = isCheckable(node) ? 'checked' : 'value';\n  var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);\n\n  var currentValue = '' + node[valueField];\n\n  // if someone has already defined a value or Safari, then bail\n  // and don't track value will cause over reporting of changes,\n  // but it's better then a hard failure\n  // (needed for certain tests that spyOn input values and Safari)\n  if (node.hasOwnProperty(valueField) || typeof descriptor.get !== 'function' || typeof descriptor.set !== 'function') {\n    return;\n  }\n\n  Object.defineProperty(node, valueField, {\n    enumerable: descriptor.enumerable,\n    configurable: true,\n    get: function () {\n      return descriptor.get.call(this);\n    },\n    set: function (value) {\n      currentValue = '' + value;\n      descriptor.set.call(this, value);\n    }\n  });\n\n  var tracker = {\n    getValue: function () {\n      return currentValue;\n    },\n    setValue: function (value) {\n      currentValue = '' + value;\n    },\n    stopTracking: function () {\n      detachTracker(node);\n      delete node[valueField];\n    }\n  };\n  return tracker;\n}\n\nfunction track(node) {\n  if (getTracker(node)) {\n    return;\n  }\n\n  // TODO: Once it's just Fiber we can move this to node._wrapperState\n  node._valueTracker = trackValueOnNode(node);\n}\n\nfunction updateValueIfChanged(node) {\n  if (!node) {\n    return false;\n  }\n\n  var tracker = getTracker(node);\n  // if there is no tracker at this point it's unlikely\n  // that trying again will succeed\n  if (!tracker) {\n    return true;\n  }\n\n  var lastValue = tracker.getValue();\n  var nextValue = getValueFromNode(node);\n  if (nextValue !== lastValue) {\n    tracker.setValue(nextValue);\n    return true;\n  }\n  return false;\n}\n\nvar eventTypes$1 = {\n  change: {\n    phasedRegistrationNames: {\n      bubbled: 'onChange',\n      captured: 'onChangeCapture'\n    },\n    dependencies: ['topBlur', 'topChange', 'topClick', 'topFocus', 'topInput', 'topKeyDown', 'topKeyUp', 'topSelectionChange']\n  }\n};\n\nfunction createAndAccumulateChangeEvent(inst, nativeEvent, target) {\n  var event = SyntheticEvent$1.getPooled(eventTypes$1.change, inst, nativeEvent, target);\n  event.type = 'change';\n  // Flag this event loop as needing state restore.\n  enqueueStateRestore(target);\n  accumulateTwoPhaseDispatches(event);\n  return event;\n}\n/**\n * For IE shims\n */\nvar activeElement = null;\nvar activeElementInst = null;\n\n/**\n * SECTION: handle `change` event\n */\nfunction shouldUseChangeEvent(elem) {\n  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();\n  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';\n}\n\nfunction manualDispatchChangeEvent(nativeEvent) {\n  var event = createAndAccumulateChangeEvent(activeElementInst, nativeEvent, getEventTarget(nativeEvent));\n\n  // If change and propertychange bubbled, we'd just bind to it like all the\n  // other events and have it go through ReactBrowserEventEmitter. Since it\n  // doesn't, we manually listen for the events and so we have to enqueue and\n  // process the abstract event manually.\n  //\n  // Batching is necessary here in order to ensure that all event handlers run\n  // before the next rerender (including event handlers attached to ancestor\n  // elements instead of directly on the input). Without this, controlled\n  // components don't work properly in conjunction with event bubbling because\n  // the component is rerendered and the value reverted before all the event\n  // handlers can run. See https://github.com/facebook/react/issues/708.\n  batchedUpdates(runEventInBatch, event);\n}\n\nfunction runEventInBatch(event) {\n  enqueueEvents(event);\n  processEventQueue(false);\n}\n\nfunction getInstIfValueChanged(targetInst) {\n  var targetNode = getNodeFromInstance$1(targetInst);\n  if (updateValueIfChanged(targetNode)) {\n    return targetInst;\n  }\n}\n\nfunction getTargetInstForChangeEvent(topLevelType, targetInst) {\n  if (topLevelType === 'topChange') {\n    return targetInst;\n  }\n}\n\n/**\n * SECTION: handle `input` event\n */\nvar isInputEventSupported = false;\nif (ExecutionEnvironment.canUseDOM) {\n  // IE9 claims to support the input event but fails to trigger it when\n  // deleting text, so we ignore its input events.\n  isInputEventSupported = isEventSupported('input') && (!document.documentMode || document.documentMode > 9);\n}\n\n/**\n * (For IE <=9) Starts tracking propertychange events on the passed-in element\n * and override the value property so that we can distinguish user events from\n * value changes in JS.\n */\nfunction startWatchingForValueChange(target, targetInst) {\n  activeElement = target;\n  activeElementInst = targetInst;\n  activeElement.attachEvent('onpropertychange', handlePropertyChange);\n}\n\n/**\n * (For IE <=9) Removes the event listeners from the currently-tracked element,\n * if any exists.\n */\nfunction stopWatchingForValueChange() {\n  if (!activeElement) {\n    return;\n  }\n  activeElement.detachEvent('onpropertychange', handlePropertyChange);\n  activeElement = null;\n  activeElementInst = null;\n}\n\n/**\n * (For IE <=9) Handles a propertychange event, sending a `change` event if\n * the value of the active element has changed.\n */\nfunction handlePropertyChange(nativeEvent) {\n  if (nativeEvent.propertyName !== 'value') {\n    return;\n  }\n  if (getInstIfValueChanged(activeElementInst)) {\n    manualDispatchChangeEvent(nativeEvent);\n  }\n}\n\nfunction handleEventsForInputEventPolyfill(topLevelType, target, targetInst) {\n  if (topLevelType === 'topFocus') {\n    // In IE9, propertychange fires for most input events but is buggy and\n    // doesn't fire when text is deleted, but conveniently, selectionchange\n    // appears to fire in all of the remaining cases so we catch those and\n    // forward the event if the value has changed\n    // In either case, we don't want to call the event handler if the value\n    // is changed from JS so we redefine a setter for `.value` that updates\n    // our activeElementValue variable, allowing us to ignore those changes\n    //\n    // stopWatching() should be a noop here but we call it just in case we\n    // missed a blur event somehow.\n    stopWatchingForValueChange();\n    startWatchingForValueChange(target, targetInst);\n  } else if (topLevelType === 'topBlur') {\n    stopWatchingForValueChange();\n  }\n}\n\n// For IE8 and IE9.\nfunction getTargetInstForInputEventPolyfill(topLevelType, targetInst) {\n  if (topLevelType === 'topSelectionChange' || topLevelType === 'topKeyUp' || topLevelType === 'topKeyDown') {\n    // On the selectionchange event, the target is just document which isn't\n    // helpful for us so just check activeElement instead.\n    //\n    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire\n    // propertychange on the first input event after setting `value` from a\n    // script and fires only keydown, keypress, keyup. Catching keyup usually\n    // gets it and catching keydown lets us fire an event for the first\n    // keystroke if user does a key repeat (it'll be a little delayed: right\n    // before the second keystroke). Other input methods (e.g., paste) seem to\n    // fire selectionchange normally.\n    return getInstIfValueChanged(activeElementInst);\n  }\n}\n\n/**\n * SECTION: handle `click` event\n */\nfunction shouldUseClickEvent(elem) {\n  // Use the `click` event to detect changes to checkbox and radio inputs.\n  // This approach works across all browsers, whereas `change` does not fire\n  // until `blur` in IE8.\n  var nodeName = elem.nodeName;\n  return nodeName && nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');\n}\n\nfunction getTargetInstForClickEvent(topLevelType, targetInst) {\n  if (topLevelType === 'topClick') {\n    return getInstIfValueChanged(targetInst);\n  }\n}\n\nfunction getTargetInstForInputOrChangeEvent(topLevelType, targetInst) {\n  if (topLevelType === 'topInput' || topLevelType === 'topChange') {\n    return getInstIfValueChanged(targetInst);\n  }\n}\n\nfunction handleControlledInputBlur(inst, node) {\n  // TODO: In IE, inst is occasionally null. Why?\n  if (inst == null) {\n    return;\n  }\n\n  // Fiber and ReactDOM keep wrapper state in separate places\n  var state = inst._wrapperState || node._wrapperState;\n\n  if (!state || !state.controlled || node.type !== 'number') {\n    return;\n  }\n\n  // If controlled, assign the value attribute to the current value on blur\n  var value = '' + node.value;\n  if (node.getAttribute('value') !== value) {\n    node.setAttribute('value', value);\n  }\n}\n\n/**\n * This plugin creates an `onChange` event that normalizes change events\n * across form elements. This event fires at a time when it's possible to\n * change the element's value without seeing a flicker.\n *\n * Supported elements are:\n * - input (see `isTextInputElement`)\n * - textarea\n * - select\n */\nvar ChangeEventPlugin = {\n  eventTypes: eventTypes$1,\n\n  _isInputEventSupported: isInputEventSupported,\n\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    var targetNode = targetInst ? getNodeFromInstance$1(targetInst) : window;\n\n    var getTargetInstFunc, handleEventFunc;\n    if (shouldUseChangeEvent(targetNode)) {\n      getTargetInstFunc = getTargetInstForChangeEvent;\n    } else if (isTextInputElement(targetNode)) {\n      if (isInputEventSupported) {\n        getTargetInstFunc = getTargetInstForInputOrChangeEvent;\n      } else {\n        getTargetInstFunc = getTargetInstForInputEventPolyfill;\n        handleEventFunc = handleEventsForInputEventPolyfill;\n      }\n    } else if (shouldUseClickEvent(targetNode)) {\n      getTargetInstFunc = getTargetInstForClickEvent;\n    }\n\n    if (getTargetInstFunc) {\n      var inst = getTargetInstFunc(topLevelType, targetInst);\n      if (inst) {\n        var event = createAndAccumulateChangeEvent(inst, nativeEvent, nativeEventTarget);\n        return event;\n      }\n    }\n\n    if (handleEventFunc) {\n      handleEventFunc(topLevelType, targetNode, targetInst);\n    }\n\n    // When blurring, set the value attribute for number inputs\n    if (topLevelType === 'topBlur') {\n      handleControlledInputBlur(targetInst, targetNode);\n    }\n  }\n};\n\n/**\n * Module that is injectable into `EventPluginHub`, that specifies a\n * deterministic ordering of `EventPlugin`s. A convenient way to reason about\n * plugins, without having to package every one of them. This is better than\n * having plugins be ordered in the same order that they are injected because\n * that ordering would be influenced by the packaging order.\n * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that\n * preventing default on events is convenient in `SimpleEventPlugin` handlers.\n */\nvar DOMEventPluginOrder = ['ResponderEventPlugin', 'SimpleEventPlugin', 'TapEventPlugin', 'EnterLeaveEventPlugin', 'ChangeEventPlugin', 'SelectEventPlugin', 'BeforeInputEventPlugin'];\n\n/**\n * @interface UIEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar UIEventInterface = {\n  view: null,\n  detail: null\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticEvent}\n */\nfunction SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n  return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n}\n\nSyntheticEvent$1.augmentClass(SyntheticUIEvent, UIEventInterface);\n\n/**\n * Translation from modifier key to the associated property in the event.\n * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers\n */\n\nvar modifierKeyToProp = {\n  Alt: 'altKey',\n  Control: 'ctrlKey',\n  Meta: 'metaKey',\n  Shift: 'shiftKey'\n};\n\n// IE8 does not implement getModifierState so we simply map it to the only\n// modifier keys exposed by the event itself, does not support Lock-keys.\n// Currently, all major browsers except Chrome seems to support Lock-keys.\nfunction modifierStateGetter(keyArg) {\n  var syntheticEvent = this;\n  var nativeEvent = syntheticEvent.nativeEvent;\n  if (nativeEvent.getModifierState) {\n    return nativeEvent.getModifierState(keyArg);\n  }\n  var keyProp = modifierKeyToProp[keyArg];\n  return keyProp ? !!nativeEvent[keyProp] : false;\n}\n\nfunction getEventModifierState(nativeEvent) {\n  return modifierStateGetter;\n}\n\n/**\n * @interface MouseEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar MouseEventInterface = {\n  screenX: null,\n  screenY: null,\n  clientX: null,\n  clientY: null,\n  pageX: null,\n  pageY: null,\n  ctrlKey: null,\n  shiftKey: null,\n  altKey: null,\n  metaKey: null,\n  getModifierState: getEventModifierState,\n  button: null,\n  buttons: null,\n  relatedTarget: function (event) {\n    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);\n  }\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticUIEvent}\n */\nfunction SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n}\n\nSyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);\n\nvar eventTypes$2 = {\n  mouseEnter: {\n    registrationName: 'onMouseEnter',\n    dependencies: ['topMouseOut', 'topMouseOver']\n  },\n  mouseLeave: {\n    registrationName: 'onMouseLeave',\n    dependencies: ['topMouseOut', 'topMouseOver']\n  }\n};\n\nvar EnterLeaveEventPlugin = {\n  eventTypes: eventTypes$2,\n\n  /**\n   * For almost every interaction we care about, there will be both a top-level\n   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that\n   * we do not extract duplicate events. However, moving the mouse into the\n   * browser from outside will not fire a `mouseout` event. In this case, we use\n   * the `mouseover` top-level event.\n   */\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    if (topLevelType === 'topMouseOver' && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {\n      return null;\n    }\n    if (topLevelType !== 'topMouseOut' && topLevelType !== 'topMouseOver') {\n      // Must not be a mouse in or mouse out - ignoring.\n      return null;\n    }\n\n    var win;\n    if (nativeEventTarget.window === nativeEventTarget) {\n      // `nativeEventTarget` is probably a window object.\n      win = nativeEventTarget;\n    } else {\n      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.\n      var doc = nativeEventTarget.ownerDocument;\n      if (doc) {\n        win = doc.defaultView || doc.parentWindow;\n      } else {\n        win = window;\n      }\n    }\n\n    var from;\n    var to;\n    if (topLevelType === 'topMouseOut') {\n      from = targetInst;\n      var related = nativeEvent.relatedTarget || nativeEvent.toElement;\n      to = related ? getClosestInstanceFromNode(related) : null;\n    } else {\n      // Moving to a node from outside the window.\n      from = null;\n      to = targetInst;\n    }\n\n    if (from === to) {\n      // Nothing pertains to our managed components.\n      return null;\n    }\n\n    var fromNode = from == null ? win : getNodeFromInstance$1(from);\n    var toNode = to == null ? win : getNodeFromInstance$1(to);\n\n    var leave = SyntheticMouseEvent.getPooled(eventTypes$2.mouseLeave, from, nativeEvent, nativeEventTarget);\n    leave.type = 'mouseleave';\n    leave.target = fromNode;\n    leave.relatedTarget = toNode;\n\n    var enter = SyntheticMouseEvent.getPooled(eventTypes$2.mouseEnter, to, nativeEvent, nativeEventTarget);\n    enter.type = 'mouseenter';\n    enter.target = toNode;\n    enter.relatedTarget = fromNode;\n\n    accumulateEnterLeaveDispatches(leave, enter, from, to);\n\n    return [leave, enter];\n  }\n};\n\n/**\n * `ReactInstanceMap` maintains a mapping from a public facing stateful\n * instance (key) and the internal representation (value). This allows public\n * methods to accept the user facing instance as an argument and map them back\n * to internal methods.\n *\n * Note that this module is currently shared and assumed to be stateless.\n * If this becomes an actual Map, that will break.\n */\n\n/**\n * This API should be called `delete` but we'd have to make sure to always\n * transform these to strings for IE support. When this transform is fully\n * supported we can rename it.\n */\n\n\nfunction get(key) {\n  return key._reactInternalFiber;\n}\n\nfunction has(key) {\n  return key._reactInternalFiber !== undefined;\n}\n\nfunction set(key, value) {\n  key._reactInternalFiber = value;\n}\n\nvar ReactInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nvar ReactCurrentOwner = ReactInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame = ReactInternals.ReactDebugCurrentFrame;\n\nfunction getComponentName(fiber) {\n  var type = fiber.type;\n\n  if (typeof type === 'string') {\n    return type;\n  }\n  if (typeof type === 'function') {\n    return type.displayName || type.name;\n  }\n  return null;\n}\n\n// Don't change these two values:\nvar NoEffect = 0; //           0b00000000\nvar PerformedWork = 1; //      0b00000001\n\n// You can change the rest (and add more).\nvar Placement = 2; //          0b00000010\nvar Update = 4; //             0b00000100\nvar PlacementAndUpdate = 6; // 0b00000110\nvar Deletion = 8; //           0b00001000\nvar ContentReset = 16; //      0b00010000\nvar Callback = 32; //          0b00100000\nvar Err = 64; //               0b01000000\nvar Ref = 128; //              0b10000000\n\nvar MOUNTING = 1;\nvar MOUNTED = 2;\nvar UNMOUNTED = 3;\n\nfunction isFiberMountedImpl(fiber) {\n  var node = fiber;\n  if (!fiber.alternate) {\n    // If there is no alternate, this might be a new tree that isn't inserted\n    // yet. If it is, then it will have a pending insertion effect on it.\n    if ((node.effectTag & Placement) !== NoEffect) {\n      return MOUNTING;\n    }\n    while (node['return']) {\n      node = node['return'];\n      if ((node.effectTag & Placement) !== NoEffect) {\n        return MOUNTING;\n      }\n    }\n  } else {\n    while (node['return']) {\n      node = node['return'];\n    }\n  }\n  if (node.tag === HostRoot) {\n    // TODO: Check if this was a nested HostRoot when used with\n    // renderContainerIntoSubtree.\n    return MOUNTED;\n  }\n  // If we didn't hit the root, that means that we're in an disconnected tree\n  // that has been unmounted.\n  return UNMOUNTED;\n}\n\nfunction isFiberMounted(fiber) {\n  return isFiberMountedImpl(fiber) === MOUNTED;\n}\n\nfunction isMounted(component) {\n  {\n    var owner = ReactCurrentOwner.current;\n    if (owner !== null && owner.tag === ClassComponent) {\n      var ownerFiber = owner;\n      var instance = ownerFiber.stateNode;\n      warning(instance._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentName(ownerFiber) || 'A component');\n      instance._warnedAboutRefsInRender = true;\n    }\n  }\n\n  var fiber = get(component);\n  if (!fiber) {\n    return false;\n  }\n  return isFiberMountedImpl(fiber) === MOUNTED;\n}\n\nfunction assertIsMounted(fiber) {\n  !(isFiberMountedImpl(fiber) === MOUNTED) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;\n}\n\nfunction findCurrentFiberUsingSlowPath(fiber) {\n  var alternate = fiber.alternate;\n  if (!alternate) {\n    // If there is no alternate, then we only need to check if it is mounted.\n    var state = isFiberMountedImpl(fiber);\n    !(state !== UNMOUNTED) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;\n    if (state === MOUNTING) {\n      return null;\n    }\n    return fiber;\n  }\n  // If we have two possible branches, we'll walk backwards up to the root\n  // to see what path the root points to. On the way we may hit one of the\n  // special cases and we'll deal with them.\n  var a = fiber;\n  var b = alternate;\n  while (true) {\n    var parentA = a['return'];\n    var parentB = parentA ? parentA.alternate : null;\n    if (!parentA || !parentB) {\n      // We're at the root.\n      break;\n    }\n\n    // If both copies of the parent fiber point to the same child, we can\n    // assume that the child is current. This happens when we bailout on low\n    // priority: the bailed out fiber's child reuses the current child.\n    if (parentA.child === parentB.child) {\n      var child = parentA.child;\n      while (child) {\n        if (child === a) {\n          // We've determined that A is the current branch.\n          assertIsMounted(parentA);\n          return fiber;\n        }\n        if (child === b) {\n          // We've determined that B is the current branch.\n          assertIsMounted(parentA);\n          return alternate;\n        }\n        child = child.sibling;\n      }\n      // We should never have an alternate for any mounting node. So the only\n      // way this could possibly happen is if this was unmounted, if at all.\n      invariant(false, 'Unable to find node on an unmounted component.');\n    }\n\n    if (a['return'] !== b['return']) {\n      // The return pointer of A and the return pointer of B point to different\n      // fibers. We assume that return pointers never criss-cross, so A must\n      // belong to the child set of A.return, and B must belong to the child\n      // set of B.return.\n      a = parentA;\n      b = parentB;\n    } else {\n      // The return pointers point to the same fiber. We'll have to use the\n      // default, slow path: scan the child sets of each parent alternate to see\n      // which child belongs to which set.\n      //\n      // Search parent A's child set\n      var didFindChild = false;\n      var _child = parentA.child;\n      while (_child) {\n        if (_child === a) {\n          didFindChild = true;\n          a = parentA;\n          b = parentB;\n          break;\n        }\n        if (_child === b) {\n          didFindChild = true;\n          b = parentA;\n          a = parentB;\n          break;\n        }\n        _child = _child.sibling;\n      }\n      if (!didFindChild) {\n        // Search parent B's child set\n        _child = parentB.child;\n        while (_child) {\n          if (_child === a) {\n            didFindChild = true;\n            a = parentB;\n            b = parentA;\n            break;\n          }\n          if (_child === b) {\n            didFindChild = true;\n            b = parentB;\n            a = parentA;\n            break;\n          }\n          _child = _child.sibling;\n        }\n        !didFindChild ? invariant(false, 'Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.') : void 0;\n      }\n    }\n\n    !(a.alternate === b) ? invariant(false, 'Return fibers should always be each others\\' alternates. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n  }\n  // If the root is not a host container, we're in a disconnected tree. I.e.\n  // unmounted.\n  !(a.tag === HostRoot) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;\n  if (a.stateNode.current === a) {\n    // We've determined that A is the current branch.\n    return fiber;\n  }\n  // Otherwise B has to be current branch.\n  return alternate;\n}\n\nfunction findCurrentHostFiber(parent) {\n  var currentParent = findCurrentFiberUsingSlowPath(parent);\n  if (!currentParent) {\n    return null;\n  }\n\n  // Next we'll drill down this component to find the first HostComponent/Text.\n  var node = currentParent;\n  while (true) {\n    if (node.tag === HostComponent || node.tag === HostText) {\n      return node;\n    } else if (node.child) {\n      node.child['return'] = node;\n      node = node.child;\n      continue;\n    }\n    if (node === currentParent) {\n      return null;\n    }\n    while (!node.sibling) {\n      if (!node['return'] || node['return'] === currentParent) {\n        return null;\n      }\n      node = node['return'];\n    }\n    node.sibling['return'] = node['return'];\n    node = node.sibling;\n  }\n  // Flow needs the return null here, but ESLint complains about it.\n  // eslint-disable-next-line no-unreachable\n  return null;\n}\n\nfunction findCurrentHostFiberWithNoPortals(parent) {\n  var currentParent = findCurrentFiberUsingSlowPath(parent);\n  if (!currentParent) {\n    return null;\n  }\n\n  // Next we'll drill down this component to find the first HostComponent/Text.\n  var node = currentParent;\n  while (true) {\n    if (node.tag === HostComponent || node.tag === HostText) {\n      return node;\n    } else if (node.child && node.tag !== HostPortal) {\n      node.child['return'] = node;\n      node = node.child;\n      continue;\n    }\n    if (node === currentParent) {\n      return null;\n    }\n    while (!node.sibling) {\n      if (!node['return'] || node['return'] === currentParent) {\n        return null;\n      }\n      node = node['return'];\n    }\n    node.sibling['return'] = node['return'];\n    node = node.sibling;\n  }\n  // Flow needs the return null here, but ESLint complains about it.\n  // eslint-disable-next-line no-unreachable\n  return null;\n}\n\nvar CALLBACK_BOOKKEEPING_POOL_SIZE = 10;\nvar callbackBookkeepingPool = [];\n\n/**\n * Find the deepest React component completely containing the root of the\n * passed-in instance (for use when entire React trees are nested within each\n * other). If React trees are not nested, returns null.\n */\nfunction findRootContainerNode(inst) {\n  // TODO: It may be a good idea to cache this to prevent unnecessary DOM\n  // traversal, but caching is difficult to do correctly without using a\n  // mutation observer to listen for all DOM changes.\n  while (inst['return']) {\n    inst = inst['return'];\n  }\n  if (inst.tag !== HostRoot) {\n    // This can happen if we're in a detached tree.\n    return null;\n  }\n  return inst.stateNode.containerInfo;\n}\n\n// Used to store ancestor hierarchy in top level callback\nfunction getTopLevelCallbackBookKeeping(topLevelType, nativeEvent, targetInst) {\n  if (callbackBookkeepingPool.length) {\n    var instance = callbackBookkeepingPool.pop();\n    instance.topLevelType = topLevelType;\n    instance.nativeEvent = nativeEvent;\n    instance.targetInst = targetInst;\n    return instance;\n  }\n  return {\n    topLevelType: topLevelType,\n    nativeEvent: nativeEvent,\n    targetInst: targetInst,\n    ancestors: []\n  };\n}\n\nfunction releaseTopLevelCallbackBookKeeping(instance) {\n  instance.topLevelType = null;\n  instance.nativeEvent = null;\n  instance.targetInst = null;\n  instance.ancestors.length = 0;\n  if (callbackBookkeepingPool.length < CALLBACK_BOOKKEEPING_POOL_SIZE) {\n    callbackBookkeepingPool.push(instance);\n  }\n}\n\nfunction handleTopLevelImpl(bookKeeping) {\n  var targetInst = bookKeeping.targetInst;\n\n  // Loop through the hierarchy, in case there's any nested components.\n  // It's important that we build the array of ancestors before calling any\n  // event handlers, because event handlers can modify the DOM, leading to\n  // inconsistencies with ReactMount's node cache. See #1105.\n  var ancestor = targetInst;\n  do {\n    if (!ancestor) {\n      bookKeeping.ancestors.push(ancestor);\n      break;\n    }\n    var root = findRootContainerNode(ancestor);\n    if (!root) {\n      break;\n    }\n    bookKeeping.ancestors.push(ancestor);\n    ancestor = getClosestInstanceFromNode(root);\n  } while (ancestor);\n\n  for (var i = 0; i < bookKeeping.ancestors.length; i++) {\n    targetInst = bookKeeping.ancestors[i];\n    _handleTopLevel(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));\n  }\n}\n\n// TODO: can we stop exporting these?\nvar _enabled = true;\nvar _handleTopLevel = void 0;\n\nfunction setHandleTopLevel(handleTopLevel) {\n  _handleTopLevel = handleTopLevel;\n}\n\nfunction setEnabled(enabled) {\n  _enabled = !!enabled;\n}\n\nfunction isEnabled() {\n  return _enabled;\n}\n\n/**\n * Traps top-level events by using event bubbling.\n *\n * @param {string} topLevelType Record from `BrowserEventConstants`.\n * @param {string} handlerBaseName Event name (e.g. \"click\").\n * @param {object} element Element on which to attach listener.\n * @return {?object} An object with a remove function which will forcefully\n *                  remove the listener.\n * @internal\n */\nfunction trapBubbledEvent(topLevelType, handlerBaseName, element) {\n  if (!element) {\n    return null;\n  }\n  return EventListener.listen(element, handlerBaseName, dispatchEvent.bind(null, topLevelType));\n}\n\n/**\n * Traps a top-level event by using event capturing.\n *\n * @param {string} topLevelType Record from `BrowserEventConstants`.\n * @param {string} handlerBaseName Event name (e.g. \"click\").\n * @param {object} element Element on which to attach listener.\n * @return {?object} An object with a remove function which will forcefully\n *                  remove the listener.\n * @internal\n */\nfunction trapCapturedEvent(topLevelType, handlerBaseName, element) {\n  if (!element) {\n    return null;\n  }\n  return EventListener.capture(element, handlerBaseName, dispatchEvent.bind(null, topLevelType));\n}\n\nfunction dispatchEvent(topLevelType, nativeEvent) {\n  if (!_enabled) {\n    return;\n  }\n\n  var nativeEventTarget = getEventTarget(nativeEvent);\n  var targetInst = getClosestInstanceFromNode(nativeEventTarget);\n  if (targetInst !== null && typeof targetInst.tag === 'number' && !isFiberMounted(targetInst)) {\n    // If we get an event (ex: img onload) before committing that\n    // component's mount, ignore it for now (that is, treat it as if it was an\n    // event on a non-React tree). We might also consider queueing events and\n    // dispatching them after the mount.\n    targetInst = null;\n  }\n\n  var bookKeeping = getTopLevelCallbackBookKeeping(topLevelType, nativeEvent, targetInst);\n\n  try {\n    // Event queue being processed in the same cycle allows\n    // `preventDefault`.\n    batchedUpdates(handleTopLevelImpl, bookKeeping);\n  } finally {\n    releaseTopLevelCallbackBookKeeping(bookKeeping);\n  }\n}\n\nvar ReactDOMEventListener = Object.freeze({\n\tget _enabled () { return _enabled; },\n\tget _handleTopLevel () { return _handleTopLevel; },\n\tsetHandleTopLevel: setHandleTopLevel,\n\tsetEnabled: setEnabled,\n\tisEnabled: isEnabled,\n\ttrapBubbledEvent: trapBubbledEvent,\n\ttrapCapturedEvent: trapCapturedEvent,\n\tdispatchEvent: dispatchEvent\n});\n\n/**\n * Generate a mapping of standard vendor prefixes using the defined style property and event name.\n *\n * @param {string} styleProp\n * @param {string} eventName\n * @returns {object}\n */\nfunction makePrefixMap(styleProp, eventName) {\n  var prefixes = {};\n\n  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();\n  prefixes['Webkit' + styleProp] = 'webkit' + eventName;\n  prefixes['Moz' + styleProp] = 'moz' + eventName;\n  prefixes['ms' + styleProp] = 'MS' + eventName;\n  prefixes['O' + styleProp] = 'o' + eventName.toLowerCase();\n\n  return prefixes;\n}\n\n/**\n * A list of event names to a configurable list of vendor prefixes.\n */\nvar vendorPrefixes = {\n  animationend: makePrefixMap('Animation', 'AnimationEnd'),\n  animationiteration: makePrefixMap('Animation', 'AnimationIteration'),\n  animationstart: makePrefixMap('Animation', 'AnimationStart'),\n  transitionend: makePrefixMap('Transition', 'TransitionEnd')\n};\n\n/**\n * Event names that have already been detected and prefixed (if applicable).\n */\nvar prefixedEventNames = {};\n\n/**\n * Element to check for prefixes on.\n */\nvar style = {};\n\n/**\n * Bootstrap if a DOM exists.\n */\nif (ExecutionEnvironment.canUseDOM) {\n  style = document.createElement('div').style;\n\n  // On some platforms, in particular some releases of Android 4.x,\n  // the un-prefixed \"animation\" and \"transition\" properties are defined on the\n  // style object but the events that fire will still be prefixed, so we need\n  // to check if the un-prefixed events are usable, and if not remove them from the map.\n  if (!('AnimationEvent' in window)) {\n    delete vendorPrefixes.animationend.animation;\n    delete vendorPrefixes.animationiteration.animation;\n    delete vendorPrefixes.animationstart.animation;\n  }\n\n  // Same as above\n  if (!('TransitionEvent' in window)) {\n    delete vendorPrefixes.transitionend.transition;\n  }\n}\n\n/**\n * Attempts to determine the correct vendor prefixed event name.\n *\n * @param {string} eventName\n * @returns {string}\n */\nfunction getVendorPrefixedEventName(eventName) {\n  if (prefixedEventNames[eventName]) {\n    return prefixedEventNames[eventName];\n  } else if (!vendorPrefixes[eventName]) {\n    return eventName;\n  }\n\n  var prefixMap = vendorPrefixes[eventName];\n\n  for (var styleProp in prefixMap) {\n    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {\n      return prefixedEventNames[eventName] = prefixMap[styleProp];\n    }\n  }\n\n  return '';\n}\n\n/**\n * Types of raw signals from the browser caught at the top level.\n *\n * For events like 'submit' which don't consistently bubble (which we\n * trap at a lower node than `document`), binding at `document` would\n * cause duplicate events so we don't include them here.\n */\nvar topLevelTypes$1 = {\n  topAbort: 'abort',\n  topAnimationEnd: getVendorPrefixedEventName('animationend') || 'animationend',\n  topAnimationIteration: getVendorPrefixedEventName('animationiteration') || 'animationiteration',\n  topAnimationStart: getVendorPrefixedEventName('animationstart') || 'animationstart',\n  topBlur: 'blur',\n  topCancel: 'cancel',\n  topCanPlay: 'canplay',\n  topCanPlayThrough: 'canplaythrough',\n  topChange: 'change',\n  topClick: 'click',\n  topClose: 'close',\n  topCompositionEnd: 'compositionend',\n  topCompositionStart: 'compositionstart',\n  topCompositionUpdate: 'compositionupdate',\n  topContextMenu: 'contextmenu',\n  topCopy: 'copy',\n  topCut: 'cut',\n  topDoubleClick: 'dblclick',\n  topDrag: 'drag',\n  topDragEnd: 'dragend',\n  topDragEnter: 'dragenter',\n  topDragExit: 'dragexit',\n  topDragLeave: 'dragleave',\n  topDragOver: 'dragover',\n  topDragStart: 'dragstart',\n  topDrop: 'drop',\n  topDurationChange: 'durationchange',\n  topEmptied: 'emptied',\n  topEncrypted: 'encrypted',\n  topEnded: 'ended',\n  topError: 'error',\n  topFocus: 'focus',\n  topInput: 'input',\n  topKeyDown: 'keydown',\n  topKeyPress: 'keypress',\n  topKeyUp: 'keyup',\n  topLoadedData: 'loadeddata',\n  topLoad: 'load',\n  topLoadedMetadata: 'loadedmetadata',\n  topLoadStart: 'loadstart',\n  topMouseDown: 'mousedown',\n  topMouseMove: 'mousemove',\n  topMouseOut: 'mouseout',\n  topMouseOver: 'mouseover',\n  topMouseUp: 'mouseup',\n  topPaste: 'paste',\n  topPause: 'pause',\n  topPlay: 'play',\n  topPlaying: 'playing',\n  topProgress: 'progress',\n  topRateChange: 'ratechange',\n  topScroll: 'scroll',\n  topSeeked: 'seeked',\n  topSeeking: 'seeking',\n  topSelectionChange: 'selectionchange',\n  topStalled: 'stalled',\n  topSuspend: 'suspend',\n  topTextInput: 'textInput',\n  topTimeUpdate: 'timeupdate',\n  topToggle: 'toggle',\n  topTouchCancel: 'touchcancel',\n  topTouchEnd: 'touchend',\n  topTouchMove: 'touchmove',\n  topTouchStart: 'touchstart',\n  topTransitionEnd: getVendorPrefixedEventName('transitionend') || 'transitionend',\n  topVolumeChange: 'volumechange',\n  topWaiting: 'waiting',\n  topWheel: 'wheel'\n};\n\nvar BrowserEventConstants = {\n  topLevelTypes: topLevelTypes$1\n};\n\nfunction runEventQueueInBatch(events) {\n  enqueueEvents(events);\n  processEventQueue(false);\n}\n\n/**\n * Streams a fired top-level event to `EventPluginHub` where plugins have the\n * opportunity to create `ReactEvent`s to be dispatched.\n */\nfunction handleTopLevel(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n  var events = extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);\n  runEventQueueInBatch(events);\n}\n\nvar topLevelTypes = BrowserEventConstants.topLevelTypes;\n\n/**\n * Summary of `ReactBrowserEventEmitter` event handling:\n *\n *  - Top-level delegation is used to trap most native browser events. This\n *    may only occur in the main thread and is the responsibility of\n *    ReactDOMEventListener, which is injected and can therefore support\n *    pluggable event sources. This is the only work that occurs in the main\n *    thread.\n *\n *  - We normalize and de-duplicate events to account for browser quirks. This\n *    may be done in the worker thread.\n *\n *  - Forward these native events (with the associated top-level type used to\n *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want\n *    to extract any synthetic events.\n *\n *  - The `EventPluginHub` will then process each event by annotating them with\n *    \"dispatches\", a sequence of listeners and IDs that care about that event.\n *\n *  - The `EventPluginHub` then dispatches the events.\n *\n * Overview of React and the event system:\n *\n * +------------+    .\n * |    DOM     |    .\n * +------------+    .\n *       |           .\n *       v           .\n * +------------+    .\n * | ReactEvent |    .\n * |  Listener  |    .\n * +------------+    .                         +-----------+\n *       |           .               +--------+|SimpleEvent|\n *       |           .               |         |Plugin     |\n * +-----|------+    .               v         +-----------+\n * |     |      |    .    +--------------+                    +------------+\n * |     +-----------.--->|EventPluginHub|                    |    Event   |\n * |            |    .    |              |     +-----------+  | Propagators|\n * | ReactEvent |    .    |              |     |TapEvent   |  |------------|\n * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|\n * |            |    .    |              |     +-----------+  |  utilities |\n * |     +-----------.--->|              |                    +------------+\n * |     |      |    .    +--------------+\n * +-----|------+    .                ^        +-----------+\n *       |           .                |        |Enter/Leave|\n *       +           .                +-------+|Plugin     |\n * +-------------+   .                         +-----------+\n * | application |   .\n * |-------------|   .\n * |             |   .\n * |             |   .\n * +-------------+   .\n *                   .\n *    React Core     .  General Purpose Event Plugin System\n */\n\nvar alreadyListeningTo = {};\nvar reactTopListenersCounter = 0;\n\n/**\n * To ensure no conflicts with other potential React instances on the page\n */\nvar topListenersIDKey = '_reactListenersID' + ('' + Math.random()).slice(2);\n\nfunction getListeningForDocument(mountAt) {\n  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`\n  // directly.\n  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {\n    mountAt[topListenersIDKey] = reactTopListenersCounter++;\n    alreadyListeningTo[mountAt[topListenersIDKey]] = {};\n  }\n  return alreadyListeningTo[mountAt[topListenersIDKey]];\n}\n\n/**\n * We listen for bubbled touch events on the document object.\n *\n * Firefox v8.01 (and possibly others) exhibited strange behavior when\n * mounting `onmousemove` events at some node that was not the document\n * element. The symptoms were that if your mouse is not moving over something\n * contained within that mount point (for example on the background) the\n * top-level listeners for `onmousemove` won't be called. However, if you\n * register the `mousemove` on the document object, then it will of course\n * catch all `mousemove`s. This along with iOS quirks, justifies restricting\n * top-level listeners to the document object only, at least for these\n * movement types of events and possibly all events.\n *\n * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html\n *\n * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but\n * they bubble to document.\n *\n * @param {string} registrationName Name of listener (e.g. `onClick`).\n * @param {object} contentDocumentHandle Document which owns the container\n */\nfunction listenTo(registrationName, contentDocumentHandle) {\n  var mountAt = contentDocumentHandle;\n  var isListening = getListeningForDocument(mountAt);\n  var dependencies = registrationNameDependencies[registrationName];\n\n  for (var i = 0; i < dependencies.length; i++) {\n    var dependency = dependencies[i];\n    if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {\n      if (dependency === 'topScroll') {\n        trapCapturedEvent('topScroll', 'scroll', mountAt);\n      } else if (dependency === 'topFocus' || dependency === 'topBlur') {\n        trapCapturedEvent('topFocus', 'focus', mountAt);\n        trapCapturedEvent('topBlur', 'blur', mountAt);\n\n        // to make sure blur and focus event listeners are only attached once\n        isListening.topBlur = true;\n        isListening.topFocus = true;\n      } else if (dependency === 'topCancel') {\n        if (isEventSupported('cancel', true)) {\n          trapCapturedEvent('topCancel', 'cancel', mountAt);\n        }\n        isListening.topCancel = true;\n      } else if (dependency === 'topClose') {\n        if (isEventSupported('close', true)) {\n          trapCapturedEvent('topClose', 'close', mountAt);\n        }\n        isListening.topClose = true;\n      } else if (topLevelTypes.hasOwnProperty(dependency)) {\n        trapBubbledEvent(dependency, topLevelTypes[dependency], mountAt);\n      }\n\n      isListening[dependency] = true;\n    }\n  }\n}\n\nfunction isListeningToAllDependencies(registrationName, mountAt) {\n  var isListening = getListeningForDocument(mountAt);\n  var dependencies = registrationNameDependencies[registrationName];\n  for (var i = 0; i < dependencies.length; i++) {\n    var dependency = dependencies[i];\n    if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Given any node return the first leaf node without children.\n *\n * @param {DOMElement|DOMTextNode} node\n * @return {DOMElement|DOMTextNode}\n */\nfunction getLeafNode(node) {\n  while (node && node.firstChild) {\n    node = node.firstChild;\n  }\n  return node;\n}\n\n/**\n * Get the next sibling within a container. This will walk up the\n * DOM if a node's siblings have been exhausted.\n *\n * @param {DOMElement|DOMTextNode} node\n * @return {?DOMElement|DOMTextNode}\n */\nfunction getSiblingNode(node) {\n  while (node) {\n    if (node.nextSibling) {\n      return node.nextSibling;\n    }\n    node = node.parentNode;\n  }\n}\n\n/**\n * Get object describing the nodes which contain characters at offset.\n *\n * @param {DOMElement|DOMTextNode} root\n * @param {number} offset\n * @return {?object}\n */\nfunction getNodeForCharacterOffset(root, offset) {\n  var node = getLeafNode(root);\n  var nodeStart = 0;\n  var nodeEnd = 0;\n\n  while (node) {\n    if (node.nodeType === TEXT_NODE) {\n      nodeEnd = nodeStart + node.textContent.length;\n\n      if (nodeStart <= offset && nodeEnd >= offset) {\n        return {\n          node: node,\n          offset: offset - nodeStart\n        };\n      }\n\n      nodeStart = nodeEnd;\n    }\n\n    node = getLeafNode(getSiblingNode(node));\n  }\n}\n\n/**\n * @param {DOMElement} outerNode\n * @return {?object}\n */\nfunction getOffsets(outerNode) {\n  var selection = window.getSelection && window.getSelection();\n\n  if (!selection || selection.rangeCount === 0) {\n    return null;\n  }\n\n  var anchorNode = selection.anchorNode,\n      anchorOffset = selection.anchorOffset,\n      focusNode$$1 = selection.focusNode,\n      focusOffset = selection.focusOffset;\n\n  // In Firefox, anchorNode and focusNode can be \"anonymous divs\", e.g. the\n  // up/down buttons on an <input type=\"number\">. Anonymous divs do not seem to\n  // expose properties, triggering a \"Permission denied error\" if any of its\n  // properties are accessed. The only seemingly possible way to avoid erroring\n  // is to access a property that typically works for non-anonymous divs and\n  // catch any error that may otherwise arise. See\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427\n\n  try {\n    /* eslint-disable no-unused-expressions */\n    anchorNode.nodeType;\n    focusNode$$1.nodeType;\n    /* eslint-enable no-unused-expressions */\n  } catch (e) {\n    return null;\n  }\n\n  return getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode$$1, focusOffset);\n}\n\n/**\n * Returns {start, end} where `start` is the character/codepoint index of\n * (anchorNode, anchorOffset) within the textContent of `outerNode`, and\n * `end` is the index of (focusNode, focusOffset).\n *\n * Returns null if you pass in garbage input but we should probably just crash.\n *\n * Exported only for testing.\n */\nfunction getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode$$1, focusOffset) {\n  var length = 0;\n  var start = -1;\n  var end = -1;\n  var indexWithinAnchor = 0;\n  var indexWithinFocus = 0;\n  var node = outerNode;\n  var parentNode = null;\n\n  outer: while (true) {\n    var next = null;\n\n    while (true) {\n      if (node === anchorNode && (anchorOffset === 0 || node.nodeType === TEXT_NODE)) {\n        start = length + anchorOffset;\n      }\n      if (node === focusNode$$1 && (focusOffset === 0 || node.nodeType === TEXT_NODE)) {\n        end = length + focusOffset;\n      }\n\n      if (node.nodeType === TEXT_NODE) {\n        length += node.nodeValue.length;\n      }\n\n      if ((next = node.firstChild) === null) {\n        break;\n      }\n      // Moving from `node` to its first child `next`.\n      parentNode = node;\n      node = next;\n    }\n\n    while (true) {\n      if (node === outerNode) {\n        // If `outerNode` has children, this is always the second time visiting\n        // it. If it has no children, this is still the first loop, and the only\n        // valid selection is anchorNode and focusNode both equal to this node\n        // and both offsets 0, in which case we will have handled above.\n        break outer;\n      }\n      if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) {\n        start = length;\n      }\n      if (parentNode === focusNode$$1 && ++indexWithinFocus === focusOffset) {\n        end = length;\n      }\n      if ((next = node.nextSibling) !== null) {\n        break;\n      }\n      node = parentNode;\n      parentNode = node.parentNode;\n    }\n\n    // Moving from `node` to its next sibling `next`.\n    node = next;\n  }\n\n  if (start === -1 || end === -1) {\n    // This should never happen. (Would happen if the anchor/focus nodes aren't\n    // actually inside the passed-in node.)\n    return null;\n  }\n\n  return {\n    start: start,\n    end: end\n  };\n}\n\n/**\n * In modern non-IE browsers, we can support both forward and backward\n * selections.\n *\n * Note: IE10+ supports the Selection object, but it does not support\n * the `extend` method, which means that even in modern IE, it's not possible\n * to programmatically create a backward selection. Thus, for all IE\n * versions, we use the old IE API to create our selections.\n *\n * @param {DOMElement|DOMTextNode} node\n * @param {object} offsets\n */\nfunction setOffsets(node, offsets) {\n  if (!window.getSelection) {\n    return;\n  }\n\n  var selection = window.getSelection();\n  var length = node[getTextContentAccessor()].length;\n  var start = Math.min(offsets.start, length);\n  var end = offsets.end === undefined ? start : Math.min(offsets.end, length);\n\n  // IE 11 uses modern selection, but doesn't support the extend method.\n  // Flip backward selections, so we can set with a single range.\n  if (!selection.extend && start > end) {\n    var temp = end;\n    end = start;\n    start = temp;\n  }\n\n  var startMarker = getNodeForCharacterOffset(node, start);\n  var endMarker = getNodeForCharacterOffset(node, end);\n\n  if (startMarker && endMarker) {\n    if (selection.rangeCount === 1 && selection.anchorNode === startMarker.node && selection.anchorOffset === startMarker.offset && selection.focusNode === endMarker.node && selection.focusOffset === endMarker.offset) {\n      return;\n    }\n    var range = document.createRange();\n    range.setStart(startMarker.node, startMarker.offset);\n    selection.removeAllRanges();\n\n    if (start > end) {\n      selection.addRange(range);\n      selection.extend(endMarker.node, endMarker.offset);\n    } else {\n      range.setEnd(endMarker.node, endMarker.offset);\n      selection.addRange(range);\n    }\n  }\n}\n\nfunction isInDocument(node) {\n  return containsNode(document.documentElement, node);\n}\n\n/**\n * @ReactInputSelection: React input selection module. Based on Selection.js,\n * but modified to be suitable for react and has a couple of bug fixes (doesn't\n * assume buttons have range selections allowed).\n * Input selection module for React.\n */\n\nfunction hasSelectionCapabilities(elem) {\n  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();\n  return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');\n}\n\nfunction getSelectionInformation() {\n  var focusedElem = getActiveElement();\n  return {\n    focusedElem: focusedElem,\n    selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection$1(focusedElem) : null\n  };\n}\n\n/**\n * @restoreSelection: If any selection information was potentially lost,\n * restore it. This is useful when performing operations that could remove dom\n * nodes and place them back in, resulting in focus being lost.\n */\nfunction restoreSelection(priorSelectionInformation) {\n  var curFocusedElem = getActiveElement();\n  var priorFocusedElem = priorSelectionInformation.focusedElem;\n  var priorSelectionRange = priorSelectionInformation.selectionRange;\n  if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {\n    if (hasSelectionCapabilities(priorFocusedElem)) {\n      setSelection(priorFocusedElem, priorSelectionRange);\n    }\n\n    // Focusing a node can change the scroll position, which is undesirable\n    var ancestors = [];\n    var ancestor = priorFocusedElem;\n    while (ancestor = ancestor.parentNode) {\n      if (ancestor.nodeType === ELEMENT_NODE) {\n        ancestors.push({\n          element: ancestor,\n          left: ancestor.scrollLeft,\n          top: ancestor.scrollTop\n        });\n      }\n    }\n\n    focusNode(priorFocusedElem);\n\n    for (var i = 0; i < ancestors.length; i++) {\n      var info = ancestors[i];\n      info.element.scrollLeft = info.left;\n      info.element.scrollTop = info.top;\n    }\n  }\n}\n\n/**\n * @getSelection: Gets the selection bounds of a focused textarea, input or\n * contentEditable node.\n * -@input: Look up selection bounds of this input\n * -@return {start: selectionStart, end: selectionEnd}\n */\nfunction getSelection$1(input) {\n  var selection = void 0;\n\n  if ('selectionStart' in input) {\n    // Modern browser with input or textarea.\n    selection = {\n      start: input.selectionStart,\n      end: input.selectionEnd\n    };\n  } else {\n    // Content editable or old IE textarea.\n    selection = getOffsets(input);\n  }\n\n  return selection || { start: 0, end: 0 };\n}\n\n/**\n * @setSelection: Sets the selection bounds of a textarea or input and focuses\n * the input.\n * -@input     Set selection bounds of this input or textarea\n * -@offsets   Object of same form that is returned from get*\n */\nfunction setSelection(input, offsets) {\n  var start = offsets.start,\n      end = offsets.end;\n\n  if (end === undefined) {\n    end = start;\n  }\n\n  if ('selectionStart' in input) {\n    input.selectionStart = start;\n    input.selectionEnd = Math.min(end, input.value.length);\n  } else {\n    setOffsets(input, offsets);\n  }\n}\n\nvar skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;\n\nvar eventTypes$3 = {\n  select: {\n    phasedRegistrationNames: {\n      bubbled: 'onSelect',\n      captured: 'onSelectCapture'\n    },\n    dependencies: ['topBlur', 'topContextMenu', 'topFocus', 'topKeyDown', 'topKeyUp', 'topMouseDown', 'topMouseUp', 'topSelectionChange']\n  }\n};\n\nvar activeElement$1 = null;\nvar activeElementInst$1 = null;\nvar lastSelection = null;\nvar mouseDown = false;\n\n/**\n * Get an object which is a unique representation of the current selection.\n *\n * The return value will not be consistent across nodes or browsers, but\n * two identical selections on the same node will return identical objects.\n *\n * @param {DOMElement} node\n * @return {object}\n */\nfunction getSelection(node) {\n  if ('selectionStart' in node && hasSelectionCapabilities(node)) {\n    return {\n      start: node.selectionStart,\n      end: node.selectionEnd\n    };\n  } else if (window.getSelection) {\n    var selection = window.getSelection();\n    return {\n      anchorNode: selection.anchorNode,\n      anchorOffset: selection.anchorOffset,\n      focusNode: selection.focusNode,\n      focusOffset: selection.focusOffset\n    };\n  }\n}\n\n/**\n * Poll selection to see whether it's changed.\n *\n * @param {object} nativeEvent\n * @return {?SyntheticEvent}\n */\nfunction constructSelectEvent(nativeEvent, nativeEventTarget) {\n  // Ensure we have the right element, and that the user is not dragging a\n  // selection (this matches native `select` event behavior). In HTML5, select\n  // fires only on input and textarea thus if there's no focused element we\n  // won't dispatch.\n  if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement()) {\n    return null;\n  }\n\n  // Only fire when selection has actually changed.\n  var currentSelection = getSelection(activeElement$1);\n  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {\n    lastSelection = currentSelection;\n\n    var syntheticEvent = SyntheticEvent$1.getPooled(eventTypes$3.select, activeElementInst$1, nativeEvent, nativeEventTarget);\n\n    syntheticEvent.type = 'select';\n    syntheticEvent.target = activeElement$1;\n\n    accumulateTwoPhaseDispatches(syntheticEvent);\n\n    return syntheticEvent;\n  }\n\n  return null;\n}\n\n/**\n * This plugin creates an `onSelect` event that normalizes select events\n * across form elements.\n *\n * Supported elements are:\n * - input (see `isTextInputElement`)\n * - textarea\n * - contentEditable\n *\n * This differs from native browser implementations in the following ways:\n * - Fires on contentEditable fields as well as inputs.\n * - Fires for collapsed selection.\n * - Fires after user input.\n */\nvar SelectEventPlugin = {\n  eventTypes: eventTypes$3,\n\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    var doc = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : nativeEventTarget.nodeType === DOCUMENT_NODE ? nativeEventTarget : nativeEventTarget.ownerDocument;\n    // Track whether all listeners exists for this plugin. If none exist, we do\n    // not extract events. See #3639.\n    if (!doc || !isListeningToAllDependencies('onSelect', doc)) {\n      return null;\n    }\n\n    var targetNode = targetInst ? getNodeFromInstance$1(targetInst) : window;\n\n    switch (topLevelType) {\n      // Track the input node that has focus.\n      case 'topFocus':\n        if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {\n          activeElement$1 = targetNode;\n          activeElementInst$1 = targetInst;\n          lastSelection = null;\n        }\n        break;\n      case 'topBlur':\n        activeElement$1 = null;\n        activeElementInst$1 = null;\n        lastSelection = null;\n        break;\n      // Don't fire the event while the user is dragging. This matches the\n      // semantics of the native select event.\n      case 'topMouseDown':\n        mouseDown = true;\n        break;\n      case 'topContextMenu':\n      case 'topMouseUp':\n        mouseDown = false;\n        return constructSelectEvent(nativeEvent, nativeEventTarget);\n      // Chrome and IE fire non-standard event when selection is changed (and\n      // sometimes when it hasn't). IE's event fires out of order with respect\n      // to key and input events on deletion, so we discard it.\n      //\n      // Firefox doesn't support selectionchange, so check selection status\n      // after each key entry. The selection changes after keydown and before\n      // keyup, but we check on keydown as well in the case of holding down a\n      // key, when multiple keydown events are fired but only one keyup is.\n      // This is also our approach for IE handling, for the reason above.\n      case 'topSelectionChange':\n        if (skipSelectionChangeEvent) {\n          break;\n        }\n      // falls through\n      case 'topKeyDown':\n      case 'topKeyUp':\n        return constructSelectEvent(nativeEvent, nativeEventTarget);\n    }\n\n    return null;\n  }\n};\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface\n * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent\n */\nvar AnimationEventInterface = {\n  animationName: null,\n  elapsedTime: null,\n  pseudoElement: null\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticEvent}\n */\nfunction SyntheticAnimationEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n  return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n}\n\nSyntheticEvent$1.augmentClass(SyntheticAnimationEvent, AnimationEventInterface);\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/clipboard-apis/\n */\nvar ClipboardEventInterface = {\n  clipboardData: function (event) {\n    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;\n  }\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticEvent}\n */\nfunction SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n  return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n}\n\nSyntheticEvent$1.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);\n\n/**\n * @interface FocusEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar FocusEventInterface = {\n  relatedTarget: null\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticUIEvent}\n */\nfunction SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n}\n\nSyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);\n\n/**\n * `charCode` represents the actual \"character code\" and is safe to use with\n * `String.fromCharCode`. As such, only keys that correspond to printable\n * characters produce a valid `charCode`, the only exception to this is Enter.\n * The Tab-key is considered non-printable and does not have a `charCode`,\n * presumably because it does not produce a tab-character in browsers.\n *\n * @param {object} nativeEvent Native browser event.\n * @return {number} Normalized `charCode` property.\n */\nfunction getEventCharCode(nativeEvent) {\n  var charCode;\n  var keyCode = nativeEvent.keyCode;\n\n  if ('charCode' in nativeEvent) {\n    charCode = nativeEvent.charCode;\n\n    // FF does not set `charCode` for the Enter-key, check against `keyCode`.\n    if (charCode === 0 && keyCode === 13) {\n      charCode = 13;\n    }\n  } else {\n    // IE8 does not implement `charCode`, but `keyCode` has the correct value.\n    charCode = keyCode;\n  }\n\n  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.\n  // Must not discard the (non-)printable Enter-key.\n  if (charCode >= 32 || charCode === 13) {\n    return charCode;\n  }\n\n  return 0;\n}\n\n/**\n * Normalization of deprecated HTML5 `key` values\n * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names\n */\nvar normalizeKey = {\n  Esc: 'Escape',\n  Spacebar: ' ',\n  Left: 'ArrowLeft',\n  Up: 'ArrowUp',\n  Right: 'ArrowRight',\n  Down: 'ArrowDown',\n  Del: 'Delete',\n  Win: 'OS',\n  Menu: 'ContextMenu',\n  Apps: 'ContextMenu',\n  Scroll: 'ScrollLock',\n  MozPrintableKey: 'Unidentified'\n};\n\n/**\n * Translation from legacy `keyCode` to HTML5 `key`\n * Only special keys supported, all others depend on keyboard layout or browser\n * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names\n */\nvar translateToKey = {\n  '8': 'Backspace',\n  '9': 'Tab',\n  '12': 'Clear',\n  '13': 'Enter',\n  '16': 'Shift',\n  '17': 'Control',\n  '18': 'Alt',\n  '19': 'Pause',\n  '20': 'CapsLock',\n  '27': 'Escape',\n  '32': ' ',\n  '33': 'PageUp',\n  '34': 'PageDown',\n  '35': 'End',\n  '36': 'Home',\n  '37': 'ArrowLeft',\n  '38': 'ArrowUp',\n  '39': 'ArrowRight',\n  '40': 'ArrowDown',\n  '45': 'Insert',\n  '46': 'Delete',\n  '112': 'F1',\n  '113': 'F2',\n  '114': 'F3',\n  '115': 'F4',\n  '116': 'F5',\n  '117': 'F6',\n  '118': 'F7',\n  '119': 'F8',\n  '120': 'F9',\n  '121': 'F10',\n  '122': 'F11',\n  '123': 'F12',\n  '144': 'NumLock',\n  '145': 'ScrollLock',\n  '224': 'Meta'\n};\n\n/**\n * @param {object} nativeEvent Native browser event.\n * @return {string} Normalized `key` property.\n */\nfunction getEventKey(nativeEvent) {\n  if (nativeEvent.key) {\n    // Normalize inconsistent values reported by browsers due to\n    // implementations of a working draft specification.\n\n    // FireFox implements `key` but returns `MozPrintableKey` for all\n    // printable characters (normalized to `Unidentified`), ignore it.\n    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;\n    if (key !== 'Unidentified') {\n      return key;\n    }\n  }\n\n  // Browser does not implement `key`, polyfill as much of it as we can.\n  if (nativeEvent.type === 'keypress') {\n    var charCode = getEventCharCode(nativeEvent);\n\n    // The enter-key is technically both printable and non-printable and can\n    // thus be captured by `keypress`, no other non-printable key should.\n    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);\n  }\n  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {\n    // While user keyboard layout determines the actual meaning of each\n    // `keyCode` value, almost all function keys have a universal value.\n    return translateToKey[nativeEvent.keyCode] || 'Unidentified';\n  }\n  return '';\n}\n\n/**\n * @interface KeyboardEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar KeyboardEventInterface = {\n  key: getEventKey,\n  location: null,\n  ctrlKey: null,\n  shiftKey: null,\n  altKey: null,\n  metaKey: null,\n  repeat: null,\n  locale: null,\n  getModifierState: getEventModifierState,\n  // Legacy Interface\n  charCode: function (event) {\n    // `charCode` is the result of a KeyPress event and represents the value of\n    // the actual printable character.\n\n    // KeyPress is deprecated, but its replacement is not yet final and not\n    // implemented in any major browser. Only KeyPress has charCode.\n    if (event.type === 'keypress') {\n      return getEventCharCode(event);\n    }\n    return 0;\n  },\n  keyCode: function (event) {\n    // `keyCode` is the result of a KeyDown/Up event and represents the value of\n    // physical keyboard key.\n\n    // The actual meaning of the value depends on the users' keyboard layout\n    // which cannot be detected. Assuming that it is a US keyboard layout\n    // provides a surprisingly accurate mapping for US and European users.\n    // Due to this, it is left to the user to implement at this time.\n    if (event.type === 'keydown' || event.type === 'keyup') {\n      return event.keyCode;\n    }\n    return 0;\n  },\n  which: function (event) {\n    // `which` is an alias for either `keyCode` or `charCode` depending on the\n    // type of the event.\n    if (event.type === 'keypress') {\n      return getEventCharCode(event);\n    }\n    if (event.type === 'keydown' || event.type === 'keyup') {\n      return event.keyCode;\n    }\n    return 0;\n  }\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticUIEvent}\n */\nfunction SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n}\n\nSyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);\n\n/**\n * @interface DragEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar DragEventInterface = {\n  dataTransfer: null\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticMouseEvent}\n */\nfunction SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n}\n\nSyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);\n\n/**\n * @interface TouchEvent\n * @see http://www.w3.org/TR/touch-events/\n */\nvar TouchEventInterface = {\n  touches: null,\n  targetTouches: null,\n  changedTouches: null,\n  altKey: null,\n  metaKey: null,\n  ctrlKey: null,\n  shiftKey: null,\n  getModifierState: getEventModifierState\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticUIEvent}\n */\nfunction SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n}\n\nSyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-\n * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent\n */\nvar TransitionEventInterface = {\n  propertyName: null,\n  elapsedTime: null,\n  pseudoElement: null\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticEvent}\n */\nfunction SyntheticTransitionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n  return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n}\n\nSyntheticEvent$1.augmentClass(SyntheticTransitionEvent, TransitionEventInterface);\n\n/**\n * @interface WheelEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar WheelEventInterface = {\n  deltaX: function (event) {\n    return 'deltaX' in event ? event.deltaX : // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).\n    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;\n  },\n  deltaY: function (event) {\n    return 'deltaY' in event ? event.deltaY : // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).\n    'wheelDeltaY' in event ? -event.wheelDeltaY : // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).\n    'wheelDelta' in event ? -event.wheelDelta : 0;\n  },\n  deltaZ: null,\n\n  // Browsers without \"deltaMode\" is reporting in raw wheel delta where one\n  // notch on the scroll is always +/- 120, roughly equivalent to pixels.\n  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or\n  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.\n  deltaMode: null\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticMouseEvent}\n */\nfunction SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n}\n\nSyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);\n\n/**\n * Turns\n * ['abort', ...]\n * into\n * eventTypes = {\n *   'abort': {\n *     phasedRegistrationNames: {\n *       bubbled: 'onAbort',\n *       captured: 'onAbortCapture',\n *     },\n *     dependencies: ['topAbort'],\n *   },\n *   ...\n * };\n * topLevelEventsToDispatchConfig = {\n *   'topAbort': { sameConfig }\n * };\n */\nvar eventTypes$4 = {};\nvar topLevelEventsToDispatchConfig = {};\n['abort', 'animationEnd', 'animationIteration', 'animationStart', 'blur', 'cancel', 'canPlay', 'canPlayThrough', 'click', 'close', 'contextMenu', 'copy', 'cut', 'doubleClick', 'drag', 'dragEnd', 'dragEnter', 'dragExit', 'dragLeave', 'dragOver', 'dragStart', 'drop', 'durationChange', 'emptied', 'encrypted', 'ended', 'error', 'focus', 'input', 'invalid', 'keyDown', 'keyPress', 'keyUp', 'load', 'loadedData', 'loadedMetadata', 'loadStart', 'mouseDown', 'mouseMove', 'mouseOut', 'mouseOver', 'mouseUp', 'paste', 'pause', 'play', 'playing', 'progress', 'rateChange', 'reset', 'scroll', 'seeked', 'seeking', 'stalled', 'submit', 'suspend', 'timeUpdate', 'toggle', 'touchCancel', 'touchEnd', 'touchMove', 'touchStart', 'transitionEnd', 'volumeChange', 'waiting', 'wheel'].forEach(function (event) {\n  var capitalizedEvent = event[0].toUpperCase() + event.slice(1);\n  var onEvent = 'on' + capitalizedEvent;\n  var topEvent = 'top' + capitalizedEvent;\n\n  var type = {\n    phasedRegistrationNames: {\n      bubbled: onEvent,\n      captured: onEvent + 'Capture'\n    },\n    dependencies: [topEvent]\n  };\n  eventTypes$4[event] = type;\n  topLevelEventsToDispatchConfig[topEvent] = type;\n});\n\n// Only used in DEV for exhaustiveness validation.\nvar knownHTMLTopLevelTypes = ['topAbort', 'topCancel', 'topCanPlay', 'topCanPlayThrough', 'topClose', 'topDurationChange', 'topEmptied', 'topEncrypted', 'topEnded', 'topError', 'topInput', 'topInvalid', 'topLoad', 'topLoadedData', 'topLoadedMetadata', 'topLoadStart', 'topPause', 'topPlay', 'topPlaying', 'topProgress', 'topRateChange', 'topReset', 'topSeeked', 'topSeeking', 'topStalled', 'topSubmit', 'topSuspend', 'topTimeUpdate', 'topToggle', 'topVolumeChange', 'topWaiting'];\n\nvar SimpleEventPlugin = {\n  eventTypes: eventTypes$4,\n\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];\n    if (!dispatchConfig) {\n      return null;\n    }\n    var EventConstructor;\n    switch (topLevelType) {\n      case 'topKeyPress':\n        // Firefox creates a keypress event for function keys too. This removes\n        // the unwanted keypress events. Enter is however both printable and\n        // non-printable. One would expect Tab to be as well (but it isn't).\n        if (getEventCharCode(nativeEvent) === 0) {\n          return null;\n        }\n      /* falls through */\n      case 'topKeyDown':\n      case 'topKeyUp':\n        EventConstructor = SyntheticKeyboardEvent;\n        break;\n      case 'topBlur':\n      case 'topFocus':\n        EventConstructor = SyntheticFocusEvent;\n        break;\n      case 'topClick':\n        // Firefox creates a click event on right mouse clicks. This removes the\n        // unwanted click events.\n        if (nativeEvent.button === 2) {\n          return null;\n        }\n      /* falls through */\n      case 'topDoubleClick':\n      case 'topMouseDown':\n      case 'topMouseMove':\n      case 'topMouseUp':\n      // TODO: Disabled elements should not respond to mouse events\n      /* falls through */\n      case 'topMouseOut':\n      case 'topMouseOver':\n      case 'topContextMenu':\n        EventConstructor = SyntheticMouseEvent;\n        break;\n      case 'topDrag':\n      case 'topDragEnd':\n      case 'topDragEnter':\n      case 'topDragExit':\n      case 'topDragLeave':\n      case 'topDragOver':\n      case 'topDragStart':\n      case 'topDrop':\n        EventConstructor = SyntheticDragEvent;\n        break;\n      case 'topTouchCancel':\n      case 'topTouchEnd':\n      case 'topTouchMove':\n      case 'topTouchStart':\n        EventConstructor = SyntheticTouchEvent;\n        break;\n      case 'topAnimationEnd':\n      case 'topAnimationIteration':\n      case 'topAnimationStart':\n        EventConstructor = SyntheticAnimationEvent;\n        break;\n      case 'topTransitionEnd':\n        EventConstructor = SyntheticTransitionEvent;\n        break;\n      case 'topScroll':\n        EventConstructor = SyntheticUIEvent;\n        break;\n      case 'topWheel':\n        EventConstructor = SyntheticWheelEvent;\n        break;\n      case 'topCopy':\n      case 'topCut':\n      case 'topPaste':\n        EventConstructor = SyntheticClipboardEvent;\n        break;\n      default:\n        {\n          if (knownHTMLTopLevelTypes.indexOf(topLevelType) === -1) {\n            warning(false, 'SimpleEventPlugin: Unhandled event type, `%s`. This warning ' + 'is likely caused by a bug in React. Please file an issue.', topLevelType);\n          }\n        }\n        // HTML Events\n        // @see http://www.w3.org/TR/html5/index.html#events-0\n        EventConstructor = SyntheticEvent$1;\n        break;\n    }\n    var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);\n    accumulateTwoPhaseDispatches(event);\n    return event;\n  }\n};\n\nsetHandleTopLevel(handleTopLevel);\n\n/**\n * Inject modules for resolving DOM hierarchy and plugin ordering.\n */\ninjection$1.injectEventPluginOrder(DOMEventPluginOrder);\ninjection$2.injectComponentTree(ReactDOMComponentTree);\n\n/**\n * Some important event plugins included by default (without having to require\n * them).\n */\ninjection$1.injectEventPluginsByName({\n  SimpleEventPlugin: SimpleEventPlugin,\n  EnterLeaveEventPlugin: EnterLeaveEventPlugin,\n  ChangeEventPlugin: ChangeEventPlugin,\n  SelectEventPlugin: SelectEventPlugin,\n  BeforeInputEventPlugin: BeforeInputEventPlugin\n});\n\nvar enableAsyncSubtreeAPI = true;\nvar enableAsyncSchedulingByDefaultInReactDOM = false;\n// Exports ReactDOM.createRoot\nvar enableCreateRoot = false;\nvar enableUserTimingAPI = true;\n\n// Mutating mode (React DOM, React ART, React Native):\nvar enableMutatingReconciler = true;\n// Experimental noop mode (currently unused):\nvar enableNoopReconciler = false;\n// Experimental persistent mode (CS):\nvar enablePersistentReconciler = false;\n\n// Helps identify side effects in begin-phase lifecycle hooks and setState reducers:\nvar debugRenderPhaseSideEffects = false;\n\n// Only used in www builds.\n\nvar valueStack = [];\n\n{\n  var fiberStack = [];\n}\n\nvar index = -1;\n\nfunction createCursor(defaultValue) {\n  return {\n    current: defaultValue\n  };\n}\n\n\n\nfunction pop(cursor, fiber) {\n  if (index < 0) {\n    {\n      warning(false, 'Unexpected pop.');\n    }\n    return;\n  }\n\n  {\n    if (fiber !== fiberStack[index]) {\n      warning(false, 'Unexpected Fiber popped.');\n    }\n  }\n\n  cursor.current = valueStack[index];\n\n  valueStack[index] = null;\n\n  {\n    fiberStack[index] = null;\n  }\n\n  index--;\n}\n\nfunction push(cursor, value, fiber) {\n  index++;\n\n  valueStack[index] = cursor.current;\n\n  {\n    fiberStack[index] = fiber;\n  }\n\n  cursor.current = value;\n}\n\nfunction reset$1() {\n  while (index > -1) {\n    valueStack[index] = null;\n\n    {\n      fiberStack[index] = null;\n    }\n\n    index--;\n  }\n}\n\nvar describeComponentFrame = function (name, source, ownerName) {\n  return '\\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');\n};\n\nfunction describeFiber(fiber) {\n  switch (fiber.tag) {\n    case IndeterminateComponent:\n    case FunctionalComponent:\n    case ClassComponent:\n    case HostComponent:\n      var owner = fiber._debugOwner;\n      var source = fiber._debugSource;\n      var name = getComponentName(fiber);\n      var ownerName = null;\n      if (owner) {\n        ownerName = getComponentName(owner);\n      }\n      return describeComponentFrame(name, source, ownerName);\n    default:\n      return '';\n  }\n}\n\n// This function can only be called with a work-in-progress fiber and\n// only during begin or complete phase. Do not call it under any other\n// circumstances.\nfunction getStackAddendumByWorkInProgressFiber(workInProgress) {\n  var info = '';\n  var node = workInProgress;\n  do {\n    info += describeFiber(node);\n    // Otherwise this return pointer might point to the wrong tree:\n    node = node['return'];\n  } while (node);\n  return info;\n}\n\nfunction getCurrentFiberOwnerName() {\n  {\n    var fiber = ReactDebugCurrentFiber.current;\n    if (fiber === null) {\n      return null;\n    }\n    var owner = fiber._debugOwner;\n    if (owner !== null && typeof owner !== 'undefined') {\n      return getComponentName(owner);\n    }\n  }\n  return null;\n}\n\nfunction getCurrentFiberStackAddendum() {\n  {\n    var fiber = ReactDebugCurrentFiber.current;\n    if (fiber === null) {\n      return null;\n    }\n    // Safe because if current fiber exists, we are reconciling,\n    // and it is guaranteed to be the work-in-progress version.\n    return getStackAddendumByWorkInProgressFiber(fiber);\n  }\n  return null;\n}\n\nfunction resetCurrentFiber() {\n  ReactDebugCurrentFrame.getCurrentStack = null;\n  ReactDebugCurrentFiber.current = null;\n  ReactDebugCurrentFiber.phase = null;\n}\n\nfunction setCurrentFiber(fiber) {\n  ReactDebugCurrentFrame.getCurrentStack = getCurrentFiberStackAddendum;\n  ReactDebugCurrentFiber.current = fiber;\n  ReactDebugCurrentFiber.phase = null;\n}\n\nfunction setCurrentPhase(phase) {\n  ReactDebugCurrentFiber.phase = phase;\n}\n\nvar ReactDebugCurrentFiber = {\n  current: null,\n  phase: null,\n  resetCurrentFiber: resetCurrentFiber,\n  setCurrentFiber: setCurrentFiber,\n  setCurrentPhase: setCurrentPhase,\n  getCurrentFiberOwnerName: getCurrentFiberOwnerName,\n  getCurrentFiberStackAddendum: getCurrentFiberStackAddendum\n};\n\n// Prefix measurements so that it's possible to filter them.\n// Longer prefixes are hard to read in DevTools.\nvar reactEmoji = '\\u269B';\nvar warningEmoji = '\\u26D4';\nvar supportsUserTiming = typeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function';\n\n// Keep track of current fiber so that we know the path to unwind on pause.\n// TODO: this looks the same as nextUnitOfWork in scheduler. Can we unify them?\nvar currentFiber = null;\n// If we're in the middle of user code, which fiber and method is it?\n// Reusing `currentFiber` would be confusing for this because user code fiber\n// can change during commit phase too, but we don't need to unwind it (since\n// lifecycles in the commit phase don't resemble a tree).\nvar currentPhase = null;\nvar currentPhaseFiber = null;\n// Did lifecycle hook schedule an update? This is often a performance problem,\n// so we will keep track of it, and include it in the report.\n// Track commits caused by cascading updates.\nvar isCommitting = false;\nvar hasScheduledUpdateInCurrentCommit = false;\nvar hasScheduledUpdateInCurrentPhase = false;\nvar commitCountInCurrentWorkLoop = 0;\nvar effectCountInCurrentCommit = 0;\nvar isWaitingForCallback = false;\n// During commits, we only show a measurement once per method name\n// to avoid stretch the commit phase with measurement overhead.\nvar labelsInCurrentCommit = new Set();\n\nvar formatMarkName = function (markName) {\n  return reactEmoji + ' ' + markName;\n};\n\nvar formatLabel = function (label, warning$$1) {\n  var prefix = warning$$1 ? warningEmoji + ' ' : reactEmoji + ' ';\n  var suffix = warning$$1 ? ' Warning: ' + warning$$1 : '';\n  return '' + prefix + label + suffix;\n};\n\nvar beginMark = function (markName) {\n  performance.mark(formatMarkName(markName));\n};\n\nvar clearMark = function (markName) {\n  performance.clearMarks(formatMarkName(markName));\n};\n\nvar endMark = function (label, markName, warning$$1) {\n  var formattedMarkName = formatMarkName(markName);\n  var formattedLabel = formatLabel(label, warning$$1);\n  try {\n    performance.measure(formattedLabel, formattedMarkName);\n  } catch (err) {}\n  // If previous mark was missing for some reason, this will throw.\n  // This could only happen if React crashed in an unexpected place earlier.\n  // Don't pile on with more errors.\n\n  // Clear marks immediately to avoid growing buffer.\n  performance.clearMarks(formattedMarkName);\n  performance.clearMeasures(formattedLabel);\n};\n\nvar getFiberMarkName = function (label, debugID) {\n  return label + ' (#' + debugID + ')';\n};\n\nvar getFiberLabel = function (componentName, isMounted, phase) {\n  if (phase === null) {\n    // These are composite component total time measurements.\n    return componentName + ' [' + (isMounted ? 'update' : 'mount') + ']';\n  } else {\n    // Composite component methods.\n    return componentName + '.' + phase;\n  }\n};\n\nvar beginFiberMark = function (fiber, phase) {\n  var componentName = getComponentName(fiber) || 'Unknown';\n  var debugID = fiber._debugID;\n  var isMounted = fiber.alternate !== null;\n  var label = getFiberLabel(componentName, isMounted, phase);\n\n  if (isCommitting && labelsInCurrentCommit.has(label)) {\n    // During the commit phase, we don't show duplicate labels because\n    // there is a fixed overhead for every measurement, and we don't\n    // want to stretch the commit phase beyond necessary.\n    return false;\n  }\n  labelsInCurrentCommit.add(label);\n\n  var markName = getFiberMarkName(label, debugID);\n  beginMark(markName);\n  return true;\n};\n\nvar clearFiberMark = function (fiber, phase) {\n  var componentName = getComponentName(fiber) || 'Unknown';\n  var debugID = fiber._debugID;\n  var isMounted = fiber.alternate !== null;\n  var label = getFiberLabel(componentName, isMounted, phase);\n  var markName = getFiberMarkName(label, debugID);\n  clearMark(markName);\n};\n\nvar endFiberMark = function (fiber, phase, warning$$1) {\n  var componentName = getComponentName(fiber) || 'Unknown';\n  var debugID = fiber._debugID;\n  var isMounted = fiber.alternate !== null;\n  var label = getFiberLabel(componentName, isMounted, phase);\n  var markName = getFiberMarkName(label, debugID);\n  endMark(label, markName, warning$$1);\n};\n\nvar shouldIgnoreFiber = function (fiber) {\n  // Host components should be skipped in the timeline.\n  // We could check typeof fiber.type, but does this work with RN?\n  switch (fiber.tag) {\n    case HostRoot:\n    case HostComponent:\n    case HostText:\n    case HostPortal:\n    case ReturnComponent:\n    case Fragment:\n      return true;\n    default:\n      return false;\n  }\n};\n\nvar clearPendingPhaseMeasurement = function () {\n  if (currentPhase !== null && currentPhaseFiber !== null) {\n    clearFiberMark(currentPhaseFiber, currentPhase);\n  }\n  currentPhaseFiber = null;\n  currentPhase = null;\n  hasScheduledUpdateInCurrentPhase = false;\n};\n\nvar pauseTimers = function () {\n  // Stops all currently active measurements so that they can be resumed\n  // if we continue in a later deferred loop from the same unit of work.\n  var fiber = currentFiber;\n  while (fiber) {\n    if (fiber._debugIsCurrentlyTiming) {\n      endFiberMark(fiber, null, null);\n    }\n    fiber = fiber['return'];\n  }\n};\n\nvar resumeTimersRecursively = function (fiber) {\n  if (fiber['return'] !== null) {\n    resumeTimersRecursively(fiber['return']);\n  }\n  if (fiber._debugIsCurrentlyTiming) {\n    beginFiberMark(fiber, null);\n  }\n};\n\nvar resumeTimers = function () {\n  // Resumes all measurements that were active during the last deferred loop.\n  if (currentFiber !== null) {\n    resumeTimersRecursively(currentFiber);\n  }\n};\n\nfunction recordEffect() {\n  if (enableUserTimingAPI) {\n    effectCountInCurrentCommit++;\n  }\n}\n\nfunction recordScheduleUpdate() {\n  if (enableUserTimingAPI) {\n    if (isCommitting) {\n      hasScheduledUpdateInCurrentCommit = true;\n    }\n    if (currentPhase !== null && currentPhase !== 'componentWillMount' && currentPhase !== 'componentWillReceiveProps') {\n      hasScheduledUpdateInCurrentPhase = true;\n    }\n  }\n}\n\nfunction startRequestCallbackTimer() {\n  if (enableUserTimingAPI) {\n    if (supportsUserTiming && !isWaitingForCallback) {\n      isWaitingForCallback = true;\n      beginMark('(Waiting for async callback...)');\n    }\n  }\n}\n\nfunction stopRequestCallbackTimer(didExpire) {\n  if (enableUserTimingAPI) {\n    if (supportsUserTiming) {\n      isWaitingForCallback = false;\n      var warning$$1 = didExpire ? 'React was blocked by main thread' : null;\n      endMark('(Waiting for async callback...)', '(Waiting for async callback...)', warning$$1);\n    }\n  }\n}\n\nfunction startWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // If we pause, this is the fiber to unwind from.\n    currentFiber = fiber;\n    if (!beginFiberMark(fiber, null)) {\n      return;\n    }\n    fiber._debugIsCurrentlyTiming = true;\n  }\n}\n\nfunction cancelWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // Remember we shouldn't complete measurement for this fiber.\n    // Otherwise flamechart will be deep even for small updates.\n    fiber._debugIsCurrentlyTiming = false;\n    clearFiberMark(fiber, null);\n  }\n}\n\nfunction stopWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // If we pause, its parent is the fiber to unwind from.\n    currentFiber = fiber['return'];\n    if (!fiber._debugIsCurrentlyTiming) {\n      return;\n    }\n    fiber._debugIsCurrentlyTiming = false;\n    endFiberMark(fiber, null, null);\n  }\n}\n\nfunction stopFailedWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // If we pause, its parent is the fiber to unwind from.\n    currentFiber = fiber['return'];\n    if (!fiber._debugIsCurrentlyTiming) {\n      return;\n    }\n    fiber._debugIsCurrentlyTiming = false;\n    var warning$$1 = 'An error was thrown inside this error boundary';\n    endFiberMark(fiber, null, warning$$1);\n  }\n}\n\nfunction startPhaseTimer(fiber, phase) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    clearPendingPhaseMeasurement();\n    if (!beginFiberMark(fiber, phase)) {\n      return;\n    }\n    currentPhaseFiber = fiber;\n    currentPhase = phase;\n  }\n}\n\nfunction stopPhaseTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    if (currentPhase !== null && currentPhaseFiber !== null) {\n      var warning$$1 = hasScheduledUpdateInCurrentPhase ? 'Scheduled a cascading update' : null;\n      endFiberMark(currentPhaseFiber, currentPhase, warning$$1);\n    }\n    currentPhase = null;\n    currentPhaseFiber = null;\n  }\n}\n\nfunction startWorkLoopTimer(nextUnitOfWork) {\n  if (enableUserTimingAPI) {\n    currentFiber = nextUnitOfWork;\n    if (!supportsUserTiming) {\n      return;\n    }\n    commitCountInCurrentWorkLoop = 0;\n    // This is top level call.\n    // Any other measurements are performed within.\n    beginMark('(React Tree Reconciliation)');\n    // Resume any measurements that were in progress during the last loop.\n    resumeTimers();\n  }\n}\n\nfunction stopWorkLoopTimer(interruptedBy) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    var warning$$1 = null;\n    if (interruptedBy !== null) {\n      if (interruptedBy.tag === HostRoot) {\n        warning$$1 = 'A top-level update interrupted the previous render';\n      } else {\n        var componentName = getComponentName(interruptedBy) || 'Unknown';\n        warning$$1 = 'An update to ' + componentName + ' interrupted the previous render';\n      }\n    } else if (commitCountInCurrentWorkLoop > 1) {\n      warning$$1 = 'There were cascading updates';\n    }\n    commitCountInCurrentWorkLoop = 0;\n    // Pause any measurements until the next loop.\n    pauseTimers();\n    endMark('(React Tree Reconciliation)', '(React Tree Reconciliation)', warning$$1);\n  }\n}\n\nfunction startCommitTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    isCommitting = true;\n    hasScheduledUpdateInCurrentCommit = false;\n    labelsInCurrentCommit.clear();\n    beginMark('(Committing Changes)');\n  }\n}\n\nfunction stopCommitTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n\n    var warning$$1 = null;\n    if (hasScheduledUpdateInCurrentCommit) {\n      warning$$1 = 'Lifecycle hook scheduled a cascading update';\n    } else if (commitCountInCurrentWorkLoop > 0) {\n      warning$$1 = 'Caused by a cascading update in earlier commit';\n    }\n    hasScheduledUpdateInCurrentCommit = false;\n    commitCountInCurrentWorkLoop++;\n    isCommitting = false;\n    labelsInCurrentCommit.clear();\n\n    endMark('(Committing Changes)', '(Committing Changes)', warning$$1);\n  }\n}\n\nfunction startCommitHostEffectsTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    effectCountInCurrentCommit = 0;\n    beginMark('(Committing Host Effects)');\n  }\n}\n\nfunction stopCommitHostEffectsTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    var count = effectCountInCurrentCommit;\n    effectCountInCurrentCommit = 0;\n    endMark('(Committing Host Effects: ' + count + ' Total)', '(Committing Host Effects)', null);\n  }\n}\n\nfunction startCommitLifeCyclesTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    effectCountInCurrentCommit = 0;\n    beginMark('(Calling Lifecycle Methods)');\n  }\n}\n\nfunction stopCommitLifeCyclesTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    var count = effectCountInCurrentCommit;\n    effectCountInCurrentCommit = 0;\n    endMark('(Calling Lifecycle Methods: ' + count + ' Total)', '(Calling Lifecycle Methods)', null);\n  }\n}\n\n{\n  var warnedAboutMissingGetChildContext = {};\n}\n\n// A cursor to the current merged context object on the stack.\nvar contextStackCursor = createCursor(emptyObject);\n// A cursor to a boolean indicating whether the context has changed.\nvar didPerformWorkStackCursor = createCursor(false);\n// Keep track of the previous context object that was on the stack.\n// We use this to get access to the parent context after we have already\n// pushed the next context provider, and now need to merge their contexts.\nvar previousContext = emptyObject;\n\nfunction getUnmaskedContext(workInProgress) {\n  var hasOwnContext = isContextProvider(workInProgress);\n  if (hasOwnContext) {\n    // If the fiber is a context provider itself, when we read its context\n    // we have already pushed its own child context on the stack. A context\n    // provider should not \"see\" its own child context. Therefore we read the\n    // previous (parent) context instead for a context provider.\n    return previousContext;\n  }\n  return contextStackCursor.current;\n}\n\nfunction cacheContext(workInProgress, unmaskedContext, maskedContext) {\n  var instance = workInProgress.stateNode;\n  instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;\n  instance.__reactInternalMemoizedMaskedChildContext = maskedContext;\n}\n\nfunction getMaskedContext(workInProgress, unmaskedContext) {\n  var type = workInProgress.type;\n  var contextTypes = type.contextTypes;\n  if (!contextTypes) {\n    return emptyObject;\n  }\n\n  // Avoid recreating masked context unless unmasked context has changed.\n  // Failing to do this will result in unnecessary calls to componentWillReceiveProps.\n  // This may trigger infinite loops if componentWillReceiveProps calls setState.\n  var instance = workInProgress.stateNode;\n  if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {\n    return instance.__reactInternalMemoizedMaskedChildContext;\n  }\n\n  var context = {};\n  for (var key in contextTypes) {\n    context[key] = unmaskedContext[key];\n  }\n\n  {\n    var name = getComponentName(workInProgress) || 'Unknown';\n    checkPropTypes(contextTypes, context, 'context', name, ReactDebugCurrentFiber.getCurrentFiberStackAddendum);\n  }\n\n  // Cache unmasked context so we can avoid recreating masked context unless necessary.\n  // Context is created before the class component is instantiated so check for instance.\n  if (instance) {\n    cacheContext(workInProgress, unmaskedContext, context);\n  }\n\n  return context;\n}\n\nfunction hasContextChanged() {\n  return didPerformWorkStackCursor.current;\n}\n\nfunction isContextConsumer(fiber) {\n  return fiber.tag === ClassComponent && fiber.type.contextTypes != null;\n}\n\nfunction isContextProvider(fiber) {\n  return fiber.tag === ClassComponent && fiber.type.childContextTypes != null;\n}\n\nfunction popContextProvider(fiber) {\n  if (!isContextProvider(fiber)) {\n    return;\n  }\n\n  pop(didPerformWorkStackCursor, fiber);\n  pop(contextStackCursor, fiber);\n}\n\nfunction popTopLevelContextObject(fiber) {\n  pop(didPerformWorkStackCursor, fiber);\n  pop(contextStackCursor, fiber);\n}\n\nfunction pushTopLevelContextObject(fiber, context, didChange) {\n  !(contextStackCursor.cursor == null) ? invariant(false, 'Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n  push(contextStackCursor, context, fiber);\n  push(didPerformWorkStackCursor, didChange, fiber);\n}\n\nfunction processChildContext(fiber, parentContext) {\n  var instance = fiber.stateNode;\n  var childContextTypes = fiber.type.childContextTypes;\n\n  // TODO (bvaughn) Replace this behavior with an invariant() in the future.\n  // It has only been added in Fiber to match the (unintentional) behavior in Stack.\n  if (typeof instance.getChildContext !== 'function') {\n    {\n      var componentName = getComponentName(fiber) || 'Unknown';\n\n      if (!warnedAboutMissingGetChildContext[componentName]) {\n        warnedAboutMissingGetChildContext[componentName] = true;\n        warning(false, '%s.childContextTypes is specified but there is no getChildContext() method ' + 'on the instance. You can either define getChildContext() on %s or remove ' + 'childContextTypes from it.', componentName, componentName);\n      }\n    }\n    return parentContext;\n  }\n\n  var childContext = void 0;\n  {\n    ReactDebugCurrentFiber.setCurrentPhase('getChildContext');\n  }\n  startPhaseTimer(fiber, 'getChildContext');\n  childContext = instance.getChildContext();\n  stopPhaseTimer();\n  {\n    ReactDebugCurrentFiber.setCurrentPhase(null);\n  }\n  for (var contextKey in childContext) {\n    !(contextKey in childContextTypes) ? invariant(false, '%s.getChildContext(): key \"%s\" is not defined in childContextTypes.', getComponentName(fiber) || 'Unknown', contextKey) : void 0;\n  }\n  {\n    var name = getComponentName(fiber) || 'Unknown';\n    checkPropTypes(childContextTypes, childContext, 'child context', name,\n    // In practice, there is one case in which we won't get a stack. It's when\n    // somebody calls unstable_renderSubtreeIntoContainer() and we process\n    // context from the parent component instance. The stack will be missing\n    // because it's outside of the reconciliation, and so the pointer has not\n    // been set. This is rare and doesn't matter. We'll also remove that API.\n    ReactDebugCurrentFiber.getCurrentFiberStackAddendum);\n  }\n\n  return _assign({}, parentContext, childContext);\n}\n\nfunction pushContextProvider(workInProgress) {\n  if (!isContextProvider(workInProgress)) {\n    return false;\n  }\n\n  var instance = workInProgress.stateNode;\n  // We push the context as early as possible to ensure stack integrity.\n  // If the instance does not exist yet, we will push null at first,\n  // and replace it on the stack later when invalidating the context.\n  var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyObject;\n\n  // Remember the parent context so we can merge with it later.\n  // Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.\n  previousContext = contextStackCursor.current;\n  push(contextStackCursor, memoizedMergedChildContext, workInProgress);\n  push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);\n\n  return true;\n}\n\nfunction invalidateContextProvider(workInProgress, didChange) {\n  var instance = workInProgress.stateNode;\n  !instance ? invariant(false, 'Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n  if (didChange) {\n    // Merge parent and own context.\n    // Skip this if we're not updating due to sCU.\n    // This avoids unnecessarily recomputing memoized values.\n    var mergedContext = processChildContext(workInProgress, previousContext);\n    instance.__reactInternalMemoizedMergedChildContext = mergedContext;\n\n    // Replace the old (or empty) context with the new one.\n    // It is important to unwind the context in the reverse order.\n    pop(didPerformWorkStackCursor, workInProgress);\n    pop(contextStackCursor, workInProgress);\n    // Now push the new context and mark that it has changed.\n    push(contextStackCursor, mergedContext, workInProgress);\n    push(didPerformWorkStackCursor, didChange, workInProgress);\n  } else {\n    pop(didPerformWorkStackCursor, workInProgress);\n    push(didPerformWorkStackCursor, didChange, workInProgress);\n  }\n}\n\nfunction resetContext() {\n  previousContext = emptyObject;\n  contextStackCursor.current = emptyObject;\n  didPerformWorkStackCursor.current = false;\n}\n\nfunction findCurrentUnmaskedContext(fiber) {\n  // Currently this is only used with renderSubtreeIntoContainer; not sure if it\n  // makes sense elsewhere\n  !(isFiberMounted(fiber) && fiber.tag === ClassComponent) ? invariant(false, 'Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n  var node = fiber;\n  while (node.tag !== HostRoot) {\n    if (isContextProvider(node)) {\n      return node.stateNode.__reactInternalMemoizedMergedChildContext;\n    }\n    var parent = node['return'];\n    !parent ? invariant(false, 'Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    node = parent;\n  }\n  return node.stateNode.context;\n}\n\nvar NoWork = 0; // TODO: Use an opaque type once ESLint et al support the syntax\n\nvar Sync = 1;\nvar Never = 2147483647; // Max int32: Math.pow(2, 31) - 1\n\nvar UNIT_SIZE = 10;\nvar MAGIC_NUMBER_OFFSET = 2;\n\n// 1 unit of expiration time represents 10ms.\nfunction msToExpirationTime(ms) {\n  // Always add an offset so that we don't clash with the magic number for NoWork.\n  return (ms / UNIT_SIZE | 0) + MAGIC_NUMBER_OFFSET;\n}\n\nfunction expirationTimeToMs(expirationTime) {\n  return (expirationTime - MAGIC_NUMBER_OFFSET) * UNIT_SIZE;\n}\n\nfunction ceiling(num, precision) {\n  return ((num / precision | 0) + 1) * precision;\n}\n\nfunction computeExpirationBucket(currentTime, expirationInMs, bucketSizeMs) {\n  return ceiling(currentTime + expirationInMs / UNIT_SIZE, bucketSizeMs / UNIT_SIZE);\n}\n\nvar NoContext = 0;\nvar AsyncUpdates = 1;\n\n{\n  var hasBadMapPolyfill = false;\n  try {\n    var nonExtensibleObject = Object.preventExtensions({});\n    /* eslint-disable no-new */\n    \n    /* eslint-enable no-new */\n  } catch (e) {\n    // TODO: Consider warning about bad polyfills\n    hasBadMapPolyfill = true;\n  }\n}\n\n// A Fiber is work on a Component that needs to be done or was done. There can\n// be more than one per component.\n\n\n{\n  var debugCounter = 1;\n}\n\nfunction FiberNode(tag, key, internalContextTag) {\n  // Instance\n  this.tag = tag;\n  this.key = key;\n  this.type = null;\n  this.stateNode = null;\n\n  // Fiber\n  this['return'] = null;\n  this.child = null;\n  this.sibling = null;\n  this.index = 0;\n\n  this.ref = null;\n\n  this.pendingProps = null;\n  this.memoizedProps = null;\n  this.updateQueue = null;\n  this.memoizedState = null;\n\n  this.internalContextTag = internalContextTag;\n\n  // Effects\n  this.effectTag = NoEffect;\n  this.nextEffect = null;\n\n  this.firstEffect = null;\n  this.lastEffect = null;\n\n  this.expirationTime = NoWork;\n\n  this.alternate = null;\n\n  {\n    this._debugID = debugCounter++;\n    this._debugSource = null;\n    this._debugOwner = null;\n    this._debugIsCurrentlyTiming = false;\n    if (!hasBadMapPolyfill && typeof Object.preventExtensions === 'function') {\n      Object.preventExtensions(this);\n    }\n  }\n}\n\n// This is a constructor function, rather than a POJO constructor, still\n// please ensure we do the following:\n// 1) Nobody should add any instance methods on this. Instance methods can be\n//    more difficult to predict when they get optimized and they are almost\n//    never inlined properly in static compilers.\n// 2) Nobody should rely on `instanceof Fiber` for type testing. We should\n//    always know when it is a fiber.\n// 3) We might want to experiment with using numeric keys since they are easier\n//    to optimize in a non-JIT environment.\n// 4) We can easily go from a constructor to a createFiber object literal if that\n//    is faster.\n// 5) It should be easy to port this to a C struct and keep a C implementation\n//    compatible.\nvar createFiber = function (tag, key, internalContextTag) {\n  // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors\n  return new FiberNode(tag, key, internalContextTag);\n};\n\nfunction shouldConstruct(Component) {\n  return !!(Component.prototype && Component.prototype.isReactComponent);\n}\n\n// This is used to create an alternate fiber to do work on.\nfunction createWorkInProgress(current, pendingProps, expirationTime) {\n  var workInProgress = current.alternate;\n  if (workInProgress === null) {\n    // We use a double buffering pooling technique because we know that we'll\n    // only ever need at most two versions of a tree. We pool the \"other\" unused\n    // node that we're free to reuse. This is lazily created to avoid allocating\n    // extra objects for things that are never updated. It also allow us to\n    // reclaim the extra memory if needed.\n    workInProgress = createFiber(current.tag, current.key, current.internalContextTag);\n    workInProgress.type = current.type;\n    workInProgress.stateNode = current.stateNode;\n\n    {\n      // DEV-only fields\n      workInProgress._debugID = current._debugID;\n      workInProgress._debugSource = current._debugSource;\n      workInProgress._debugOwner = current._debugOwner;\n    }\n\n    workInProgress.alternate = current;\n    current.alternate = workInProgress;\n  } else {\n    // We already have an alternate.\n    // Reset the effect tag.\n    workInProgress.effectTag = NoEffect;\n\n    // The effect list is no longer valid.\n    workInProgress.nextEffect = null;\n    workInProgress.firstEffect = null;\n    workInProgress.lastEffect = null;\n  }\n\n  workInProgress.expirationTime = expirationTime;\n  workInProgress.pendingProps = pendingProps;\n\n  workInProgress.child = current.child;\n  workInProgress.memoizedProps = current.memoizedProps;\n  workInProgress.memoizedState = current.memoizedState;\n  workInProgress.updateQueue = current.updateQueue;\n\n  // These will be overridden during the parent's reconciliation\n  workInProgress.sibling = current.sibling;\n  workInProgress.index = current.index;\n  workInProgress.ref = current.ref;\n\n  return workInProgress;\n}\n\nfunction createHostRootFiber() {\n  var fiber = createFiber(HostRoot, null, NoContext);\n  return fiber;\n}\n\nfunction createFiberFromElement(element, internalContextTag, expirationTime) {\n  var owner = null;\n  {\n    owner = element._owner;\n  }\n\n  var fiber = void 0;\n  var type = element.type,\n      key = element.key;\n\n  if (typeof type === 'function') {\n    fiber = shouldConstruct(type) ? createFiber(ClassComponent, key, internalContextTag) : createFiber(IndeterminateComponent, key, internalContextTag);\n    fiber.type = type;\n    fiber.pendingProps = element.props;\n  } else if (typeof type === 'string') {\n    fiber = createFiber(HostComponent, key, internalContextTag);\n    fiber.type = type;\n    fiber.pendingProps = element.props;\n  } else if (typeof type === 'object' && type !== null && typeof type.tag === 'number') {\n    // Currently assumed to be a continuation and therefore is a fiber already.\n    // TODO: The yield system is currently broken for updates in some cases.\n    // The reified yield stores a fiber, but we don't know which fiber that is;\n    // the current or a workInProgress? When the continuation gets rendered here\n    // we don't know if we can reuse that fiber or if we need to clone it.\n    // There is probably a clever way to restructure this.\n    fiber = type;\n    fiber.pendingProps = element.props;\n  } else {\n    var info = '';\n    {\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n      var ownerName = owner ? getComponentName(owner) : null;\n      if (ownerName) {\n        info += '\\n\\nCheck the render method of `' + ownerName + '`.';\n      }\n    }\n    invariant(false, 'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s', type == null ? type : typeof type, info);\n  }\n\n  {\n    fiber._debugSource = element._source;\n    fiber._debugOwner = element._owner;\n  }\n\n  fiber.expirationTime = expirationTime;\n\n  return fiber;\n}\n\nfunction createFiberFromFragment(elements, internalContextTag, expirationTime, key) {\n  var fiber = createFiber(Fragment, key, internalContextTag);\n  fiber.pendingProps = elements;\n  fiber.expirationTime = expirationTime;\n  return fiber;\n}\n\nfunction createFiberFromText(content, internalContextTag, expirationTime) {\n  var fiber = createFiber(HostText, null, internalContextTag);\n  fiber.pendingProps = content;\n  fiber.expirationTime = expirationTime;\n  return fiber;\n}\n\nfunction createFiberFromHostInstanceForDeletion() {\n  var fiber = createFiber(HostComponent, null, NoContext);\n  fiber.type = 'DELETED';\n  return fiber;\n}\n\nfunction createFiberFromCall(call, internalContextTag, expirationTime) {\n  var fiber = createFiber(CallComponent, call.key, internalContextTag);\n  fiber.type = call.handler;\n  fiber.pendingProps = call;\n  fiber.expirationTime = expirationTime;\n  return fiber;\n}\n\nfunction createFiberFromReturn(returnNode, internalContextTag, expirationTime) {\n  var fiber = createFiber(ReturnComponent, null, internalContextTag);\n  fiber.expirationTime = expirationTime;\n  return fiber;\n}\n\nfunction createFiberFromPortal(portal, internalContextTag, expirationTime) {\n  var fiber = createFiber(HostPortal, portal.key, internalContextTag);\n  fiber.pendingProps = portal.children || [];\n  fiber.expirationTime = expirationTime;\n  fiber.stateNode = {\n    containerInfo: portal.containerInfo,\n    pendingChildren: null, // Used by persistent updates\n    implementation: portal.implementation\n  };\n  return fiber;\n}\n\nfunction createFiberRoot(containerInfo, hydrate) {\n  // Cyclic construction. This cheats the type system right now because\n  // stateNode is any.\n  var uninitializedFiber = createHostRootFiber();\n  var root = {\n    current: uninitializedFiber,\n    containerInfo: containerInfo,\n    pendingChildren: null,\n    remainingExpirationTime: NoWork,\n    isReadyForCommit: false,\n    finishedWork: null,\n    context: null,\n    pendingContext: null,\n    hydrate: hydrate,\n    nextScheduledRoot: null\n  };\n  uninitializedFiber.stateNode = root;\n  return root;\n}\n\nvar onCommitFiberRoot = null;\nvar onCommitFiberUnmount = null;\nvar hasLoggedError = false;\n\nfunction catchErrors(fn) {\n  return function (arg) {\n    try {\n      return fn(arg);\n    } catch (err) {\n      if (true && !hasLoggedError) {\n        hasLoggedError = true;\n        warning(false, 'React DevTools encountered an error: %s', err);\n      }\n    }\n  };\n}\n\nfunction injectInternals(internals) {\n  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {\n    // No DevTools\n    return false;\n  }\n  var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;\n  if (hook.isDisabled) {\n    // This isn't a real property on the hook, but it can be set to opt out\n    // of DevTools integration and associated warnings and logs.\n    // https://github.com/facebook/react/issues/3877\n    return true;\n  }\n  if (!hook.supportsFiber) {\n    {\n      warning(false, 'The installed version of React DevTools is too old and will not work ' + 'with the current version of React. Please update React DevTools. ' + 'https://fb.me/react-devtools');\n    }\n    // DevTools exists, even though it doesn't support Fiber.\n    return true;\n  }\n  try {\n    var rendererID = hook.inject(internals);\n    // We have successfully injected, so now it is safe to set up hooks.\n    onCommitFiberRoot = catchErrors(function (root) {\n      return hook.onCommitFiberRoot(rendererID, root);\n    });\n    onCommitFiberUnmount = catchErrors(function (fiber) {\n      return hook.onCommitFiberUnmount(rendererID, fiber);\n    });\n  } catch (err) {\n    // Catch all errors because it is unsafe to throw during initialization.\n    {\n      warning(false, 'React DevTools encountered an error: %s.', err);\n    }\n  }\n  // DevTools exists\n  return true;\n}\n\nfunction onCommitRoot(root) {\n  if (typeof onCommitFiberRoot === 'function') {\n    onCommitFiberRoot(root);\n  }\n}\n\nfunction onCommitUnmount(fiber) {\n  if (typeof onCommitFiberUnmount === 'function') {\n    onCommitFiberUnmount(fiber);\n  }\n}\n\n{\n  var didWarnUpdateInsideUpdate = false;\n}\n\n// Callbacks are not validated until invocation\n\n\n// Singly linked-list of updates. When an update is scheduled, it is added to\n// the queue of the current fiber and the work-in-progress fiber. The two queues\n// are separate but they share a persistent structure.\n//\n// During reconciliation, updates are removed from the work-in-progress fiber,\n// but they remain on the current fiber. That ensures that if a work-in-progress\n// is aborted, the aborted updates are recovered by cloning from current.\n//\n// The work-in-progress queue is always a subset of the current queue.\n//\n// When the tree is committed, the work-in-progress becomes the current.\n\n\nfunction createUpdateQueue(baseState) {\n  var queue = {\n    baseState: baseState,\n    expirationTime: NoWork,\n    first: null,\n    last: null,\n    callbackList: null,\n    hasForceUpdate: false,\n    isInitialized: false\n  };\n  {\n    queue.isProcessing = false;\n  }\n  return queue;\n}\n\nfunction insertUpdateIntoQueue(queue, update) {\n  // Append the update to the end of the list.\n  if (queue.last === null) {\n    // Queue is empty\n    queue.first = queue.last = update;\n  } else {\n    queue.last.next = update;\n    queue.last = update;\n  }\n  if (queue.expirationTime === NoWork || queue.expirationTime > update.expirationTime) {\n    queue.expirationTime = update.expirationTime;\n  }\n}\n\nfunction insertUpdateIntoFiber(fiber, update) {\n  // We'll have at least one and at most two distinct update queues.\n  var alternateFiber = fiber.alternate;\n  var queue1 = fiber.updateQueue;\n  if (queue1 === null) {\n    // TODO: We don't know what the base state will be until we begin work.\n    // It depends on which fiber is the next current. Initialize with an empty\n    // base state, then set to the memoizedState when rendering. Not super\n    // happy with this approach.\n    queue1 = fiber.updateQueue = createUpdateQueue(null);\n  }\n\n  var queue2 = void 0;\n  if (alternateFiber !== null) {\n    queue2 = alternateFiber.updateQueue;\n    if (queue2 === null) {\n      queue2 = alternateFiber.updateQueue = createUpdateQueue(null);\n    }\n  } else {\n    queue2 = null;\n  }\n  queue2 = queue2 !== queue1 ? queue2 : null;\n\n  // Warn if an update is scheduled from inside an updater function.\n  {\n    if ((queue1.isProcessing || queue2 !== null && queue2.isProcessing) && !didWarnUpdateInsideUpdate) {\n      warning(false, 'An update (setState, replaceState, or forceUpdate) was scheduled ' + 'from inside an update function. Update functions should be pure, ' + 'with zero side-effects. Consider using componentDidUpdate or a ' + 'callback.');\n      didWarnUpdateInsideUpdate = true;\n    }\n  }\n\n  // If there's only one queue, add the update to that queue and exit.\n  if (queue2 === null) {\n    insertUpdateIntoQueue(queue1, update);\n    return;\n  }\n\n  // If either queue is empty, we need to add to both queues.\n  if (queue1.last === null || queue2.last === null) {\n    insertUpdateIntoQueue(queue1, update);\n    insertUpdateIntoQueue(queue2, update);\n    return;\n  }\n\n  // If both lists are not empty, the last update is the same for both lists\n  // because of structural sharing. So, we should only append to one of\n  // the lists.\n  insertUpdateIntoQueue(queue1, update);\n  // But we still need to update the `last` pointer of queue2.\n  queue2.last = update;\n}\n\nfunction getUpdateExpirationTime(fiber) {\n  if (fiber.tag !== ClassComponent && fiber.tag !== HostRoot) {\n    return NoWork;\n  }\n  var updateQueue = fiber.updateQueue;\n  if (updateQueue === null) {\n    return NoWork;\n  }\n  return updateQueue.expirationTime;\n}\n\nfunction getStateFromUpdate(update, instance, prevState, props) {\n  var partialState = update.partialState;\n  if (typeof partialState === 'function') {\n    var updateFn = partialState;\n\n    // Invoke setState callback an extra time to help detect side-effects.\n    if (debugRenderPhaseSideEffects) {\n      updateFn.call(instance, prevState, props);\n    }\n\n    return updateFn.call(instance, prevState, props);\n  } else {\n    return partialState;\n  }\n}\n\nfunction processUpdateQueue(current, workInProgress, queue, instance, props, renderExpirationTime) {\n  if (current !== null && current.updateQueue === queue) {\n    // We need to create a work-in-progress queue, by cloning the current queue.\n    var currentQueue = queue;\n    queue = workInProgress.updateQueue = {\n      baseState: currentQueue.baseState,\n      expirationTime: currentQueue.expirationTime,\n      first: currentQueue.first,\n      last: currentQueue.last,\n      isInitialized: currentQueue.isInitialized,\n      // These fields are no longer valid because they were already committed.\n      // Reset them.\n      callbackList: null,\n      hasForceUpdate: false\n    };\n  }\n\n  {\n    // Set this flag so we can warn if setState is called inside the update\n    // function of another setState.\n    queue.isProcessing = true;\n  }\n\n  // Reset the remaining expiration time. If we skip over any updates, we'll\n  // increase this accordingly.\n  queue.expirationTime = NoWork;\n\n  // TODO: We don't know what the base state will be until we begin work.\n  // It depends on which fiber is the next current. Initialize with an empty\n  // base state, then set to the memoizedState when rendering. Not super\n  // happy with this approach.\n  var state = void 0;\n  if (queue.isInitialized) {\n    state = queue.baseState;\n  } else {\n    state = queue.baseState = workInProgress.memoizedState;\n    queue.isInitialized = true;\n  }\n  var dontMutatePrevState = true;\n  var update = queue.first;\n  var didSkip = false;\n  while (update !== null) {\n    var updateExpirationTime = update.expirationTime;\n    if (updateExpirationTime > renderExpirationTime) {\n      // This update does not have sufficient priority. Skip it.\n      var remainingExpirationTime = queue.expirationTime;\n      if (remainingExpirationTime === NoWork || remainingExpirationTime > updateExpirationTime) {\n        // Update the remaining expiration time.\n        queue.expirationTime = updateExpirationTime;\n      }\n      if (!didSkip) {\n        didSkip = true;\n        queue.baseState = state;\n      }\n      // Continue to the next update.\n      update = update.next;\n      continue;\n    }\n\n    // This update does have sufficient priority.\n\n    // If no previous updates were skipped, drop this update from the queue by\n    // advancing the head of the list.\n    if (!didSkip) {\n      queue.first = update.next;\n      if (queue.first === null) {\n        queue.last = null;\n      }\n    }\n\n    // Process the update\n    var _partialState = void 0;\n    if (update.isReplace) {\n      state = getStateFromUpdate(update, instance, state, props);\n      dontMutatePrevState = true;\n    } else {\n      _partialState = getStateFromUpdate(update, instance, state, props);\n      if (_partialState) {\n        if (dontMutatePrevState) {\n          // $FlowFixMe: Idk how to type this properly.\n          state = _assign({}, state, _partialState);\n        } else {\n          state = _assign(state, _partialState);\n        }\n        dontMutatePrevState = false;\n      }\n    }\n    if (update.isForced) {\n      queue.hasForceUpdate = true;\n    }\n    if (update.callback !== null) {\n      // Append to list of callbacks.\n      var _callbackList = queue.callbackList;\n      if (_callbackList === null) {\n        _callbackList = queue.callbackList = [];\n      }\n      _callbackList.push(update);\n    }\n    update = update.next;\n  }\n\n  if (queue.callbackList !== null) {\n    workInProgress.effectTag |= Callback;\n  } else if (queue.first === null && !queue.hasForceUpdate) {\n    // The queue is empty. We can reset it.\n    workInProgress.updateQueue = null;\n  }\n\n  if (!didSkip) {\n    didSkip = true;\n    queue.baseState = state;\n  }\n\n  {\n    // No longer processing.\n    queue.isProcessing = false;\n  }\n\n  return state;\n}\n\nfunction commitCallbacks(queue, context) {\n  var callbackList = queue.callbackList;\n  if (callbackList === null) {\n    return;\n  }\n  // Set the list to null to make sure they don't get called more than once.\n  queue.callbackList = null;\n  for (var i = 0; i < callbackList.length; i++) {\n    var update = callbackList[i];\n    var _callback = update.callback;\n    // This update might be processed again. Clear the callback so it's only\n    // called once.\n    update.callback = null;\n    !(typeof _callback === 'function') ? invariant(false, 'Invalid argument passed as callback. Expected a function. Instead received: %s', _callback) : void 0;\n    _callback.call(context);\n  }\n}\n\nvar fakeInternalInstance = {};\nvar isArray = Array.isArray;\n\n{\n  var didWarnAboutStateAssignmentForComponent = {};\n\n  var warnOnInvalidCallback = function (callback, callerName) {\n    warning(callback === null || typeof callback === 'function', '%s(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callerName, callback);\n  };\n\n  // This is so gross but it's at least non-critical and can be removed if\n  // it causes problems. This is meant to give a nicer error message for\n  // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,\n  // ...)) which otherwise throws a \"_processChildContext is not a function\"\n  // exception.\n  Object.defineProperty(fakeInternalInstance, '_processChildContext', {\n    enumerable: false,\n    value: function () {\n      invariant(false, '_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn\\'t supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).');\n    }\n  });\n  Object.freeze(fakeInternalInstance);\n}\n\nvar ReactFiberClassComponent = function (scheduleWork, computeExpirationForFiber, memoizeProps, memoizeState) {\n  // Class component state updater\n  var updater = {\n    isMounted: isMounted,\n    enqueueSetState: function (instance, partialState, callback) {\n      var fiber = get(instance);\n      callback = callback === undefined ? null : callback;\n      {\n        warnOnInvalidCallback(callback, 'setState');\n      }\n      var expirationTime = computeExpirationForFiber(fiber);\n      var update = {\n        expirationTime: expirationTime,\n        partialState: partialState,\n        callback: callback,\n        isReplace: false,\n        isForced: false,\n        nextCallback: null,\n        next: null\n      };\n      insertUpdateIntoFiber(fiber, update);\n      scheduleWork(fiber, expirationTime);\n    },\n    enqueueReplaceState: function (instance, state, callback) {\n      var fiber = get(instance);\n      callback = callback === undefined ? null : callback;\n      {\n        warnOnInvalidCallback(callback, 'replaceState');\n      }\n      var expirationTime = computeExpirationForFiber(fiber);\n      var update = {\n        expirationTime: expirationTime,\n        partialState: state,\n        callback: callback,\n        isReplace: true,\n        isForced: false,\n        nextCallback: null,\n        next: null\n      };\n      insertUpdateIntoFiber(fiber, update);\n      scheduleWork(fiber, expirationTime);\n    },\n    enqueueForceUpdate: function (instance, callback) {\n      var fiber = get(instance);\n      callback = callback === undefined ? null : callback;\n      {\n        warnOnInvalidCallback(callback, 'forceUpdate');\n      }\n      var expirationTime = computeExpirationForFiber(fiber);\n      var update = {\n        expirationTime: expirationTime,\n        partialState: null,\n        callback: callback,\n        isReplace: false,\n        isForced: true,\n        nextCallback: null,\n        next: null\n      };\n      insertUpdateIntoFiber(fiber, update);\n      scheduleWork(fiber, expirationTime);\n    }\n  };\n\n  function checkShouldComponentUpdate(workInProgress, oldProps, newProps, oldState, newState, newContext) {\n    if (oldProps === null || workInProgress.updateQueue !== null && workInProgress.updateQueue.hasForceUpdate) {\n      // If the workInProgress already has an Update effect, return true\n      return true;\n    }\n\n    var instance = workInProgress.stateNode;\n    var type = workInProgress.type;\n    if (typeof instance.shouldComponentUpdate === 'function') {\n      startPhaseTimer(workInProgress, 'shouldComponentUpdate');\n      var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, newContext);\n      stopPhaseTimer();\n\n      // Simulate an async bailout/interruption by invoking lifecycle twice.\n      if (debugRenderPhaseSideEffects) {\n        instance.shouldComponentUpdate(newProps, newState, newContext);\n      }\n\n      {\n        warning(shouldUpdate !== undefined, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', getComponentName(workInProgress) || 'Unknown');\n      }\n\n      return shouldUpdate;\n    }\n\n    if (type.prototype && type.prototype.isPureReactComponent) {\n      return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);\n    }\n\n    return true;\n  }\n\n  function checkClassInstance(workInProgress) {\n    var instance = workInProgress.stateNode;\n    var type = workInProgress.type;\n    {\n      var name = getComponentName(workInProgress);\n      var renderPresent = instance.render;\n\n      if (!renderPresent) {\n        if (type.prototype && typeof type.prototype.render === 'function') {\n          warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: did you accidentally return an object from the constructor?', name);\n        } else {\n          warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', name);\n        }\n      }\n\n      var noGetInitialStateOnES6 = !instance.getInitialState || instance.getInitialState.isReactClassApproved || instance.state;\n      warning(noGetInitialStateOnES6, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', name);\n      var noGetDefaultPropsOnES6 = !instance.getDefaultProps || instance.getDefaultProps.isReactClassApproved;\n      warning(noGetDefaultPropsOnES6, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', name);\n      var noInstancePropTypes = !instance.propTypes;\n      warning(noInstancePropTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', name);\n      var noInstanceContextTypes = !instance.contextTypes;\n      warning(noInstanceContextTypes, 'contextTypes was defined as an instance property on %s. Use a static ' + 'property to define contextTypes instead.', name);\n      var noComponentShouldUpdate = typeof instance.componentShouldUpdate !== 'function';\n      warning(noComponentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', name);\n      if (type.prototype && type.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== 'undefined') {\n        warning(false, '%s has a method called shouldComponentUpdate(). ' + 'shouldComponentUpdate should not be used when extending React.PureComponent. ' + 'Please extend React.Component if shouldComponentUpdate is used.', getComponentName(workInProgress) || 'A pure component');\n      }\n      var noComponentDidUnmount = typeof instance.componentDidUnmount !== 'function';\n      warning(noComponentDidUnmount, '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', name);\n      var noComponentDidReceiveProps = typeof instance.componentDidReceiveProps !== 'function';\n      warning(noComponentDidReceiveProps, '%s has a method called ' + 'componentDidReceiveProps(). But there is no such lifecycle method. ' + 'If you meant to update the state in response to changing props, ' + 'use componentWillReceiveProps(). If you meant to fetch data or ' + 'run side-effects or mutations after React has updated the UI, use componentDidUpdate().', name);\n      var noComponentWillRecieveProps = typeof instance.componentWillRecieveProps !== 'function';\n      warning(noComponentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', name);\n      var hasMutatedProps = instance.props !== workInProgress.pendingProps;\n      warning(instance.props === undefined || !hasMutatedProps, '%s(...): When calling super() in `%s`, make sure to pass ' + \"up the same props that your component's constructor was passed.\", name, name);\n      var noInstanceDefaultProps = !instance.defaultProps;\n      warning(noInstanceDefaultProps, 'Setting defaultProps as an instance property on %s is not supported and will be ignored.' + ' Instead, define defaultProps as a static property on %s.', name, name);\n    }\n\n    var state = instance.state;\n    if (state && (typeof state !== 'object' || isArray(state))) {\n      warning(false, '%s.state: must be set to an object or null', getComponentName(workInProgress));\n    }\n    if (typeof instance.getChildContext === 'function') {\n      warning(typeof workInProgress.type.childContextTypes === 'object', '%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', getComponentName(workInProgress));\n    }\n  }\n\n  function resetInputPointers(workInProgress, instance) {\n    instance.props = workInProgress.memoizedProps;\n    instance.state = workInProgress.memoizedState;\n  }\n\n  function adoptClassInstance(workInProgress, instance) {\n    instance.updater = updater;\n    workInProgress.stateNode = instance;\n    // The instance needs access to the fiber so that it can schedule updates\n    set(instance, workInProgress);\n    {\n      instance._reactInternalInstance = fakeInternalInstance;\n    }\n  }\n\n  function constructClassInstance(workInProgress, props) {\n    var ctor = workInProgress.type;\n    var unmaskedContext = getUnmaskedContext(workInProgress);\n    var needsContext = isContextConsumer(workInProgress);\n    var context = needsContext ? getMaskedContext(workInProgress, unmaskedContext) : emptyObject;\n    var instance = new ctor(props, context);\n    adoptClassInstance(workInProgress, instance);\n\n    // Cache unmasked context so we can avoid recreating masked context unless necessary.\n    // ReactFiberContext usually updates this cache but can't for newly-created instances.\n    if (needsContext) {\n      cacheContext(workInProgress, unmaskedContext, context);\n    }\n\n    return instance;\n  }\n\n  function callComponentWillMount(workInProgress, instance) {\n    startPhaseTimer(workInProgress, 'componentWillMount');\n    var oldState = instance.state;\n    instance.componentWillMount();\n    stopPhaseTimer();\n\n    // Simulate an async bailout/interruption by invoking lifecycle twice.\n    if (debugRenderPhaseSideEffects) {\n      instance.componentWillMount();\n    }\n\n    if (oldState !== instance.state) {\n      {\n        warning(false, '%s.componentWillMount(): Assigning directly to this.state is ' + \"deprecated (except inside a component's \" + 'constructor). Use setState instead.', getComponentName(workInProgress));\n      }\n      updater.enqueueReplaceState(instance, instance.state, null);\n    }\n  }\n\n  function callComponentWillReceiveProps(workInProgress, instance, newProps, newContext) {\n    startPhaseTimer(workInProgress, 'componentWillReceiveProps');\n    var oldState = instance.state;\n    instance.componentWillReceiveProps(newProps, newContext);\n    stopPhaseTimer();\n\n    // Simulate an async bailout/interruption by invoking lifecycle twice.\n    if (debugRenderPhaseSideEffects) {\n      instance.componentWillReceiveProps(newProps, newContext);\n    }\n\n    if (instance.state !== oldState) {\n      {\n        var componentName = getComponentName(workInProgress) || 'Component';\n        if (!didWarnAboutStateAssignmentForComponent[componentName]) {\n          warning(false, '%s.componentWillReceiveProps(): Assigning directly to ' + \"this.state is deprecated (except inside a component's \" + 'constructor). Use setState instead.', componentName);\n          didWarnAboutStateAssignmentForComponent[componentName] = true;\n        }\n      }\n      updater.enqueueReplaceState(instance, instance.state, null);\n    }\n  }\n\n  // Invokes the mount life-cycles on a previously never rendered instance.\n  function mountClassInstance(workInProgress, renderExpirationTime) {\n    var current = workInProgress.alternate;\n\n    {\n      checkClassInstance(workInProgress);\n    }\n\n    var instance = workInProgress.stateNode;\n    var state = instance.state || null;\n\n    var props = workInProgress.pendingProps;\n    !props ? invariant(false, 'There must be pending props for an initial mount. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n    var unmaskedContext = getUnmaskedContext(workInProgress);\n\n    instance.props = props;\n    instance.state = workInProgress.memoizedState = state;\n    instance.refs = emptyObject;\n    instance.context = getMaskedContext(workInProgress, unmaskedContext);\n\n    if (enableAsyncSubtreeAPI && workInProgress.type != null && workInProgress.type.prototype != null && workInProgress.type.prototype.unstable_isAsyncReactComponent === true) {\n      workInProgress.internalContextTag |= AsyncUpdates;\n    }\n\n    if (typeof instance.componentWillMount === 'function') {\n      callComponentWillMount(workInProgress, instance);\n      // If we had additional state updates during this life-cycle, let's\n      // process them now.\n      var updateQueue = workInProgress.updateQueue;\n      if (updateQueue !== null) {\n        instance.state = processUpdateQueue(current, workInProgress, updateQueue, instance, props, renderExpirationTime);\n      }\n    }\n    if (typeof instance.componentDidMount === 'function') {\n      workInProgress.effectTag |= Update;\n    }\n  }\n\n  // Called on a preexisting class instance. Returns false if a resumed render\n  // could be reused.\n  // function resumeMountClassInstance(\n  //   workInProgress: Fiber,\n  //   priorityLevel: PriorityLevel,\n  // ): boolean {\n  //   const instance = workInProgress.stateNode;\n  //   resetInputPointers(workInProgress, instance);\n\n  //   let newState = workInProgress.memoizedState;\n  //   let newProps = workInProgress.pendingProps;\n  //   if (!newProps) {\n  //     // If there isn't any new props, then we'll reuse the memoized props.\n  //     // This could be from already completed work.\n  //     newProps = workInProgress.memoizedProps;\n  //     invariant(\n  //       newProps != null,\n  //       'There should always be pending or memoized props. This error is ' +\n  //         'likely caused by a bug in React. Please file an issue.',\n  //     );\n  //   }\n  //   const newUnmaskedContext = getUnmaskedContext(workInProgress);\n  //   const newContext = getMaskedContext(workInProgress, newUnmaskedContext);\n\n  //   const oldContext = instance.context;\n  //   const oldProps = workInProgress.memoizedProps;\n\n  //   if (\n  //     typeof instance.componentWillReceiveProps === 'function' &&\n  //     (oldProps !== newProps || oldContext !== newContext)\n  //   ) {\n  //     callComponentWillReceiveProps(\n  //       workInProgress,\n  //       instance,\n  //       newProps,\n  //       newContext,\n  //     );\n  //   }\n\n  //   // Process the update queue before calling shouldComponentUpdate\n  //   const updateQueue = workInProgress.updateQueue;\n  //   if (updateQueue !== null) {\n  //     newState = processUpdateQueue(\n  //       workInProgress,\n  //       updateQueue,\n  //       instance,\n  //       newState,\n  //       newProps,\n  //       priorityLevel,\n  //     );\n  //   }\n\n  //   // TODO: Should we deal with a setState that happened after the last\n  //   // componentWillMount and before this componentWillMount? Probably\n  //   // unsupported anyway.\n\n  //   if (\n  //     !checkShouldComponentUpdate(\n  //       workInProgress,\n  //       workInProgress.memoizedProps,\n  //       newProps,\n  //       workInProgress.memoizedState,\n  //       newState,\n  //       newContext,\n  //     )\n  //   ) {\n  //     // Update the existing instance's state, props, and context pointers even\n  //     // though we're bailing out.\n  //     instance.props = newProps;\n  //     instance.state = newState;\n  //     instance.context = newContext;\n  //     return false;\n  //   }\n\n  //   // Update the input pointers now so that they are correct when we call\n  //   // componentWillMount\n  //   instance.props = newProps;\n  //   instance.state = newState;\n  //   instance.context = newContext;\n\n  //   if (typeof instance.componentWillMount === 'function') {\n  //     callComponentWillMount(workInProgress, instance);\n  //     // componentWillMount may have called setState. Process the update queue.\n  //     const newUpdateQueue = workInProgress.updateQueue;\n  //     if (newUpdateQueue !== null) {\n  //       newState = processUpdateQueue(\n  //         workInProgress,\n  //         newUpdateQueue,\n  //         instance,\n  //         newState,\n  //         newProps,\n  //         priorityLevel,\n  //       );\n  //     }\n  //   }\n\n  //   if (typeof instance.componentDidMount === 'function') {\n  //     workInProgress.effectTag |= Update;\n  //   }\n\n  //   instance.state = newState;\n\n  //   return true;\n  // }\n\n  // Invokes the update life-cycles and returns false if it shouldn't rerender.\n  function updateClassInstance(current, workInProgress, renderExpirationTime) {\n    var instance = workInProgress.stateNode;\n    resetInputPointers(workInProgress, instance);\n\n    var oldProps = workInProgress.memoizedProps;\n    var newProps = workInProgress.pendingProps;\n    if (!newProps) {\n      // If there aren't any new props, then we'll reuse the memoized props.\n      // This could be from already completed work.\n      newProps = oldProps;\n      !(newProps != null) ? invariant(false, 'There should always be pending or memoized props. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    }\n    var oldContext = instance.context;\n    var newUnmaskedContext = getUnmaskedContext(workInProgress);\n    var newContext = getMaskedContext(workInProgress, newUnmaskedContext);\n\n    // Note: During these life-cycles, instance.props/instance.state are what\n    // ever the previously attempted to render - not the \"current\". However,\n    // during componentDidUpdate we pass the \"current\" props.\n\n    if (typeof instance.componentWillReceiveProps === 'function' && (oldProps !== newProps || oldContext !== newContext)) {\n      callComponentWillReceiveProps(workInProgress, instance, newProps, newContext);\n    }\n\n    // Compute the next state using the memoized state and the update queue.\n    var oldState = workInProgress.memoizedState;\n    // TODO: Previous state can be null.\n    var newState = void 0;\n    if (workInProgress.updateQueue !== null) {\n      newState = processUpdateQueue(current, workInProgress, workInProgress.updateQueue, instance, newProps, renderExpirationTime);\n    } else {\n      newState = oldState;\n    }\n\n    if (oldProps === newProps && oldState === newState && !hasContextChanged() && !(workInProgress.updateQueue !== null && workInProgress.updateQueue.hasForceUpdate)) {\n      // If an update was already in progress, we should schedule an Update\n      // effect even though we're bailing out, so that cWU/cDU are called.\n      if (typeof instance.componentDidUpdate === 'function') {\n        if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n          workInProgress.effectTag |= Update;\n        }\n      }\n      return false;\n    }\n\n    var shouldUpdate = checkShouldComponentUpdate(workInProgress, oldProps, newProps, oldState, newState, newContext);\n\n    if (shouldUpdate) {\n      if (typeof instance.componentWillUpdate === 'function') {\n        startPhaseTimer(workInProgress, 'componentWillUpdate');\n        instance.componentWillUpdate(newProps, newState, newContext);\n        stopPhaseTimer();\n\n        // Simulate an async bailout/interruption by invoking lifecycle twice.\n        if (debugRenderPhaseSideEffects) {\n          instance.componentWillUpdate(newProps, newState, newContext);\n        }\n      }\n      if (typeof instance.componentDidUpdate === 'function') {\n        workInProgress.effectTag |= Update;\n      }\n    } else {\n      // If an update was already in progress, we should schedule an Update\n      // effect even though we're bailing out, so that cWU/cDU are called.\n      if (typeof instance.componentDidUpdate === 'function') {\n        if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n          workInProgress.effectTag |= Update;\n        }\n      }\n\n      // If shouldComponentUpdate returned false, we should still update the\n      // memoized props/state to indicate that this work can be reused.\n      memoizeProps(workInProgress, newProps);\n      memoizeState(workInProgress, newState);\n    }\n\n    // Update the existing instance's state, props, and context pointers even\n    // if shouldComponentUpdate returns false.\n    instance.props = newProps;\n    instance.state = newState;\n    instance.context = newContext;\n\n    return shouldUpdate;\n  }\n\n  return {\n    adoptClassInstance: adoptClassInstance,\n    constructClassInstance: constructClassInstance,\n    mountClassInstance: mountClassInstance,\n    // resumeMountClassInstance,\n    updateClassInstance: updateClassInstance\n  };\n};\n\n// The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nvar hasSymbol = typeof Symbol === 'function' && Symbol['for'];\n\nvar REACT_ELEMENT_TYPE = hasSymbol ? Symbol['for']('react.element') : 0xeac7;\nvar REACT_CALL_TYPE = hasSymbol ? Symbol['for']('react.call') : 0xeac8;\nvar REACT_RETURN_TYPE = hasSymbol ? Symbol['for']('react.return') : 0xeac9;\nvar REACT_PORTAL_TYPE = hasSymbol ? Symbol['for']('react.portal') : 0xeaca;\nvar REACT_FRAGMENT_TYPE = hasSymbol ? Symbol['for']('react.fragment') : 0xeacb;\n\nvar MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\n\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable === 'undefined') {\n    return null;\n  }\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n  return null;\n}\n\nvar getCurrentFiberStackAddendum$1 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;\n\n\n{\n  var didWarnAboutMaps = false;\n  /**\n   * Warn if there's no key explicitly set on dynamic arrays of children or\n   * object keys are not valid. This allows us to keep track of children between\n   * updates.\n   */\n  var ownerHasKeyUseWarning = {};\n  var ownerHasFunctionTypeWarning = {};\n\n  var warnForMissingKey = function (child) {\n    if (child === null || typeof child !== 'object') {\n      return;\n    }\n    if (!child._store || child._store.validated || child.key != null) {\n      return;\n    }\n    !(typeof child._store === 'object') ? invariant(false, 'React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    child._store.validated = true;\n\n    var currentComponentErrorInfo = 'Each child in an array or iterator should have a unique ' + '\"key\" prop. See https://fb.me/react-warning-keys for ' + 'more information.' + (getCurrentFiberStackAddendum$1() || '');\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true;\n\n    warning(false, 'Each child in an array or iterator should have a unique ' + '\"key\" prop. See https://fb.me/react-warning-keys for ' + 'more information.%s', getCurrentFiberStackAddendum$1());\n  };\n}\n\nvar isArray$1 = Array.isArray;\n\nfunction coerceRef(current, element) {\n  var mixedRef = element.ref;\n  if (mixedRef !== null && typeof mixedRef !== 'function') {\n    if (element._owner) {\n      var owner = element._owner;\n      var inst = void 0;\n      if (owner) {\n        var ownerFiber = owner;\n        !(ownerFiber.tag === ClassComponent) ? invariant(false, 'Stateless function components cannot have refs.') : void 0;\n        inst = ownerFiber.stateNode;\n      }\n      !inst ? invariant(false, 'Missing owner for string ref %s. This error is likely caused by a bug in React. Please file an issue.', mixedRef) : void 0;\n      var stringRef = '' + mixedRef;\n      // Check if previous string ref matches new string ref\n      if (current !== null && current.ref !== null && current.ref._stringRef === stringRef) {\n        return current.ref;\n      }\n      var ref = function (value) {\n        var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;\n        if (value === null) {\n          delete refs[stringRef];\n        } else {\n          refs[stringRef] = value;\n        }\n      };\n      ref._stringRef = stringRef;\n      return ref;\n    } else {\n      !(typeof mixedRef === 'string') ? invariant(false, 'Expected ref to be a function or a string.') : void 0;\n      !element._owner ? invariant(false, 'Element ref was specified as a string (%s) but no owner was set. You may have multiple copies of React loaded. (details: https://fb.me/react-refs-must-have-owner).', mixedRef) : void 0;\n    }\n  }\n  return mixedRef;\n}\n\nfunction throwOnInvalidObjectType(returnFiber, newChild) {\n  if (returnFiber.type !== 'textarea') {\n    var addendum = '';\n    {\n      addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + (getCurrentFiberStackAddendum$1() || '');\n    }\n    invariant(false, 'Objects are not valid as a React child (found: %s).%s', Object.prototype.toString.call(newChild) === '[object Object]' ? 'object with keys {' + Object.keys(newChild).join(', ') + '}' : newChild, addendum);\n  }\n}\n\nfunction warnOnFunctionType() {\n  var currentComponentErrorInfo = 'Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.' + (getCurrentFiberStackAddendum$1() || '');\n\n  if (ownerHasFunctionTypeWarning[currentComponentErrorInfo]) {\n    return;\n  }\n  ownerHasFunctionTypeWarning[currentComponentErrorInfo] = true;\n\n  warning(false, 'Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.%s', getCurrentFiberStackAddendum$1() || '');\n}\n\n// This wrapper function exists because I expect to clone the code in each path\n// to be able to optimize each path individually by branching early. This needs\n// a compiler or we can do it manually. Helpers that don't need this branching\n// live outside of this function.\nfunction ChildReconciler(shouldTrackSideEffects) {\n  function deleteChild(returnFiber, childToDelete) {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return;\n    }\n    // Deletions are added in reversed order so we add it to the front.\n    // At this point, the return fiber's effect list is empty except for\n    // deletions, so we can just append the deletion to the list. The remaining\n    // effects aren't added until the complete phase. Once we implement\n    // resuming, this may not be true.\n    var last = returnFiber.lastEffect;\n    if (last !== null) {\n      last.nextEffect = childToDelete;\n      returnFiber.lastEffect = childToDelete;\n    } else {\n      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;\n    }\n    childToDelete.nextEffect = null;\n    childToDelete.effectTag = Deletion;\n  }\n\n  function deleteRemainingChildren(returnFiber, currentFirstChild) {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return null;\n    }\n\n    // TODO: For the shouldClone case, this could be micro-optimized a bit by\n    // assuming that after the first child we've already added everything.\n    var childToDelete = currentFirstChild;\n    while (childToDelete !== null) {\n      deleteChild(returnFiber, childToDelete);\n      childToDelete = childToDelete.sibling;\n    }\n    return null;\n  }\n\n  function mapRemainingChildren(returnFiber, currentFirstChild) {\n    // Add the remaining children to a temporary map so that we can find them by\n    // keys quickly. Implicit (null) keys get added to this set with their index\n    var existingChildren = new Map();\n\n    var existingChild = currentFirstChild;\n    while (existingChild !== null) {\n      if (existingChild.key !== null) {\n        existingChildren.set(existingChild.key, existingChild);\n      } else {\n        existingChildren.set(existingChild.index, existingChild);\n      }\n      existingChild = existingChild.sibling;\n    }\n    return existingChildren;\n  }\n\n  function useFiber(fiber, pendingProps, expirationTime) {\n    // We currently set sibling to null and index to 0 here because it is easy\n    // to forget to do before returning it. E.g. for the single child case.\n    var clone = createWorkInProgress(fiber, pendingProps, expirationTime);\n    clone.index = 0;\n    clone.sibling = null;\n    return clone;\n  }\n\n  function placeChild(newFiber, lastPlacedIndex, newIndex) {\n    newFiber.index = newIndex;\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return lastPlacedIndex;\n    }\n    var current = newFiber.alternate;\n    if (current !== null) {\n      var oldIndex = current.index;\n      if (oldIndex < lastPlacedIndex) {\n        // This is a move.\n        newFiber.effectTag = Placement;\n        return lastPlacedIndex;\n      } else {\n        // This item can stay in place.\n        return oldIndex;\n      }\n    } else {\n      // This is an insertion.\n      newFiber.effectTag = Placement;\n      return lastPlacedIndex;\n    }\n  }\n\n  function placeSingleChild(newFiber) {\n    // This is simpler for the single child case. We only need to do a\n    // placement for inserting new children.\n    if (shouldTrackSideEffects && newFiber.alternate === null) {\n      newFiber.effectTag = Placement;\n    }\n    return newFiber;\n  }\n\n  function updateTextNode(returnFiber, current, textContent, expirationTime) {\n    if (current === null || current.tag !== HostText) {\n      // Insert\n      var created = createFiberFromText(textContent, returnFiber.internalContextTag, expirationTime);\n      created['return'] = returnFiber;\n      return created;\n    } else {\n      // Update\n      var existing = useFiber(current, textContent, expirationTime);\n      existing['return'] = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateElement(returnFiber, current, element, expirationTime) {\n    if (current !== null && current.type === element.type) {\n      // Move based on index\n      var existing = useFiber(current, element.props, expirationTime);\n      existing.ref = coerceRef(current, element);\n      existing['return'] = returnFiber;\n      {\n        existing._debugSource = element._source;\n        existing._debugOwner = element._owner;\n      }\n      return existing;\n    } else {\n      // Insert\n      var created = createFiberFromElement(element, returnFiber.internalContextTag, expirationTime);\n      created.ref = coerceRef(current, element);\n      created['return'] = returnFiber;\n      return created;\n    }\n  }\n\n  function updateCall(returnFiber, current, call, expirationTime) {\n    // TODO: Should this also compare handler to determine whether to reuse?\n    if (current === null || current.tag !== CallComponent) {\n      // Insert\n      var created = createFiberFromCall(call, returnFiber.internalContextTag, expirationTime);\n      created['return'] = returnFiber;\n      return created;\n    } else {\n      // Move based on index\n      var existing = useFiber(current, call, expirationTime);\n      existing['return'] = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateReturn(returnFiber, current, returnNode, expirationTime) {\n    if (current === null || current.tag !== ReturnComponent) {\n      // Insert\n      var created = createFiberFromReturn(returnNode, returnFiber.internalContextTag, expirationTime);\n      created.type = returnNode.value;\n      created['return'] = returnFiber;\n      return created;\n    } else {\n      // Move based on index\n      var existing = useFiber(current, null, expirationTime);\n      existing.type = returnNode.value;\n      existing['return'] = returnFiber;\n      return existing;\n    }\n  }\n\n  function updatePortal(returnFiber, current, portal, expirationTime) {\n    if (current === null || current.tag !== HostPortal || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) {\n      // Insert\n      var created = createFiberFromPortal(portal, returnFiber.internalContextTag, expirationTime);\n      created['return'] = returnFiber;\n      return created;\n    } else {\n      // Update\n      var existing = useFiber(current, portal.children || [], expirationTime);\n      existing['return'] = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateFragment(returnFiber, current, fragment, expirationTime, key) {\n    if (current === null || current.tag !== Fragment) {\n      // Insert\n      var created = createFiberFromFragment(fragment, returnFiber.internalContextTag, expirationTime, key);\n      created['return'] = returnFiber;\n      return created;\n    } else {\n      // Update\n      var existing = useFiber(current, fragment, expirationTime);\n      existing['return'] = returnFiber;\n      return existing;\n    }\n  }\n\n  function createChild(returnFiber, newChild, expirationTime) {\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      // Text nodes don't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      var created = createFiberFromText('' + newChild, returnFiber.internalContextTag, expirationTime);\n      created['return'] = returnFiber;\n      return created;\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          {\n            if (newChild.type === REACT_FRAGMENT_TYPE) {\n              var _created = createFiberFromFragment(newChild.props.children, returnFiber.internalContextTag, expirationTime, newChild.key);\n              _created['return'] = returnFiber;\n              return _created;\n            } else {\n              var _created2 = createFiberFromElement(newChild, returnFiber.internalContextTag, expirationTime);\n              _created2.ref = coerceRef(null, newChild);\n              _created2['return'] = returnFiber;\n              return _created2;\n            }\n          }\n\n        case REACT_CALL_TYPE:\n          {\n            var _created3 = createFiberFromCall(newChild, returnFiber.internalContextTag, expirationTime);\n            _created3['return'] = returnFiber;\n            return _created3;\n          }\n\n        case REACT_RETURN_TYPE:\n          {\n            var _created4 = createFiberFromReturn(newChild, returnFiber.internalContextTag, expirationTime);\n            _created4.type = newChild.value;\n            _created4['return'] = returnFiber;\n            return _created4;\n          }\n\n        case REACT_PORTAL_TYPE:\n          {\n            var _created5 = createFiberFromPortal(newChild, returnFiber.internalContextTag, expirationTime);\n            _created5['return'] = returnFiber;\n            return _created5;\n          }\n      }\n\n      if (isArray$1(newChild) || getIteratorFn(newChild)) {\n        var _created6 = createFiberFromFragment(newChild, returnFiber.internalContextTag, expirationTime, null);\n        _created6['return'] = returnFiber;\n        return _created6;\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  function updateSlot(returnFiber, oldFiber, newChild, expirationTime) {\n    // Update the fiber if the keys match, otherwise return null.\n\n    var key = oldFiber !== null ? oldFiber.key : null;\n\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      // Text nodes don't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      if (key !== null) {\n        return null;\n      }\n      return updateTextNode(returnFiber, oldFiber, '' + newChild, expirationTime);\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          {\n            if (newChild.key === key) {\n              if (newChild.type === REACT_FRAGMENT_TYPE) {\n                return updateFragment(returnFiber, oldFiber, newChild.props.children, expirationTime, key);\n              }\n              return updateElement(returnFiber, oldFiber, newChild, expirationTime);\n            } else {\n              return null;\n            }\n          }\n\n        case REACT_CALL_TYPE:\n          {\n            if (newChild.key === key) {\n              return updateCall(returnFiber, oldFiber, newChild, expirationTime);\n            } else {\n              return null;\n            }\n          }\n\n        case REACT_RETURN_TYPE:\n          {\n            // Returns don't have keys. If the previous node is implicitly keyed\n            // we can continue to replace it without aborting even if it is not a\n            // yield.\n            if (key === null) {\n              return updateReturn(returnFiber, oldFiber, newChild, expirationTime);\n            } else {\n              return null;\n            }\n          }\n\n        case REACT_PORTAL_TYPE:\n          {\n            if (newChild.key === key) {\n              return updatePortal(returnFiber, oldFiber, newChild, expirationTime);\n            } else {\n              return null;\n            }\n          }\n      }\n\n      if (isArray$1(newChild) || getIteratorFn(newChild)) {\n        if (key !== null) {\n          return null;\n        }\n\n        return updateFragment(returnFiber, oldFiber, newChild, expirationTime, null);\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  function updateFromMap(existingChildren, returnFiber, newIdx, newChild, expirationTime) {\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      // Text nodes don't have keys, so we neither have to check the old nor\n      // new node for the key. If both are text nodes, they match.\n      var matchedFiber = existingChildren.get(newIdx) || null;\n      return updateTextNode(returnFiber, matchedFiber, '' + newChild, expirationTime);\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          {\n            var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n            if (newChild.type === REACT_FRAGMENT_TYPE) {\n              return updateFragment(returnFiber, _matchedFiber, newChild.props.children, expirationTime, newChild.key);\n            }\n            return updateElement(returnFiber, _matchedFiber, newChild, expirationTime);\n          }\n\n        case REACT_CALL_TYPE:\n          {\n            var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n            return updateCall(returnFiber, _matchedFiber2, newChild, expirationTime);\n          }\n\n        case REACT_RETURN_TYPE:\n          {\n            // Returns don't have keys, so we neither have to check the old nor\n            // new node for the key. If both are returns, they match.\n            var _matchedFiber3 = existingChildren.get(newIdx) || null;\n            return updateReturn(returnFiber, _matchedFiber3, newChild, expirationTime);\n          }\n\n        case REACT_PORTAL_TYPE:\n          {\n            var _matchedFiber4 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n            return updatePortal(returnFiber, _matchedFiber4, newChild, expirationTime);\n          }\n      }\n\n      if (isArray$1(newChild) || getIteratorFn(newChild)) {\n        var _matchedFiber5 = existingChildren.get(newIdx) || null;\n        return updateFragment(returnFiber, _matchedFiber5, newChild, expirationTime, null);\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Warns if there is a duplicate or missing key\n   */\n  function warnOnInvalidKey(child, knownKeys) {\n    {\n      if (typeof child !== 'object' || child === null) {\n        return knownKeys;\n      }\n      switch (child.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n        case REACT_CALL_TYPE:\n        case REACT_PORTAL_TYPE:\n          warnForMissingKey(child);\n          var key = child.key;\n          if (typeof key !== 'string') {\n            break;\n          }\n          if (knownKeys === null) {\n            knownKeys = new Set();\n            knownKeys.add(key);\n            break;\n          }\n          if (!knownKeys.has(key)) {\n            knownKeys.add(key);\n            break;\n          }\n          warning(false, 'Encountered two children with the same key, `%s`. ' + 'Keys should be unique so that components maintain their identity ' + 'across updates. Non-unique keys may cause children to be ' + 'duplicated and/or omitted — the behavior is unsupported and ' + 'could change in a future version.%s', key, getCurrentFiberStackAddendum$1());\n          break;\n        default:\n          break;\n      }\n    }\n    return knownKeys;\n  }\n\n  function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, expirationTime) {\n    // This algorithm can't optimize by searching from boths ends since we\n    // don't have backpointers on fibers. I'm trying to see how far we can get\n    // with that model. If it ends up not being worth the tradeoffs, we can\n    // add it later.\n\n    // Even with a two ended optimization, we'd want to optimize for the case\n    // where there are few changes and brute force the comparison instead of\n    // going for the Map. It'd like to explore hitting that path first in\n    // forward-only mode and only go for the Map once we notice that we need\n    // lots of look ahead. This doesn't handle reversal as well as two ended\n    // search but that's unusual. Besides, for the two ended optimization to\n    // work on Iterables, we'd need to copy the whole set.\n\n    // In this first iteration, we'll just live with hitting the bad case\n    // (adding everything to a Map) in for every insert/move.\n\n    // If you change this code, also update reconcileChildrenIterator() which\n    // uses the same algorithm.\n\n    {\n      // First, validate keys.\n      var knownKeys = null;\n      for (var i = 0; i < newChildren.length; i++) {\n        var child = newChildren[i];\n        knownKeys = warnOnInvalidKey(child, knownKeys);\n      }\n    }\n\n    var resultingFirstChild = null;\n    var previousNewFiber = null;\n\n    var oldFiber = currentFirstChild;\n    var lastPlacedIndex = 0;\n    var newIdx = 0;\n    var nextOldFiber = null;\n    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n      var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], expirationTime);\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (oldFiber === null) {\n          oldFiber = nextOldFiber;\n        }\n        break;\n      }\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n\n    if (newIdx === newChildren.length) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n      return resultingFirstChild;\n    }\n\n    if (oldFiber === null) {\n      // If we don't have any more existing children we can choose a fast path\n      // since the rest will all be insertions.\n      for (; newIdx < newChildren.length; newIdx++) {\n        var _newFiber = createChild(returnFiber, newChildren[newIdx], expirationTime);\n        if (!_newFiber) {\n          continue;\n        }\n        lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          // TODO: Move out of the loop. This only happens for the first run.\n          resultingFirstChild = _newFiber;\n        } else {\n          previousNewFiber.sibling = _newFiber;\n        }\n        previousNewFiber = _newFiber;\n      }\n      return resultingFirstChild;\n    }\n\n    // Add all children to a key map for quick lookups.\n    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n\n    // Keep scanning and use the map to restore deleted items as moves.\n    for (; newIdx < newChildren.length; newIdx++) {\n      var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], expirationTime);\n      if (_newFiber2) {\n        if (shouldTrackSideEffects) {\n          if (_newFiber2.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren['delete'](_newFiber2.key === null ? newIdx : _newFiber2.key);\n          }\n        }\n        lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          resultingFirstChild = _newFiber2;\n        } else {\n          previousNewFiber.sibling = _newFiber2;\n        }\n        previousNewFiber = _newFiber2;\n      }\n    }\n\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach(function (child) {\n        return deleteChild(returnFiber, child);\n      });\n    }\n\n    return resultingFirstChild;\n  }\n\n  function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, expirationTime) {\n    // This is the same implementation as reconcileChildrenArray(),\n    // but using the iterator instead.\n\n    var iteratorFn = getIteratorFn(newChildrenIterable);\n    !(typeof iteratorFn === 'function') ? invariant(false, 'An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n    {\n      // Warn about using Maps as children\n      if (typeof newChildrenIterable.entries === 'function') {\n        var possibleMap = newChildrenIterable;\n        if (possibleMap.entries === iteratorFn) {\n          warning(didWarnAboutMaps, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.%s', getCurrentFiberStackAddendum$1());\n          didWarnAboutMaps = true;\n        }\n      }\n\n      // First, validate keys.\n      // We'll get a different iterator later for the main pass.\n      var _newChildren = iteratorFn.call(newChildrenIterable);\n      if (_newChildren) {\n        var knownKeys = null;\n        var _step = _newChildren.next();\n        for (; !_step.done; _step = _newChildren.next()) {\n          var child = _step.value;\n          knownKeys = warnOnInvalidKey(child, knownKeys);\n        }\n      }\n    }\n\n    var newChildren = iteratorFn.call(newChildrenIterable);\n    !(newChildren != null) ? invariant(false, 'An iterable object provided no iterator.') : void 0;\n\n    var resultingFirstChild = null;\n    var previousNewFiber = null;\n\n    var oldFiber = currentFirstChild;\n    var lastPlacedIndex = 0;\n    var newIdx = 0;\n    var nextOldFiber = null;\n\n    var step = newChildren.next();\n    for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n      var newFiber = updateSlot(returnFiber, oldFiber, step.value, expirationTime);\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (!oldFiber) {\n          oldFiber = nextOldFiber;\n        }\n        break;\n      }\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n\n    if (step.done) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n      return resultingFirstChild;\n    }\n\n    if (oldFiber === null) {\n      // If we don't have any more existing children we can choose a fast path\n      // since the rest will all be insertions.\n      for (; !step.done; newIdx++, step = newChildren.next()) {\n        var _newFiber3 = createChild(returnFiber, step.value, expirationTime);\n        if (_newFiber3 === null) {\n          continue;\n        }\n        lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          // TODO: Move out of the loop. This only happens for the first run.\n          resultingFirstChild = _newFiber3;\n        } else {\n          previousNewFiber.sibling = _newFiber3;\n        }\n        previousNewFiber = _newFiber3;\n      }\n      return resultingFirstChild;\n    }\n\n    // Add all children to a key map for quick lookups.\n    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n\n    // Keep scanning and use the map to restore deleted items as moves.\n    for (; !step.done; newIdx++, step = newChildren.next()) {\n      var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, expirationTime);\n      if (_newFiber4 !== null) {\n        if (shouldTrackSideEffects) {\n          if (_newFiber4.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren['delete'](_newFiber4.key === null ? newIdx : _newFiber4.key);\n          }\n        }\n        lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          resultingFirstChild = _newFiber4;\n        } else {\n          previousNewFiber.sibling = _newFiber4;\n        }\n        previousNewFiber = _newFiber4;\n      }\n    }\n\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach(function (child) {\n        return deleteChild(returnFiber, child);\n      });\n    }\n\n    return resultingFirstChild;\n  }\n\n  function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, expirationTime) {\n    // There's no need to check for keys on text nodes since we don't have a\n    // way to define them.\n    if (currentFirstChild !== null && currentFirstChild.tag === HostText) {\n      // We already have an existing node so let's just update it and delete\n      // the rest.\n      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n      var existing = useFiber(currentFirstChild, textContent, expirationTime);\n      existing['return'] = returnFiber;\n      return existing;\n    }\n    // The existing first child is not a text node so we need to create one\n    // and delete the existing ones.\n    deleteRemainingChildren(returnFiber, currentFirstChild);\n    var created = createFiberFromText(textContent, returnFiber.internalContextTag, expirationTime);\n    created['return'] = returnFiber;\n    return created;\n  }\n\n  function reconcileSingleElement(returnFiber, currentFirstChild, element, expirationTime) {\n    var key = element.key;\n    var child = currentFirstChild;\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        if (child.tag === Fragment ? element.type === REACT_FRAGMENT_TYPE : child.type === element.type) {\n          deleteRemainingChildren(returnFiber, child.sibling);\n          var existing = useFiber(child, element.type === REACT_FRAGMENT_TYPE ? element.props.children : element.props, expirationTime);\n          existing.ref = coerceRef(child, element);\n          existing['return'] = returnFiber;\n          {\n            existing._debugSource = element._source;\n            existing._debugOwner = element._owner;\n          }\n          return existing;\n        } else {\n          deleteRemainingChildren(returnFiber, child);\n          break;\n        }\n      } else {\n        deleteChild(returnFiber, child);\n      }\n      child = child.sibling;\n    }\n\n    if (element.type === REACT_FRAGMENT_TYPE) {\n      var created = createFiberFromFragment(element.props.children, returnFiber.internalContextTag, expirationTime, element.key);\n      created['return'] = returnFiber;\n      return created;\n    } else {\n      var _created7 = createFiberFromElement(element, returnFiber.internalContextTag, expirationTime);\n      _created7.ref = coerceRef(currentFirstChild, element);\n      _created7['return'] = returnFiber;\n      return _created7;\n    }\n  }\n\n  function reconcileSingleCall(returnFiber, currentFirstChild, call, expirationTime) {\n    var key = call.key;\n    var child = currentFirstChild;\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        if (child.tag === CallComponent) {\n          deleteRemainingChildren(returnFiber, child.sibling);\n          var existing = useFiber(child, call, expirationTime);\n          existing['return'] = returnFiber;\n          return existing;\n        } else {\n          deleteRemainingChildren(returnFiber, child);\n          break;\n        }\n      } else {\n        deleteChild(returnFiber, child);\n      }\n      child = child.sibling;\n    }\n\n    var created = createFiberFromCall(call, returnFiber.internalContextTag, expirationTime);\n    created['return'] = returnFiber;\n    return created;\n  }\n\n  function reconcileSingleReturn(returnFiber, currentFirstChild, returnNode, expirationTime) {\n    // There's no need to check for keys on yields since they're stateless.\n    var child = currentFirstChild;\n    if (child !== null) {\n      if (child.tag === ReturnComponent) {\n        deleteRemainingChildren(returnFiber, child.sibling);\n        var existing = useFiber(child, null, expirationTime);\n        existing.type = returnNode.value;\n        existing['return'] = returnFiber;\n        return existing;\n      } else {\n        deleteRemainingChildren(returnFiber, child);\n      }\n    }\n\n    var created = createFiberFromReturn(returnNode, returnFiber.internalContextTag, expirationTime);\n    created.type = returnNode.value;\n    created['return'] = returnFiber;\n    return created;\n  }\n\n  function reconcileSinglePortal(returnFiber, currentFirstChild, portal, expirationTime) {\n    var key = portal.key;\n    var child = currentFirstChild;\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {\n          deleteRemainingChildren(returnFiber, child.sibling);\n          var existing = useFiber(child, portal.children || [], expirationTime);\n          existing['return'] = returnFiber;\n          return existing;\n        } else {\n          deleteRemainingChildren(returnFiber, child);\n          break;\n        }\n      } else {\n        deleteChild(returnFiber, child);\n      }\n      child = child.sibling;\n    }\n\n    var created = createFiberFromPortal(portal, returnFiber.internalContextTag, expirationTime);\n    created['return'] = returnFiber;\n    return created;\n  }\n\n  // This API will tag the children with the side-effect of the reconciliation\n  // itself. They will be added to the side-effect list as we pass through the\n  // children and the parent.\n  function reconcileChildFibers(returnFiber, currentFirstChild, newChild, expirationTime) {\n    // This function is not recursive.\n    // If the top level item is an array, we treat it as a set of children,\n    // not as a fragment. Nested arrays on the other hand will be treated as\n    // fragment nodes. Recursion happens at the normal flow.\n\n    // Handle top level unkeyed fragments as if they were arrays.\n    // This leads to an ambiguity between <>{[...]}</> and <>...</>.\n    // We treat the ambiguous cases above the same.\n    if (typeof newChild === 'object' && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null) {\n      newChild = newChild.props.children;\n    }\n\n    // Handle object types\n    var isObject = typeof newChild === 'object' && newChild !== null;\n\n    if (isObject) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, expirationTime));\n\n        case REACT_CALL_TYPE:\n          return placeSingleChild(reconcileSingleCall(returnFiber, currentFirstChild, newChild, expirationTime));\n        case REACT_RETURN_TYPE:\n          return placeSingleChild(reconcileSingleReturn(returnFiber, currentFirstChild, newChild, expirationTime));\n        case REACT_PORTAL_TYPE:\n          return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, expirationTime));\n      }\n    }\n\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, '' + newChild, expirationTime));\n    }\n\n    if (isArray$1(newChild)) {\n      return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, expirationTime);\n    }\n\n    if (getIteratorFn(newChild)) {\n      return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, expirationTime);\n    }\n\n    if (isObject) {\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n    if (typeof newChild === 'undefined') {\n      // If the new child is undefined, and the return fiber is a composite\n      // component, throw an error. If Fiber return types are disabled,\n      // we already threw above.\n      switch (returnFiber.tag) {\n        case ClassComponent:\n          {\n            {\n              var instance = returnFiber.stateNode;\n              if (instance.render._isMockFunction) {\n                // We allow auto-mocks to proceed as if they're returning null.\n                break;\n              }\n            }\n          }\n        // Intentionally fall through to the next case, which handles both\n        // functions and classes\n        // eslint-disable-next-lined no-fallthrough\n        case FunctionalComponent:\n          {\n            var Component = returnFiber.type;\n            invariant(false, '%s(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.', Component.displayName || Component.name || 'Component');\n          }\n      }\n    }\n\n    // Remaining cases are all treated as empty.\n    return deleteRemainingChildren(returnFiber, currentFirstChild);\n  }\n\n  return reconcileChildFibers;\n}\n\nvar reconcileChildFibers = ChildReconciler(true);\nvar mountChildFibers = ChildReconciler(false);\n\nfunction cloneChildFibers(current, workInProgress) {\n  !(current === null || workInProgress.child === current.child) ? invariant(false, 'Resuming work not yet implemented.') : void 0;\n\n  if (workInProgress.child === null) {\n    return;\n  }\n\n  var currentChild = workInProgress.child;\n  var newChild = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);\n  workInProgress.child = newChild;\n\n  newChild['return'] = workInProgress;\n  while (currentChild.sibling !== null) {\n    currentChild = currentChild.sibling;\n    newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);\n    newChild['return'] = workInProgress;\n  }\n  newChild.sibling = null;\n}\n\n{\n  var warnedAboutStatelessRefs = {};\n}\n\nvar ReactFiberBeginWork = function (config, hostContext, hydrationContext, scheduleWork, computeExpirationForFiber) {\n  var shouldSetTextContent = config.shouldSetTextContent,\n      useSyncScheduling = config.useSyncScheduling,\n      shouldDeprioritizeSubtree = config.shouldDeprioritizeSubtree;\n  var pushHostContext = hostContext.pushHostContext,\n      pushHostContainer = hostContext.pushHostContainer;\n  var enterHydrationState = hydrationContext.enterHydrationState,\n      resetHydrationState = hydrationContext.resetHydrationState,\n      tryToClaimNextHydratableInstance = hydrationContext.tryToClaimNextHydratableInstance;\n\n  var _ReactFiberClassCompo = ReactFiberClassComponent(scheduleWork, computeExpirationForFiber, memoizeProps, memoizeState),\n      adoptClassInstance = _ReactFiberClassCompo.adoptClassInstance,\n      constructClassInstance = _ReactFiberClassCompo.constructClassInstance,\n      mountClassInstance = _ReactFiberClassCompo.mountClassInstance,\n      updateClassInstance = _ReactFiberClassCompo.updateClassInstance;\n\n  // TODO: Remove this and use reconcileChildrenAtExpirationTime directly.\n\n\n  function reconcileChildren(current, workInProgress, nextChildren) {\n    reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, workInProgress.expirationTime);\n  }\n\n  function reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, renderExpirationTime) {\n    if (current === null) {\n      // If this is a fresh new component that hasn't been rendered yet, we\n      // won't update its child set by applying minimal side-effects. Instead,\n      // we will add them all to the child before it gets rendered. That means\n      // we can optimize this reconciliation pass by not tracking side-effects.\n      workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderExpirationTime);\n    } else {\n      // If the current child is the same as the work in progress, it means that\n      // we haven't yet started any work on these children. Therefore, we use\n      // the clone algorithm to create a copy of all the current children.\n\n      // If we had any progressed work already, that is invalid at this point so\n      // let's throw it out.\n      workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren, renderExpirationTime);\n    }\n  }\n\n  function updateFragment(current, workInProgress) {\n    var nextChildren = workInProgress.pendingProps;\n    if (hasContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n      if (nextChildren === null) {\n        nextChildren = workInProgress.memoizedProps;\n      }\n    } else if (nextChildren === null || workInProgress.memoizedProps === nextChildren) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n    reconcileChildren(current, workInProgress, nextChildren);\n    memoizeProps(workInProgress, nextChildren);\n    return workInProgress.child;\n  }\n\n  function markRef(current, workInProgress) {\n    var ref = workInProgress.ref;\n    if (ref !== null && (!current || current.ref !== ref)) {\n      // Schedule a Ref effect\n      workInProgress.effectTag |= Ref;\n    }\n  }\n\n  function updateFunctionalComponent(current, workInProgress) {\n    var fn = workInProgress.type;\n    var nextProps = workInProgress.pendingProps;\n\n    var memoizedProps = workInProgress.memoizedProps;\n    if (hasContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n      if (nextProps === null) {\n        nextProps = memoizedProps;\n      }\n    } else {\n      if (nextProps === null || memoizedProps === nextProps) {\n        return bailoutOnAlreadyFinishedWork(current, workInProgress);\n      }\n      // TODO: consider bringing fn.shouldComponentUpdate() back.\n      // It used to be here.\n    }\n\n    var unmaskedContext = getUnmaskedContext(workInProgress);\n    var context = getMaskedContext(workInProgress, unmaskedContext);\n\n    var nextChildren;\n\n    {\n      ReactCurrentOwner.current = workInProgress;\n      ReactDebugCurrentFiber.setCurrentPhase('render');\n      nextChildren = fn(nextProps, context);\n      ReactDebugCurrentFiber.setCurrentPhase(null);\n    }\n    // React DevTools reads this flag.\n    workInProgress.effectTag |= PerformedWork;\n    reconcileChildren(current, workInProgress, nextChildren);\n    memoizeProps(workInProgress, nextProps);\n    return workInProgress.child;\n  }\n\n  function updateClassComponent(current, workInProgress, renderExpirationTime) {\n    // Push context providers early to prevent context stack mismatches.\n    // During mounting we don't know the child context yet as the instance doesn't exist.\n    // We will invalidate the child context in finishClassComponent() right after rendering.\n    var hasContext = pushContextProvider(workInProgress);\n\n    var shouldUpdate = void 0;\n    if (current === null) {\n      if (!workInProgress.stateNode) {\n        // In the initial pass we might need to construct the instance.\n        constructClassInstance(workInProgress, workInProgress.pendingProps);\n        mountClassInstance(workInProgress, renderExpirationTime);\n        shouldUpdate = true;\n      } else {\n        invariant(false, 'Resuming work not yet implemented.');\n        // In a resume, we'll already have an instance we can reuse.\n        // shouldUpdate = resumeMountClassInstance(workInProgress, renderExpirationTime);\n      }\n    } else {\n      shouldUpdate = updateClassInstance(current, workInProgress, renderExpirationTime);\n    }\n    return finishClassComponent(current, workInProgress, shouldUpdate, hasContext);\n  }\n\n  function finishClassComponent(current, workInProgress, shouldUpdate, hasContext) {\n    // Refs should update even if shouldComponentUpdate returns false\n    markRef(current, workInProgress);\n\n    if (!shouldUpdate) {\n      // Context providers should defer to sCU for rendering\n      if (hasContext) {\n        invalidateContextProvider(workInProgress, false);\n      }\n\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n\n    var instance = workInProgress.stateNode;\n\n    // Rerender\n    ReactCurrentOwner.current = workInProgress;\n    var nextChildren = void 0;\n    {\n      ReactDebugCurrentFiber.setCurrentPhase('render');\n      nextChildren = instance.render();\n      if (debugRenderPhaseSideEffects) {\n        instance.render();\n      }\n      ReactDebugCurrentFiber.setCurrentPhase(null);\n    }\n    // React DevTools reads this flag.\n    workInProgress.effectTag |= PerformedWork;\n    reconcileChildren(current, workInProgress, nextChildren);\n    // Memoize props and state using the values we just used to render.\n    // TODO: Restructure so we never read values from the instance.\n    memoizeState(workInProgress, instance.state);\n    memoizeProps(workInProgress, instance.props);\n\n    // The context might have changed so we need to recalculate it.\n    if (hasContext) {\n      invalidateContextProvider(workInProgress, true);\n    }\n\n    return workInProgress.child;\n  }\n\n  function pushHostRootContext(workInProgress) {\n    var root = workInProgress.stateNode;\n    if (root.pendingContext) {\n      pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context);\n    } else if (root.context) {\n      // Should always be set\n      pushTopLevelContextObject(workInProgress, root.context, false);\n    }\n    pushHostContainer(workInProgress, root.containerInfo);\n  }\n\n  function updateHostRoot(current, workInProgress, renderExpirationTime) {\n    pushHostRootContext(workInProgress);\n    var updateQueue = workInProgress.updateQueue;\n    if (updateQueue !== null) {\n      var prevState = workInProgress.memoizedState;\n      var state = processUpdateQueue(current, workInProgress, updateQueue, null, null, renderExpirationTime);\n      if (prevState === state) {\n        // If the state is the same as before, that's a bailout because we had\n        // no work that expires at this time.\n        resetHydrationState();\n        return bailoutOnAlreadyFinishedWork(current, workInProgress);\n      }\n      var element = state.element;\n      var root = workInProgress.stateNode;\n      if ((current === null || current.child === null) && root.hydrate && enterHydrationState(workInProgress)) {\n        // If we don't have any current children this might be the first pass.\n        // We always try to hydrate. If this isn't a hydration pass there won't\n        // be any children to hydrate which is effectively the same thing as\n        // not hydrating.\n\n        // This is a bit of a hack. We track the host root as a placement to\n        // know that we're currently in a mounting state. That way isMounted\n        // works as expected. We must reset this before committing.\n        // TODO: Delete this when we delete isMounted and findDOMNode.\n        workInProgress.effectTag |= Placement;\n\n        // Ensure that children mount into this root without tracking\n        // side-effects. This ensures that we don't store Placement effects on\n        // nodes that will be hydrated.\n        workInProgress.child = mountChildFibers(workInProgress, null, element, renderExpirationTime);\n      } else {\n        // Otherwise reset hydration state in case we aborted and resumed another\n        // root.\n        resetHydrationState();\n        reconcileChildren(current, workInProgress, element);\n      }\n      memoizeState(workInProgress, state);\n      return workInProgress.child;\n    }\n    resetHydrationState();\n    // If there is no update queue, that's a bailout because the root has no props.\n    return bailoutOnAlreadyFinishedWork(current, workInProgress);\n  }\n\n  function updateHostComponent(current, workInProgress, renderExpirationTime) {\n    pushHostContext(workInProgress);\n\n    if (current === null) {\n      tryToClaimNextHydratableInstance(workInProgress);\n    }\n\n    var type = workInProgress.type;\n    var memoizedProps = workInProgress.memoizedProps;\n    var nextProps = workInProgress.pendingProps;\n    if (nextProps === null) {\n      nextProps = memoizedProps;\n      !(nextProps !== null) ? invariant(false, 'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    }\n    var prevProps = current !== null ? current.memoizedProps : null;\n\n    if (hasContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n    } else if (nextProps === null || memoizedProps === nextProps) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n\n    var nextChildren = nextProps.children;\n    var isDirectTextChild = shouldSetTextContent(type, nextProps);\n\n    if (isDirectTextChild) {\n      // We special case a direct text child of a host node. This is a common\n      // case. We won't handle it as a reified child. We will instead handle\n      // this in the host environment that also have access to this prop. That\n      // avoids allocating another HostText fiber and traversing it.\n      nextChildren = null;\n    } else if (prevProps && shouldSetTextContent(type, prevProps)) {\n      // If we're switching from a direct text child to a normal child, or to\n      // empty, we need to schedule the text content to be reset.\n      workInProgress.effectTag |= ContentReset;\n    }\n\n    markRef(current, workInProgress);\n\n    // Check the host config to see if the children are offscreen/hidden.\n    if (renderExpirationTime !== Never && !useSyncScheduling && shouldDeprioritizeSubtree(type, nextProps)) {\n      // Down-prioritize the children.\n      workInProgress.expirationTime = Never;\n      // Bailout and come back to this fiber later.\n      return null;\n    }\n\n    reconcileChildren(current, workInProgress, nextChildren);\n    memoizeProps(workInProgress, nextProps);\n    return workInProgress.child;\n  }\n\n  function updateHostText(current, workInProgress) {\n    if (current === null) {\n      tryToClaimNextHydratableInstance(workInProgress);\n    }\n    var nextProps = workInProgress.pendingProps;\n    if (nextProps === null) {\n      nextProps = workInProgress.memoizedProps;\n    }\n    memoizeProps(workInProgress, nextProps);\n    // Nothing to do here. This is terminal. We'll do the completion step\n    // immediately after.\n    return null;\n  }\n\n  function mountIndeterminateComponent(current, workInProgress, renderExpirationTime) {\n    !(current === null) ? invariant(false, 'An indeterminate component should never have mounted. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    var fn = workInProgress.type;\n    var props = workInProgress.pendingProps;\n    var unmaskedContext = getUnmaskedContext(workInProgress);\n    var context = getMaskedContext(workInProgress, unmaskedContext);\n\n    var value;\n\n    {\n      if (fn.prototype && typeof fn.prototype.render === 'function') {\n        var componentName = getComponentName(workInProgress);\n        warning(false, \"The <%s /> component appears to have a render method, but doesn't extend React.Component. \" + 'This is likely to cause errors. Change %s to extend React.Component instead.', componentName, componentName);\n      }\n      ReactCurrentOwner.current = workInProgress;\n      value = fn(props, context);\n    }\n    // React DevTools reads this flag.\n    workInProgress.effectTag |= PerformedWork;\n\n    if (typeof value === 'object' && value !== null && typeof value.render === 'function') {\n      // Proceed under the assumption that this is a class instance\n      workInProgress.tag = ClassComponent;\n\n      // Push context providers early to prevent context stack mismatches.\n      // During mounting we don't know the child context yet as the instance doesn't exist.\n      // We will invalidate the child context in finishClassComponent() right after rendering.\n      var hasContext = pushContextProvider(workInProgress);\n      adoptClassInstance(workInProgress, value);\n      mountClassInstance(workInProgress, renderExpirationTime);\n      return finishClassComponent(current, workInProgress, true, hasContext);\n    } else {\n      // Proceed under the assumption that this is a functional component\n      workInProgress.tag = FunctionalComponent;\n      {\n        var Component = workInProgress.type;\n\n        if (Component) {\n          warning(!Component.childContextTypes, '%s(...): childContextTypes cannot be defined on a functional component.', Component.displayName || Component.name || 'Component');\n        }\n        if (workInProgress.ref !== null) {\n          var info = '';\n          var ownerName = ReactDebugCurrentFiber.getCurrentFiberOwnerName();\n          if (ownerName) {\n            info += '\\n\\nCheck the render method of `' + ownerName + '`.';\n          }\n\n          var warningKey = ownerName || workInProgress._debugID || '';\n          var debugSource = workInProgress._debugSource;\n          if (debugSource) {\n            warningKey = debugSource.fileName + ':' + debugSource.lineNumber;\n          }\n          if (!warnedAboutStatelessRefs[warningKey]) {\n            warnedAboutStatelessRefs[warningKey] = true;\n            warning(false, 'Stateless function components cannot be given refs. ' + 'Attempts to access this ref will fail.%s%s', info, ReactDebugCurrentFiber.getCurrentFiberStackAddendum());\n          }\n        }\n      }\n      reconcileChildren(current, workInProgress, value);\n      memoizeProps(workInProgress, props);\n      return workInProgress.child;\n    }\n  }\n\n  function updateCallComponent(current, workInProgress, renderExpirationTime) {\n    var nextCall = workInProgress.pendingProps;\n    if (hasContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n      if (nextCall === null) {\n        nextCall = current && current.memoizedProps;\n        !(nextCall !== null) ? invariant(false, 'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n      }\n    } else if (nextCall === null || workInProgress.memoizedProps === nextCall) {\n      nextCall = workInProgress.memoizedProps;\n      // TODO: When bailing out, we might need to return the stateNode instead\n      // of the child. To check it for work.\n      // return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n\n    var nextChildren = nextCall.children;\n\n    // The following is a fork of reconcileChildrenAtExpirationTime but using\n    // stateNode to store the child.\n    if (current === null) {\n      workInProgress.stateNode = mountChildFibers(workInProgress, workInProgress.stateNode, nextChildren, renderExpirationTime);\n    } else {\n      workInProgress.stateNode = reconcileChildFibers(workInProgress, workInProgress.stateNode, nextChildren, renderExpirationTime);\n    }\n\n    memoizeProps(workInProgress, nextCall);\n    // This doesn't take arbitrary time so we could synchronously just begin\n    // eagerly do the work of workInProgress.child as an optimization.\n    return workInProgress.stateNode;\n  }\n\n  function updatePortalComponent(current, workInProgress, renderExpirationTime) {\n    pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n    var nextChildren = workInProgress.pendingProps;\n    if (hasContextChanged()) {\n      // Normally we can bail out on props equality but if context has changed\n      // we don't do the bailout and we have to reuse existing props instead.\n      if (nextChildren === null) {\n        nextChildren = current && current.memoizedProps;\n        !(nextChildren != null) ? invariant(false, 'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n      }\n    } else if (nextChildren === null || workInProgress.memoizedProps === nextChildren) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress);\n    }\n\n    if (current === null) {\n      // Portals are special because we don't append the children during mount\n      // but at commit. Therefore we need to track insertions which the normal\n      // flow doesn't do during mount. This doesn't happen at the root because\n      // the root always starts with a \"current\" with a null child.\n      // TODO: Consider unifying this with how the root works.\n      workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderExpirationTime);\n      memoizeProps(workInProgress, nextChildren);\n    } else {\n      reconcileChildren(current, workInProgress, nextChildren);\n      memoizeProps(workInProgress, nextChildren);\n    }\n    return workInProgress.child;\n  }\n\n  /*\n  function reuseChildrenEffects(returnFiber : Fiber, firstChild : Fiber) {\n    let child = firstChild;\n    do {\n      // Ensure that the first and last effect of the parent corresponds\n      // to the children's first and last effect.\n      if (!returnFiber.firstEffect) {\n        returnFiber.firstEffect = child.firstEffect;\n      }\n      if (child.lastEffect) {\n        if (returnFiber.lastEffect) {\n          returnFiber.lastEffect.nextEffect = child.firstEffect;\n        }\n        returnFiber.lastEffect = child.lastEffect;\n      }\n    } while (child = child.sibling);\n  }\n  */\n\n  function bailoutOnAlreadyFinishedWork(current, workInProgress) {\n    cancelWorkTimer(workInProgress);\n\n    // TODO: We should ideally be able to bail out early if the children have no\n    // more work to do. However, since we don't have a separation of this\n    // Fiber's priority and its children yet - we don't know without doing lots\n    // of the same work we do anyway. Once we have that separation we can just\n    // bail out here if the children has no more work at this priority level.\n    // if (workInProgress.priorityOfChildren <= priorityLevel) {\n    //   // If there are side-effects in these children that have not yet been\n    //   // committed we need to ensure that they get properly transferred up.\n    //   if (current && current.child !== workInProgress.child) {\n    //     reuseChildrenEffects(workInProgress, child);\n    //   }\n    //   return null;\n    // }\n\n    cloneChildFibers(current, workInProgress);\n    return workInProgress.child;\n  }\n\n  function bailoutOnLowPriority(current, workInProgress) {\n    cancelWorkTimer(workInProgress);\n\n    // TODO: Handle HostComponent tags here as well and call pushHostContext()?\n    // See PR 8590 discussion for context\n    switch (workInProgress.tag) {\n      case HostRoot:\n        pushHostRootContext(workInProgress);\n        break;\n      case ClassComponent:\n        pushContextProvider(workInProgress);\n        break;\n      case HostPortal:\n        pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n        break;\n    }\n    // TODO: What if this is currently in progress?\n    // How can that happen? How is this not being cloned?\n    return null;\n  }\n\n  // TODO: Delete memoizeProps/State and move to reconcile/bailout instead\n  function memoizeProps(workInProgress, nextProps) {\n    workInProgress.memoizedProps = nextProps;\n  }\n\n  function memoizeState(workInProgress, nextState) {\n    workInProgress.memoizedState = nextState;\n    // Don't reset the updateQueue, in case there are pending updates. Resetting\n    // is handled by processUpdateQueue.\n  }\n\n  function beginWork(current, workInProgress, renderExpirationTime) {\n    if (workInProgress.expirationTime === NoWork || workInProgress.expirationTime > renderExpirationTime) {\n      return bailoutOnLowPriority(current, workInProgress);\n    }\n\n    switch (workInProgress.tag) {\n      case IndeterminateComponent:\n        return mountIndeterminateComponent(current, workInProgress, renderExpirationTime);\n      case FunctionalComponent:\n        return updateFunctionalComponent(current, workInProgress);\n      case ClassComponent:\n        return updateClassComponent(current, workInProgress, renderExpirationTime);\n      case HostRoot:\n        return updateHostRoot(current, workInProgress, renderExpirationTime);\n      case HostComponent:\n        return updateHostComponent(current, workInProgress, renderExpirationTime);\n      case HostText:\n        return updateHostText(current, workInProgress);\n      case CallHandlerPhase:\n        // This is a restart. Reset the tag to the initial phase.\n        workInProgress.tag = CallComponent;\n      // Intentionally fall through since this is now the same.\n      case CallComponent:\n        return updateCallComponent(current, workInProgress, renderExpirationTime);\n      case ReturnComponent:\n        // A return component is just a placeholder, we can just run through the\n        // next one immediately.\n        return null;\n      case HostPortal:\n        return updatePortalComponent(current, workInProgress, renderExpirationTime);\n      case Fragment:\n        return updateFragment(current, workInProgress);\n      default:\n        invariant(false, 'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');\n    }\n  }\n\n  function beginFailedWork(current, workInProgress, renderExpirationTime) {\n    // Push context providers here to avoid a push/pop context mismatch.\n    switch (workInProgress.tag) {\n      case ClassComponent:\n        pushContextProvider(workInProgress);\n        break;\n      case HostRoot:\n        pushHostRootContext(workInProgress);\n        break;\n      default:\n        invariant(false, 'Invalid type of work. This error is likely caused by a bug in React. Please file an issue.');\n    }\n\n    // Add an error effect so we can handle the error during the commit phase\n    workInProgress.effectTag |= Err;\n\n    // This is a weird case where we do \"resume\" work — work that failed on\n    // our first attempt. Because we no longer have a notion of \"progressed\n    // deletions,\" reset the child to the current child to make sure we delete\n    // it again. TODO: Find a better way to handle this, perhaps during a more\n    // general overhaul of error handling.\n    if (current === null) {\n      workInProgress.child = null;\n    } else if (workInProgress.child !== current.child) {\n      workInProgress.child = current.child;\n    }\n\n    if (workInProgress.expirationTime === NoWork || workInProgress.expirationTime > renderExpirationTime) {\n      return bailoutOnLowPriority(current, workInProgress);\n    }\n\n    // If we don't bail out, we're going be recomputing our children so we need\n    // to drop our effect list.\n    workInProgress.firstEffect = null;\n    workInProgress.lastEffect = null;\n\n    // Unmount the current children as if the component rendered null\n    var nextChildren = null;\n    reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, renderExpirationTime);\n\n    if (workInProgress.tag === ClassComponent) {\n      var instance = workInProgress.stateNode;\n      workInProgress.memoizedProps = instance.props;\n      workInProgress.memoizedState = instance.state;\n    }\n\n    return workInProgress.child;\n  }\n\n  return {\n    beginWork: beginWork,\n    beginFailedWork: beginFailedWork\n  };\n};\n\nvar ReactFiberCompleteWork = function (config, hostContext, hydrationContext) {\n  var createInstance = config.createInstance,\n      createTextInstance = config.createTextInstance,\n      appendInitialChild = config.appendInitialChild,\n      finalizeInitialChildren = config.finalizeInitialChildren,\n      prepareUpdate = config.prepareUpdate,\n      mutation = config.mutation,\n      persistence = config.persistence;\n  var getRootHostContainer = hostContext.getRootHostContainer,\n      popHostContext = hostContext.popHostContext,\n      getHostContext = hostContext.getHostContext,\n      popHostContainer = hostContext.popHostContainer;\n  var prepareToHydrateHostInstance = hydrationContext.prepareToHydrateHostInstance,\n      prepareToHydrateHostTextInstance = hydrationContext.prepareToHydrateHostTextInstance,\n      popHydrationState = hydrationContext.popHydrationState;\n\n\n  function markUpdate(workInProgress) {\n    // Tag the fiber with an update effect. This turns a Placement into\n    // an UpdateAndPlacement.\n    workInProgress.effectTag |= Update;\n  }\n\n  function markRef(workInProgress) {\n    workInProgress.effectTag |= Ref;\n  }\n\n  function appendAllReturns(returns, workInProgress) {\n    var node = workInProgress.stateNode;\n    if (node) {\n      node['return'] = workInProgress;\n    }\n    while (node !== null) {\n      if (node.tag === HostComponent || node.tag === HostText || node.tag === HostPortal) {\n        invariant(false, 'A call cannot have host component children.');\n      } else if (node.tag === ReturnComponent) {\n        returns.push(node.type);\n      } else if (node.child !== null) {\n        node.child['return'] = node;\n        node = node.child;\n        continue;\n      }\n      while (node.sibling === null) {\n        if (node['return'] === null || node['return'] === workInProgress) {\n          return;\n        }\n        node = node['return'];\n      }\n      node.sibling['return'] = node['return'];\n      node = node.sibling;\n    }\n  }\n\n  function moveCallToHandlerPhase(current, workInProgress, renderExpirationTime) {\n    var call = workInProgress.memoizedProps;\n    !call ? invariant(false, 'Should be resolved by now. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n    // First step of the call has completed. Now we need to do the second.\n    // TODO: It would be nice to have a multi stage call represented by a\n    // single component, or at least tail call optimize nested ones. Currently\n    // that requires additional fields that we don't want to add to the fiber.\n    // So this requires nested handlers.\n    // Note: This doesn't mutate the alternate node. I don't think it needs to\n    // since this stage is reset for every pass.\n    workInProgress.tag = CallHandlerPhase;\n\n    // Build up the returns.\n    // TODO: Compare this to a generator or opaque helpers like Children.\n    var returns = [];\n    appendAllReturns(returns, workInProgress);\n    var fn = call.handler;\n    var props = call.props;\n    var nextChildren = fn(props, returns);\n\n    var currentFirstChild = current !== null ? current.child : null;\n    workInProgress.child = reconcileChildFibers(workInProgress, currentFirstChild, nextChildren, renderExpirationTime);\n    return workInProgress.child;\n  }\n\n  function appendAllChildren(parent, workInProgress) {\n    // We only have the top Fiber that was created but we need recurse down its\n    // children to find all the terminal nodes.\n    var node = workInProgress.child;\n    while (node !== null) {\n      if (node.tag === HostComponent || node.tag === HostText) {\n        appendInitialChild(parent, node.stateNode);\n      } else if (node.tag === HostPortal) {\n        // If we have a portal child, then we don't want to traverse\n        // down its children. Instead, we'll get insertions from each child in\n        // the portal directly.\n      } else if (node.child !== null) {\n        node.child['return'] = node;\n        node = node.child;\n        continue;\n      }\n      if (node === workInProgress) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node['return'] === null || node['return'] === workInProgress) {\n          return;\n        }\n        node = node['return'];\n      }\n      node.sibling['return'] = node['return'];\n      node = node.sibling;\n    }\n  }\n\n  var updateHostContainer = void 0;\n  var updateHostComponent = void 0;\n  var updateHostText = void 0;\n  if (mutation) {\n    if (enableMutatingReconciler) {\n      // Mutation mode\n      updateHostContainer = function (workInProgress) {\n        // Noop\n      };\n      updateHostComponent = function (current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance) {\n        // TODO: Type this specific to this type of component.\n        workInProgress.updateQueue = updatePayload;\n        // If the update payload indicates that there is a change or if there\n        // is a new ref we mark this as an update. All the work is done in commitWork.\n        if (updatePayload) {\n          markUpdate(workInProgress);\n        }\n      };\n      updateHostText = function (current, workInProgress, oldText, newText) {\n        // If the text differs, mark it as an update. All the work in done in commitWork.\n        if (oldText !== newText) {\n          markUpdate(workInProgress);\n        }\n      };\n    } else {\n      invariant(false, 'Mutating reconciler is disabled.');\n    }\n  } else if (persistence) {\n    if (enablePersistentReconciler) {\n      // Persistent host tree mode\n      var cloneInstance = persistence.cloneInstance,\n          createContainerChildSet = persistence.createContainerChildSet,\n          appendChildToContainerChildSet = persistence.appendChildToContainerChildSet,\n          finalizeContainerChildren = persistence.finalizeContainerChildren;\n\n      // An unfortunate fork of appendAllChildren because we have two different parent types.\n\n      var appendAllChildrenToContainer = function (containerChildSet, workInProgress) {\n        // We only have the top Fiber that was created but we need recurse down its\n        // children to find all the terminal nodes.\n        var node = workInProgress.child;\n        while (node !== null) {\n          if (node.tag === HostComponent || node.tag === HostText) {\n            appendChildToContainerChildSet(containerChildSet, node.stateNode);\n          } else if (node.tag === HostPortal) {\n            // If we have a portal child, then we don't want to traverse\n            // down its children. Instead, we'll get insertions from each child in\n            // the portal directly.\n          } else if (node.child !== null) {\n            node.child['return'] = node;\n            node = node.child;\n            continue;\n          }\n          if (node === workInProgress) {\n            return;\n          }\n          while (node.sibling === null) {\n            if (node['return'] === null || node['return'] === workInProgress) {\n              return;\n            }\n            node = node['return'];\n          }\n          node.sibling['return'] = node['return'];\n          node = node.sibling;\n        }\n      };\n      updateHostContainer = function (workInProgress) {\n        var portalOrRoot = workInProgress.stateNode;\n        var childrenUnchanged = workInProgress.firstEffect === null;\n        if (childrenUnchanged) {\n          // No changes, just reuse the existing instance.\n        } else {\n          var container = portalOrRoot.containerInfo;\n          var newChildSet = createContainerChildSet(container);\n          if (finalizeContainerChildren(container, newChildSet)) {\n            markUpdate(workInProgress);\n          }\n          portalOrRoot.pendingChildren = newChildSet;\n          // If children might have changed, we have to add them all to the set.\n          appendAllChildrenToContainer(newChildSet, workInProgress);\n          // Schedule an update on the container to swap out the container.\n          markUpdate(workInProgress);\n        }\n      };\n      updateHostComponent = function (current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance) {\n        // If there are no effects associated with this node, then none of our children had any updates.\n        // This guarantees that we can reuse all of them.\n        var childrenUnchanged = workInProgress.firstEffect === null;\n        var currentInstance = current.stateNode;\n        if (childrenUnchanged && updatePayload === null) {\n          // No changes, just reuse the existing instance.\n          // Note that this might release a previous clone.\n          workInProgress.stateNode = currentInstance;\n        } else {\n          var recyclableInstance = workInProgress.stateNode;\n          var newInstance = cloneInstance(currentInstance, updatePayload, type, oldProps, newProps, workInProgress, childrenUnchanged, recyclableInstance);\n          if (finalizeInitialChildren(newInstance, type, newProps, rootContainerInstance)) {\n            markUpdate(workInProgress);\n          }\n          workInProgress.stateNode = newInstance;\n          if (childrenUnchanged) {\n            // If there are no other effects in this tree, we need to flag this node as having one.\n            // Even though we're not going to use it for anything.\n            // Otherwise parents won't know that there are new children to propagate upwards.\n            markUpdate(workInProgress);\n          } else {\n            // If children might have changed, we have to add them all to the set.\n            appendAllChildren(newInstance, workInProgress);\n          }\n        }\n      };\n      updateHostText = function (current, workInProgress, oldText, newText) {\n        if (oldText !== newText) {\n          // If the text content differs, we'll create a new text instance for it.\n          var rootContainerInstance = getRootHostContainer();\n          var currentHostContext = getHostContext();\n          workInProgress.stateNode = createTextInstance(newText, rootContainerInstance, currentHostContext, workInProgress);\n          // We'll have to mark it as having an effect, even though we won't use the effect for anything.\n          // This lets the parents know that at least one of their children has changed.\n          markUpdate(workInProgress);\n        }\n      };\n    } else {\n      invariant(false, 'Persistent reconciler is disabled.');\n    }\n  } else {\n    if (enableNoopReconciler) {\n      // No host operations\n      updateHostContainer = function (workInProgress) {\n        // Noop\n      };\n      updateHostComponent = function (current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance) {\n        // Noop\n      };\n      updateHostText = function (current, workInProgress, oldText, newText) {\n        // Noop\n      };\n    } else {\n      invariant(false, 'Noop reconciler is disabled.');\n    }\n  }\n\n  function completeWork(current, workInProgress, renderExpirationTime) {\n    // Get the latest props.\n    var newProps = workInProgress.pendingProps;\n    if (newProps === null) {\n      newProps = workInProgress.memoizedProps;\n    } else if (workInProgress.expirationTime !== Never || renderExpirationTime === Never) {\n      // Reset the pending props, unless this was a down-prioritization.\n      workInProgress.pendingProps = null;\n    }\n\n    switch (workInProgress.tag) {\n      case FunctionalComponent:\n        return null;\n      case ClassComponent:\n        {\n          // We are leaving this subtree, so pop context if any.\n          popContextProvider(workInProgress);\n          return null;\n        }\n      case HostRoot:\n        {\n          popHostContainer(workInProgress);\n          popTopLevelContextObject(workInProgress);\n          var fiberRoot = workInProgress.stateNode;\n          if (fiberRoot.pendingContext) {\n            fiberRoot.context = fiberRoot.pendingContext;\n            fiberRoot.pendingContext = null;\n          }\n\n          if (current === null || current.child === null) {\n            // If we hydrated, pop so that we can delete any remaining children\n            // that weren't hydrated.\n            popHydrationState(workInProgress);\n            // This resets the hacky state to fix isMounted before committing.\n            // TODO: Delete this when we delete isMounted and findDOMNode.\n            workInProgress.effectTag &= ~Placement;\n          }\n          updateHostContainer(workInProgress);\n          return null;\n        }\n      case HostComponent:\n        {\n          popHostContext(workInProgress);\n          var rootContainerInstance = getRootHostContainer();\n          var type = workInProgress.type;\n          if (current !== null && workInProgress.stateNode != null) {\n            // If we have an alternate, that means this is an update and we need to\n            // schedule a side-effect to do the updates.\n            var oldProps = current.memoizedProps;\n            // If we get updated because one of our children updated, we don't\n            // have newProps so we'll have to reuse them.\n            // TODO: Split the update API as separate for the props vs. children.\n            // Even better would be if children weren't special cased at all tho.\n            var instance = workInProgress.stateNode;\n            var currentHostContext = getHostContext();\n            var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);\n\n            updateHostComponent(current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance);\n\n            if (current.ref !== workInProgress.ref) {\n              markRef(workInProgress);\n            }\n          } else {\n            if (!newProps) {\n              !(workInProgress.stateNode !== null) ? invariant(false, 'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n              // This can happen when we abort work.\n              return null;\n            }\n\n            var _currentHostContext = getHostContext();\n            // TODO: Move createInstance to beginWork and keep it on a context\n            // \"stack\" as the parent. Then append children as we go in beginWork\n            // or completeWork depending on we want to add then top->down or\n            // bottom->up. Top->down is faster in IE11.\n            var wasHydrated = popHydrationState(workInProgress);\n            if (wasHydrated) {\n              // TODO: Move this and createInstance step into the beginPhase\n              // to consolidate.\n              if (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, _currentHostContext)) {\n                // If changes to the hydrated node needs to be applied at the\n                // commit-phase we mark this as such.\n                markUpdate(workInProgress);\n              }\n            } else {\n              var _instance = createInstance(type, newProps, rootContainerInstance, _currentHostContext, workInProgress);\n\n              appendAllChildren(_instance, workInProgress);\n\n              // Certain renderers require commit-time effects for initial mount.\n              // (eg DOM renderer supports auto-focus for certain elements).\n              // Make sure such renderers get scheduled for later work.\n              if (finalizeInitialChildren(_instance, type, newProps, rootContainerInstance)) {\n                markUpdate(workInProgress);\n              }\n              workInProgress.stateNode = _instance;\n            }\n\n            if (workInProgress.ref !== null) {\n              // If there is a ref on a host node we need to schedule a callback\n              markRef(workInProgress);\n            }\n          }\n          return null;\n        }\n      case HostText:\n        {\n          var newText = newProps;\n          if (current && workInProgress.stateNode != null) {\n            var oldText = current.memoizedProps;\n            // If we have an alternate, that means this is an update and we need\n            // to schedule a side-effect to do the updates.\n            updateHostText(current, workInProgress, oldText, newText);\n          } else {\n            if (typeof newText !== 'string') {\n              !(workInProgress.stateNode !== null) ? invariant(false, 'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n              // This can happen when we abort work.\n              return null;\n            }\n            var _rootContainerInstance = getRootHostContainer();\n            var _currentHostContext2 = getHostContext();\n            var _wasHydrated = popHydrationState(workInProgress);\n            if (_wasHydrated) {\n              if (prepareToHydrateHostTextInstance(workInProgress)) {\n                markUpdate(workInProgress);\n              }\n            } else {\n              workInProgress.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext2, workInProgress);\n            }\n          }\n          return null;\n        }\n      case CallComponent:\n        return moveCallToHandlerPhase(current, workInProgress, renderExpirationTime);\n      case CallHandlerPhase:\n        // Reset the tag to now be a first phase call.\n        workInProgress.tag = CallComponent;\n        return null;\n      case ReturnComponent:\n        // Does nothing.\n        return null;\n      case Fragment:\n        return null;\n      case HostPortal:\n        popHostContainer(workInProgress);\n        updateHostContainer(workInProgress);\n        return null;\n      // Error cases\n      case IndeterminateComponent:\n        invariant(false, 'An indeterminate component should have become determinate before completing. This error is likely caused by a bug in React. Please file an issue.');\n      // eslint-disable-next-line no-fallthrough\n      default:\n        invariant(false, 'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');\n    }\n  }\n\n  return {\n    completeWork: completeWork\n  };\n};\n\nvar invokeGuardedCallback$2 = ReactErrorUtils.invokeGuardedCallback;\nvar hasCaughtError$1 = ReactErrorUtils.hasCaughtError;\nvar clearCaughtError$1 = ReactErrorUtils.clearCaughtError;\n\n\nvar ReactFiberCommitWork = function (config, captureError) {\n  var getPublicInstance = config.getPublicInstance,\n      mutation = config.mutation,\n      persistence = config.persistence;\n\n\n  var callComponentWillUnmountWithTimer = function (current, instance) {\n    startPhaseTimer(current, 'componentWillUnmount');\n    instance.props = current.memoizedProps;\n    instance.state = current.memoizedState;\n    instance.componentWillUnmount();\n    stopPhaseTimer();\n  };\n\n  // Capture errors so they don't interrupt unmounting.\n  function safelyCallComponentWillUnmount(current, instance) {\n    {\n      invokeGuardedCallback$2(null, callComponentWillUnmountWithTimer, null, current, instance);\n      if (hasCaughtError$1()) {\n        var unmountError = clearCaughtError$1();\n        captureError(current, unmountError);\n      }\n    }\n  }\n\n  function safelyDetachRef(current) {\n    var ref = current.ref;\n    if (ref !== null) {\n      {\n        invokeGuardedCallback$2(null, ref, null, null);\n        if (hasCaughtError$1()) {\n          var refError = clearCaughtError$1();\n          captureError(current, refError);\n        }\n      }\n    }\n  }\n\n  function commitLifeCycles(current, finishedWork) {\n    switch (finishedWork.tag) {\n      case ClassComponent:\n        {\n          var instance = finishedWork.stateNode;\n          if (finishedWork.effectTag & Update) {\n            if (current === null) {\n              startPhaseTimer(finishedWork, 'componentDidMount');\n              instance.props = finishedWork.memoizedProps;\n              instance.state = finishedWork.memoizedState;\n              instance.componentDidMount();\n              stopPhaseTimer();\n            } else {\n              var prevProps = current.memoizedProps;\n              var prevState = current.memoizedState;\n              startPhaseTimer(finishedWork, 'componentDidUpdate');\n              instance.props = finishedWork.memoizedProps;\n              instance.state = finishedWork.memoizedState;\n              instance.componentDidUpdate(prevProps, prevState);\n              stopPhaseTimer();\n            }\n          }\n          var updateQueue = finishedWork.updateQueue;\n          if (updateQueue !== null) {\n            commitCallbacks(updateQueue, instance);\n          }\n          return;\n        }\n      case HostRoot:\n        {\n          var _updateQueue = finishedWork.updateQueue;\n          if (_updateQueue !== null) {\n            var _instance = finishedWork.child !== null ? finishedWork.child.stateNode : null;\n            commitCallbacks(_updateQueue, _instance);\n          }\n          return;\n        }\n      case HostComponent:\n        {\n          var _instance2 = finishedWork.stateNode;\n\n          // Renderers may schedule work to be done after host components are mounted\n          // (eg DOM renderer may schedule auto-focus for inputs and form controls).\n          // These effects should only be committed when components are first mounted,\n          // aka when there is no current/alternate.\n          if (current === null && finishedWork.effectTag & Update) {\n            var type = finishedWork.type;\n            var props = finishedWork.memoizedProps;\n            commitMount(_instance2, type, props, finishedWork);\n          }\n\n          return;\n        }\n      case HostText:\n        {\n          // We have no life-cycles associated with text.\n          return;\n        }\n      case HostPortal:\n        {\n          // We have no life-cycles associated with portals.\n          return;\n        }\n      default:\n        {\n          invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');\n        }\n    }\n  }\n\n  function commitAttachRef(finishedWork) {\n    var ref = finishedWork.ref;\n    if (ref !== null) {\n      var instance = finishedWork.stateNode;\n      switch (finishedWork.tag) {\n        case HostComponent:\n          ref(getPublicInstance(instance));\n          break;\n        default:\n          ref(instance);\n      }\n    }\n  }\n\n  function commitDetachRef(current) {\n    var currentRef = current.ref;\n    if (currentRef !== null) {\n      currentRef(null);\n    }\n  }\n\n  // User-originating errors (lifecycles and refs) should not interrupt\n  // deletion, so don't let them throw. Host-originating errors should\n  // interrupt deletion, so it's okay\n  function commitUnmount(current) {\n    if (typeof onCommitUnmount === 'function') {\n      onCommitUnmount(current);\n    }\n\n    switch (current.tag) {\n      case ClassComponent:\n        {\n          safelyDetachRef(current);\n          var instance = current.stateNode;\n          if (typeof instance.componentWillUnmount === 'function') {\n            safelyCallComponentWillUnmount(current, instance);\n          }\n          return;\n        }\n      case HostComponent:\n        {\n          safelyDetachRef(current);\n          return;\n        }\n      case CallComponent:\n        {\n          commitNestedUnmounts(current.stateNode);\n          return;\n        }\n      case HostPortal:\n        {\n          // TODO: this is recursive.\n          // We are also not using this parent because\n          // the portal will get pushed immediately.\n          if (enableMutatingReconciler && mutation) {\n            unmountHostComponents(current);\n          } else if (enablePersistentReconciler && persistence) {\n            emptyPortalContainer(current);\n          }\n          return;\n        }\n    }\n  }\n\n  function commitNestedUnmounts(root) {\n    // While we're inside a removed host node we don't want to call\n    // removeChild on the inner nodes because they're removed by the top\n    // call anyway. We also want to call componentWillUnmount on all\n    // composites before this host node is removed from the tree. Therefore\n    var node = root;\n    while (true) {\n      commitUnmount(node);\n      // Visit children because they may contain more composite or host nodes.\n      // Skip portals because commitUnmount() currently visits them recursively.\n      if (node.child !== null && (\n      // If we use mutation we drill down into portals using commitUnmount above.\n      // If we don't use mutation we drill down into portals here instead.\n      !mutation || node.tag !== HostPortal)) {\n        node.child['return'] = node;\n        node = node.child;\n        continue;\n      }\n      if (node === root) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node['return'] === null || node['return'] === root) {\n          return;\n        }\n        node = node['return'];\n      }\n      node.sibling['return'] = node['return'];\n      node = node.sibling;\n    }\n  }\n\n  function detachFiber(current) {\n    // Cut off the return pointers to disconnect it from the tree. Ideally, we\n    // should clear the child pointer of the parent alternate to let this\n    // get GC:ed but we don't know which for sure which parent is the current\n    // one so we'll settle for GC:ing the subtree of this child. This child\n    // itself will be GC:ed when the parent updates the next time.\n    current['return'] = null;\n    current.child = null;\n    if (current.alternate) {\n      current.alternate.child = null;\n      current.alternate['return'] = null;\n    }\n  }\n\n  if (!mutation) {\n    var commitContainer = void 0;\n    if (persistence) {\n      var replaceContainerChildren = persistence.replaceContainerChildren,\n          createContainerChildSet = persistence.createContainerChildSet;\n\n      var emptyPortalContainer = function (current) {\n        var portal = current.stateNode;\n        var containerInfo = portal.containerInfo;\n\n        var emptyChildSet = createContainerChildSet(containerInfo);\n        replaceContainerChildren(containerInfo, emptyChildSet);\n      };\n      commitContainer = function (finishedWork) {\n        switch (finishedWork.tag) {\n          case ClassComponent:\n            {\n              return;\n            }\n          case HostComponent:\n            {\n              return;\n            }\n          case HostText:\n            {\n              return;\n            }\n          case HostRoot:\n          case HostPortal:\n            {\n              var portalOrRoot = finishedWork.stateNode;\n              var containerInfo = portalOrRoot.containerInfo,\n                  _pendingChildren = portalOrRoot.pendingChildren;\n\n              replaceContainerChildren(containerInfo, _pendingChildren);\n              return;\n            }\n          default:\n            {\n              invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');\n            }\n        }\n      };\n    } else {\n      commitContainer = function (finishedWork) {\n        // Noop\n      };\n    }\n    if (enablePersistentReconciler || enableNoopReconciler) {\n      return {\n        commitResetTextContent: function (finishedWork) {},\n        commitPlacement: function (finishedWork) {},\n        commitDeletion: function (current) {\n          // Detach refs and call componentWillUnmount() on the whole subtree.\n          commitNestedUnmounts(current);\n          detachFiber(current);\n        },\n        commitWork: function (current, finishedWork) {\n          commitContainer(finishedWork);\n        },\n\n        commitLifeCycles: commitLifeCycles,\n        commitAttachRef: commitAttachRef,\n        commitDetachRef: commitDetachRef\n      };\n    } else if (persistence) {\n      invariant(false, 'Persistent reconciler is disabled.');\n    } else {\n      invariant(false, 'Noop reconciler is disabled.');\n    }\n  }\n  var commitMount = mutation.commitMount,\n      commitUpdate = mutation.commitUpdate,\n      resetTextContent = mutation.resetTextContent,\n      commitTextUpdate = mutation.commitTextUpdate,\n      appendChild = mutation.appendChild,\n      appendChildToContainer = mutation.appendChildToContainer,\n      insertBefore = mutation.insertBefore,\n      insertInContainerBefore = mutation.insertInContainerBefore,\n      removeChild = mutation.removeChild,\n      removeChildFromContainer = mutation.removeChildFromContainer;\n\n\n  function getHostParentFiber(fiber) {\n    var parent = fiber['return'];\n    while (parent !== null) {\n      if (isHostParent(parent)) {\n        return parent;\n      }\n      parent = parent['return'];\n    }\n    invariant(false, 'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.');\n  }\n\n  function isHostParent(fiber) {\n    return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;\n  }\n\n  function getHostSibling(fiber) {\n    // We're going to search forward into the tree until we find a sibling host\n    // node. Unfortunately, if multiple insertions are done in a row we have to\n    // search past them. This leads to exponential search for the next sibling.\n    var node = fiber;\n    siblings: while (true) {\n      // If we didn't find anything, let's try the next sibling.\n      while (node.sibling === null) {\n        if (node['return'] === null || isHostParent(node['return'])) {\n          // If we pop out of the root or hit the parent the fiber we are the\n          // last sibling.\n          return null;\n        }\n        node = node['return'];\n      }\n      node.sibling['return'] = node['return'];\n      node = node.sibling;\n      while (node.tag !== HostComponent && node.tag !== HostText) {\n        // If it is not host node and, we might have a host node inside it.\n        // Try to search down until we find one.\n        if (node.effectTag & Placement) {\n          // If we don't have a child, try the siblings instead.\n          continue siblings;\n        }\n        // If we don't have a child, try the siblings instead.\n        // We also skip portals because they are not part of this host tree.\n        if (node.child === null || node.tag === HostPortal) {\n          continue siblings;\n        } else {\n          node.child['return'] = node;\n          node = node.child;\n        }\n      }\n      // Check if this host node is stable or about to be placed.\n      if (!(node.effectTag & Placement)) {\n        // Found it!\n        return node.stateNode;\n      }\n    }\n  }\n\n  function commitPlacement(finishedWork) {\n    // Recursively insert all host nodes into the parent.\n    var parentFiber = getHostParentFiber(finishedWork);\n    var parent = void 0;\n    var isContainer = void 0;\n    switch (parentFiber.tag) {\n      case HostComponent:\n        parent = parentFiber.stateNode;\n        isContainer = false;\n        break;\n      case HostRoot:\n        parent = parentFiber.stateNode.containerInfo;\n        isContainer = true;\n        break;\n      case HostPortal:\n        parent = parentFiber.stateNode.containerInfo;\n        isContainer = true;\n        break;\n      default:\n        invariant(false, 'Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.');\n    }\n    if (parentFiber.effectTag & ContentReset) {\n      // Reset the text content of the parent before doing any insertions\n      resetTextContent(parent);\n      // Clear ContentReset from the effect tag\n      parentFiber.effectTag &= ~ContentReset;\n    }\n\n    var before = getHostSibling(finishedWork);\n    // We only have the top Fiber that was inserted but we need recurse down its\n    // children to find all the terminal nodes.\n    var node = finishedWork;\n    while (true) {\n      if (node.tag === HostComponent || node.tag === HostText) {\n        if (before) {\n          if (isContainer) {\n            insertInContainerBefore(parent, node.stateNode, before);\n          } else {\n            insertBefore(parent, node.stateNode, before);\n          }\n        } else {\n          if (isContainer) {\n            appendChildToContainer(parent, node.stateNode);\n          } else {\n            appendChild(parent, node.stateNode);\n          }\n        }\n      } else if (node.tag === HostPortal) {\n        // If the insertion itself is a portal, then we don't want to traverse\n        // down its children. Instead, we'll get insertions from each child in\n        // the portal directly.\n      } else if (node.child !== null) {\n        node.child['return'] = node;\n        node = node.child;\n        continue;\n      }\n      if (node === finishedWork) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node['return'] === null || node['return'] === finishedWork) {\n          return;\n        }\n        node = node['return'];\n      }\n      node.sibling['return'] = node['return'];\n      node = node.sibling;\n    }\n  }\n\n  function unmountHostComponents(current) {\n    // We only have the top Fiber that was inserted but we need recurse down its\n    var node = current;\n\n    // Each iteration, currentParent is populated with node's host parent if not\n    // currentParentIsValid.\n    var currentParentIsValid = false;\n    var currentParent = void 0;\n    var currentParentIsContainer = void 0;\n\n    while (true) {\n      if (!currentParentIsValid) {\n        var parent = node['return'];\n        findParent: while (true) {\n          !(parent !== null) ? invariant(false, 'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n          switch (parent.tag) {\n            case HostComponent:\n              currentParent = parent.stateNode;\n              currentParentIsContainer = false;\n              break findParent;\n            case HostRoot:\n              currentParent = parent.stateNode.containerInfo;\n              currentParentIsContainer = true;\n              break findParent;\n            case HostPortal:\n              currentParent = parent.stateNode.containerInfo;\n              currentParentIsContainer = true;\n              break findParent;\n          }\n          parent = parent['return'];\n        }\n        currentParentIsValid = true;\n      }\n\n      if (node.tag === HostComponent || node.tag === HostText) {\n        commitNestedUnmounts(node);\n        // After all the children have unmounted, it is now safe to remove the\n        // node from the tree.\n        if (currentParentIsContainer) {\n          removeChildFromContainer(currentParent, node.stateNode);\n        } else {\n          removeChild(currentParent, node.stateNode);\n        }\n        // Don't visit children because we already visited them.\n      } else if (node.tag === HostPortal) {\n        // When we go into a portal, it becomes the parent to remove from.\n        // We will reassign it back when we pop the portal on the way up.\n        currentParent = node.stateNode.containerInfo;\n        // Visit children because portals might contain host components.\n        if (node.child !== null) {\n          node.child['return'] = node;\n          node = node.child;\n          continue;\n        }\n      } else {\n        commitUnmount(node);\n        // Visit children because we may find more host components below.\n        if (node.child !== null) {\n          node.child['return'] = node;\n          node = node.child;\n          continue;\n        }\n      }\n      if (node === current) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node['return'] === null || node['return'] === current) {\n          return;\n        }\n        node = node['return'];\n        if (node.tag === HostPortal) {\n          // When we go out of the portal, we need to restore the parent.\n          // Since we don't keep a stack of them, we will search for it.\n          currentParentIsValid = false;\n        }\n      }\n      node.sibling['return'] = node['return'];\n      node = node.sibling;\n    }\n  }\n\n  function commitDeletion(current) {\n    // Recursively delete all host nodes from the parent.\n    // Detach refs and call componentWillUnmount() on the whole subtree.\n    unmountHostComponents(current);\n    detachFiber(current);\n  }\n\n  function commitWork(current, finishedWork) {\n    switch (finishedWork.tag) {\n      case ClassComponent:\n        {\n          return;\n        }\n      case HostComponent:\n        {\n          var instance = finishedWork.stateNode;\n          if (instance != null) {\n            // Commit the work prepared earlier.\n            var newProps = finishedWork.memoizedProps;\n            // For hydration we reuse the update path but we treat the oldProps\n            // as the newProps. The updatePayload will contain the real change in\n            // this case.\n            var oldProps = current !== null ? current.memoizedProps : newProps;\n            var type = finishedWork.type;\n            // TODO: Type the updateQueue to be specific to host components.\n            var updatePayload = finishedWork.updateQueue;\n            finishedWork.updateQueue = null;\n            if (updatePayload !== null) {\n              commitUpdate(instance, updatePayload, type, oldProps, newProps, finishedWork);\n            }\n          }\n          return;\n        }\n      case HostText:\n        {\n          !(finishedWork.stateNode !== null) ? invariant(false, 'This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n          var textInstance = finishedWork.stateNode;\n          var newText = finishedWork.memoizedProps;\n          // For hydration we reuse the update path but we treat the oldProps\n          // as the newProps. The updatePayload will contain the real change in\n          // this case.\n          var oldText = current !== null ? current.memoizedProps : newText;\n          commitTextUpdate(textInstance, oldText, newText);\n          return;\n        }\n      case HostRoot:\n        {\n          return;\n        }\n      default:\n        {\n          invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');\n        }\n    }\n  }\n\n  function commitResetTextContent(current) {\n    resetTextContent(current.stateNode);\n  }\n\n  if (enableMutatingReconciler) {\n    return {\n      commitResetTextContent: commitResetTextContent,\n      commitPlacement: commitPlacement,\n      commitDeletion: commitDeletion,\n      commitWork: commitWork,\n      commitLifeCycles: commitLifeCycles,\n      commitAttachRef: commitAttachRef,\n      commitDetachRef: commitDetachRef\n    };\n  } else {\n    invariant(false, 'Mutating reconciler is disabled.');\n  }\n};\n\nvar NO_CONTEXT = {};\n\nvar ReactFiberHostContext = function (config) {\n  var getChildHostContext = config.getChildHostContext,\n      getRootHostContext = config.getRootHostContext;\n\n\n  var contextStackCursor = createCursor(NO_CONTEXT);\n  var contextFiberStackCursor = createCursor(NO_CONTEXT);\n  var rootInstanceStackCursor = createCursor(NO_CONTEXT);\n\n  function requiredContext(c) {\n    !(c !== NO_CONTEXT) ? invariant(false, 'Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    return c;\n  }\n\n  function getRootHostContainer() {\n    var rootInstance = requiredContext(rootInstanceStackCursor.current);\n    return rootInstance;\n  }\n\n  function pushHostContainer(fiber, nextRootInstance) {\n    // Push current root instance onto the stack;\n    // This allows us to reset root when portals are popped.\n    push(rootInstanceStackCursor, nextRootInstance, fiber);\n\n    var nextRootContext = getRootHostContext(nextRootInstance);\n\n    // Track the context and the Fiber that provided it.\n    // This enables us to pop only Fibers that provide unique contexts.\n    push(contextFiberStackCursor, fiber, fiber);\n    push(contextStackCursor, nextRootContext, fiber);\n  }\n\n  function popHostContainer(fiber) {\n    pop(contextStackCursor, fiber);\n    pop(contextFiberStackCursor, fiber);\n    pop(rootInstanceStackCursor, fiber);\n  }\n\n  function getHostContext() {\n    var context = requiredContext(contextStackCursor.current);\n    return context;\n  }\n\n  function pushHostContext(fiber) {\n    var rootInstance = requiredContext(rootInstanceStackCursor.current);\n    var context = requiredContext(contextStackCursor.current);\n    var nextContext = getChildHostContext(context, fiber.type, rootInstance);\n\n    // Don't push this Fiber's context unless it's unique.\n    if (context === nextContext) {\n      return;\n    }\n\n    // Track the context and the Fiber that provided it.\n    // This enables us to pop only Fibers that provide unique contexts.\n    push(contextFiberStackCursor, fiber, fiber);\n    push(contextStackCursor, nextContext, fiber);\n  }\n\n  function popHostContext(fiber) {\n    // Do not pop unless this Fiber provided the current context.\n    // pushHostContext() only pushes Fibers that provide unique contexts.\n    if (contextFiberStackCursor.current !== fiber) {\n      return;\n    }\n\n    pop(contextStackCursor, fiber);\n    pop(contextFiberStackCursor, fiber);\n  }\n\n  function resetHostContainer() {\n    contextStackCursor.current = NO_CONTEXT;\n    rootInstanceStackCursor.current = NO_CONTEXT;\n  }\n\n  return {\n    getHostContext: getHostContext,\n    getRootHostContainer: getRootHostContainer,\n    popHostContainer: popHostContainer,\n    popHostContext: popHostContext,\n    pushHostContainer: pushHostContainer,\n    pushHostContext: pushHostContext,\n    resetHostContainer: resetHostContainer\n  };\n};\n\nvar ReactFiberHydrationContext = function (config) {\n  var shouldSetTextContent = config.shouldSetTextContent,\n      hydration = config.hydration;\n\n  // If this doesn't have hydration mode.\n\n  if (!hydration) {\n    return {\n      enterHydrationState: function () {\n        return false;\n      },\n      resetHydrationState: function () {},\n      tryToClaimNextHydratableInstance: function () {},\n      prepareToHydrateHostInstance: function () {\n        invariant(false, 'Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');\n      },\n      prepareToHydrateHostTextInstance: function () {\n        invariant(false, 'Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');\n      },\n      popHydrationState: function (fiber) {\n        return false;\n      }\n    };\n  }\n\n  var canHydrateInstance = hydration.canHydrateInstance,\n      canHydrateTextInstance = hydration.canHydrateTextInstance,\n      getNextHydratableSibling = hydration.getNextHydratableSibling,\n      getFirstHydratableChild = hydration.getFirstHydratableChild,\n      hydrateInstance = hydration.hydrateInstance,\n      hydrateTextInstance = hydration.hydrateTextInstance,\n      didNotMatchHydratedContainerTextInstance = hydration.didNotMatchHydratedContainerTextInstance,\n      didNotMatchHydratedTextInstance = hydration.didNotMatchHydratedTextInstance,\n      didNotHydrateContainerInstance = hydration.didNotHydrateContainerInstance,\n      didNotHydrateInstance = hydration.didNotHydrateInstance,\n      didNotFindHydratableContainerInstance = hydration.didNotFindHydratableContainerInstance,\n      didNotFindHydratableContainerTextInstance = hydration.didNotFindHydratableContainerTextInstance,\n      didNotFindHydratableInstance = hydration.didNotFindHydratableInstance,\n      didNotFindHydratableTextInstance = hydration.didNotFindHydratableTextInstance;\n\n  // The deepest Fiber on the stack involved in a hydration context.\n  // This may have been an insertion or a hydration.\n\n  var hydrationParentFiber = null;\n  var nextHydratableInstance = null;\n  var isHydrating = false;\n\n  function enterHydrationState(fiber) {\n    var parentInstance = fiber.stateNode.containerInfo;\n    nextHydratableInstance = getFirstHydratableChild(parentInstance);\n    hydrationParentFiber = fiber;\n    isHydrating = true;\n    return true;\n  }\n\n  function deleteHydratableInstance(returnFiber, instance) {\n    {\n      switch (returnFiber.tag) {\n        case HostRoot:\n          didNotHydrateContainerInstance(returnFiber.stateNode.containerInfo, instance);\n          break;\n        case HostComponent:\n          didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance);\n          break;\n      }\n    }\n\n    var childToDelete = createFiberFromHostInstanceForDeletion();\n    childToDelete.stateNode = instance;\n    childToDelete['return'] = returnFiber;\n    childToDelete.effectTag = Deletion;\n\n    // This might seem like it belongs on progressedFirstDeletion. However,\n    // these children are not part of the reconciliation list of children.\n    // Even if we abort and rereconcile the children, that will try to hydrate\n    // again and the nodes are still in the host tree so these will be\n    // recreated.\n    if (returnFiber.lastEffect !== null) {\n      returnFiber.lastEffect.nextEffect = childToDelete;\n      returnFiber.lastEffect = childToDelete;\n    } else {\n      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;\n    }\n  }\n\n  function insertNonHydratedInstance(returnFiber, fiber) {\n    fiber.effectTag |= Placement;\n    {\n      switch (returnFiber.tag) {\n        case HostRoot:\n          {\n            var parentContainer = returnFiber.stateNode.containerInfo;\n            switch (fiber.tag) {\n              case HostComponent:\n                var type = fiber.type;\n                var props = fiber.pendingProps;\n                didNotFindHydratableContainerInstance(parentContainer, type, props);\n                break;\n              case HostText:\n                var text = fiber.pendingProps;\n                didNotFindHydratableContainerTextInstance(parentContainer, text);\n                break;\n            }\n            break;\n          }\n        case HostComponent:\n          {\n            var parentType = returnFiber.type;\n            var parentProps = returnFiber.memoizedProps;\n            var parentInstance = returnFiber.stateNode;\n            switch (fiber.tag) {\n              case HostComponent:\n                var _type = fiber.type;\n                var _props = fiber.pendingProps;\n                didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type, _props);\n                break;\n              case HostText:\n                var _text = fiber.pendingProps;\n                didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text);\n                break;\n            }\n            break;\n          }\n        default:\n          return;\n      }\n    }\n  }\n\n  function tryHydrate(fiber, nextInstance) {\n    switch (fiber.tag) {\n      case HostComponent:\n        {\n          var type = fiber.type;\n          var props = fiber.pendingProps;\n          var instance = canHydrateInstance(nextInstance, type, props);\n          if (instance !== null) {\n            fiber.stateNode = instance;\n            return true;\n          }\n          return false;\n        }\n      case HostText:\n        {\n          var text = fiber.pendingProps;\n          var textInstance = canHydrateTextInstance(nextInstance, text);\n          if (textInstance !== null) {\n            fiber.stateNode = textInstance;\n            return true;\n          }\n          return false;\n        }\n      default:\n        return false;\n    }\n  }\n\n  function tryToClaimNextHydratableInstance(fiber) {\n    if (!isHydrating) {\n      return;\n    }\n    var nextInstance = nextHydratableInstance;\n    if (!nextInstance) {\n      // Nothing to hydrate. Make it an insertion.\n      insertNonHydratedInstance(hydrationParentFiber, fiber);\n      isHydrating = false;\n      hydrationParentFiber = fiber;\n      return;\n    }\n    if (!tryHydrate(fiber, nextInstance)) {\n      // If we can't hydrate this instance let's try the next one.\n      // We use this as a heuristic. It's based on intuition and not data so it\n      // might be flawed or unnecessary.\n      nextInstance = getNextHydratableSibling(nextInstance);\n      if (!nextInstance || !tryHydrate(fiber, nextInstance)) {\n        // Nothing to hydrate. Make it an insertion.\n        insertNonHydratedInstance(hydrationParentFiber, fiber);\n        isHydrating = false;\n        hydrationParentFiber = fiber;\n        return;\n      }\n      // We matched the next one, we'll now assume that the first one was\n      // superfluous and we'll delete it. Since we can't eagerly delete it\n      // we'll have to schedule a deletion. To do that, this node needs a dummy\n      // fiber associated with it.\n      deleteHydratableInstance(hydrationParentFiber, nextHydratableInstance);\n    }\n    hydrationParentFiber = fiber;\n    nextHydratableInstance = getFirstHydratableChild(nextInstance);\n  }\n\n  function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {\n    var instance = fiber.stateNode;\n    var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber);\n    // TODO: Type this specific to this type of component.\n    fiber.updateQueue = updatePayload;\n    // If the update payload indicates that there is a change or if there\n    // is a new ref we mark this as an update.\n    if (updatePayload !== null) {\n      return true;\n    }\n    return false;\n  }\n\n  function prepareToHydrateHostTextInstance(fiber) {\n    var textInstance = fiber.stateNode;\n    var textContent = fiber.memoizedProps;\n    var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);\n    {\n      if (shouldUpdate) {\n        // We assume that prepareToHydrateHostTextInstance is called in a context where the\n        // hydration parent is the parent host component of this host text.\n        var returnFiber = hydrationParentFiber;\n        if (returnFiber !== null) {\n          switch (returnFiber.tag) {\n            case HostRoot:\n              {\n                var parentContainer = returnFiber.stateNode.containerInfo;\n                didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent);\n                break;\n              }\n            case HostComponent:\n              {\n                var parentType = returnFiber.type;\n                var parentProps = returnFiber.memoizedProps;\n                var parentInstance = returnFiber.stateNode;\n                didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent);\n                break;\n              }\n          }\n        }\n      }\n    }\n    return shouldUpdate;\n  }\n\n  function popToNextHostParent(fiber) {\n    var parent = fiber['return'];\n    while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot) {\n      parent = parent['return'];\n    }\n    hydrationParentFiber = parent;\n  }\n\n  function popHydrationState(fiber) {\n    if (fiber !== hydrationParentFiber) {\n      // We're deeper than the current hydration context, inside an inserted\n      // tree.\n      return false;\n    }\n    if (!isHydrating) {\n      // If we're not currently hydrating but we're in a hydration context, then\n      // we were an insertion and now need to pop up reenter hydration of our\n      // siblings.\n      popToNextHostParent(fiber);\n      isHydrating = true;\n      return false;\n    }\n\n    var type = fiber.type;\n\n    // If we have any remaining hydratable nodes, we need to delete them now.\n    // We only do this deeper than head and body since they tend to have random\n    // other nodes in them. We also ignore components with pure text content in\n    // side of them.\n    // TODO: Better heuristic.\n    if (fiber.tag !== HostComponent || type !== 'head' && type !== 'body' && !shouldSetTextContent(type, fiber.memoizedProps)) {\n      var nextInstance = nextHydratableInstance;\n      while (nextInstance) {\n        deleteHydratableInstance(fiber, nextInstance);\n        nextInstance = getNextHydratableSibling(nextInstance);\n      }\n    }\n\n    popToNextHostParent(fiber);\n    nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;\n    return true;\n  }\n\n  function resetHydrationState() {\n    hydrationParentFiber = null;\n    nextHydratableInstance = null;\n    isHydrating = false;\n  }\n\n  return {\n    enterHydrationState: enterHydrationState,\n    resetHydrationState: resetHydrationState,\n    tryToClaimNextHydratableInstance: tryToClaimNextHydratableInstance,\n    prepareToHydrateHostInstance: prepareToHydrateHostInstance,\n    prepareToHydrateHostTextInstance: prepareToHydrateHostTextInstance,\n    popHydrationState: popHydrationState\n  };\n};\n\n// This lets us hook into Fiber to debug what it's doing.\n// See https://github.com/facebook/react/pull/8033.\n// This is not part of the public API, not even for React DevTools.\n// You may only inject a debugTool if you work on React Fiber itself.\nvar ReactFiberInstrumentation = {\n  debugTool: null\n};\n\nvar ReactFiberInstrumentation_1 = ReactFiberInstrumentation;\n\nvar defaultShowDialog = function (capturedError) {\n  return true;\n};\n\nvar showDialog = defaultShowDialog;\n\nfunction logCapturedError(capturedError) {\n  var logError = showDialog(capturedError);\n\n  // Allow injected showDialog() to prevent default console.error logging.\n  // This enables renderers like ReactNative to better manage redbox behavior.\n  if (logError === false) {\n    return;\n  }\n\n  var error = capturedError.error;\n  var suppressLogging = error && error.suppressReactErrorLogging;\n  if (suppressLogging) {\n    return;\n  }\n\n  {\n    var componentName = capturedError.componentName,\n        componentStack = capturedError.componentStack,\n        errorBoundaryName = capturedError.errorBoundaryName,\n        errorBoundaryFound = capturedError.errorBoundaryFound,\n        willRetry = capturedError.willRetry;\n\n\n    var componentNameMessage = componentName ? 'The above error occurred in the <' + componentName + '> component:' : 'The above error occurred in one of your React components:';\n\n    var errorBoundaryMessage = void 0;\n    // errorBoundaryFound check is sufficient; errorBoundaryName check is to satisfy Flow.\n    if (errorBoundaryFound && errorBoundaryName) {\n      if (willRetry) {\n        errorBoundaryMessage = 'React will try to recreate this component tree from scratch ' + ('using the error boundary you provided, ' + errorBoundaryName + '.');\n      } else {\n        errorBoundaryMessage = 'This error was initially handled by the error boundary ' + errorBoundaryName + '.\\n' + 'Recreating the tree from scratch failed so React will unmount the tree.';\n      }\n    } else {\n      errorBoundaryMessage = 'Consider adding an error boundary to your tree to customize error handling behavior.\\n' + 'Visit https://fb.me/react-error-boundaries to learn more about error boundaries.';\n    }\n    var combinedMessage = '' + componentNameMessage + componentStack + '\\n\\n' + ('' + errorBoundaryMessage);\n\n    // In development, we provide our own message with just the component stack.\n    // We don't include the original error message and JS stack because the browser\n    // has already printed it. Even if the application swallows the error, it is still\n    // displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.\n    console.error(combinedMessage);\n  }\n}\n\nvar invokeGuardedCallback$1 = ReactErrorUtils.invokeGuardedCallback;\nvar hasCaughtError = ReactErrorUtils.hasCaughtError;\nvar clearCaughtError = ReactErrorUtils.clearCaughtError;\n\n\n{\n  var didWarnAboutStateTransition = false;\n  var didWarnSetStateChildContext = false;\n  var didWarnStateUpdateForUnmountedComponent = {};\n\n  var warnAboutUpdateOnUnmounted = function (fiber) {\n    var componentName = getComponentName(fiber) || 'ReactClass';\n    if (didWarnStateUpdateForUnmountedComponent[componentName]) {\n      return;\n    }\n    warning(false, 'Can only update a mounted or mounting ' + 'component. This usually means you called setState, replaceState, ' + 'or forceUpdate on an unmounted component. This is a no-op.\\n\\nPlease ' + 'check the code for the %s component.', componentName);\n    didWarnStateUpdateForUnmountedComponent[componentName] = true;\n  };\n\n  var warnAboutInvalidUpdates = function (instance) {\n    switch (ReactDebugCurrentFiber.phase) {\n      case 'getChildContext':\n        if (didWarnSetStateChildContext) {\n          return;\n        }\n        warning(false, 'setState(...): Cannot call setState() inside getChildContext()');\n        didWarnSetStateChildContext = true;\n        break;\n      case 'render':\n        if (didWarnAboutStateTransition) {\n          return;\n        }\n        warning(false, 'Cannot update during an existing state transition (such as within ' + \"`render` or another component's constructor). Render methods should \" + 'be a pure function of props and state; constructor side-effects are ' + 'an anti-pattern, but can be moved to `componentWillMount`.');\n        didWarnAboutStateTransition = true;\n        break;\n    }\n  };\n}\n\nvar ReactFiberScheduler = function (config) {\n  var hostContext = ReactFiberHostContext(config);\n  var hydrationContext = ReactFiberHydrationContext(config);\n  var popHostContainer = hostContext.popHostContainer,\n      popHostContext = hostContext.popHostContext,\n      resetHostContainer = hostContext.resetHostContainer;\n\n  var _ReactFiberBeginWork = ReactFiberBeginWork(config, hostContext, hydrationContext, scheduleWork, computeExpirationForFiber),\n      beginWork = _ReactFiberBeginWork.beginWork,\n      beginFailedWork = _ReactFiberBeginWork.beginFailedWork;\n\n  var _ReactFiberCompleteWo = ReactFiberCompleteWork(config, hostContext, hydrationContext),\n      completeWork = _ReactFiberCompleteWo.completeWork;\n\n  var _ReactFiberCommitWork = ReactFiberCommitWork(config, captureError),\n      commitResetTextContent = _ReactFiberCommitWork.commitResetTextContent,\n      commitPlacement = _ReactFiberCommitWork.commitPlacement,\n      commitDeletion = _ReactFiberCommitWork.commitDeletion,\n      commitWork = _ReactFiberCommitWork.commitWork,\n      commitLifeCycles = _ReactFiberCommitWork.commitLifeCycles,\n      commitAttachRef = _ReactFiberCommitWork.commitAttachRef,\n      commitDetachRef = _ReactFiberCommitWork.commitDetachRef;\n\n  var now = config.now,\n      scheduleDeferredCallback = config.scheduleDeferredCallback,\n      cancelDeferredCallback = config.cancelDeferredCallback,\n      useSyncScheduling = config.useSyncScheduling,\n      prepareForCommit = config.prepareForCommit,\n      resetAfterCommit = config.resetAfterCommit;\n\n  // Represents the current time in ms.\n\n  var startTime = now();\n  var mostRecentCurrentTime = msToExpirationTime(0);\n\n  // Represents the expiration time that incoming updates should use. (If this\n  // is NoWork, use the default strategy: async updates in async mode, sync\n  // updates in sync mode.)\n  var expirationContext = NoWork;\n\n  var isWorking = false;\n\n  // The next work in progress fiber that we're currently working on.\n  var nextUnitOfWork = null;\n  var nextRoot = null;\n  // The time at which we're currently rendering work.\n  var nextRenderExpirationTime = NoWork;\n\n  // The next fiber with an effect that we're currently committing.\n  var nextEffect = null;\n\n  // Keep track of which fibers have captured an error that need to be handled.\n  // Work is removed from this collection after componentDidCatch is called.\n  var capturedErrors = null;\n  // Keep track of which fibers have failed during the current batch of work.\n  // This is a different set than capturedErrors, because it is not reset until\n  // the end of the batch. This is needed to propagate errors correctly if a\n  // subtree fails more than once.\n  var failedBoundaries = null;\n  // Error boundaries that captured an error during the current commit.\n  var commitPhaseBoundaries = null;\n  var firstUncaughtError = null;\n  var didFatal = false;\n\n  var isCommitting = false;\n  var isUnmounting = false;\n\n  // Used for performance tracking.\n  var interruptedBy = null;\n\n  function resetContextStack() {\n    // Reset the stack\n    reset$1();\n    // Reset the cursors\n    resetContext();\n    resetHostContainer();\n  }\n\n  function commitAllHostEffects() {\n    while (nextEffect !== null) {\n      {\n        ReactDebugCurrentFiber.setCurrentFiber(nextEffect);\n      }\n      recordEffect();\n\n      var effectTag = nextEffect.effectTag;\n      if (effectTag & ContentReset) {\n        commitResetTextContent(nextEffect);\n      }\n\n      if (effectTag & Ref) {\n        var current = nextEffect.alternate;\n        if (current !== null) {\n          commitDetachRef(current);\n        }\n      }\n\n      // The following switch statement is only concerned about placement,\n      // updates, and deletions. To avoid needing to add a case for every\n      // possible bitmap value, we remove the secondary effects from the\n      // effect tag and switch on that value.\n      var primaryEffectTag = effectTag & ~(Callback | Err | ContentReset | Ref | PerformedWork);\n      switch (primaryEffectTag) {\n        case Placement:\n          {\n            commitPlacement(nextEffect);\n            // Clear the \"placement\" from effect tag so that we know that this is inserted, before\n            // any life-cycles like componentDidMount gets called.\n            // TODO: findDOMNode doesn't rely on this any more but isMounted\n            // does and isMounted is deprecated anyway so we should be able\n            // to kill this.\n            nextEffect.effectTag &= ~Placement;\n            break;\n          }\n        case PlacementAndUpdate:\n          {\n            // Placement\n            commitPlacement(nextEffect);\n            // Clear the \"placement\" from effect tag so that we know that this is inserted, before\n            // any life-cycles like componentDidMount gets called.\n            nextEffect.effectTag &= ~Placement;\n\n            // Update\n            var _current = nextEffect.alternate;\n            commitWork(_current, nextEffect);\n            break;\n          }\n        case Update:\n          {\n            var _current2 = nextEffect.alternate;\n            commitWork(_current2, nextEffect);\n            break;\n          }\n        case Deletion:\n          {\n            isUnmounting = true;\n            commitDeletion(nextEffect);\n            isUnmounting = false;\n            break;\n          }\n      }\n      nextEffect = nextEffect.nextEffect;\n    }\n\n    {\n      ReactDebugCurrentFiber.resetCurrentFiber();\n    }\n  }\n\n  function commitAllLifeCycles() {\n    while (nextEffect !== null) {\n      var effectTag = nextEffect.effectTag;\n\n      if (effectTag & (Update | Callback)) {\n        recordEffect();\n        var current = nextEffect.alternate;\n        commitLifeCycles(current, nextEffect);\n      }\n\n      if (effectTag & Ref) {\n        recordEffect();\n        commitAttachRef(nextEffect);\n      }\n\n      if (effectTag & Err) {\n        recordEffect();\n        commitErrorHandling(nextEffect);\n      }\n\n      var next = nextEffect.nextEffect;\n      // Ensure that we clean these up so that we don't accidentally keep them.\n      // I'm not actually sure this matters because we can't reset firstEffect\n      // and lastEffect since they're on every node, not just the effectful\n      // ones. So we have to clean everything as we reuse nodes anyway.\n      nextEffect.nextEffect = null;\n      // Ensure that we reset the effectTag here so that we can rely on effect\n      // tags to reason about the current life-cycle.\n      nextEffect = next;\n    }\n  }\n\n  function commitRoot(finishedWork) {\n    // We keep track of this so that captureError can collect any boundaries\n    // that capture an error during the commit phase. The reason these aren't\n    // local to this function is because errors that occur during cWU are\n    // captured elsewhere, to prevent the unmount from being interrupted.\n    isWorking = true;\n    isCommitting = true;\n    startCommitTimer();\n\n    var root = finishedWork.stateNode;\n    !(root.current !== finishedWork) ? invariant(false, 'Cannot commit the same tree as before. This is probably a bug related to the return field. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    root.isReadyForCommit = false;\n\n    // Reset this to null before calling lifecycles\n    ReactCurrentOwner.current = null;\n\n    var firstEffect = void 0;\n    if (finishedWork.effectTag > PerformedWork) {\n      // A fiber's effect list consists only of its children, not itself. So if\n      // the root has an effect, we need to add it to the end of the list. The\n      // resulting list is the set that would belong to the root's parent, if\n      // it had one; that is, all the effects in the tree including the root.\n      if (finishedWork.lastEffect !== null) {\n        finishedWork.lastEffect.nextEffect = finishedWork;\n        firstEffect = finishedWork.firstEffect;\n      } else {\n        firstEffect = finishedWork;\n      }\n    } else {\n      // There is no effect on the root.\n      firstEffect = finishedWork.firstEffect;\n    }\n\n    prepareForCommit();\n\n    // Commit all the side-effects within a tree. We'll do this in two passes.\n    // The first pass performs all the host insertions, updates, deletions and\n    // ref unmounts.\n    nextEffect = firstEffect;\n    startCommitHostEffectsTimer();\n    while (nextEffect !== null) {\n      var didError = false;\n      var _error = void 0;\n      {\n        invokeGuardedCallback$1(null, commitAllHostEffects, null);\n        if (hasCaughtError()) {\n          didError = true;\n          _error = clearCaughtError();\n        }\n      }\n      if (didError) {\n        !(nextEffect !== null) ? invariant(false, 'Should have next effect. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        captureError(nextEffect, _error);\n        // Clean-up\n        if (nextEffect !== null) {\n          nextEffect = nextEffect.nextEffect;\n        }\n      }\n    }\n    stopCommitHostEffectsTimer();\n\n    resetAfterCommit();\n\n    // The work-in-progress tree is now the current tree. This must come after\n    // the first pass of the commit phase, so that the previous tree is still\n    // current during componentWillUnmount, but before the second pass, so that\n    // the finished work is current during componentDidMount/Update.\n    root.current = finishedWork;\n\n    // In the second pass we'll perform all life-cycles and ref callbacks.\n    // Life-cycles happen as a separate pass so that all placements, updates,\n    // and deletions in the entire tree have already been invoked.\n    // This pass also triggers any renderer-specific initial effects.\n    nextEffect = firstEffect;\n    startCommitLifeCyclesTimer();\n    while (nextEffect !== null) {\n      var _didError = false;\n      var _error2 = void 0;\n      {\n        invokeGuardedCallback$1(null, commitAllLifeCycles, null);\n        if (hasCaughtError()) {\n          _didError = true;\n          _error2 = clearCaughtError();\n        }\n      }\n      if (_didError) {\n        !(nextEffect !== null) ? invariant(false, 'Should have next effect. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        captureError(nextEffect, _error2);\n        if (nextEffect !== null) {\n          nextEffect = nextEffect.nextEffect;\n        }\n      }\n    }\n\n    isCommitting = false;\n    isWorking = false;\n    stopCommitLifeCyclesTimer();\n    stopCommitTimer();\n    if (typeof onCommitRoot === 'function') {\n      onCommitRoot(finishedWork.stateNode);\n    }\n    if (true && ReactFiberInstrumentation_1.debugTool) {\n      ReactFiberInstrumentation_1.debugTool.onCommitWork(finishedWork);\n    }\n\n    // If we caught any errors during this commit, schedule their boundaries\n    // to update.\n    if (commitPhaseBoundaries) {\n      commitPhaseBoundaries.forEach(scheduleErrorRecovery);\n      commitPhaseBoundaries = null;\n    }\n\n    if (firstUncaughtError !== null) {\n      var _error3 = firstUncaughtError;\n      firstUncaughtError = null;\n      onUncaughtError(_error3);\n    }\n\n    var remainingTime = root.current.expirationTime;\n\n    if (remainingTime === NoWork) {\n      capturedErrors = null;\n      failedBoundaries = null;\n    }\n\n    return remainingTime;\n  }\n\n  function resetExpirationTime(workInProgress, renderTime) {\n    if (renderTime !== Never && workInProgress.expirationTime === Never) {\n      // The children of this component are hidden. Don't bubble their\n      // expiration times.\n      return;\n    }\n\n    // Check for pending updates.\n    var newExpirationTime = getUpdateExpirationTime(workInProgress);\n\n    // TODO: Calls need to visit stateNode\n\n    // Bubble up the earliest expiration time.\n    var child = workInProgress.child;\n    while (child !== null) {\n      if (child.expirationTime !== NoWork && (newExpirationTime === NoWork || newExpirationTime > child.expirationTime)) {\n        newExpirationTime = child.expirationTime;\n      }\n      child = child.sibling;\n    }\n    workInProgress.expirationTime = newExpirationTime;\n  }\n\n  function completeUnitOfWork(workInProgress) {\n    while (true) {\n      // The current, flushed, state of this fiber is the alternate.\n      // Ideally nothing should rely on this, but relying on it here\n      // means that we don't need an additional field on the work in\n      // progress.\n      var current = workInProgress.alternate;\n      {\n        ReactDebugCurrentFiber.setCurrentFiber(workInProgress);\n      }\n      var next = completeWork(current, workInProgress, nextRenderExpirationTime);\n      {\n        ReactDebugCurrentFiber.resetCurrentFiber();\n      }\n\n      var returnFiber = workInProgress['return'];\n      var siblingFiber = workInProgress.sibling;\n\n      resetExpirationTime(workInProgress, nextRenderExpirationTime);\n\n      if (next !== null) {\n        stopWorkTimer(workInProgress);\n        if (true && ReactFiberInstrumentation_1.debugTool) {\n          ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);\n        }\n        // If completing this work spawned new work, do that next. We'll come\n        // back here again.\n        return next;\n      }\n\n      if (returnFiber !== null) {\n        // Append all the effects of the subtree and this fiber onto the effect\n        // list of the parent. The completion order of the children affects the\n        // side-effect order.\n        if (returnFiber.firstEffect === null) {\n          returnFiber.firstEffect = workInProgress.firstEffect;\n        }\n        if (workInProgress.lastEffect !== null) {\n          if (returnFiber.lastEffect !== null) {\n            returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;\n          }\n          returnFiber.lastEffect = workInProgress.lastEffect;\n        }\n\n        // If this fiber had side-effects, we append it AFTER the children's\n        // side-effects. We can perform certain side-effects earlier if\n        // needed, by doing multiple passes over the effect list. We don't want\n        // to schedule our own side-effect on our own list because if end up\n        // reusing children we'll schedule this effect onto itself since we're\n        // at the end.\n        var effectTag = workInProgress.effectTag;\n        // Skip both NoWork and PerformedWork tags when creating the effect list.\n        // PerformedWork effect is read by React DevTools but shouldn't be committed.\n        if (effectTag > PerformedWork) {\n          if (returnFiber.lastEffect !== null) {\n            returnFiber.lastEffect.nextEffect = workInProgress;\n          } else {\n            returnFiber.firstEffect = workInProgress;\n          }\n          returnFiber.lastEffect = workInProgress;\n        }\n      }\n\n      stopWorkTimer(workInProgress);\n      if (true && ReactFiberInstrumentation_1.debugTool) {\n        ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);\n      }\n\n      if (siblingFiber !== null) {\n        // If there is more work to do in this returnFiber, do that next.\n        return siblingFiber;\n      } else if (returnFiber !== null) {\n        // If there's no more work in this returnFiber. Complete the returnFiber.\n        workInProgress = returnFiber;\n        continue;\n      } else {\n        // We've reached the root.\n        var root = workInProgress.stateNode;\n        root.isReadyForCommit = true;\n        return null;\n      }\n    }\n\n    // Without this explicit null return Flow complains of invalid return type\n    // TODO Remove the above while(true) loop\n    // eslint-disable-next-line no-unreachable\n    return null;\n  }\n\n  function performUnitOfWork(workInProgress) {\n    // The current, flushed, state of this fiber is the alternate.\n    // Ideally nothing should rely on this, but relying on it here\n    // means that we don't need an additional field on the work in\n    // progress.\n    var current = workInProgress.alternate;\n\n    // See if beginning this work spawns more work.\n    startWorkTimer(workInProgress);\n    {\n      ReactDebugCurrentFiber.setCurrentFiber(workInProgress);\n    }\n\n    var next = beginWork(current, workInProgress, nextRenderExpirationTime);\n    {\n      ReactDebugCurrentFiber.resetCurrentFiber();\n    }\n    if (true && ReactFiberInstrumentation_1.debugTool) {\n      ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);\n    }\n\n    if (next === null) {\n      // If this doesn't spawn new work, complete the current work.\n      next = completeUnitOfWork(workInProgress);\n    }\n\n    ReactCurrentOwner.current = null;\n\n    return next;\n  }\n\n  function performFailedUnitOfWork(workInProgress) {\n    // The current, flushed, state of this fiber is the alternate.\n    // Ideally nothing should rely on this, but relying on it here\n    // means that we don't need an additional field on the work in\n    // progress.\n    var current = workInProgress.alternate;\n\n    // See if beginning this work spawns more work.\n    startWorkTimer(workInProgress);\n    {\n      ReactDebugCurrentFiber.setCurrentFiber(workInProgress);\n    }\n    var next = beginFailedWork(current, workInProgress, nextRenderExpirationTime);\n    {\n      ReactDebugCurrentFiber.resetCurrentFiber();\n    }\n    if (true && ReactFiberInstrumentation_1.debugTool) {\n      ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);\n    }\n\n    if (next === null) {\n      // If this doesn't spawn new work, complete the current work.\n      next = completeUnitOfWork(workInProgress);\n    }\n\n    ReactCurrentOwner.current = null;\n\n    return next;\n  }\n\n  function workLoop(expirationTime) {\n    if (capturedErrors !== null) {\n      // If there are unhandled errors, switch to the slow work loop.\n      // TODO: How to avoid this check in the fast path? Maybe the renderer\n      // could keep track of which roots have unhandled errors and call a\n      // forked version of renderRoot.\n      slowWorkLoopThatChecksForFailedWork(expirationTime);\n      return;\n    }\n    if (nextRenderExpirationTime === NoWork || nextRenderExpirationTime > expirationTime) {\n      return;\n    }\n\n    if (nextRenderExpirationTime <= mostRecentCurrentTime) {\n      // Flush all expired work.\n      while (nextUnitOfWork !== null) {\n        nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n      }\n    } else {\n      // Flush asynchronous work until the deadline runs out of time.\n      while (nextUnitOfWork !== null && !shouldYield()) {\n        nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n      }\n    }\n  }\n\n  function slowWorkLoopThatChecksForFailedWork(expirationTime) {\n    if (nextRenderExpirationTime === NoWork || nextRenderExpirationTime > expirationTime) {\n      return;\n    }\n\n    if (nextRenderExpirationTime <= mostRecentCurrentTime) {\n      // Flush all expired work.\n      while (nextUnitOfWork !== null) {\n        if (hasCapturedError(nextUnitOfWork)) {\n          // Use a forked version of performUnitOfWork\n          nextUnitOfWork = performFailedUnitOfWork(nextUnitOfWork);\n        } else {\n          nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n        }\n      }\n    } else {\n      // Flush asynchronous work until the deadline runs out of time.\n      while (nextUnitOfWork !== null && !shouldYield()) {\n        if (hasCapturedError(nextUnitOfWork)) {\n          // Use a forked version of performUnitOfWork\n          nextUnitOfWork = performFailedUnitOfWork(nextUnitOfWork);\n        } else {\n          nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n        }\n      }\n    }\n  }\n\n  function renderRootCatchBlock(root, failedWork, boundary, expirationTime) {\n    // We're going to restart the error boundary that captured the error.\n    // Conceptually, we're unwinding the stack. We need to unwind the\n    // context stack, too.\n    unwindContexts(failedWork, boundary);\n\n    // Restart the error boundary using a forked version of\n    // performUnitOfWork that deletes the boundary's children. The entire\n    // failed subree will be unmounted. During the commit phase, a special\n    // lifecycle method is called on the error boundary, which triggers\n    // a re-render.\n    nextUnitOfWork = performFailedUnitOfWork(boundary);\n\n    // Continue working.\n    workLoop(expirationTime);\n  }\n\n  function renderRoot(root, expirationTime) {\n    !!isWorking ? invariant(false, 'renderRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    isWorking = true;\n\n    // We're about to mutate the work-in-progress tree. If the root was pending\n    // commit, it no longer is: we'll need to complete it again.\n    root.isReadyForCommit = false;\n\n    // Check if we're starting from a fresh stack, or if we're resuming from\n    // previously yielded work.\n    if (root !== nextRoot || expirationTime !== nextRenderExpirationTime || nextUnitOfWork === null) {\n      // Reset the stack and start working from the root.\n      resetContextStack();\n      nextRoot = root;\n      nextRenderExpirationTime = expirationTime;\n      nextUnitOfWork = createWorkInProgress(nextRoot.current, null, expirationTime);\n    }\n\n    startWorkLoopTimer(nextUnitOfWork);\n\n    var didError = false;\n    var error = null;\n    {\n      invokeGuardedCallback$1(null, workLoop, null, expirationTime);\n      if (hasCaughtError()) {\n        didError = true;\n        error = clearCaughtError();\n      }\n    }\n\n    // An error was thrown during the render phase.\n    while (didError) {\n      if (didFatal) {\n        // This was a fatal error. Don't attempt to recover from it.\n        firstUncaughtError = error;\n        break;\n      }\n\n      var failedWork = nextUnitOfWork;\n      if (failedWork === null) {\n        // An error was thrown but there's no current unit of work. This can\n        // happen during the commit phase if there's a bug in the renderer.\n        didFatal = true;\n        continue;\n      }\n\n      // \"Capture\" the error by finding the nearest boundary. If there is no\n      // error boundary, we use the root.\n      var boundary = captureError(failedWork, error);\n      !(boundary !== null) ? invariant(false, 'Should have found an error boundary. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n      if (didFatal) {\n        // The error we just captured was a fatal error. This happens\n        // when the error propagates to the root more than once.\n        continue;\n      }\n\n      didError = false;\n      error = null;\n      {\n        invokeGuardedCallback$1(null, renderRootCatchBlock, null, root, failedWork, boundary, expirationTime);\n        if (hasCaughtError()) {\n          didError = true;\n          error = clearCaughtError();\n          continue;\n        }\n      }\n      // We're finished working. Exit the error loop.\n      break;\n    }\n\n    var uncaughtError = firstUncaughtError;\n\n    // We're done performing work. Time to clean up.\n    stopWorkLoopTimer(interruptedBy);\n    interruptedBy = null;\n    isWorking = false;\n    didFatal = false;\n    firstUncaughtError = null;\n\n    if (uncaughtError !== null) {\n      onUncaughtError(uncaughtError);\n    }\n\n    return root.isReadyForCommit ? root.current.alternate : null;\n  }\n\n  // Returns the boundary that captured the error, or null if the error is ignored\n  function captureError(failedWork, error) {\n    // It is no longer valid because we exited the user code.\n    ReactCurrentOwner.current = null;\n    {\n      ReactDebugCurrentFiber.resetCurrentFiber();\n    }\n\n    // Search for the nearest error boundary.\n    var boundary = null;\n\n    // Passed to logCapturedError()\n    var errorBoundaryFound = false;\n    var willRetry = false;\n    var errorBoundaryName = null;\n\n    // Host containers are a special case. If the failed work itself is a host\n    // container, then it acts as its own boundary. In all other cases, we\n    // ignore the work itself and only search through the parents.\n    if (failedWork.tag === HostRoot) {\n      boundary = failedWork;\n\n      if (isFailedBoundary(failedWork)) {\n        // If this root already failed, there must have been an error when\n        // attempting to unmount it. This is a worst-case scenario and\n        // should only be possible if there's a bug in the renderer.\n        didFatal = true;\n      }\n    } else {\n      var node = failedWork['return'];\n      while (node !== null && boundary === null) {\n        if (node.tag === ClassComponent) {\n          var instance = node.stateNode;\n          if (typeof instance.componentDidCatch === 'function') {\n            errorBoundaryFound = true;\n            errorBoundaryName = getComponentName(node);\n\n            // Found an error boundary!\n            boundary = node;\n            willRetry = true;\n          }\n        } else if (node.tag === HostRoot) {\n          // Treat the root like a no-op error boundary\n          boundary = node;\n        }\n\n        if (isFailedBoundary(node)) {\n          // This boundary is already in a failed state.\n\n          // If we're currently unmounting, that means this error was\n          // thrown while unmounting a failed subtree. We should ignore\n          // the error.\n          if (isUnmounting) {\n            return null;\n          }\n\n          // If we're in the commit phase, we should check to see if\n          // this boundary already captured an error during this commit.\n          // This case exists because multiple errors can be thrown during\n          // a single commit without interruption.\n          if (commitPhaseBoundaries !== null && (commitPhaseBoundaries.has(node) || node.alternate !== null && commitPhaseBoundaries.has(node.alternate))) {\n            // If so, we should ignore this error.\n            return null;\n          }\n\n          // The error should propagate to the next boundary -— we keep looking.\n          boundary = null;\n          willRetry = false;\n        }\n\n        node = node['return'];\n      }\n    }\n\n    if (boundary !== null) {\n      // Add to the collection of failed boundaries. This lets us know that\n      // subsequent errors in this subtree should propagate to the next boundary.\n      if (failedBoundaries === null) {\n        failedBoundaries = new Set();\n      }\n      failedBoundaries.add(boundary);\n\n      // This method is unsafe outside of the begin and complete phases.\n      // We might be in the commit phase when an error is captured.\n      // The risk is that the return path from this Fiber may not be accurate.\n      // That risk is acceptable given the benefit of providing users more context.\n      var _componentStack = getStackAddendumByWorkInProgressFiber(failedWork);\n      var _componentName = getComponentName(failedWork);\n\n      // Add to the collection of captured errors. This is stored as a global\n      // map of errors and their component stack location keyed by the boundaries\n      // that capture them. We mostly use this Map as a Set; it's a Map only to\n      // avoid adding a field to Fiber to store the error.\n      if (capturedErrors === null) {\n        capturedErrors = new Map();\n      }\n\n      var capturedError = {\n        componentName: _componentName,\n        componentStack: _componentStack,\n        error: error,\n        errorBoundary: errorBoundaryFound ? boundary.stateNode : null,\n        errorBoundaryFound: errorBoundaryFound,\n        errorBoundaryName: errorBoundaryName,\n        willRetry: willRetry\n      };\n\n      capturedErrors.set(boundary, capturedError);\n\n      try {\n        logCapturedError(capturedError);\n      } catch (e) {\n        // Prevent cycle if logCapturedError() throws.\n        // A cycle may still occur if logCapturedError renders a component that throws.\n        var suppressLogging = e && e.suppressReactErrorLogging;\n        if (!suppressLogging) {\n          console.error(e);\n        }\n      }\n\n      // If we're in the commit phase, defer scheduling an update on the\n      // boundary until after the commit is complete\n      if (isCommitting) {\n        if (commitPhaseBoundaries === null) {\n          commitPhaseBoundaries = new Set();\n        }\n        commitPhaseBoundaries.add(boundary);\n      } else {\n        // Otherwise, schedule an update now.\n        // TODO: Is this actually necessary during the render phase? Is it\n        // possible to unwind and continue rendering at the same priority,\n        // without corrupting internal state?\n        scheduleErrorRecovery(boundary);\n      }\n      return boundary;\n    } else if (firstUncaughtError === null) {\n      // If no boundary is found, we'll need to throw the error\n      firstUncaughtError = error;\n    }\n    return null;\n  }\n\n  function hasCapturedError(fiber) {\n    // TODO: capturedErrors should store the boundary instance, to avoid needing\n    // to check the alternate.\n    return capturedErrors !== null && (capturedErrors.has(fiber) || fiber.alternate !== null && capturedErrors.has(fiber.alternate));\n  }\n\n  function isFailedBoundary(fiber) {\n    // TODO: failedBoundaries should store the boundary instance, to avoid\n    // needing to check the alternate.\n    return failedBoundaries !== null && (failedBoundaries.has(fiber) || fiber.alternate !== null && failedBoundaries.has(fiber.alternate));\n  }\n\n  function commitErrorHandling(effectfulFiber) {\n    var capturedError = void 0;\n    if (capturedErrors !== null) {\n      capturedError = capturedErrors.get(effectfulFiber);\n      capturedErrors['delete'](effectfulFiber);\n      if (capturedError == null) {\n        if (effectfulFiber.alternate !== null) {\n          effectfulFiber = effectfulFiber.alternate;\n          capturedError = capturedErrors.get(effectfulFiber);\n          capturedErrors['delete'](effectfulFiber);\n        }\n      }\n    }\n\n    !(capturedError != null) ? invariant(false, 'No error for given unit of work. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n    switch (effectfulFiber.tag) {\n      case ClassComponent:\n        var instance = effectfulFiber.stateNode;\n\n        var info = {\n          componentStack: capturedError.componentStack\n        };\n\n        // Allow the boundary to handle the error, usually by scheduling\n        // an update to itself\n        instance.componentDidCatch(capturedError.error, info);\n        return;\n      case HostRoot:\n        if (firstUncaughtError === null) {\n          firstUncaughtError = capturedError.error;\n        }\n        return;\n      default:\n        invariant(false, 'Invalid type of work. This error is likely caused by a bug in React. Please file an issue.');\n    }\n  }\n\n  function unwindContexts(from, to) {\n    var node = from;\n    while (node !== null) {\n      switch (node.tag) {\n        case ClassComponent:\n          popContextProvider(node);\n          break;\n        case HostComponent:\n          popHostContext(node);\n          break;\n        case HostRoot:\n          popHostContainer(node);\n          break;\n        case HostPortal:\n          popHostContainer(node);\n          break;\n      }\n      if (node === to || node.alternate === to) {\n        stopFailedWorkTimer(node);\n        break;\n      } else {\n        stopWorkTimer(node);\n      }\n      node = node['return'];\n    }\n  }\n\n  function computeAsyncExpiration() {\n    // Given the current clock time, returns an expiration time. We use rounding\n    // to batch like updates together.\n    // Should complete within ~1000ms. 1200ms max.\n    var currentTime = recalculateCurrentTime();\n    var expirationMs = 1000;\n    var bucketSizeMs = 200;\n    return computeExpirationBucket(currentTime, expirationMs, bucketSizeMs);\n  }\n\n  function computeExpirationForFiber(fiber) {\n    var expirationTime = void 0;\n    if (expirationContext !== NoWork) {\n      // An explicit expiration context was set;\n      expirationTime = expirationContext;\n    } else if (isWorking) {\n      if (isCommitting) {\n        // Updates that occur during the commit phase should have sync priority\n        // by default.\n        expirationTime = Sync;\n      } else {\n        // Updates during the render phase should expire at the same time as\n        // the work that is being rendered.\n        expirationTime = nextRenderExpirationTime;\n      }\n    } else {\n      // No explicit expiration context was set, and we're not currently\n      // performing work. Calculate a new expiration time.\n      if (useSyncScheduling && !(fiber.internalContextTag & AsyncUpdates)) {\n        // This is a sync update\n        expirationTime = Sync;\n      } else {\n        // This is an async update\n        expirationTime = computeAsyncExpiration();\n      }\n    }\n    return expirationTime;\n  }\n\n  function scheduleWork(fiber, expirationTime) {\n    return scheduleWorkImpl(fiber, expirationTime, false);\n  }\n\n  function checkRootNeedsClearing(root, fiber, expirationTime) {\n    if (!isWorking && root === nextRoot && expirationTime < nextRenderExpirationTime) {\n      // Restart the root from the top.\n      if (nextUnitOfWork !== null) {\n        // This is an interruption. (Used for performance tracking.)\n        interruptedBy = fiber;\n      }\n      nextRoot = null;\n      nextUnitOfWork = null;\n      nextRenderExpirationTime = NoWork;\n    }\n  }\n\n  function scheduleWorkImpl(fiber, expirationTime, isErrorRecovery) {\n    recordScheduleUpdate();\n\n    {\n      if (!isErrorRecovery && fiber.tag === ClassComponent) {\n        var instance = fiber.stateNode;\n        warnAboutInvalidUpdates(instance);\n      }\n    }\n\n    var node = fiber;\n    while (node !== null) {\n      // Walk the parent path to the root and update each node's\n      // expiration time.\n      if (node.expirationTime === NoWork || node.expirationTime > expirationTime) {\n        node.expirationTime = expirationTime;\n      }\n      if (node.alternate !== null) {\n        if (node.alternate.expirationTime === NoWork || node.alternate.expirationTime > expirationTime) {\n          node.alternate.expirationTime = expirationTime;\n        }\n      }\n      if (node['return'] === null) {\n        if (node.tag === HostRoot) {\n          var root = node.stateNode;\n\n          checkRootNeedsClearing(root, fiber, expirationTime);\n          requestWork(root, expirationTime);\n          checkRootNeedsClearing(root, fiber, expirationTime);\n        } else {\n          {\n            if (!isErrorRecovery && fiber.tag === ClassComponent) {\n              warnAboutUpdateOnUnmounted(fiber);\n            }\n          }\n          return;\n        }\n      }\n      node = node['return'];\n    }\n  }\n\n  function scheduleErrorRecovery(fiber) {\n    scheduleWorkImpl(fiber, Sync, true);\n  }\n\n  function recalculateCurrentTime() {\n    // Subtract initial time so it fits inside 32bits\n    var ms = now() - startTime;\n    mostRecentCurrentTime = msToExpirationTime(ms);\n    return mostRecentCurrentTime;\n  }\n\n  function deferredUpdates(fn) {\n    var previousExpirationContext = expirationContext;\n    expirationContext = computeAsyncExpiration();\n    try {\n      return fn();\n    } finally {\n      expirationContext = previousExpirationContext;\n    }\n  }\n\n  function syncUpdates(fn) {\n    var previousExpirationContext = expirationContext;\n    expirationContext = Sync;\n    try {\n      return fn();\n    } finally {\n      expirationContext = previousExpirationContext;\n    }\n  }\n\n  // TODO: Everything below this is written as if it has been lifted to the\n  // renderers. I'll do this in a follow-up.\n\n  // Linked-list of roots\n  var firstScheduledRoot = null;\n  var lastScheduledRoot = null;\n\n  var callbackExpirationTime = NoWork;\n  var callbackID = -1;\n  var isRendering = false;\n  var nextFlushedRoot = null;\n  var nextFlushedExpirationTime = NoWork;\n  var deadlineDidExpire = false;\n  var hasUnhandledError = false;\n  var unhandledError = null;\n  var deadline = null;\n\n  var isBatchingUpdates = false;\n  var isUnbatchingUpdates = false;\n\n  // Use these to prevent an infinite loop of nested updates\n  var NESTED_UPDATE_LIMIT = 1000;\n  var nestedUpdateCount = 0;\n\n  var timeHeuristicForUnitOfWork = 1;\n\n  function scheduleCallbackWithExpiration(expirationTime) {\n    if (callbackExpirationTime !== NoWork) {\n      // A callback is already scheduled. Check its expiration time (timeout).\n      if (expirationTime > callbackExpirationTime) {\n        // Existing callback has sufficient timeout. Exit.\n        return;\n      } else {\n        // Existing callback has insufficient timeout. Cancel and schedule a\n        // new one.\n        cancelDeferredCallback(callbackID);\n      }\n      // The request callback timer is already running. Don't start a new one.\n    } else {\n      startRequestCallbackTimer();\n    }\n\n    // Compute a timeout for the given expiration time.\n    var currentMs = now() - startTime;\n    var expirationMs = expirationTimeToMs(expirationTime);\n    var timeout = expirationMs - currentMs;\n\n    callbackExpirationTime = expirationTime;\n    callbackID = scheduleDeferredCallback(performAsyncWork, { timeout: timeout });\n  }\n\n  // requestWork is called by the scheduler whenever a root receives an update.\n  // It's up to the renderer to call renderRoot at some point in the future.\n  function requestWork(root, expirationTime) {\n    if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\n      invariant(false, 'Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.');\n    }\n\n    // Add the root to the schedule.\n    // Check if this root is already part of the schedule.\n    if (root.nextScheduledRoot === null) {\n      // This root is not already scheduled. Add it.\n      root.remainingExpirationTime = expirationTime;\n      if (lastScheduledRoot === null) {\n        firstScheduledRoot = lastScheduledRoot = root;\n        root.nextScheduledRoot = root;\n      } else {\n        lastScheduledRoot.nextScheduledRoot = root;\n        lastScheduledRoot = root;\n        lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;\n      }\n    } else {\n      // This root is already scheduled, but its priority may have increased.\n      var remainingExpirationTime = root.remainingExpirationTime;\n      if (remainingExpirationTime === NoWork || expirationTime < remainingExpirationTime) {\n        // Update the priority.\n        root.remainingExpirationTime = expirationTime;\n      }\n    }\n\n    if (isRendering) {\n      // Prevent reentrancy. Remaining work will be scheduled at the end of\n      // the currently rendering batch.\n      return;\n    }\n\n    if (isBatchingUpdates) {\n      // Flush work at the end of the batch.\n      if (isUnbatchingUpdates) {\n        // ...unless we're inside unbatchedUpdates, in which case we should\n        // flush it now.\n        nextFlushedRoot = root;\n        nextFlushedExpirationTime = Sync;\n        performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime);\n      }\n      return;\n    }\n\n    // TODO: Get rid of Sync and use current time?\n    if (expirationTime === Sync) {\n      performWork(Sync, null);\n    } else {\n      scheduleCallbackWithExpiration(expirationTime);\n    }\n  }\n\n  function findHighestPriorityRoot() {\n    var highestPriorityWork = NoWork;\n    var highestPriorityRoot = null;\n\n    if (lastScheduledRoot !== null) {\n      var previousScheduledRoot = lastScheduledRoot;\n      var root = firstScheduledRoot;\n      while (root !== null) {\n        var remainingExpirationTime = root.remainingExpirationTime;\n        if (remainingExpirationTime === NoWork) {\n          // This root no longer has work. Remove it from the scheduler.\n\n          // TODO: This check is redudant, but Flow is confused by the branch\n          // below where we set lastScheduledRoot to null, even though we break\n          // from the loop right after.\n          !(previousScheduledRoot !== null && lastScheduledRoot !== null) ? invariant(false, 'Should have a previous and last root. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n          if (root === root.nextScheduledRoot) {\n            // This is the only root in the list.\n            root.nextScheduledRoot = null;\n            firstScheduledRoot = lastScheduledRoot = null;\n            break;\n          } else if (root === firstScheduledRoot) {\n            // This is the first root in the list.\n            var next = root.nextScheduledRoot;\n            firstScheduledRoot = next;\n            lastScheduledRoot.nextScheduledRoot = next;\n            root.nextScheduledRoot = null;\n          } else if (root === lastScheduledRoot) {\n            // This is the last root in the list.\n            lastScheduledRoot = previousScheduledRoot;\n            lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;\n            root.nextScheduledRoot = null;\n            break;\n          } else {\n            previousScheduledRoot.nextScheduledRoot = root.nextScheduledRoot;\n            root.nextScheduledRoot = null;\n          }\n          root = previousScheduledRoot.nextScheduledRoot;\n        } else {\n          if (highestPriorityWork === NoWork || remainingExpirationTime < highestPriorityWork) {\n            // Update the priority, if it's higher\n            highestPriorityWork = remainingExpirationTime;\n            highestPriorityRoot = root;\n          }\n          if (root === lastScheduledRoot) {\n            break;\n          }\n          previousScheduledRoot = root;\n          root = root.nextScheduledRoot;\n        }\n      }\n    }\n\n    // If the next root is the same as the previous root, this is a nested\n    // update. To prevent an infinite loop, increment the nested update count.\n    var previousFlushedRoot = nextFlushedRoot;\n    if (previousFlushedRoot !== null && previousFlushedRoot === highestPriorityRoot) {\n      nestedUpdateCount++;\n    } else {\n      // Reset whenever we switch roots.\n      nestedUpdateCount = 0;\n    }\n    nextFlushedRoot = highestPriorityRoot;\n    nextFlushedExpirationTime = highestPriorityWork;\n  }\n\n  function performAsyncWork(dl) {\n    performWork(NoWork, dl);\n  }\n\n  function performWork(minExpirationTime, dl) {\n    deadline = dl;\n\n    // Keep working on roots until there's no more work, or until the we reach\n    // the deadline.\n    findHighestPriorityRoot();\n\n    if (enableUserTimingAPI && deadline !== null) {\n      var didExpire = nextFlushedExpirationTime < recalculateCurrentTime();\n      stopRequestCallbackTimer(didExpire);\n    }\n\n    while (nextFlushedRoot !== null && nextFlushedExpirationTime !== NoWork && (minExpirationTime === NoWork || nextFlushedExpirationTime <= minExpirationTime) && !deadlineDidExpire) {\n      performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime);\n      // Find the next highest priority work.\n      findHighestPriorityRoot();\n    }\n\n    // We're done flushing work. Either we ran out of time in this callback,\n    // or there's no more work left with sufficient priority.\n\n    // If we're inside a callback, set this to false since we just completed it.\n    if (deadline !== null) {\n      callbackExpirationTime = NoWork;\n      callbackID = -1;\n    }\n    // If there's work left over, schedule a new callback.\n    if (nextFlushedExpirationTime !== NoWork) {\n      scheduleCallbackWithExpiration(nextFlushedExpirationTime);\n    }\n\n    // Clean-up.\n    deadline = null;\n    deadlineDidExpire = false;\n    nestedUpdateCount = 0;\n\n    if (hasUnhandledError) {\n      var _error4 = unhandledError;\n      unhandledError = null;\n      hasUnhandledError = false;\n      throw _error4;\n    }\n  }\n\n  function performWorkOnRoot(root, expirationTime) {\n    !!isRendering ? invariant(false, 'performWorkOnRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n    isRendering = true;\n\n    // Check if this is async work or sync/expired work.\n    // TODO: Pass current time as argument to renderRoot, commitRoot\n    if (expirationTime <= recalculateCurrentTime()) {\n      // Flush sync work.\n      var finishedWork = root.finishedWork;\n      if (finishedWork !== null) {\n        // This root is already complete. We can commit it.\n        root.finishedWork = null;\n        root.remainingExpirationTime = commitRoot(finishedWork);\n      } else {\n        root.finishedWork = null;\n        finishedWork = renderRoot(root, expirationTime);\n        if (finishedWork !== null) {\n          // We've completed the root. Commit it.\n          root.remainingExpirationTime = commitRoot(finishedWork);\n        }\n      }\n    } else {\n      // Flush async work.\n      var _finishedWork = root.finishedWork;\n      if (_finishedWork !== null) {\n        // This root is already complete. We can commit it.\n        root.finishedWork = null;\n        root.remainingExpirationTime = commitRoot(_finishedWork);\n      } else {\n        root.finishedWork = null;\n        _finishedWork = renderRoot(root, expirationTime);\n        if (_finishedWork !== null) {\n          // We've completed the root. Check the deadline one more time\n          // before committing.\n          if (!shouldYield()) {\n            // Still time left. Commit the root.\n            root.remainingExpirationTime = commitRoot(_finishedWork);\n          } else {\n            // There's no time left. Mark this root as complete. We'll come\n            // back and commit it later.\n            root.finishedWork = _finishedWork;\n          }\n        }\n      }\n    }\n\n    isRendering = false;\n  }\n\n  // When working on async work, the reconciler asks the renderer if it should\n  // yield execution. For DOM, we implement this with requestIdleCallback.\n  function shouldYield() {\n    if (deadline === null) {\n      return false;\n    }\n    if (deadline.timeRemaining() > timeHeuristicForUnitOfWork) {\n      // Disregard deadline.didTimeout. Only expired work should be flushed\n      // during a timeout. This path is only hit for non-expired work.\n      return false;\n    }\n    deadlineDidExpire = true;\n    return true;\n  }\n\n  // TODO: Not happy about this hook. Conceptually, renderRoot should return a\n  // tuple of (isReadyForCommit, didError, error)\n  function onUncaughtError(error) {\n    !(nextFlushedRoot !== null) ? invariant(false, 'Should be working on a root. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    // Unschedule this root so we don't work on it again until there's\n    // another update.\n    nextFlushedRoot.remainingExpirationTime = NoWork;\n    if (!hasUnhandledError) {\n      hasUnhandledError = true;\n      unhandledError = error;\n    }\n  }\n\n  // TODO: Batching should be implemented at the renderer level, not inside\n  // the reconciler.\n  function batchedUpdates(fn, a) {\n    var previousIsBatchingUpdates = isBatchingUpdates;\n    isBatchingUpdates = true;\n    try {\n      return fn(a);\n    } finally {\n      isBatchingUpdates = previousIsBatchingUpdates;\n      if (!isBatchingUpdates && !isRendering) {\n        performWork(Sync, null);\n      }\n    }\n  }\n\n  // TODO: Batching should be implemented at the renderer level, not inside\n  // the reconciler.\n  function unbatchedUpdates(fn) {\n    if (isBatchingUpdates && !isUnbatchingUpdates) {\n      isUnbatchingUpdates = true;\n      try {\n        return fn();\n      } finally {\n        isUnbatchingUpdates = false;\n      }\n    }\n    return fn();\n  }\n\n  // TODO: Batching should be implemented at the renderer level, not within\n  // the reconciler.\n  function flushSync(fn) {\n    var previousIsBatchingUpdates = isBatchingUpdates;\n    isBatchingUpdates = true;\n    try {\n      return syncUpdates(fn);\n    } finally {\n      isBatchingUpdates = previousIsBatchingUpdates;\n      !!isRendering ? invariant(false, 'flushSync was called from inside a lifecycle method. It cannot be called when React is already rendering.') : void 0;\n      performWork(Sync, null);\n    }\n  }\n\n  return {\n    computeAsyncExpiration: computeAsyncExpiration,\n    computeExpirationForFiber: computeExpirationForFiber,\n    scheduleWork: scheduleWork,\n    batchedUpdates: batchedUpdates,\n    unbatchedUpdates: unbatchedUpdates,\n    flushSync: flushSync,\n    deferredUpdates: deferredUpdates\n  };\n};\n\n{\n  var didWarnAboutNestedUpdates = false;\n}\n\n// 0 is PROD, 1 is DEV.\n// Might add PROFILE later.\n\n\nfunction getContextForSubtree(parentComponent) {\n  if (!parentComponent) {\n    return emptyObject;\n  }\n\n  var fiber = get(parentComponent);\n  var parentContext = findCurrentUnmaskedContext(fiber);\n  return isContextProvider(fiber) ? processChildContext(fiber, parentContext) : parentContext;\n}\n\nvar ReactFiberReconciler$1 = function (config) {\n  var getPublicInstance = config.getPublicInstance;\n\n  var _ReactFiberScheduler = ReactFiberScheduler(config),\n      computeAsyncExpiration = _ReactFiberScheduler.computeAsyncExpiration,\n      computeExpirationForFiber = _ReactFiberScheduler.computeExpirationForFiber,\n      scheduleWork = _ReactFiberScheduler.scheduleWork,\n      batchedUpdates = _ReactFiberScheduler.batchedUpdates,\n      unbatchedUpdates = _ReactFiberScheduler.unbatchedUpdates,\n      flushSync = _ReactFiberScheduler.flushSync,\n      deferredUpdates = _ReactFiberScheduler.deferredUpdates;\n\n  function scheduleTopLevelUpdate(current, element, callback) {\n    {\n      if (ReactDebugCurrentFiber.phase === 'render' && ReactDebugCurrentFiber.current !== null && !didWarnAboutNestedUpdates) {\n        didWarnAboutNestedUpdates = true;\n        warning(false, 'Render methods should be a pure function of props and state; ' + 'triggering nested component updates from render is not allowed. ' + 'If necessary, trigger nested updates in componentDidUpdate.\\n\\n' + 'Check the render method of %s.', getComponentName(ReactDebugCurrentFiber.current) || 'Unknown');\n      }\n    }\n\n    callback = callback === undefined ? null : callback;\n    {\n      warning(callback === null || typeof callback === 'function', 'render(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callback);\n    }\n\n    var expirationTime = void 0;\n    // Check if the top-level element is an async wrapper component. If so,\n    // treat updates to the root as async. This is a bit weird but lets us\n    // avoid a separate `renderAsync` API.\n    if (enableAsyncSubtreeAPI && element != null && element.type != null && element.type.prototype != null && element.type.prototype.unstable_isAsyncReactComponent === true) {\n      expirationTime = computeAsyncExpiration();\n    } else {\n      expirationTime = computeExpirationForFiber(current);\n    }\n\n    var update = {\n      expirationTime: expirationTime,\n      partialState: { element: element },\n      callback: callback,\n      isReplace: false,\n      isForced: false,\n      nextCallback: null,\n      next: null\n    };\n    insertUpdateIntoFiber(current, update);\n    scheduleWork(current, expirationTime);\n  }\n\n  function findHostInstance(fiber) {\n    var hostFiber = findCurrentHostFiber(fiber);\n    if (hostFiber === null) {\n      return null;\n    }\n    return hostFiber.stateNode;\n  }\n\n  return {\n    createContainer: function (containerInfo, hydrate) {\n      return createFiberRoot(containerInfo, hydrate);\n    },\n    updateContainer: function (element, container, parentComponent, callback) {\n      // TODO: If this is a nested container, this won't be the root.\n      var current = container.current;\n\n      {\n        if (ReactFiberInstrumentation_1.debugTool) {\n          if (current.alternate === null) {\n            ReactFiberInstrumentation_1.debugTool.onMountContainer(container);\n          } else if (element === null) {\n            ReactFiberInstrumentation_1.debugTool.onUnmountContainer(container);\n          } else {\n            ReactFiberInstrumentation_1.debugTool.onUpdateContainer(container);\n          }\n        }\n      }\n\n      var context = getContextForSubtree(parentComponent);\n      if (container.context === null) {\n        container.context = context;\n      } else {\n        container.pendingContext = context;\n      }\n\n      scheduleTopLevelUpdate(current, element, callback);\n    },\n\n\n    batchedUpdates: batchedUpdates,\n\n    unbatchedUpdates: unbatchedUpdates,\n\n    deferredUpdates: deferredUpdates,\n\n    flushSync: flushSync,\n\n    getPublicRootInstance: function (container) {\n      var containerFiber = container.current;\n      if (!containerFiber.child) {\n        return null;\n      }\n      switch (containerFiber.child.tag) {\n        case HostComponent:\n          return getPublicInstance(containerFiber.child.stateNode);\n        default:\n          return containerFiber.child.stateNode;\n      }\n    },\n\n\n    findHostInstance: findHostInstance,\n\n    findHostInstanceWithNoPortals: function (fiber) {\n      var hostFiber = findCurrentHostFiberWithNoPortals(fiber);\n      if (hostFiber === null) {\n        return null;\n      }\n      return hostFiber.stateNode;\n    },\n    injectIntoDevTools: function (devToolsConfig) {\n      var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;\n\n      return injectInternals(_assign({}, devToolsConfig, {\n        findHostInstanceByFiber: function (fiber) {\n          return findHostInstance(fiber);\n        },\n        findFiberByHostInstance: function (instance) {\n          if (!findFiberByHostInstance) {\n            // Might not be implemented by the renderer.\n            return null;\n          }\n          return findFiberByHostInstance(instance);\n        }\n      }));\n    }\n  };\n};\n\nvar ReactFiberReconciler$2 = Object.freeze({\n\tdefault: ReactFiberReconciler$1\n});\n\nvar ReactFiberReconciler$3 = ( ReactFiberReconciler$2 && ReactFiberReconciler$1 ) || ReactFiberReconciler$2;\n\n// TODO: bundle Flow types with the package.\n\n\n\n// TODO: decide on the top-level export form.\n// This is hacky but makes it work with both Rollup and Jest.\nvar reactReconciler = ReactFiberReconciler$3['default'] ? ReactFiberReconciler$3['default'] : ReactFiberReconciler$3;\n\nfunction createPortal$1(children, containerInfo,\n// TODO: figure out the API for cross-renderer implementation.\nimplementation) {\n  var key = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n  return {\n    // This tag allow us to uniquely identify this as a React Portal\n    $$typeof: REACT_PORTAL_TYPE,\n    key: key == null ? null : '' + key,\n    children: children,\n    containerInfo: containerInfo,\n    implementation: implementation\n  };\n}\n\n// TODO: this is special because it gets imported during build.\n\nvar ReactVersion = '16.2.0';\n\n// a requestAnimationFrame, storing the time for the start of the frame, then\n// scheduling a postMessage which gets scheduled after paint. Within the\n// postMessage handler do as much work as possible until time + frame rate.\n// By separating the idle call into a separate event tick we ensure that\n// layout, paint and other browser work is counted against the available time.\n// The frame rate is dynamically adjusted.\n\n{\n  if (ExecutionEnvironment.canUseDOM && typeof requestAnimationFrame !== 'function') {\n    warning(false, 'React depends on requestAnimationFrame. Make sure that you load a ' + 'polyfill in older browsers. http://fb.me/react-polyfills');\n  }\n}\n\nvar hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\n\nvar now = void 0;\nif (hasNativePerformanceNow) {\n  now = function () {\n    return performance.now();\n  };\n} else {\n  now = function () {\n    return Date.now();\n  };\n}\n\n// TODO: There's no way to cancel, because Fiber doesn't atm.\nvar rIC = void 0;\nvar cIC = void 0;\n\nif (!ExecutionEnvironment.canUseDOM) {\n  rIC = function (frameCallback) {\n    return setTimeout(function () {\n      frameCallback({\n        timeRemaining: function () {\n          return Infinity;\n        }\n      });\n    });\n  };\n  cIC = function (timeoutID) {\n    clearTimeout(timeoutID);\n  };\n} else if (typeof requestIdleCallback !== 'function' || typeof cancelIdleCallback !== 'function') {\n  // Polyfill requestIdleCallback and cancelIdleCallback\n\n  var scheduledRICCallback = null;\n  var isIdleScheduled = false;\n  var timeoutTime = -1;\n\n  var isAnimationFrameScheduled = false;\n\n  var frameDeadline = 0;\n  // We start out assuming that we run at 30fps but then the heuristic tracking\n  // will adjust this value to a faster fps if we get more frequent animation\n  // frames.\n  var previousFrameTime = 33;\n  var activeFrameTime = 33;\n\n  var frameDeadlineObject;\n  if (hasNativePerformanceNow) {\n    frameDeadlineObject = {\n      didTimeout: false,\n      timeRemaining: function () {\n        // We assume that if we have a performance timer that the rAF callback\n        // gets a performance timer value. Not sure if this is always true.\n        var remaining = frameDeadline - performance.now();\n        return remaining > 0 ? remaining : 0;\n      }\n    };\n  } else {\n    frameDeadlineObject = {\n      didTimeout: false,\n      timeRemaining: function () {\n        // Fallback to Date.now()\n        var remaining = frameDeadline - Date.now();\n        return remaining > 0 ? remaining : 0;\n      }\n    };\n  }\n\n  // We use the postMessage trick to defer idle work until after the repaint.\n  var messageKey = '__reactIdleCallback$' + Math.random().toString(36).slice(2);\n  var idleTick = function (event) {\n    if (event.source !== window || event.data !== messageKey) {\n      return;\n    }\n\n    isIdleScheduled = false;\n\n    var currentTime = now();\n    if (frameDeadline - currentTime <= 0) {\n      // There's no time left in this idle period. Check if the callback has\n      // a timeout and whether it's been exceeded.\n      if (timeoutTime !== -1 && timeoutTime <= currentTime) {\n        // Exceeded the timeout. Invoke the callback even though there's no\n        // time left.\n        frameDeadlineObject.didTimeout = true;\n      } else {\n        // No timeout.\n        if (!isAnimationFrameScheduled) {\n          // Schedule another animation callback so we retry later.\n          isAnimationFrameScheduled = true;\n          requestAnimationFrame(animationTick);\n        }\n        // Exit without invoking the callback.\n        return;\n      }\n    } else {\n      // There's still time left in this idle period.\n      frameDeadlineObject.didTimeout = false;\n    }\n\n    timeoutTime = -1;\n    var callback = scheduledRICCallback;\n    scheduledRICCallback = null;\n    if (callback !== null) {\n      callback(frameDeadlineObject);\n    }\n  };\n  // Assumes that we have addEventListener in this environment. Might need\n  // something better for old IE.\n  window.addEventListener('message', idleTick, false);\n\n  var animationTick = function (rafTime) {\n    isAnimationFrameScheduled = false;\n    var nextFrameTime = rafTime - frameDeadline + activeFrameTime;\n    if (nextFrameTime < activeFrameTime && previousFrameTime < activeFrameTime) {\n      if (nextFrameTime < 8) {\n        // Defensive coding. We don't support higher frame rates than 120hz.\n        // If we get lower than that, it is probably a bug.\n        nextFrameTime = 8;\n      }\n      // If one frame goes long, then the next one can be short to catch up.\n      // If two frames are short in a row, then that's an indication that we\n      // actually have a higher frame rate than what we're currently optimizing.\n      // We adjust our heuristic dynamically accordingly. For example, if we're\n      // running on 120hz display or 90hz VR display.\n      // Take the max of the two in case one of them was an anomaly due to\n      // missed frame deadlines.\n      activeFrameTime = nextFrameTime < previousFrameTime ? previousFrameTime : nextFrameTime;\n    } else {\n      previousFrameTime = nextFrameTime;\n    }\n    frameDeadline = rafTime + activeFrameTime;\n    if (!isIdleScheduled) {\n      isIdleScheduled = true;\n      window.postMessage(messageKey, '*');\n    }\n  };\n\n  rIC = function (callback, options) {\n    // This assumes that we only schedule one callback at a time because that's\n    // how Fiber uses it.\n    scheduledRICCallback = callback;\n    if (options != null && typeof options.timeout === 'number') {\n      timeoutTime = now() + options.timeout;\n    }\n    if (!isAnimationFrameScheduled) {\n      // If rAF didn't already schedule one, we need to schedule a frame.\n      // TODO: If this rAF doesn't materialize because the browser throttles, we\n      // might want to still have setTimeout trigger rIC as a backup to ensure\n      // that we keep performing work.\n      isAnimationFrameScheduled = true;\n      requestAnimationFrame(animationTick);\n    }\n    return 0;\n  };\n\n  cIC = function () {\n    scheduledRICCallback = null;\n    isIdleScheduled = false;\n    timeoutTime = -1;\n  };\n} else {\n  rIC = window.requestIdleCallback;\n  cIC = window.cancelIdleCallback;\n}\n\n/**\n * Forked from fbjs/warning:\n * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js\n *\n * Only change is we use console.warn instead of console.error,\n * and do nothing when 'console' is not supported.\n * This really simplifies the code.\n * ---\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar lowPriorityWarning = function () {};\n\n{\n  var printWarning = function (format) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var argIndex = 0;\n    var message = 'Warning: ' + format.replace(/%s/g, function () {\n      return args[argIndex++];\n    });\n    if (typeof console !== 'undefined') {\n      console.warn(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n\n  lowPriorityWarning = function (condition, format) {\n    if (format === undefined) {\n      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');\n    }\n    if (!condition) {\n      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        args[_key2 - 2] = arguments[_key2];\n      }\n\n      printWarning.apply(undefined, [format].concat(args));\n    }\n  };\n}\n\nvar lowPriorityWarning$1 = lowPriorityWarning;\n\n// isAttributeNameSafe() is currently duplicated in DOMMarkupOperations.\n// TODO: Find a better place for this.\nvar VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + ATTRIBUTE_NAME_START_CHAR + '][' + ATTRIBUTE_NAME_CHAR + ']*$');\nvar illegalAttributeNameCache = {};\nvar validatedAttributeNameCache = {};\nfunction isAttributeNameSafe(attributeName) {\n  if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {\n    return true;\n  }\n  if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {\n    return false;\n  }\n  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {\n    validatedAttributeNameCache[attributeName] = true;\n    return true;\n  }\n  illegalAttributeNameCache[attributeName] = true;\n  {\n    warning(false, 'Invalid attribute name: `%s`', attributeName);\n  }\n  return false;\n}\n\n// shouldIgnoreValue() is currently duplicated in DOMMarkupOperations.\n// TODO: Find a better place for this.\nfunction shouldIgnoreValue(propertyInfo, value) {\n  return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;\n}\n\n/**\n * Operations for dealing with DOM properties.\n */\n\n\n\n\n\n/**\n * Get the value for a property on a node. Only used in DEV for SSR validation.\n * The \"expected\" argument is used as a hint of what the expected value is.\n * Some properties have multiple equivalent values.\n */\nfunction getValueForProperty(node, name, expected) {\n  {\n    var propertyInfo = getPropertyInfo(name);\n    if (propertyInfo) {\n      var mutationMethod = propertyInfo.mutationMethod;\n      if (mutationMethod || propertyInfo.mustUseProperty) {\n        return node[propertyInfo.propertyName];\n      } else {\n        var attributeName = propertyInfo.attributeName;\n\n        var stringValue = null;\n\n        if (propertyInfo.hasOverloadedBooleanValue) {\n          if (node.hasAttribute(attributeName)) {\n            var value = node.getAttribute(attributeName);\n            if (value === '') {\n              return true;\n            }\n            if (shouldIgnoreValue(propertyInfo, expected)) {\n              return value;\n            }\n            if (value === '' + expected) {\n              return expected;\n            }\n            return value;\n          }\n        } else if (node.hasAttribute(attributeName)) {\n          if (shouldIgnoreValue(propertyInfo, expected)) {\n            // We had an attribute but shouldn't have had one, so read it\n            // for the error message.\n            return node.getAttribute(attributeName);\n          }\n          if (propertyInfo.hasBooleanValue) {\n            // If this was a boolean, it doesn't matter what the value is\n            // the fact that we have it is the same as the expected.\n            return expected;\n          }\n          // Even if this property uses a namespace we use getAttribute\n          // because we assume its namespaced name is the same as our config.\n          // To use getAttributeNS we need the local name which we don't have\n          // in our config atm.\n          stringValue = node.getAttribute(attributeName);\n        }\n\n        if (shouldIgnoreValue(propertyInfo, expected)) {\n          return stringValue === null ? expected : stringValue;\n        } else if (stringValue === '' + expected) {\n          return expected;\n        } else {\n          return stringValue;\n        }\n      }\n    }\n  }\n}\n\n/**\n * Get the value for a attribute on a node. Only used in DEV for SSR validation.\n * The third argument is used as a hint of what the expected value is. Some\n * attributes have multiple equivalent values.\n */\nfunction getValueForAttribute(node, name, expected) {\n  {\n    if (!isAttributeNameSafe(name)) {\n      return;\n    }\n    if (!node.hasAttribute(name)) {\n      return expected === undefined ? undefined : null;\n    }\n    var value = node.getAttribute(name);\n    if (value === '' + expected) {\n      return expected;\n    }\n    return value;\n  }\n}\n\n/**\n * Sets the value for a property on a node.\n *\n * @param {DOMElement} node\n * @param {string} name\n * @param {*} value\n */\nfunction setValueForProperty(node, name, value) {\n  var propertyInfo = getPropertyInfo(name);\n\n  if (propertyInfo && shouldSetAttribute(name, value)) {\n    var mutationMethod = propertyInfo.mutationMethod;\n    if (mutationMethod) {\n      mutationMethod(node, value);\n    } else if (shouldIgnoreValue(propertyInfo, value)) {\n      deleteValueForProperty(node, name);\n      return;\n    } else if (propertyInfo.mustUseProperty) {\n      // Contrary to `setAttribute`, object properties are properly\n      // `toString`ed by IE8/9.\n      node[propertyInfo.propertyName] = value;\n    } else {\n      var attributeName = propertyInfo.attributeName;\n      var namespace = propertyInfo.attributeNamespace;\n      // `setAttribute` with objects becomes only `[object]` in IE8/9,\n      // ('' + value) makes it output the correct toString()-value.\n      if (namespace) {\n        node.setAttributeNS(namespace, attributeName, '' + value);\n      } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {\n        node.setAttribute(attributeName, '');\n      } else {\n        node.setAttribute(attributeName, '' + value);\n      }\n    }\n  } else {\n    setValueForAttribute(node, name, shouldSetAttribute(name, value) ? value : null);\n    return;\n  }\n\n  {\n    \n  }\n}\n\nfunction setValueForAttribute(node, name, value) {\n  if (!isAttributeNameSafe(name)) {\n    return;\n  }\n  if (value == null) {\n    node.removeAttribute(name);\n  } else {\n    node.setAttribute(name, '' + value);\n  }\n\n  {\n    \n  }\n}\n\n/**\n * Deletes an attributes from a node.\n *\n * @param {DOMElement} node\n * @param {string} name\n */\nfunction deleteValueForAttribute(node, name) {\n  node.removeAttribute(name);\n}\n\n/**\n * Deletes the value for a property on a node.\n *\n * @param {DOMElement} node\n * @param {string} name\n */\nfunction deleteValueForProperty(node, name) {\n  var propertyInfo = getPropertyInfo(name);\n  if (propertyInfo) {\n    var mutationMethod = propertyInfo.mutationMethod;\n    if (mutationMethod) {\n      mutationMethod(node, undefined);\n    } else if (propertyInfo.mustUseProperty) {\n      var propName = propertyInfo.propertyName;\n      if (propertyInfo.hasBooleanValue) {\n        node[propName] = false;\n      } else {\n        node[propName] = '';\n      }\n    } else {\n      node.removeAttribute(propertyInfo.attributeName);\n    }\n  } else {\n    node.removeAttribute(name);\n  }\n}\n\nvar ReactControlledValuePropTypes = {\n  checkPropTypes: null\n};\n\n{\n  var hasReadOnlyValue = {\n    button: true,\n    checkbox: true,\n    image: true,\n    hidden: true,\n    radio: true,\n    reset: true,\n    submit: true\n  };\n\n  var propTypes = {\n    value: function (props, propName, componentName) {\n      if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {\n        return null;\n      }\n      return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');\n    },\n    checked: function (props, propName, componentName) {\n      if (!props[propName] || props.onChange || props.readOnly || props.disabled) {\n        return null;\n      }\n      return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');\n    }\n  };\n\n  /**\n   * Provide a linked `value` attribute for controlled forms. You should not use\n   * this outside of the ReactDOM controlled form components.\n   */\n  ReactControlledValuePropTypes.checkPropTypes = function (tagName, props, getStack) {\n    checkPropTypes(propTypes, props, 'prop', tagName, getStack);\n  };\n}\n\n// TODO: direct imports like some-package/src/* are bad. Fix me.\nvar getCurrentFiberOwnerName$2 = ReactDebugCurrentFiber.getCurrentFiberOwnerName;\nvar getCurrentFiberStackAddendum$3 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;\n\nvar didWarnValueDefaultValue = false;\nvar didWarnCheckedDefaultChecked = false;\nvar didWarnControlledToUncontrolled = false;\nvar didWarnUncontrolledToControlled = false;\n\nfunction isControlled(props) {\n  var usesChecked = props.type === 'checkbox' || props.type === 'radio';\n  return usesChecked ? props.checked != null : props.value != null;\n}\n\n/**\n * Implements an <input> host component that allows setting these optional\n * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.\n *\n * If `checked` or `value` are not supplied (or null/undefined), user actions\n * that affect the checked state or value will trigger updates to the element.\n *\n * If they are supplied (and not null/undefined), the rendered element will not\n * trigger updates to the element. Instead, the props must change in order for\n * the rendered element to be updated.\n *\n * The rendered element will be initialized as unchecked (or `defaultChecked`)\n * with an empty value (or `defaultValue`).\n *\n * See http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html\n */\n\nfunction getHostProps(element, props) {\n  var node = element;\n  var value = props.value;\n  var checked = props.checked;\n\n  var hostProps = _assign({\n    // Make sure we set .type before any other properties (setting .value\n    // before .type means .value is lost in IE11 and below)\n    type: undefined,\n    // Make sure we set .step before .value (setting .value before .step\n    // means .value is rounded on mount, based upon step precision)\n    step: undefined,\n    // Make sure we set .min & .max before .value (to ensure proper order\n    // in corner cases such as min or max deriving from value, e.g. Issue #7170)\n    min: undefined,\n    max: undefined\n  }, props, {\n    defaultChecked: undefined,\n    defaultValue: undefined,\n    value: value != null ? value : node._wrapperState.initialValue,\n    checked: checked != null ? checked : node._wrapperState.initialChecked\n  });\n\n  return hostProps;\n}\n\nfunction initWrapperState(element, props) {\n  {\n    ReactControlledValuePropTypes.checkPropTypes('input', props, getCurrentFiberStackAddendum$3);\n\n    if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {\n      warning(false, '%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', getCurrentFiberOwnerName$2() || 'A component', props.type);\n      didWarnCheckedDefaultChecked = true;\n    }\n    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {\n      warning(false, '%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', getCurrentFiberOwnerName$2() || 'A component', props.type);\n      didWarnValueDefaultValue = true;\n    }\n  }\n\n  var defaultValue = props.defaultValue;\n  var node = element;\n  node._wrapperState = {\n    initialChecked: props.checked != null ? props.checked : props.defaultChecked,\n    initialValue: props.value != null ? props.value : defaultValue,\n    controlled: isControlled(props)\n  };\n}\n\nfunction updateChecked(element, props) {\n  var node = element;\n  var checked = props.checked;\n  if (checked != null) {\n    setValueForProperty(node, 'checked', checked);\n  }\n}\n\nfunction updateWrapper(element, props) {\n  var node = element;\n  {\n    var controlled = isControlled(props);\n\n    if (!node._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {\n      warning(false, 'A component is changing an uncontrolled input of type %s to be controlled. ' + 'Input elements should not switch from uncontrolled to controlled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components%s', props.type, getCurrentFiberStackAddendum$3());\n      didWarnUncontrolledToControlled = true;\n    }\n    if (node._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {\n      warning(false, 'A component is changing a controlled input of type %s to be uncontrolled. ' + 'Input elements should not switch from controlled to uncontrolled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components%s', props.type, getCurrentFiberStackAddendum$3());\n      didWarnControlledToUncontrolled = true;\n    }\n  }\n\n  updateChecked(element, props);\n\n  var value = props.value;\n  if (value != null) {\n    if (value === 0 && node.value === '') {\n      node.value = '0';\n      // Note: IE9 reports a number inputs as 'text', so check props instead.\n    } else if (props.type === 'number') {\n      // Simulate `input.valueAsNumber`. IE9 does not support it\n      var valueAsNumber = parseFloat(node.value) || 0;\n\n      if (\n      // eslint-disable-next-line\n      value != valueAsNumber ||\n      // eslint-disable-next-line\n      value == valueAsNumber && node.value != value) {\n        // Cast `value` to a string to ensure the value is set correctly. While\n        // browsers typically do this as necessary, jsdom doesn't.\n        node.value = '' + value;\n      }\n    } else if (node.value !== '' + value) {\n      // Cast `value` to a string to ensure the value is set correctly. While\n      // browsers typically do this as necessary, jsdom doesn't.\n      node.value = '' + value;\n    }\n  } else {\n    if (props.value == null && props.defaultValue != null) {\n      // In Chrome, assigning defaultValue to certain input types triggers input validation.\n      // For number inputs, the display value loses trailing decimal points. For email inputs,\n      // Chrome raises \"The specified value <x> is not a valid email address\".\n      //\n      // Here we check to see if the defaultValue has actually changed, avoiding these problems\n      // when the user is inputting text\n      //\n      // https://github.com/facebook/react/issues/7253\n      if (node.defaultValue !== '' + props.defaultValue) {\n        node.defaultValue = '' + props.defaultValue;\n      }\n    }\n    if (props.checked == null && props.defaultChecked != null) {\n      node.defaultChecked = !!props.defaultChecked;\n    }\n  }\n}\n\nfunction postMountWrapper(element, props) {\n  var node = element;\n\n  // Detach value from defaultValue. We won't do anything if we're working on\n  // submit or reset inputs as those values & defaultValues are linked. They\n  // are not resetable nodes so this operation doesn't matter and actually\n  // removes browser-default values (eg \"Submit Query\") when no value is\n  // provided.\n\n  switch (props.type) {\n    case 'submit':\n    case 'reset':\n      break;\n    case 'color':\n    case 'date':\n    case 'datetime':\n    case 'datetime-local':\n    case 'month':\n    case 'time':\n    case 'week':\n      // This fixes the no-show issue on iOS Safari and Android Chrome:\n      // https://github.com/facebook/react/issues/7233\n      node.value = '';\n      node.value = node.defaultValue;\n      break;\n    default:\n      node.value = node.value;\n      break;\n  }\n\n  // Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug\n  // this is needed to work around a chrome bug where setting defaultChecked\n  // will sometimes influence the value of checked (even after detachment).\n  // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416\n  // We need to temporarily unset name to avoid disrupting radio button groups.\n  var name = node.name;\n  if (name !== '') {\n    node.name = '';\n  }\n  node.defaultChecked = !node.defaultChecked;\n  node.defaultChecked = !node.defaultChecked;\n  if (name !== '') {\n    node.name = name;\n  }\n}\n\nfunction restoreControlledState$1(element, props) {\n  var node = element;\n  updateWrapper(node, props);\n  updateNamedCousins(node, props);\n}\n\nfunction updateNamedCousins(rootNode, props) {\n  var name = props.name;\n  if (props.type === 'radio' && name != null) {\n    var queryRoot = rootNode;\n\n    while (queryRoot.parentNode) {\n      queryRoot = queryRoot.parentNode;\n    }\n\n    // If `rootNode.form` was non-null, then we could try `form.elements`,\n    // but that sometimes behaves strangely in IE8. We could also try using\n    // `form.getElementsByName`, but that will only return direct children\n    // and won't include inputs that use the HTML5 `form=` attribute. Since\n    // the input might not even be in a form. It might not even be in the\n    // document. Let's just use the local `querySelectorAll` to ensure we don't\n    // miss anything.\n    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type=\"radio\"]');\n\n    for (var i = 0; i < group.length; i++) {\n      var otherNode = group[i];\n      if (otherNode === rootNode || otherNode.form !== rootNode.form) {\n        continue;\n      }\n      // This will throw if radio buttons rendered by different copies of React\n      // and the same name are rendered into the same form (same as #1939).\n      // That's probably okay; we don't support it just as we don't support\n      // mixing React radio buttons with non-React ones.\n      var otherProps = getFiberCurrentPropsFromNode$1(otherNode);\n      !otherProps ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.') : void 0;\n\n      // We need update the tracked value on the named cousin since the value\n      // was changed but the input saw no event or value set\n      updateValueIfChanged(otherNode);\n\n      // If this is a controlled radio button group, forcing the input that\n      // was previously checked to update will cause it to be come re-checked\n      // as appropriate.\n      updateWrapper(otherNode, otherProps);\n    }\n  }\n}\n\nfunction flattenChildren(children) {\n  var content = '';\n\n  // Flatten children and warn if they aren't strings or numbers;\n  // invalid types are ignored.\n  // We can silently skip them because invalid DOM nesting warning\n  // catches these cases in Fiber.\n  React.Children.forEach(children, function (child) {\n    if (child == null) {\n      return;\n    }\n    if (typeof child === 'string' || typeof child === 'number') {\n      content += child;\n    }\n  });\n\n  return content;\n}\n\n/**\n * Implements an <option> host component that warns when `selected` is set.\n */\n\nfunction validateProps(element, props) {\n  // TODO (yungsters): Remove support for `selected` in <option>.\n  {\n    warning(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.');\n  }\n}\n\nfunction postMountWrapper$1(element, props) {\n  // value=\"\" should make a value attribute (#6219)\n  if (props.value != null) {\n    element.setAttribute('value', props.value);\n  }\n}\n\nfunction getHostProps$1(element, props) {\n  var hostProps = _assign({ children: undefined }, props);\n  var content = flattenChildren(props.children);\n\n  if (content) {\n    hostProps.children = content;\n  }\n\n  return hostProps;\n}\n\n// TODO: direct imports like some-package/src/* are bad. Fix me.\nvar getCurrentFiberOwnerName$3 = ReactDebugCurrentFiber.getCurrentFiberOwnerName;\nvar getCurrentFiberStackAddendum$4 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;\n\n\n{\n  var didWarnValueDefaultValue$1 = false;\n}\n\nfunction getDeclarationErrorAddendum() {\n  var ownerName = getCurrentFiberOwnerName$3();\n  if (ownerName) {\n    return '\\n\\nCheck the render method of `' + ownerName + '`.';\n  }\n  return '';\n}\n\nvar valuePropNames = ['value', 'defaultValue'];\n\n/**\n * Validation function for `value` and `defaultValue`.\n */\nfunction checkSelectPropTypes(props) {\n  ReactControlledValuePropTypes.checkPropTypes('select', props, getCurrentFiberStackAddendum$4);\n\n  for (var i = 0; i < valuePropNames.length; i++) {\n    var propName = valuePropNames[i];\n    if (props[propName] == null) {\n      continue;\n    }\n    var isArray = Array.isArray(props[propName]);\n    if (props.multiple && !isArray) {\n      warning(false, 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum());\n    } else if (!props.multiple && isArray) {\n      warning(false, 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum());\n    }\n  }\n}\n\nfunction updateOptions(node, multiple, propValue, setDefaultSelected) {\n  var options = node.options;\n\n  if (multiple) {\n    var selectedValues = propValue;\n    var selectedValue = {};\n    for (var i = 0; i < selectedValues.length; i++) {\n      // Prefix to avoid chaos with special keys.\n      selectedValue['$' + selectedValues[i]] = true;\n    }\n    for (var _i = 0; _i < options.length; _i++) {\n      var selected = selectedValue.hasOwnProperty('$' + options[_i].value);\n      if (options[_i].selected !== selected) {\n        options[_i].selected = selected;\n      }\n      if (selected && setDefaultSelected) {\n        options[_i].defaultSelected = true;\n      }\n    }\n  } else {\n    // Do not set `select.value` as exact behavior isn't consistent across all\n    // browsers for all cases.\n    var _selectedValue = '' + propValue;\n    var defaultSelected = null;\n    for (var _i2 = 0; _i2 < options.length; _i2++) {\n      if (options[_i2].value === _selectedValue) {\n        options[_i2].selected = true;\n        if (setDefaultSelected) {\n          options[_i2].defaultSelected = true;\n        }\n        return;\n      }\n      if (defaultSelected === null && !options[_i2].disabled) {\n        defaultSelected = options[_i2];\n      }\n    }\n    if (defaultSelected !== null) {\n      defaultSelected.selected = true;\n    }\n  }\n}\n\n/**\n * Implements a <select> host component that allows optionally setting the\n * props `value` and `defaultValue`. If `multiple` is false, the prop must be a\n * stringable. If `multiple` is true, the prop must be an array of stringables.\n *\n * If `value` is not supplied (or null/undefined), user actions that change the\n * selected option will trigger updates to the rendered options.\n *\n * If it is supplied (and not null/undefined), the rendered options will not\n * update in response to user actions. Instead, the `value` prop must change in\n * order for the rendered options to update.\n *\n * If `defaultValue` is provided, any options with the supplied values will be\n * selected.\n */\n\nfunction getHostProps$2(element, props) {\n  return _assign({}, props, {\n    value: undefined\n  });\n}\n\nfunction initWrapperState$1(element, props) {\n  var node = element;\n  {\n    checkSelectPropTypes(props);\n  }\n\n  var value = props.value;\n  node._wrapperState = {\n    initialValue: value != null ? value : props.defaultValue,\n    wasMultiple: !!props.multiple\n  };\n\n  {\n    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue$1) {\n      warning(false, 'Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components');\n      didWarnValueDefaultValue$1 = true;\n    }\n  }\n}\n\nfunction postMountWrapper$2(element, props) {\n  var node = element;\n  node.multiple = !!props.multiple;\n  var value = props.value;\n  if (value != null) {\n    updateOptions(node, !!props.multiple, value, false);\n  } else if (props.defaultValue != null) {\n    updateOptions(node, !!props.multiple, props.defaultValue, true);\n  }\n}\n\nfunction postUpdateWrapper(element, props) {\n  var node = element;\n  // After the initial mount, we control selected-ness manually so don't pass\n  // this value down\n  node._wrapperState.initialValue = undefined;\n\n  var wasMultiple = node._wrapperState.wasMultiple;\n  node._wrapperState.wasMultiple = !!props.multiple;\n\n  var value = props.value;\n  if (value != null) {\n    updateOptions(node, !!props.multiple, value, false);\n  } else if (wasMultiple !== !!props.multiple) {\n    // For simplicity, reapply `defaultValue` if `multiple` is toggled.\n    if (props.defaultValue != null) {\n      updateOptions(node, !!props.multiple, props.defaultValue, true);\n    } else {\n      // Revert the select back to its default unselected state.\n      updateOptions(node, !!props.multiple, props.multiple ? [] : '', false);\n    }\n  }\n}\n\nfunction restoreControlledState$2(element, props) {\n  var node = element;\n  var value = props.value;\n\n  if (value != null) {\n    updateOptions(node, !!props.multiple, value, false);\n  }\n}\n\n// TODO: direct imports like some-package/src/* are bad. Fix me.\nvar getCurrentFiberStackAddendum$5 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;\n\nvar didWarnValDefaultVal = false;\n\n/**\n * Implements a <textarea> host component that allows setting `value`, and\n * `defaultValue`. This differs from the traditional DOM API because value is\n * usually set as PCDATA children.\n *\n * If `value` is not supplied (or null/undefined), user actions that affect the\n * value will trigger updates to the element.\n *\n * If `value` is supplied (and not null/undefined), the rendered element will\n * not trigger updates to the element. Instead, the `value` prop must change in\n * order for the rendered element to be updated.\n *\n * The rendered element will be initialized with an empty value, the prop\n * `defaultValue` if specified, or the children content (deprecated).\n */\n\nfunction getHostProps$3(element, props) {\n  var node = element;\n  !(props.dangerouslySetInnerHTML == null) ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : void 0;\n\n  // Always set children to the same thing. In IE9, the selection range will\n  // get reset if `textContent` is mutated.  We could add a check in setTextContent\n  // to only set the value if/when the value differs from the node value (which would\n  // completely solve this IE9 bug), but Sebastian+Sophie seemed to like this\n  // solution. The value can be a boolean or object so that's why it's forced\n  // to be a string.\n  var hostProps = _assign({}, props, {\n    value: undefined,\n    defaultValue: undefined,\n    children: '' + node._wrapperState.initialValue\n  });\n\n  return hostProps;\n}\n\nfunction initWrapperState$2(element, props) {\n  var node = element;\n  {\n    ReactControlledValuePropTypes.checkPropTypes('textarea', props, getCurrentFiberStackAddendum$5);\n    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {\n      warning(false, 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components');\n      didWarnValDefaultVal = true;\n    }\n  }\n\n  var initialValue = props.value;\n\n  // Only bother fetching default value if we're going to use it\n  if (initialValue == null) {\n    var defaultValue = props.defaultValue;\n    // TODO (yungsters): Remove support for children content in <textarea>.\n    var children = props.children;\n    if (children != null) {\n      {\n        warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.');\n      }\n      !(defaultValue == null) ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : void 0;\n      if (Array.isArray(children)) {\n        !(children.length <= 1) ? invariant(false, '<textarea> can only have at most one child.') : void 0;\n        children = children[0];\n      }\n\n      defaultValue = '' + children;\n    }\n    if (defaultValue == null) {\n      defaultValue = '';\n    }\n    initialValue = defaultValue;\n  }\n\n  node._wrapperState = {\n    initialValue: '' + initialValue\n  };\n}\n\nfunction updateWrapper$1(element, props) {\n  var node = element;\n  var value = props.value;\n  if (value != null) {\n    // Cast `value` to a string to ensure the value is set correctly. While\n    // browsers typically do this as necessary, jsdom doesn't.\n    var newValue = '' + value;\n\n    // To avoid side effects (such as losing text selection), only set value if changed\n    if (newValue !== node.value) {\n      node.value = newValue;\n    }\n    if (props.defaultValue == null) {\n      node.defaultValue = newValue;\n    }\n  }\n  if (props.defaultValue != null) {\n    node.defaultValue = props.defaultValue;\n  }\n}\n\nfunction postMountWrapper$3(element, props) {\n  var node = element;\n  // This is in postMount because we need access to the DOM node, which is not\n  // available until after the component has mounted.\n  var textContent = node.textContent;\n\n  // Only set node.value if textContent is equal to the expected\n  // initial value. In IE10/IE11 there is a bug where the placeholder attribute\n  // will populate textContent as well.\n  // https://developer.microsoft.com/microsoft-edge/platform/issues/101525/\n  if (textContent === node._wrapperState.initialValue) {\n    node.value = textContent;\n  }\n}\n\nfunction restoreControlledState$3(element, props) {\n  // DOM component is still mounted; update\n  updateWrapper$1(element, props);\n}\n\nvar HTML_NAMESPACE$1 = 'http://www.w3.org/1999/xhtml';\nvar MATH_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\nvar SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n\nvar Namespaces = {\n  html: HTML_NAMESPACE$1,\n  mathml: MATH_NAMESPACE,\n  svg: SVG_NAMESPACE\n};\n\n// Assumes there is no parent namespace.\nfunction getIntrinsicNamespace(type) {\n  switch (type) {\n    case 'svg':\n      return SVG_NAMESPACE;\n    case 'math':\n      return MATH_NAMESPACE;\n    default:\n      return HTML_NAMESPACE$1;\n  }\n}\n\nfunction getChildNamespace(parentNamespace, type) {\n  if (parentNamespace == null || parentNamespace === HTML_NAMESPACE$1) {\n    // No (or default) parent namespace: potential entry point.\n    return getIntrinsicNamespace(type);\n  }\n  if (parentNamespace === SVG_NAMESPACE && type === 'foreignObject') {\n    // We're leaving SVG.\n    return HTML_NAMESPACE$1;\n  }\n  // By default, pass namespace below.\n  return parentNamespace;\n}\n\n/* globals MSApp */\n\n/**\n * Create a function which has 'unsafe' privileges (required by windows8 apps)\n */\nvar createMicrosoftUnsafeLocalFunction = function (func) {\n  if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {\n    return function (arg0, arg1, arg2, arg3) {\n      MSApp.execUnsafeLocalFunction(function () {\n        return func(arg0, arg1, arg2, arg3);\n      });\n    };\n  } else {\n    return func;\n  }\n};\n\n// SVG temp container for IE lacking innerHTML\nvar reusableSVGContainer = void 0;\n\n/**\n * Set the innerHTML property of a node\n *\n * @param {DOMElement} node\n * @param {string} html\n * @internal\n */\nvar setInnerHTML = createMicrosoftUnsafeLocalFunction(function (node, html) {\n  // IE does not have innerHTML for SVG nodes, so instead we inject the\n  // new markup in a temp node and then move the child nodes across into\n  // the target node\n\n  if (node.namespaceURI === Namespaces.svg && !('innerHTML' in node)) {\n    reusableSVGContainer = reusableSVGContainer || document.createElement('div');\n    reusableSVGContainer.innerHTML = '<svg>' + html + '</svg>';\n    var svgNode = reusableSVGContainer.firstChild;\n    while (node.firstChild) {\n      node.removeChild(node.firstChild);\n    }\n    while (svgNode.firstChild) {\n      node.appendChild(svgNode.firstChild);\n    }\n  } else {\n    node.innerHTML = html;\n  }\n});\n\n/**\n * Set the textContent property of a node, ensuring that whitespace is preserved\n * even in IE8. innerText is a poor substitute for textContent and, among many\n * issues, inserts <br> instead of the literal newline chars. innerHTML behaves\n * as it should.\n *\n * @param {DOMElement} node\n * @param {string} text\n * @internal\n */\nvar setTextContent = function (node, text) {\n  if (text) {\n    var firstChild = node.firstChild;\n\n    if (firstChild && firstChild === node.lastChild && firstChild.nodeType === TEXT_NODE) {\n      firstChild.nodeValue = text;\n      return;\n    }\n  }\n  node.textContent = text;\n};\n\n/**\n * CSS properties which accept numbers but are not in units of \"px\".\n */\nvar isUnitlessNumber = {\n  animationIterationCount: true,\n  borderImageOutset: true,\n  borderImageSlice: true,\n  borderImageWidth: true,\n  boxFlex: true,\n  boxFlexGroup: true,\n  boxOrdinalGroup: true,\n  columnCount: true,\n  columns: true,\n  flex: true,\n  flexGrow: true,\n  flexPositive: true,\n  flexShrink: true,\n  flexNegative: true,\n  flexOrder: true,\n  gridRow: true,\n  gridRowEnd: true,\n  gridRowSpan: true,\n  gridRowStart: true,\n  gridColumn: true,\n  gridColumnEnd: true,\n  gridColumnSpan: true,\n  gridColumnStart: true,\n  fontWeight: true,\n  lineClamp: true,\n  lineHeight: true,\n  opacity: true,\n  order: true,\n  orphans: true,\n  tabSize: true,\n  widows: true,\n  zIndex: true,\n  zoom: true,\n\n  // SVG-related properties\n  fillOpacity: true,\n  floodOpacity: true,\n  stopOpacity: true,\n  strokeDasharray: true,\n  strokeDashoffset: true,\n  strokeMiterlimit: true,\n  strokeOpacity: true,\n  strokeWidth: true\n};\n\n/**\n * @param {string} prefix vendor-specific prefix, eg: Webkit\n * @param {string} key style name, eg: transitionDuration\n * @return {string} style name prefixed with `prefix`, properly camelCased, eg:\n * WebkitTransitionDuration\n */\nfunction prefixKey(prefix, key) {\n  return prefix + key.charAt(0).toUpperCase() + key.substring(1);\n}\n\n/**\n * Support style names that may come passed in prefixed by adding permutations\n * of vendor prefixes.\n */\nvar prefixes = ['Webkit', 'ms', 'Moz', 'O'];\n\n// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an\n// infinite loop, because it iterates over the newly added props too.\nObject.keys(isUnitlessNumber).forEach(function (prop) {\n  prefixes.forEach(function (prefix) {\n    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];\n  });\n});\n\n/**\n * Convert a value into the proper css writable value. The style name `name`\n * should be logical (no hyphens), as specified\n * in `CSSProperty.isUnitlessNumber`.\n *\n * @param {string} name CSS property name such as `topMargin`.\n * @param {*} value CSS property value such as `10px`.\n * @return {string} Normalized style value with dimensions applied.\n */\nfunction dangerousStyleValue(name, value, isCustomProperty) {\n  // Note that we've removed escapeTextForBrowser() calls here since the\n  // whole string will be escaped when the attribute is injected into\n  // the markup. If you provide unsafe user data here they can inject\n  // arbitrary CSS which may be problematic (I couldn't repro this):\n  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet\n  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/\n  // This is not an XSS hole but instead a potential CSS injection issue\n  // which has lead to a greater discussion about how we're going to\n  // trust URLs moving forward. See #2115901\n\n  var isEmpty = value == null || typeof value === 'boolean' || value === '';\n  if (isEmpty) {\n    return '';\n  }\n\n  if (!isCustomProperty && typeof value === 'number' && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) {\n    return value + 'px'; // Presumes implicit 'px' suffix for unitless numbers\n  }\n\n  return ('' + value).trim();\n}\n\nvar warnValidStyle = emptyFunction;\n\n{\n  // 'msTransform' is correct, but the other prefixes should be capitalized\n  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;\n\n  // style values shouldn't contain a semicolon\n  var badStyleValueWithSemicolonPattern = /;\\s*$/;\n\n  var warnedStyleNames = {};\n  var warnedStyleValues = {};\n  var warnedForNaNValue = false;\n  var warnedForInfinityValue = false;\n\n  var warnHyphenatedStyleName = function (name, getStack) {\n    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {\n      return;\n    }\n\n    warnedStyleNames[name] = true;\n    warning(false, 'Unsupported style property %s. Did you mean %s?%s', name, camelizeStyleName(name), getStack());\n  };\n\n  var warnBadVendoredStyleName = function (name, getStack) {\n    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {\n      return;\n    }\n\n    warnedStyleNames[name] = true;\n    warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?%s', name, name.charAt(0).toUpperCase() + name.slice(1), getStack());\n  };\n\n  var warnStyleValueWithSemicolon = function (name, value, getStack) {\n    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {\n      return;\n    }\n\n    warnedStyleValues[value] = true;\n    warning(false, \"Style property values shouldn't contain a semicolon. \" + 'Try \"%s: %s\" instead.%s', name, value.replace(badStyleValueWithSemicolonPattern, ''), getStack());\n  };\n\n  var warnStyleValueIsNaN = function (name, value, getStack) {\n    if (warnedForNaNValue) {\n      return;\n    }\n\n    warnedForNaNValue = true;\n    warning(false, '`NaN` is an invalid value for the `%s` css style property.%s', name, getStack());\n  };\n\n  var warnStyleValueIsInfinity = function (name, value, getStack) {\n    if (warnedForInfinityValue) {\n      return;\n    }\n\n    warnedForInfinityValue = true;\n    warning(false, '`Infinity` is an invalid value for the `%s` css style property.%s', name, getStack());\n  };\n\n  warnValidStyle = function (name, value, getStack) {\n    if (name.indexOf('-') > -1) {\n      warnHyphenatedStyleName(name, getStack);\n    } else if (badVendoredStyleNamePattern.test(name)) {\n      warnBadVendoredStyleName(name, getStack);\n    } else if (badStyleValueWithSemicolonPattern.test(value)) {\n      warnStyleValueWithSemicolon(name, value, getStack);\n    }\n\n    if (typeof value === 'number') {\n      if (isNaN(value)) {\n        warnStyleValueIsNaN(name, value, getStack);\n      } else if (!isFinite(value)) {\n        warnStyleValueIsInfinity(name, value, getStack);\n      }\n    }\n  };\n}\n\nvar warnValidStyle$1 = warnValidStyle;\n\n/**\n * Operations for dealing with CSS properties.\n */\n\n/**\n * This creates a string that is expected to be equivalent to the style\n * attribute generated by server-side rendering. It by-passes warnings and\n * security checks so it's not safe to use this value for anything other than\n * comparison. It is only used in DEV for SSR validation.\n */\nfunction createDangerousStringForStyles(styles) {\n  {\n    var serialized = '';\n    var delimiter = '';\n    for (var styleName in styles) {\n      if (!styles.hasOwnProperty(styleName)) {\n        continue;\n      }\n      var styleValue = styles[styleName];\n      if (styleValue != null) {\n        var isCustomProperty = styleName.indexOf('--') === 0;\n        serialized += delimiter + hyphenateStyleName(styleName) + ':';\n        serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);\n\n        delimiter = ';';\n      }\n    }\n    return serialized || null;\n  }\n}\n\n/**\n * Sets the value for multiple styles on a node.  If a value is specified as\n * '' (empty string), the corresponding style property will be unset.\n *\n * @param {DOMElement} node\n * @param {object} styles\n */\nfunction setValueForStyles(node, styles, getStack) {\n  var style = node.style;\n  for (var styleName in styles) {\n    if (!styles.hasOwnProperty(styleName)) {\n      continue;\n    }\n    var isCustomProperty = styleName.indexOf('--') === 0;\n    {\n      if (!isCustomProperty) {\n        warnValidStyle$1(styleName, styles[styleName], getStack);\n      }\n    }\n    var styleValue = dangerousStyleValue(styleName, styles[styleName], isCustomProperty);\n    if (styleName === 'float') {\n      styleName = 'cssFloat';\n    }\n    if (isCustomProperty) {\n      style.setProperty(styleName, styleValue);\n    } else {\n      style[styleName] = styleValue;\n    }\n  }\n}\n\n// For HTML, certain tags should omit their close tag. We keep a whitelist for\n// those special-case tags.\n\nvar omittedCloseTags = {\n  area: true,\n  base: true,\n  br: true,\n  col: true,\n  embed: true,\n  hr: true,\n  img: true,\n  input: true,\n  keygen: true,\n  link: true,\n  meta: true,\n  param: true,\n  source: true,\n  track: true,\n  wbr: true\n};\n\n// For HTML, certain tags cannot have children. This has the same purpose as\n// `omittedCloseTags` except that `menuitem` should still have its closing tag.\n\nvar voidElementTags = _assign({\n  menuitem: true\n}, omittedCloseTags);\n\nvar HTML$1 = '__html';\n\nfunction assertValidProps(tag, props, getStack) {\n  if (!props) {\n    return;\n  }\n  // Note the use of `==` which checks for null or undefined.\n  if (voidElementTags[tag]) {\n    !(props.children == null && props.dangerouslySetInnerHTML == null) ? invariant(false, '%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s', tag, getStack()) : void 0;\n  }\n  if (props.dangerouslySetInnerHTML != null) {\n    !(props.children == null) ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : void 0;\n    !(typeof props.dangerouslySetInnerHTML === 'object' && HTML$1 in props.dangerouslySetInnerHTML) ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.') : void 0;\n  }\n  {\n    warning(props.suppressContentEditableWarning || !props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.%s', getStack());\n  }\n  !(props.style == null || typeof props.style === 'object') ? invariant(false, 'The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \\'em\\'}} when using JSX.%s', getStack()) : void 0;\n}\n\nfunction isCustomComponent(tagName, props) {\n  if (tagName.indexOf('-') === -1) {\n    return typeof props.is === 'string';\n  }\n  switch (tagName) {\n    // These are reserved SVG and MathML elements.\n    // We don't mind this whitelist too much because we expect it to never grow.\n    // The alternative is to track the namespace in a few places which is convoluted.\n    // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts\n    case 'annotation-xml':\n    case 'color-profile':\n    case 'font-face':\n    case 'font-face-src':\n    case 'font-face-uri':\n    case 'font-face-format':\n    case 'font-face-name':\n    case 'missing-glyph':\n      return false;\n    default:\n      return true;\n  }\n}\n\nvar ariaProperties = {\n  'aria-current': 0, // state\n  'aria-details': 0,\n  'aria-disabled': 0, // state\n  'aria-hidden': 0, // state\n  'aria-invalid': 0, // state\n  'aria-keyshortcuts': 0,\n  'aria-label': 0,\n  'aria-roledescription': 0,\n  // Widget Attributes\n  'aria-autocomplete': 0,\n  'aria-checked': 0,\n  'aria-expanded': 0,\n  'aria-haspopup': 0,\n  'aria-level': 0,\n  'aria-modal': 0,\n  'aria-multiline': 0,\n  'aria-multiselectable': 0,\n  'aria-orientation': 0,\n  'aria-placeholder': 0,\n  'aria-pressed': 0,\n  'aria-readonly': 0,\n  'aria-required': 0,\n  'aria-selected': 0,\n  'aria-sort': 0,\n  'aria-valuemax': 0,\n  'aria-valuemin': 0,\n  'aria-valuenow': 0,\n  'aria-valuetext': 0,\n  // Live Region Attributes\n  'aria-atomic': 0,\n  'aria-busy': 0,\n  'aria-live': 0,\n  'aria-relevant': 0,\n  // Drag-and-Drop Attributes\n  'aria-dropeffect': 0,\n  'aria-grabbed': 0,\n  // Relationship Attributes\n  'aria-activedescendant': 0,\n  'aria-colcount': 0,\n  'aria-colindex': 0,\n  'aria-colspan': 0,\n  'aria-controls': 0,\n  'aria-describedby': 0,\n  'aria-errormessage': 0,\n  'aria-flowto': 0,\n  'aria-labelledby': 0,\n  'aria-owns': 0,\n  'aria-posinset': 0,\n  'aria-rowcount': 0,\n  'aria-rowindex': 0,\n  'aria-rowspan': 0,\n  'aria-setsize': 0\n};\n\nvar warnedProperties = {};\nvar rARIA = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');\nvar rARIACamel = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction getStackAddendum() {\n  var stack = ReactDebugCurrentFrame.getStackAddendum();\n  return stack != null ? stack : '';\n}\n\nfunction validateProperty(tagName, name) {\n  if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) {\n    return true;\n  }\n\n  if (rARIACamel.test(name)) {\n    var ariaName = 'aria-' + name.slice(4).toLowerCase();\n    var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;\n\n    // If this is an aria-* attribute, but is not listed in the known DOM\n    // DOM properties, then it is an invalid aria-* attribute.\n    if (correctName == null) {\n      warning(false, 'Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.%s', name, getStackAddendum());\n      warnedProperties[name] = true;\n      return true;\n    }\n    // aria-* attributes should be lowercase; suggest the lowercase version.\n    if (name !== correctName) {\n      warning(false, 'Invalid ARIA attribute `%s`. Did you mean `%s`?%s', name, correctName, getStackAddendum());\n      warnedProperties[name] = true;\n      return true;\n    }\n  }\n\n  if (rARIA.test(name)) {\n    var lowerCasedName = name.toLowerCase();\n    var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;\n\n    // If this is an aria-* attribute, but is not listed in the known DOM\n    // DOM properties, then it is an invalid aria-* attribute.\n    if (standardName == null) {\n      warnedProperties[name] = true;\n      return false;\n    }\n    // aria-* attributes should be lowercase; suggest the lowercase version.\n    if (name !== standardName) {\n      warning(false, 'Unknown ARIA attribute `%s`. Did you mean `%s`?%s', name, standardName, getStackAddendum());\n      warnedProperties[name] = true;\n      return true;\n    }\n  }\n\n  return true;\n}\n\nfunction warnInvalidARIAProps(type, props) {\n  var invalidProps = [];\n\n  for (var key in props) {\n    var isValid = validateProperty(type, key);\n    if (!isValid) {\n      invalidProps.push(key);\n    }\n  }\n\n  var unknownPropString = invalidProps.map(function (prop) {\n    return '`' + prop + '`';\n  }).join(', ');\n\n  if (invalidProps.length === 1) {\n    warning(false, 'Invalid aria prop %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, type, getStackAddendum());\n  } else if (invalidProps.length > 1) {\n    warning(false, 'Invalid aria props %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, type, getStackAddendum());\n  }\n}\n\nfunction validateProperties(type, props) {\n  if (isCustomComponent(type, props)) {\n    return;\n  }\n  warnInvalidARIAProps(type, props);\n}\n\nvar didWarnValueNull = false;\n\nfunction getStackAddendum$1() {\n  var stack = ReactDebugCurrentFrame.getStackAddendum();\n  return stack != null ? stack : '';\n}\n\nfunction validateProperties$1(type, props) {\n  if (type !== 'input' && type !== 'textarea' && type !== 'select') {\n    return;\n  }\n\n  if (props != null && props.value === null && !didWarnValueNull) {\n    didWarnValueNull = true;\n    if (type === 'select' && props.multiple) {\n      warning(false, '`value` prop on `%s` should not be null. ' + 'Consider using an empty array when `multiple` is set to `true` ' + 'to clear the component or `undefined` for uncontrolled components.%s', type, getStackAddendum$1());\n    } else {\n      warning(false, '`value` prop on `%s` should not be null. ' + 'Consider using an empty string to clear the component or `undefined` ' + 'for uncontrolled components.%s', type, getStackAddendum$1());\n    }\n  }\n}\n\n// When adding attributes to the HTML or SVG whitelist, be sure to\n// also add them to this module to ensure casing and incorrect name\n// warnings.\nvar possibleStandardNames = {\n  // HTML\n  accept: 'accept',\n  acceptcharset: 'acceptCharset',\n  'accept-charset': 'acceptCharset',\n  accesskey: 'accessKey',\n  action: 'action',\n  allowfullscreen: 'allowFullScreen',\n  alt: 'alt',\n  as: 'as',\n  async: 'async',\n  autocapitalize: 'autoCapitalize',\n  autocomplete: 'autoComplete',\n  autocorrect: 'autoCorrect',\n  autofocus: 'autoFocus',\n  autoplay: 'autoPlay',\n  autosave: 'autoSave',\n  capture: 'capture',\n  cellpadding: 'cellPadding',\n  cellspacing: 'cellSpacing',\n  challenge: 'challenge',\n  charset: 'charSet',\n  checked: 'checked',\n  children: 'children',\n  cite: 'cite',\n  'class': 'className',\n  classid: 'classID',\n  classname: 'className',\n  cols: 'cols',\n  colspan: 'colSpan',\n  content: 'content',\n  contenteditable: 'contentEditable',\n  contextmenu: 'contextMenu',\n  controls: 'controls',\n  controlslist: 'controlsList',\n  coords: 'coords',\n  crossorigin: 'crossOrigin',\n  dangerouslysetinnerhtml: 'dangerouslySetInnerHTML',\n  data: 'data',\n  datetime: 'dateTime',\n  'default': 'default',\n  defaultchecked: 'defaultChecked',\n  defaultvalue: 'defaultValue',\n  defer: 'defer',\n  dir: 'dir',\n  disabled: 'disabled',\n  download: 'download',\n  draggable: 'draggable',\n  enctype: 'encType',\n  'for': 'htmlFor',\n  form: 'form',\n  formmethod: 'formMethod',\n  formaction: 'formAction',\n  formenctype: 'formEncType',\n  formnovalidate: 'formNoValidate',\n  formtarget: 'formTarget',\n  frameborder: 'frameBorder',\n  headers: 'headers',\n  height: 'height',\n  hidden: 'hidden',\n  high: 'high',\n  href: 'href',\n  hreflang: 'hrefLang',\n  htmlfor: 'htmlFor',\n  httpequiv: 'httpEquiv',\n  'http-equiv': 'httpEquiv',\n  icon: 'icon',\n  id: 'id',\n  innerhtml: 'innerHTML',\n  inputmode: 'inputMode',\n  integrity: 'integrity',\n  is: 'is',\n  itemid: 'itemID',\n  itemprop: 'itemProp',\n  itemref: 'itemRef',\n  itemscope: 'itemScope',\n  itemtype: 'itemType',\n  keyparams: 'keyParams',\n  keytype: 'keyType',\n  kind: 'kind',\n  label: 'label',\n  lang: 'lang',\n  list: 'list',\n  loop: 'loop',\n  low: 'low',\n  manifest: 'manifest',\n  marginwidth: 'marginWidth',\n  marginheight: 'marginHeight',\n  max: 'max',\n  maxlength: 'maxLength',\n  media: 'media',\n  mediagroup: 'mediaGroup',\n  method: 'method',\n  min: 'min',\n  minlength: 'minLength',\n  multiple: 'multiple',\n  muted: 'muted',\n  name: 'name',\n  nonce: 'nonce',\n  novalidate: 'noValidate',\n  open: 'open',\n  optimum: 'optimum',\n  pattern: 'pattern',\n  placeholder: 'placeholder',\n  playsinline: 'playsInline',\n  poster: 'poster',\n  preload: 'preload',\n  profile: 'profile',\n  radiogroup: 'radioGroup',\n  readonly: 'readOnly',\n  referrerpolicy: 'referrerPolicy',\n  rel: 'rel',\n  required: 'required',\n  reversed: 'reversed',\n  role: 'role',\n  rows: 'rows',\n  rowspan: 'rowSpan',\n  sandbox: 'sandbox',\n  scope: 'scope',\n  scoped: 'scoped',\n  scrolling: 'scrolling',\n  seamless: 'seamless',\n  selected: 'selected',\n  shape: 'shape',\n  size: 'size',\n  sizes: 'sizes',\n  span: 'span',\n  spellcheck: 'spellCheck',\n  src: 'src',\n  srcdoc: 'srcDoc',\n  srclang: 'srcLang',\n  srcset: 'srcSet',\n  start: 'start',\n  step: 'step',\n  style: 'style',\n  summary: 'summary',\n  tabindex: 'tabIndex',\n  target: 'target',\n  title: 'title',\n  type: 'type',\n  usemap: 'useMap',\n  value: 'value',\n  width: 'width',\n  wmode: 'wmode',\n  wrap: 'wrap',\n\n  // SVG\n  about: 'about',\n  accentheight: 'accentHeight',\n  'accent-height': 'accentHeight',\n  accumulate: 'accumulate',\n  additive: 'additive',\n  alignmentbaseline: 'alignmentBaseline',\n  'alignment-baseline': 'alignmentBaseline',\n  allowreorder: 'allowReorder',\n  alphabetic: 'alphabetic',\n  amplitude: 'amplitude',\n  arabicform: 'arabicForm',\n  'arabic-form': 'arabicForm',\n  ascent: 'ascent',\n  attributename: 'attributeName',\n  attributetype: 'attributeType',\n  autoreverse: 'autoReverse',\n  azimuth: 'azimuth',\n  basefrequency: 'baseFrequency',\n  baselineshift: 'baselineShift',\n  'baseline-shift': 'baselineShift',\n  baseprofile: 'baseProfile',\n  bbox: 'bbox',\n  begin: 'begin',\n  bias: 'bias',\n  by: 'by',\n  calcmode: 'calcMode',\n  capheight: 'capHeight',\n  'cap-height': 'capHeight',\n  clip: 'clip',\n  clippath: 'clipPath',\n  'clip-path': 'clipPath',\n  clippathunits: 'clipPathUnits',\n  cliprule: 'clipRule',\n  'clip-rule': 'clipRule',\n  color: 'color',\n  colorinterpolation: 'colorInterpolation',\n  'color-interpolation': 'colorInterpolation',\n  colorinterpolationfilters: 'colorInterpolationFilters',\n  'color-interpolation-filters': 'colorInterpolationFilters',\n  colorprofile: 'colorProfile',\n  'color-profile': 'colorProfile',\n  colorrendering: 'colorRendering',\n  'color-rendering': 'colorRendering',\n  contentscripttype: 'contentScriptType',\n  contentstyletype: 'contentStyleType',\n  cursor: 'cursor',\n  cx: 'cx',\n  cy: 'cy',\n  d: 'd',\n  datatype: 'datatype',\n  decelerate: 'decelerate',\n  descent: 'descent',\n  diffuseconstant: 'diffuseConstant',\n  direction: 'direction',\n  display: 'display',\n  divisor: 'divisor',\n  dominantbaseline: 'dominantBaseline',\n  'dominant-baseline': 'dominantBaseline',\n  dur: 'dur',\n  dx: 'dx',\n  dy: 'dy',\n  edgemode: 'edgeMode',\n  elevation: 'elevation',\n  enablebackground: 'enableBackground',\n  'enable-background': 'enableBackground',\n  end: 'end',\n  exponent: 'exponent',\n  externalresourcesrequired: 'externalResourcesRequired',\n  fill: 'fill',\n  fillopacity: 'fillOpacity',\n  'fill-opacity': 'fillOpacity',\n  fillrule: 'fillRule',\n  'fill-rule': 'fillRule',\n  filter: 'filter',\n  filterres: 'filterRes',\n  filterunits: 'filterUnits',\n  floodopacity: 'floodOpacity',\n  'flood-opacity': 'floodOpacity',\n  floodcolor: 'floodColor',\n  'flood-color': 'floodColor',\n  focusable: 'focusable',\n  fontfamily: 'fontFamily',\n  'font-family': 'fontFamily',\n  fontsize: 'fontSize',\n  'font-size': 'fontSize',\n  fontsizeadjust: 'fontSizeAdjust',\n  'font-size-adjust': 'fontSizeAdjust',\n  fontstretch: 'fontStretch',\n  'font-stretch': 'fontStretch',\n  fontstyle: 'fontStyle',\n  'font-style': 'fontStyle',\n  fontvariant: 'fontVariant',\n  'font-variant': 'fontVariant',\n  fontweight: 'fontWeight',\n  'font-weight': 'fontWeight',\n  format: 'format',\n  from: 'from',\n  fx: 'fx',\n  fy: 'fy',\n  g1: 'g1',\n  g2: 'g2',\n  glyphname: 'glyphName',\n  'glyph-name': 'glyphName',\n  glyphorientationhorizontal: 'glyphOrientationHorizontal',\n  'glyph-orientation-horizontal': 'glyphOrientationHorizontal',\n  glyphorientationvertical: 'glyphOrientationVertical',\n  'glyph-orientation-vertical': 'glyphOrientationVertical',\n  glyphref: 'glyphRef',\n  gradienttransform: 'gradientTransform',\n  gradientunits: 'gradientUnits',\n  hanging: 'hanging',\n  horizadvx: 'horizAdvX',\n  'horiz-adv-x': 'horizAdvX',\n  horizoriginx: 'horizOriginX',\n  'horiz-origin-x': 'horizOriginX',\n  ideographic: 'ideographic',\n  imagerendering: 'imageRendering',\n  'image-rendering': 'imageRendering',\n  in2: 'in2',\n  'in': 'in',\n  inlist: 'inlist',\n  intercept: 'intercept',\n  k1: 'k1',\n  k2: 'k2',\n  k3: 'k3',\n  k4: 'k4',\n  k: 'k',\n  kernelmatrix: 'kernelMatrix',\n  kernelunitlength: 'kernelUnitLength',\n  kerning: 'kerning',\n  keypoints: 'keyPoints',\n  keysplines: 'keySplines',\n  keytimes: 'keyTimes',\n  lengthadjust: 'lengthAdjust',\n  letterspacing: 'letterSpacing',\n  'letter-spacing': 'letterSpacing',\n  lightingcolor: 'lightingColor',\n  'lighting-color': 'lightingColor',\n  limitingconeangle: 'limitingConeAngle',\n  local: 'local',\n  markerend: 'markerEnd',\n  'marker-end': 'markerEnd',\n  markerheight: 'markerHeight',\n  markermid: 'markerMid',\n  'marker-mid': 'markerMid',\n  markerstart: 'markerStart',\n  'marker-start': 'markerStart',\n  markerunits: 'markerUnits',\n  markerwidth: 'markerWidth',\n  mask: 'mask',\n  maskcontentunits: 'maskContentUnits',\n  maskunits: 'maskUnits',\n  mathematical: 'mathematical',\n  mode: 'mode',\n  numoctaves: 'numOctaves',\n  offset: 'offset',\n  opacity: 'opacity',\n  operator: 'operator',\n  order: 'order',\n  orient: 'orient',\n  orientation: 'orientation',\n  origin: 'origin',\n  overflow: 'overflow',\n  overlineposition: 'overlinePosition',\n  'overline-position': 'overlinePosition',\n  overlinethickness: 'overlineThickness',\n  'overline-thickness': 'overlineThickness',\n  paintorder: 'paintOrder',\n  'paint-order': 'paintOrder',\n  panose1: 'panose1',\n  'panose-1': 'panose1',\n  pathlength: 'pathLength',\n  patterncontentunits: 'patternContentUnits',\n  patterntransform: 'patternTransform',\n  patternunits: 'patternUnits',\n  pointerevents: 'pointerEvents',\n  'pointer-events': 'pointerEvents',\n  points: 'points',\n  pointsatx: 'pointsAtX',\n  pointsaty: 'pointsAtY',\n  pointsatz: 'pointsAtZ',\n  prefix: 'prefix',\n  preservealpha: 'preserveAlpha',\n  preserveaspectratio: 'preserveAspectRatio',\n  primitiveunits: 'primitiveUnits',\n  property: 'property',\n  r: 'r',\n  radius: 'radius',\n  refx: 'refX',\n  refy: 'refY',\n  renderingintent: 'renderingIntent',\n  'rendering-intent': 'renderingIntent',\n  repeatcount: 'repeatCount',\n  repeatdur: 'repeatDur',\n  requiredextensions: 'requiredExtensions',\n  requiredfeatures: 'requiredFeatures',\n  resource: 'resource',\n  restart: 'restart',\n  result: 'result',\n  results: 'results',\n  rotate: 'rotate',\n  rx: 'rx',\n  ry: 'ry',\n  scale: 'scale',\n  security: 'security',\n  seed: 'seed',\n  shaperendering: 'shapeRendering',\n  'shape-rendering': 'shapeRendering',\n  slope: 'slope',\n  spacing: 'spacing',\n  specularconstant: 'specularConstant',\n  specularexponent: 'specularExponent',\n  speed: 'speed',\n  spreadmethod: 'spreadMethod',\n  startoffset: 'startOffset',\n  stddeviation: 'stdDeviation',\n  stemh: 'stemh',\n  stemv: 'stemv',\n  stitchtiles: 'stitchTiles',\n  stopcolor: 'stopColor',\n  'stop-color': 'stopColor',\n  stopopacity: 'stopOpacity',\n  'stop-opacity': 'stopOpacity',\n  strikethroughposition: 'strikethroughPosition',\n  'strikethrough-position': 'strikethroughPosition',\n  strikethroughthickness: 'strikethroughThickness',\n  'strikethrough-thickness': 'strikethroughThickness',\n  string: 'string',\n  stroke: 'stroke',\n  strokedasharray: 'strokeDasharray',\n  'stroke-dasharray': 'strokeDasharray',\n  strokedashoffset: 'strokeDashoffset',\n  'stroke-dashoffset': 'strokeDashoffset',\n  strokelinecap: 'strokeLinecap',\n  'stroke-linecap': 'strokeLinecap',\n  strokelinejoin: 'strokeLinejoin',\n  'stroke-linejoin': 'strokeLinejoin',\n  strokemiterlimit: 'strokeMiterlimit',\n  'stroke-miterlimit': 'strokeMiterlimit',\n  strokewidth: 'strokeWidth',\n  'stroke-width': 'strokeWidth',\n  strokeopacity: 'strokeOpacity',\n  'stroke-opacity': 'strokeOpacity',\n  suppresscontenteditablewarning: 'suppressContentEditableWarning',\n  suppresshydrationwarning: 'suppressHydrationWarning',\n  surfacescale: 'surfaceScale',\n  systemlanguage: 'systemLanguage',\n  tablevalues: 'tableValues',\n  targetx: 'targetX',\n  targety: 'targetY',\n  textanchor: 'textAnchor',\n  'text-anchor': 'textAnchor',\n  textdecoration: 'textDecoration',\n  'text-decoration': 'textDecoration',\n  textlength: 'textLength',\n  textrendering: 'textRendering',\n  'text-rendering': 'textRendering',\n  to: 'to',\n  transform: 'transform',\n  'typeof': 'typeof',\n  u1: 'u1',\n  u2: 'u2',\n  underlineposition: 'underlinePosition',\n  'underline-position': 'underlinePosition',\n  underlinethickness: 'underlineThickness',\n  'underline-thickness': 'underlineThickness',\n  unicode: 'unicode',\n  unicodebidi: 'unicodeBidi',\n  'unicode-bidi': 'unicodeBidi',\n  unicoderange: 'unicodeRange',\n  'unicode-range': 'unicodeRange',\n  unitsperem: 'unitsPerEm',\n  'units-per-em': 'unitsPerEm',\n  unselectable: 'unselectable',\n  valphabetic: 'vAlphabetic',\n  'v-alphabetic': 'vAlphabetic',\n  values: 'values',\n  vectoreffect: 'vectorEffect',\n  'vector-effect': 'vectorEffect',\n  version: 'version',\n  vertadvy: 'vertAdvY',\n  'vert-adv-y': 'vertAdvY',\n  vertoriginx: 'vertOriginX',\n  'vert-origin-x': 'vertOriginX',\n  vertoriginy: 'vertOriginY',\n  'vert-origin-y': 'vertOriginY',\n  vhanging: 'vHanging',\n  'v-hanging': 'vHanging',\n  videographic: 'vIdeographic',\n  'v-ideographic': 'vIdeographic',\n  viewbox: 'viewBox',\n  viewtarget: 'viewTarget',\n  visibility: 'visibility',\n  vmathematical: 'vMathematical',\n  'v-mathematical': 'vMathematical',\n  vocab: 'vocab',\n  widths: 'widths',\n  wordspacing: 'wordSpacing',\n  'word-spacing': 'wordSpacing',\n  writingmode: 'writingMode',\n  'writing-mode': 'writingMode',\n  x1: 'x1',\n  x2: 'x2',\n  x: 'x',\n  xchannelselector: 'xChannelSelector',\n  xheight: 'xHeight',\n  'x-height': 'xHeight',\n  xlinkactuate: 'xlinkActuate',\n  'xlink:actuate': 'xlinkActuate',\n  xlinkarcrole: 'xlinkArcrole',\n  'xlink:arcrole': 'xlinkArcrole',\n  xlinkhref: 'xlinkHref',\n  'xlink:href': 'xlinkHref',\n  xlinkrole: 'xlinkRole',\n  'xlink:role': 'xlinkRole',\n  xlinkshow: 'xlinkShow',\n  'xlink:show': 'xlinkShow',\n  xlinktitle: 'xlinkTitle',\n  'xlink:title': 'xlinkTitle',\n  xlinktype: 'xlinkType',\n  'xlink:type': 'xlinkType',\n  xmlbase: 'xmlBase',\n  'xml:base': 'xmlBase',\n  xmllang: 'xmlLang',\n  'xml:lang': 'xmlLang',\n  xmlns: 'xmlns',\n  'xml:space': 'xmlSpace',\n  xmlnsxlink: 'xmlnsXlink',\n  'xmlns:xlink': 'xmlnsXlink',\n  xmlspace: 'xmlSpace',\n  y1: 'y1',\n  y2: 'y2',\n  y: 'y',\n  ychannelselector: 'yChannelSelector',\n  z: 'z',\n  zoomandpan: 'zoomAndPan'\n};\n\nfunction getStackAddendum$2() {\n  var stack = ReactDebugCurrentFrame.getStackAddendum();\n  return stack != null ? stack : '';\n}\n\n{\n  var warnedProperties$1 = {};\n  var hasOwnProperty$1 = Object.prototype.hasOwnProperty;\n  var EVENT_NAME_REGEX = /^on./;\n  var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;\n  var rARIA$1 = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');\n  var rARIACamel$1 = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');\n\n  var validateProperty$1 = function (tagName, name, value, canUseEventSystem) {\n    if (hasOwnProperty$1.call(warnedProperties$1, name) && warnedProperties$1[name]) {\n      return true;\n    }\n\n    var lowerCasedName = name.toLowerCase();\n    if (lowerCasedName === 'onfocusin' || lowerCasedName === 'onfocusout') {\n      warning(false, 'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.');\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    // We can't rely on the event system being injected on the server.\n    if (canUseEventSystem) {\n      if (registrationNameModules.hasOwnProperty(name)) {\n        return true;\n      }\n      var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;\n      if (registrationName != null) {\n        warning(false, 'Invalid event handler property `%s`. Did you mean `%s`?%s', name, registrationName, getStackAddendum$2());\n        warnedProperties$1[name] = true;\n        return true;\n      }\n      if (EVENT_NAME_REGEX.test(name)) {\n        warning(false, 'Unknown event handler property `%s`. It will be ignored.%s', name, getStackAddendum$2());\n        warnedProperties$1[name] = true;\n        return true;\n      }\n    } else if (EVENT_NAME_REGEX.test(name)) {\n      // If no event plugins have been injected, we are in a server environment.\n      // So we can't tell if the event name is correct for sure, but we can filter\n      // out known bad ones like `onclick`. We can't suggest a specific replacement though.\n      if (INVALID_EVENT_NAME_REGEX.test(name)) {\n        warning(false, 'Invalid event handler property `%s`. ' + 'React events use the camelCase naming convention, for example `onClick`.%s', name, getStackAddendum$2());\n      }\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    // Let the ARIA attribute hook validate ARIA attributes\n    if (rARIA$1.test(name) || rARIACamel$1.test(name)) {\n      return true;\n    }\n\n    if (lowerCasedName === 'innerhtml') {\n      warning(false, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.');\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    if (lowerCasedName === 'aria') {\n      warning(false, 'The `aria` attribute is reserved for future use in React. ' + 'Pass individual `aria-` attributes instead.');\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    if (lowerCasedName === 'is' && value !== null && value !== undefined && typeof value !== 'string') {\n      warning(false, 'Received a `%s` for a string attribute `is`. If this is expected, cast ' + 'the value to a string.%s', typeof value, getStackAddendum$2());\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    if (typeof value === 'number' && isNaN(value)) {\n      warning(false, 'Received NaN for the `%s` attribute. If this is expected, cast ' + 'the value to a string.%s', name, getStackAddendum$2());\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    var isReserved = isReservedProp(name);\n\n    // Known attributes should match the casing specified in the property config.\n    if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {\n      var standardName = possibleStandardNames[lowerCasedName];\n      if (standardName !== name) {\n        warning(false, 'Invalid DOM property `%s`. Did you mean `%s`?%s', name, standardName, getStackAddendum$2());\n        warnedProperties$1[name] = true;\n        return true;\n      }\n    } else if (!isReserved && name !== lowerCasedName) {\n      // Unknown attributes should have lowercase casing since that's how they\n      // will be cased anyway with server rendering.\n      warning(false, 'React does not recognize the `%s` prop on a DOM element. If you ' + 'intentionally want it to appear in the DOM as a custom ' + 'attribute, spell it as lowercase `%s` instead. ' + 'If you accidentally passed it from a parent component, remove ' + 'it from the DOM element.%s', name, lowerCasedName, getStackAddendum$2());\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    if (typeof value === 'boolean' && !shouldAttributeAcceptBooleanValue(name)) {\n      if (value) {\n        warning(false, 'Received `%s` for a non-boolean attribute `%s`.\\n\\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s=\"%s\" or %s={value.toString()}.%s', value, name, name, value, name, getStackAddendum$2());\n      } else {\n        warning(false, 'Received `%s` for a non-boolean attribute `%s`.\\n\\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s=\"%s\" or %s={value.toString()}.\\n\\n' + 'If you used to conditionally omit it with %s={condition && value}, ' + 'pass %s={condition ? value : undefined} instead.%s', value, name, name, value, name, name, name, getStackAddendum$2());\n      }\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    // Now that we've validated casing, do not validate\n    // data types for reserved props\n    if (isReserved) {\n      return true;\n    }\n\n    // Warn when a known attribute is a bad type\n    if (!shouldSetAttribute(name, value)) {\n      warnedProperties$1[name] = true;\n      return false;\n    }\n\n    return true;\n  };\n}\n\nvar warnUnknownProperties = function (type, props, canUseEventSystem) {\n  var unknownProps = [];\n  for (var key in props) {\n    var isValid = validateProperty$1(type, key, props[key], canUseEventSystem);\n    if (!isValid) {\n      unknownProps.push(key);\n    }\n  }\n\n  var unknownPropString = unknownProps.map(function (prop) {\n    return '`' + prop + '`';\n  }).join(', ');\n  if (unknownProps.length === 1) {\n    warning(false, 'Invalid value for prop %s on <%s> tag. Either remove it from the element, ' + 'or pass a string or number value to keep it in the DOM. ' + 'For details, see https://fb.me/react-attribute-behavior%s', unknownPropString, type, getStackAddendum$2());\n  } else if (unknownProps.length > 1) {\n    warning(false, 'Invalid values for props %s on <%s> tag. Either remove them from the element, ' + 'or pass a string or number value to keep them in the DOM. ' + 'For details, see https://fb.me/react-attribute-behavior%s', unknownPropString, type, getStackAddendum$2());\n  }\n};\n\nfunction validateProperties$2(type, props, canUseEventSystem) {\n  if (isCustomComponent(type, props)) {\n    return;\n  }\n  warnUnknownProperties(type, props, canUseEventSystem);\n}\n\n// TODO: direct imports like some-package/src/* are bad. Fix me.\nvar getCurrentFiberOwnerName$1 = ReactDebugCurrentFiber.getCurrentFiberOwnerName;\nvar getCurrentFiberStackAddendum$2 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;\n\nvar didWarnInvalidHydration = false;\nvar didWarnShadyDOM = false;\n\nvar DANGEROUSLY_SET_INNER_HTML = 'dangerouslySetInnerHTML';\nvar SUPPRESS_CONTENT_EDITABLE_WARNING = 'suppressContentEditableWarning';\nvar SUPPRESS_HYDRATION_WARNING$1 = 'suppressHydrationWarning';\nvar AUTOFOCUS = 'autoFocus';\nvar CHILDREN = 'children';\nvar STYLE = 'style';\nvar HTML = '__html';\n\nvar HTML_NAMESPACE = Namespaces.html;\n\n\nvar getStack = emptyFunction.thatReturns('');\n\n{\n  getStack = getCurrentFiberStackAddendum$2;\n\n  var warnedUnknownTags = {\n    // Chrome is the only major browser not shipping <time>. But as of July\n    // 2017 it intends to ship it due to widespread usage. We intentionally\n    // *don't* warn for <time> even if it's unrecognized by Chrome because\n    // it soon will be, and many apps have been using it anyway.\n    time: true,\n    // There are working polyfills for <dialog>. Let people use it.\n    dialog: true\n  };\n\n  var validatePropertiesInDevelopment = function (type, props) {\n    validateProperties(type, props);\n    validateProperties$1(type, props);\n    validateProperties$2(type, props, /* canUseEventSystem */true);\n  };\n\n  // HTML parsing normalizes CR and CRLF to LF.\n  // It also can turn \\u0000 into \\uFFFD inside attributes.\n  // https://www.w3.org/TR/html5/single-page.html#preprocessing-the-input-stream\n  // If we have a mismatch, it might be caused by that.\n  // We will still patch up in this case but not fire the warning.\n  var NORMALIZE_NEWLINES_REGEX = /\\r\\n?/g;\n  var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\\u0000|\\uFFFD/g;\n\n  var normalizeMarkupForTextOrAttribute = function (markup) {\n    var markupString = typeof markup === 'string' ? markup : '' + markup;\n    return markupString.replace(NORMALIZE_NEWLINES_REGEX, '\\n').replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, '');\n  };\n\n  var warnForTextDifference = function (serverText, clientText) {\n    if (didWarnInvalidHydration) {\n      return;\n    }\n    var normalizedClientText = normalizeMarkupForTextOrAttribute(clientText);\n    var normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);\n    if (normalizedServerText === normalizedClientText) {\n      return;\n    }\n    didWarnInvalidHydration = true;\n    warning(false, 'Text content did not match. Server: \"%s\" Client: \"%s\"', normalizedServerText, normalizedClientText);\n  };\n\n  var warnForPropDifference = function (propName, serverValue, clientValue) {\n    if (didWarnInvalidHydration) {\n      return;\n    }\n    var normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue);\n    var normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);\n    if (normalizedServerValue === normalizedClientValue) {\n      return;\n    }\n    didWarnInvalidHydration = true;\n    warning(false, 'Prop `%s` did not match. Server: %s Client: %s', propName, JSON.stringify(normalizedServerValue), JSON.stringify(normalizedClientValue));\n  };\n\n  var warnForExtraAttributes = function (attributeNames) {\n    if (didWarnInvalidHydration) {\n      return;\n    }\n    didWarnInvalidHydration = true;\n    var names = [];\n    attributeNames.forEach(function (name) {\n      names.push(name);\n    });\n    warning(false, 'Extra attributes from the server: %s', names);\n  };\n\n  var warnForInvalidEventListener = function (registrationName, listener) {\n    if (listener === false) {\n      warning(false, 'Expected `%s` listener to be a function, instead got `false`.\\n\\n' + 'If you used to conditionally omit it with %s={condition && value}, ' + 'pass %s={condition ? value : undefined} instead.%s', registrationName, registrationName, registrationName, getCurrentFiberStackAddendum$2());\n    } else {\n      warning(false, 'Expected `%s` listener to be a function, instead got a value of `%s` type.%s', registrationName, typeof listener, getCurrentFiberStackAddendum$2());\n    }\n  };\n\n  // Parse the HTML and read it back to normalize the HTML string so that it\n  // can be used for comparison.\n  var normalizeHTML = function (parent, html) {\n    // We could have created a separate document here to avoid\n    // re-initializing custom elements if they exist. But this breaks\n    // how <noscript> is being handled. So we use the same document.\n    // See the discussion in https://github.com/facebook/react/pull/11157.\n    var testElement = parent.namespaceURI === HTML_NAMESPACE ? parent.ownerDocument.createElement(parent.tagName) : parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName);\n    testElement.innerHTML = html;\n    return testElement.innerHTML;\n  };\n}\n\nfunction ensureListeningTo(rootContainerElement, registrationName) {\n  var isDocumentOrFragment = rootContainerElement.nodeType === DOCUMENT_NODE || rootContainerElement.nodeType === DOCUMENT_FRAGMENT_NODE;\n  var doc = isDocumentOrFragment ? rootContainerElement : rootContainerElement.ownerDocument;\n  listenTo(registrationName, doc);\n}\n\nfunction getOwnerDocumentFromRootContainer(rootContainerElement) {\n  return rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;\n}\n\n// There are so many media events, it makes sense to just\n// maintain a list rather than create a `trapBubbledEvent` for each\nvar mediaEvents = {\n  topAbort: 'abort',\n  topCanPlay: 'canplay',\n  topCanPlayThrough: 'canplaythrough',\n  topDurationChange: 'durationchange',\n  topEmptied: 'emptied',\n  topEncrypted: 'encrypted',\n  topEnded: 'ended',\n  topError: 'error',\n  topLoadedData: 'loadeddata',\n  topLoadedMetadata: 'loadedmetadata',\n  topLoadStart: 'loadstart',\n  topPause: 'pause',\n  topPlay: 'play',\n  topPlaying: 'playing',\n  topProgress: 'progress',\n  topRateChange: 'ratechange',\n  topSeeked: 'seeked',\n  topSeeking: 'seeking',\n  topStalled: 'stalled',\n  topSuspend: 'suspend',\n  topTimeUpdate: 'timeupdate',\n  topVolumeChange: 'volumechange',\n  topWaiting: 'waiting'\n};\n\nfunction trapClickOnNonInteractiveElement(node) {\n  // Mobile Safari does not fire properly bubble click events on\n  // non-interactive elements, which means delegated click listeners do not\n  // fire. The workaround for this bug involves attaching an empty click\n  // listener on the target node.\n  // http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html\n  // Just set it using the onclick property so that we don't have to manage any\n  // bookkeeping for it. Not sure if we need to clear it when the listener is\n  // removed.\n  // TODO: Only do this for the relevant Safaris maybe?\n  node.onclick = emptyFunction;\n}\n\nfunction setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) {\n  for (var propKey in nextProps) {\n    if (!nextProps.hasOwnProperty(propKey)) {\n      continue;\n    }\n    var nextProp = nextProps[propKey];\n    if (propKey === STYLE) {\n      {\n        if (nextProp) {\n          // Freeze the next style object so that we can assume it won't be\n          // mutated. We have already warned for this in the past.\n          Object.freeze(nextProp);\n        }\n      }\n      // Relies on `updateStylesByID` not mutating `styleUpdates`.\n      setValueForStyles(domElement, nextProp, getStack);\n    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\n      var nextHtml = nextProp ? nextProp[HTML] : undefined;\n      if (nextHtml != null) {\n        setInnerHTML(domElement, nextHtml);\n      }\n    } else if (propKey === CHILDREN) {\n      if (typeof nextProp === 'string') {\n        // Avoid setting initial textContent when the text is empty. In IE11 setting\n        // textContent on a <textarea> will cause the placeholder to not\n        // show within the <textarea> until it has been focused and blurred again.\n        // https://github.com/facebook/react/issues/6731#issuecomment-254874553\n        var canSetTextContent = tag !== 'textarea' || nextProp !== '';\n        if (canSetTextContent) {\n          setTextContent(domElement, nextProp);\n        }\n      } else if (typeof nextProp === 'number') {\n        setTextContent(domElement, '' + nextProp);\n      }\n    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) {\n      // Noop\n    } else if (propKey === AUTOFOCUS) {\n      // We polyfill it separately on the client during commit.\n      // We blacklist it here rather than in the property list because we emit it in SSR.\n    } else if (registrationNameModules.hasOwnProperty(propKey)) {\n      if (nextProp != null) {\n        if (true && typeof nextProp !== 'function') {\n          warnForInvalidEventListener(propKey, nextProp);\n        }\n        ensureListeningTo(rootContainerElement, propKey);\n      }\n    } else if (isCustomComponentTag) {\n      setValueForAttribute(domElement, propKey, nextProp);\n    } else if (nextProp != null) {\n      // If we're updating to null or undefined, we should remove the property\n      // from the DOM node instead of inadvertently setting to a string. This\n      // brings us in line with the same behavior we have on initial render.\n      setValueForProperty(domElement, propKey, nextProp);\n    }\n  }\n}\n\nfunction updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {\n  // TODO: Handle wasCustomComponentTag\n  for (var i = 0; i < updatePayload.length; i += 2) {\n    var propKey = updatePayload[i];\n    var propValue = updatePayload[i + 1];\n    if (propKey === STYLE) {\n      setValueForStyles(domElement, propValue, getStack);\n    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\n      setInnerHTML(domElement, propValue);\n    } else if (propKey === CHILDREN) {\n      setTextContent(domElement, propValue);\n    } else if (isCustomComponentTag) {\n      if (propValue != null) {\n        setValueForAttribute(domElement, propKey, propValue);\n      } else {\n        deleteValueForAttribute(domElement, propKey);\n      }\n    } else if (propValue != null) {\n      setValueForProperty(domElement, propKey, propValue);\n    } else {\n      // If we're updating to null or undefined, we should remove the property\n      // from the DOM node instead of inadvertently setting to a string. This\n      // brings us in line with the same behavior we have on initial render.\n      deleteValueForProperty(domElement, propKey);\n    }\n  }\n}\n\nfunction createElement$1(type, props, rootContainerElement, parentNamespace) {\n  // We create tags in the namespace of their parent container, except HTML\n  var ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement);\n  var domElement;\n  var namespaceURI = parentNamespace;\n  if (namespaceURI === HTML_NAMESPACE) {\n    namespaceURI = getIntrinsicNamespace(type);\n  }\n  if (namespaceURI === HTML_NAMESPACE) {\n    {\n      var isCustomComponentTag = isCustomComponent(type, props);\n      // Should this check be gated by parent namespace? Not sure we want to\n      // allow <SVG> or <mATH>.\n      warning(isCustomComponentTag || type === type.toLowerCase(), '<%s /> is using uppercase HTML. Always use lowercase HTML tags ' + 'in React.', type);\n    }\n\n    if (type === 'script') {\n      // Create the script via .innerHTML so its \"parser-inserted\" flag is\n      // set to true and it does not execute\n      var div = ownerDocument.createElement('div');\n      div.innerHTML = '<script><' + '/script>'; // eslint-disable-line\n      // This is guaranteed to yield a script element.\n      var firstChild = div.firstChild;\n      domElement = div.removeChild(firstChild);\n    } else if (typeof props.is === 'string') {\n      // $FlowIssue `createElement` should be updated for Web Components\n      domElement = ownerDocument.createElement(type, { is: props.is });\n    } else {\n      // Separate else branch instead of using `props.is || undefined` above because of a Firefox bug.\n      // See discussion in https://github.com/facebook/react/pull/6896\n      // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240\n      domElement = ownerDocument.createElement(type);\n    }\n  } else {\n    domElement = ownerDocument.createElementNS(namespaceURI, type);\n  }\n\n  {\n    if (namespaceURI === HTML_NAMESPACE) {\n      if (!isCustomComponentTag && Object.prototype.toString.call(domElement) === '[object HTMLUnknownElement]' && !Object.prototype.hasOwnProperty.call(warnedUnknownTags, type)) {\n        warnedUnknownTags[type] = true;\n        warning(false, 'The tag <%s> is unrecognized in this browser. ' + 'If you meant to render a React component, start its name with ' + 'an uppercase letter.', type);\n      }\n    }\n  }\n\n  return domElement;\n}\n\nfunction createTextNode$1(text, rootContainerElement) {\n  return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);\n}\n\nfunction setInitialProperties$1(domElement, tag, rawProps, rootContainerElement) {\n  var isCustomComponentTag = isCustomComponent(tag, rawProps);\n  {\n    validatePropertiesInDevelopment(tag, rawProps);\n    if (isCustomComponentTag && !didWarnShadyDOM && domElement.shadyRoot) {\n      warning(false, '%s is using shady DOM. Using shady DOM with React can ' + 'cause things to break subtly.', getCurrentFiberOwnerName$1() || 'A component');\n      didWarnShadyDOM = true;\n    }\n  }\n\n  // TODO: Make sure that we check isMounted before firing any of these events.\n  var props;\n  switch (tag) {\n    case 'iframe':\n    case 'object':\n      trapBubbledEvent('topLoad', 'load', domElement);\n      props = rawProps;\n      break;\n    case 'video':\n    case 'audio':\n      // Create listener for each media event\n      for (var event in mediaEvents) {\n        if (mediaEvents.hasOwnProperty(event)) {\n          trapBubbledEvent(event, mediaEvents[event], domElement);\n        }\n      }\n      props = rawProps;\n      break;\n    case 'source':\n      trapBubbledEvent('topError', 'error', domElement);\n      props = rawProps;\n      break;\n    case 'img':\n    case 'image':\n      trapBubbledEvent('topError', 'error', domElement);\n      trapBubbledEvent('topLoad', 'load', domElement);\n      props = rawProps;\n      break;\n    case 'form':\n      trapBubbledEvent('topReset', 'reset', domElement);\n      trapBubbledEvent('topSubmit', 'submit', domElement);\n      props = rawProps;\n      break;\n    case 'details':\n      trapBubbledEvent('topToggle', 'toggle', domElement);\n      props = rawProps;\n      break;\n    case 'input':\n      initWrapperState(domElement, rawProps);\n      props = getHostProps(domElement, rawProps);\n      trapBubbledEvent('topInvalid', 'invalid', domElement);\n      // For controlled components we always need to ensure we're listening\n      // to onChange. Even if there is no listener.\n      ensureListeningTo(rootContainerElement, 'onChange');\n      break;\n    case 'option':\n      validateProps(domElement, rawProps);\n      props = getHostProps$1(domElement, rawProps);\n      break;\n    case 'select':\n      initWrapperState$1(domElement, rawProps);\n      props = getHostProps$2(domElement, rawProps);\n      trapBubbledEvent('topInvalid', 'invalid', domElement);\n      // For controlled components we always need to ensure we're listening\n      // to onChange. Even if there is no listener.\n      ensureListeningTo(rootContainerElement, 'onChange');\n      break;\n    case 'textarea':\n      initWrapperState$2(domElement, rawProps);\n      props = getHostProps$3(domElement, rawProps);\n      trapBubbledEvent('topInvalid', 'invalid', domElement);\n      // For controlled components we always need to ensure we're listening\n      // to onChange. Even if there is no listener.\n      ensureListeningTo(rootContainerElement, 'onChange');\n      break;\n    default:\n      props = rawProps;\n  }\n\n  assertValidProps(tag, props, getStack);\n\n  setInitialDOMProperties(tag, domElement, rootContainerElement, props, isCustomComponentTag);\n\n  switch (tag) {\n    case 'input':\n      // TODO: Make sure we check if this is still unmounted or do any clean\n      // up necessary since we never stop tracking anymore.\n      track(domElement);\n      postMountWrapper(domElement, rawProps);\n      break;\n    case 'textarea':\n      // TODO: Make sure we check if this is still unmounted or do any clean\n      // up necessary since we never stop tracking anymore.\n      track(domElement);\n      postMountWrapper$3(domElement, rawProps);\n      break;\n    case 'option':\n      postMountWrapper$1(domElement, rawProps);\n      break;\n    case 'select':\n      postMountWrapper$2(domElement, rawProps);\n      break;\n    default:\n      if (typeof props.onClick === 'function') {\n        // TODO: This cast may not be sound for SVG, MathML or custom elements.\n        trapClickOnNonInteractiveElement(domElement);\n      }\n      break;\n  }\n}\n\n// Calculate the diff between the two objects.\nfunction diffProperties$1(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {\n  {\n    validatePropertiesInDevelopment(tag, nextRawProps);\n  }\n\n  var updatePayload = null;\n\n  var lastProps;\n  var nextProps;\n  switch (tag) {\n    case 'input':\n      lastProps = getHostProps(domElement, lastRawProps);\n      nextProps = getHostProps(domElement, nextRawProps);\n      updatePayload = [];\n      break;\n    case 'option':\n      lastProps = getHostProps$1(domElement, lastRawProps);\n      nextProps = getHostProps$1(domElement, nextRawProps);\n      updatePayload = [];\n      break;\n    case 'select':\n      lastProps = getHostProps$2(domElement, lastRawProps);\n      nextProps = getHostProps$2(domElement, nextRawProps);\n      updatePayload = [];\n      break;\n    case 'textarea':\n      lastProps = getHostProps$3(domElement, lastRawProps);\n      nextProps = getHostProps$3(domElement, nextRawProps);\n      updatePayload = [];\n      break;\n    default:\n      lastProps = lastRawProps;\n      nextProps = nextRawProps;\n      if (typeof lastProps.onClick !== 'function' && typeof nextProps.onClick === 'function') {\n        // TODO: This cast may not be sound for SVG, MathML or custom elements.\n        trapClickOnNonInteractiveElement(domElement);\n      }\n      break;\n  }\n\n  assertValidProps(tag, nextProps, getStack);\n\n  var propKey;\n  var styleName;\n  var styleUpdates = null;\n  for (propKey in lastProps) {\n    if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {\n      continue;\n    }\n    if (propKey === STYLE) {\n      var lastStyle = lastProps[propKey];\n      for (styleName in lastStyle) {\n        if (lastStyle.hasOwnProperty(styleName)) {\n          if (!styleUpdates) {\n            styleUpdates = {};\n          }\n          styleUpdates[styleName] = '';\n        }\n      }\n    } else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN) {\n      // Noop. This is handled by the clear text mechanism.\n    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) {\n      // Noop\n    } else if (propKey === AUTOFOCUS) {\n      // Noop. It doesn't work on updates anyway.\n    } else if (registrationNameModules.hasOwnProperty(propKey)) {\n      // This is a special case. If any listener updates we need to ensure\n      // that the \"current\" fiber pointer gets updated so we need a commit\n      // to update this element.\n      if (!updatePayload) {\n        updatePayload = [];\n      }\n    } else {\n      // For all other deleted properties we add it to the queue. We use\n      // the whitelist in the commit phase instead.\n      (updatePayload = updatePayload || []).push(propKey, null);\n    }\n  }\n  for (propKey in nextProps) {\n    var nextProp = nextProps[propKey];\n    var lastProp = lastProps != null ? lastProps[propKey] : undefined;\n    if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {\n      continue;\n    }\n    if (propKey === STYLE) {\n      {\n        if (nextProp) {\n          // Freeze the next style object so that we can assume it won't be\n          // mutated. We have already warned for this in the past.\n          Object.freeze(nextProp);\n        }\n      }\n      if (lastProp) {\n        // Unset styles on `lastProp` but not on `nextProp`.\n        for (styleName in lastProp) {\n          if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {\n            if (!styleUpdates) {\n              styleUpdates = {};\n            }\n            styleUpdates[styleName] = '';\n          }\n        }\n        // Update styles that changed since `lastProp`.\n        for (styleName in nextProp) {\n          if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {\n            if (!styleUpdates) {\n              styleUpdates = {};\n            }\n            styleUpdates[styleName] = nextProp[styleName];\n          }\n        }\n      } else {\n        // Relies on `updateStylesByID` not mutating `styleUpdates`.\n        if (!styleUpdates) {\n          if (!updatePayload) {\n            updatePayload = [];\n          }\n          updatePayload.push(propKey, styleUpdates);\n        }\n        styleUpdates = nextProp;\n      }\n    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\n      var nextHtml = nextProp ? nextProp[HTML] : undefined;\n      var lastHtml = lastProp ? lastProp[HTML] : undefined;\n      if (nextHtml != null) {\n        if (lastHtml !== nextHtml) {\n          (updatePayload = updatePayload || []).push(propKey, '' + nextHtml);\n        }\n      } else {\n        // TODO: It might be too late to clear this if we have children\n        // inserted already.\n      }\n    } else if (propKey === CHILDREN) {\n      if (lastProp !== nextProp && (typeof nextProp === 'string' || typeof nextProp === 'number')) {\n        (updatePayload = updatePayload || []).push(propKey, '' + nextProp);\n      }\n    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) {\n      // Noop\n    } else if (registrationNameModules.hasOwnProperty(propKey)) {\n      if (nextProp != null) {\n        // We eagerly listen to this even though we haven't committed yet.\n        if (true && typeof nextProp !== 'function') {\n          warnForInvalidEventListener(propKey, nextProp);\n        }\n        ensureListeningTo(rootContainerElement, propKey);\n      }\n      if (!updatePayload && lastProp !== nextProp) {\n        // This is a special case. If any listener updates we need to ensure\n        // that the \"current\" props pointer gets updated so we need a commit\n        // to update this element.\n        updatePayload = [];\n      }\n    } else {\n      // For any other property we always add it to the queue and then we\n      // filter it out using the whitelist during the commit.\n      (updatePayload = updatePayload || []).push(propKey, nextProp);\n    }\n  }\n  if (styleUpdates) {\n    (updatePayload = updatePayload || []).push(STYLE, styleUpdates);\n  }\n  return updatePayload;\n}\n\n// Apply the diff.\nfunction updateProperties$1(domElement, updatePayload, tag, lastRawProps, nextRawProps) {\n  // Update checked *before* name.\n  // In the middle of an update, it is possible to have multiple checked.\n  // When a checked radio tries to change name, browser makes another radio's checked false.\n  if (tag === 'input' && nextRawProps.type === 'radio' && nextRawProps.name != null) {\n    updateChecked(domElement, nextRawProps);\n  }\n\n  var wasCustomComponentTag = isCustomComponent(tag, lastRawProps);\n  var isCustomComponentTag = isCustomComponent(tag, nextRawProps);\n  // Apply the diff.\n  updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag);\n\n  // TODO: Ensure that an update gets scheduled if any of the special props\n  // changed.\n  switch (tag) {\n    case 'input':\n      // Update the wrapper around inputs *after* updating props. This has to\n      // happen after `updateDOMProperties`. Otherwise HTML5 input validations\n      // raise warnings and prevent the new value from being assigned.\n      updateWrapper(domElement, nextRawProps);\n      break;\n    case 'textarea':\n      updateWrapper$1(domElement, nextRawProps);\n      break;\n    case 'select':\n      // <select> value update needs to occur after <option> children\n      // reconciliation\n      postUpdateWrapper(domElement, nextRawProps);\n      break;\n  }\n}\n\nfunction diffHydratedProperties$1(domElement, tag, rawProps, parentNamespace, rootContainerElement) {\n  {\n    var suppressHydrationWarning = rawProps[SUPPRESS_HYDRATION_WARNING$1] === true;\n    var isCustomComponentTag = isCustomComponent(tag, rawProps);\n    validatePropertiesInDevelopment(tag, rawProps);\n    if (isCustomComponentTag && !didWarnShadyDOM && domElement.shadyRoot) {\n      warning(false, '%s is using shady DOM. Using shady DOM with React can ' + 'cause things to break subtly.', getCurrentFiberOwnerName$1() || 'A component');\n      didWarnShadyDOM = true;\n    }\n  }\n\n  // TODO: Make sure that we check isMounted before firing any of these events.\n  switch (tag) {\n    case 'iframe':\n    case 'object':\n      trapBubbledEvent('topLoad', 'load', domElement);\n      break;\n    case 'video':\n    case 'audio':\n      // Create listener for each media event\n      for (var event in mediaEvents) {\n        if (mediaEvents.hasOwnProperty(event)) {\n          trapBubbledEvent(event, mediaEvents[event], domElement);\n        }\n      }\n      break;\n    case 'source':\n      trapBubbledEvent('topError', 'error', domElement);\n      break;\n    case 'img':\n    case 'image':\n      trapBubbledEvent('topError', 'error', domElement);\n      trapBubbledEvent('topLoad', 'load', domElement);\n      break;\n    case 'form':\n      trapBubbledEvent('topReset', 'reset', domElement);\n      trapBubbledEvent('topSubmit', 'submit', domElement);\n      break;\n    case 'details':\n      trapBubbledEvent('topToggle', 'toggle', domElement);\n      break;\n    case 'input':\n      initWrapperState(domElement, rawProps);\n      trapBubbledEvent('topInvalid', 'invalid', domElement);\n      // For controlled components we always need to ensure we're listening\n      // to onChange. Even if there is no listener.\n      ensureListeningTo(rootContainerElement, 'onChange');\n      break;\n    case 'option':\n      validateProps(domElement, rawProps);\n      break;\n    case 'select':\n      initWrapperState$1(domElement, rawProps);\n      trapBubbledEvent('topInvalid', 'invalid', domElement);\n      // For controlled components we always need to ensure we're listening\n      // to onChange. Even if there is no listener.\n      ensureListeningTo(rootContainerElement, 'onChange');\n      break;\n    case 'textarea':\n      initWrapperState$2(domElement, rawProps);\n      trapBubbledEvent('topInvalid', 'invalid', domElement);\n      // For controlled components we always need to ensure we're listening\n      // to onChange. Even if there is no listener.\n      ensureListeningTo(rootContainerElement, 'onChange');\n      break;\n  }\n\n  assertValidProps(tag, rawProps, getStack);\n\n  {\n    var extraAttributeNames = new Set();\n    var attributes = domElement.attributes;\n    for (var i = 0; i < attributes.length; i++) {\n      var name = attributes[i].name.toLowerCase();\n      switch (name) {\n        // Built-in SSR attribute is whitelisted\n        case 'data-reactroot':\n          break;\n        // Controlled attributes are not validated\n        // TODO: Only ignore them on controlled tags.\n        case 'value':\n          break;\n        case 'checked':\n          break;\n        case 'selected':\n          break;\n        default:\n          // Intentionally use the original name.\n          // See discussion in https://github.com/facebook/react/pull/10676.\n          extraAttributeNames.add(attributes[i].name);\n      }\n    }\n  }\n\n  var updatePayload = null;\n  for (var propKey in rawProps) {\n    if (!rawProps.hasOwnProperty(propKey)) {\n      continue;\n    }\n    var nextProp = rawProps[propKey];\n    if (propKey === CHILDREN) {\n      // For text content children we compare against textContent. This\n      // might match additional HTML that is hidden when we read it using\n      // textContent. E.g. \"foo\" will match \"f<span>oo</span>\" but that still\n      // satisfies our requirement. Our requirement is not to produce perfect\n      // HTML and attributes. Ideally we should preserve structure but it's\n      // ok not to if the visible content is still enough to indicate what\n      // even listeners these nodes might be wired up to.\n      // TODO: Warn if there is more than a single textNode as a child.\n      // TODO: Should we use domElement.firstChild.nodeValue to compare?\n      if (typeof nextProp === 'string') {\n        if (domElement.textContent !== nextProp) {\n          if (true && !suppressHydrationWarning) {\n            warnForTextDifference(domElement.textContent, nextProp);\n          }\n          updatePayload = [CHILDREN, nextProp];\n        }\n      } else if (typeof nextProp === 'number') {\n        if (domElement.textContent !== '' + nextProp) {\n          if (true && !suppressHydrationWarning) {\n            warnForTextDifference(domElement.textContent, nextProp);\n          }\n          updatePayload = [CHILDREN, '' + nextProp];\n        }\n      }\n    } else if (registrationNameModules.hasOwnProperty(propKey)) {\n      if (nextProp != null) {\n        if (true && typeof nextProp !== 'function') {\n          warnForInvalidEventListener(propKey, nextProp);\n        }\n        ensureListeningTo(rootContainerElement, propKey);\n      }\n    } else {\n      // Validate that the properties correspond to their expected values.\n      var serverValue;\n      var propertyInfo;\n      if (suppressHydrationWarning) {\n        // Don't bother comparing. We're ignoring all these warnings.\n      } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1 ||\n      // Controlled attributes are not validated\n      // TODO: Only ignore them on controlled tags.\n      propKey === 'value' || propKey === 'checked' || propKey === 'selected') {\n        // Noop\n      } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\n        var rawHtml = nextProp ? nextProp[HTML] || '' : '';\n        var serverHTML = domElement.innerHTML;\n        var expectedHTML = normalizeHTML(domElement, rawHtml);\n        if (expectedHTML !== serverHTML) {\n          warnForPropDifference(propKey, serverHTML, expectedHTML);\n        }\n      } else if (propKey === STYLE) {\n        // $FlowFixMe - Should be inferred as not undefined.\n        extraAttributeNames['delete'](propKey);\n        var expectedStyle = createDangerousStringForStyles(nextProp);\n        serverValue = domElement.getAttribute('style');\n        if (expectedStyle !== serverValue) {\n          warnForPropDifference(propKey, serverValue, expectedStyle);\n        }\n      } else if (isCustomComponentTag) {\n        // $FlowFixMe - Should be inferred as not undefined.\n        extraAttributeNames['delete'](propKey.toLowerCase());\n        serverValue = getValueForAttribute(domElement, propKey, nextProp);\n\n        if (nextProp !== serverValue) {\n          warnForPropDifference(propKey, serverValue, nextProp);\n        }\n      } else if (shouldSetAttribute(propKey, nextProp)) {\n        if (propertyInfo = getPropertyInfo(propKey)) {\n          // $FlowFixMe - Should be inferred as not undefined.\n          extraAttributeNames['delete'](propertyInfo.attributeName);\n          serverValue = getValueForProperty(domElement, propKey, nextProp);\n        } else {\n          var ownNamespace = parentNamespace;\n          if (ownNamespace === HTML_NAMESPACE) {\n            ownNamespace = getIntrinsicNamespace(tag);\n          }\n          if (ownNamespace === HTML_NAMESPACE) {\n            // $FlowFixMe - Should be inferred as not undefined.\n            extraAttributeNames['delete'](propKey.toLowerCase());\n          } else {\n            // $FlowFixMe - Should be inferred as not undefined.\n            extraAttributeNames['delete'](propKey);\n          }\n          serverValue = getValueForAttribute(domElement, propKey, nextProp);\n        }\n\n        if (nextProp !== serverValue) {\n          warnForPropDifference(propKey, serverValue, nextProp);\n        }\n      }\n    }\n  }\n\n  {\n    // $FlowFixMe - Should be inferred as not undefined.\n    if (extraAttributeNames.size > 0 && !suppressHydrationWarning) {\n      // $FlowFixMe - Should be inferred as not undefined.\n      warnForExtraAttributes(extraAttributeNames);\n    }\n  }\n\n  switch (tag) {\n    case 'input':\n      // TODO: Make sure we check if this is still unmounted or do any clean\n      // up necessary since we never stop tracking anymore.\n      track(domElement);\n      postMountWrapper(domElement, rawProps);\n      break;\n    case 'textarea':\n      // TODO: Make sure we check if this is still unmounted or do any clean\n      // up necessary since we never stop tracking anymore.\n      track(domElement);\n      postMountWrapper$3(domElement, rawProps);\n      break;\n    case 'select':\n    case 'option':\n      // For input and textarea we current always set the value property at\n      // post mount to force it to diverge from attributes. However, for\n      // option and select we don't quite do the same thing and select\n      // is not resilient to the DOM state changing so we don't do that here.\n      // TODO: Consider not doing this for input and textarea.\n      break;\n    default:\n      if (typeof rawProps.onClick === 'function') {\n        // TODO: This cast may not be sound for SVG, MathML or custom elements.\n        trapClickOnNonInteractiveElement(domElement);\n      }\n      break;\n  }\n\n  return updatePayload;\n}\n\nfunction diffHydratedText$1(textNode, text) {\n  var isDifferent = textNode.nodeValue !== text;\n  return isDifferent;\n}\n\nfunction warnForUnmatchedText$1(textNode, text) {\n  {\n    warnForTextDifference(textNode.nodeValue, text);\n  }\n}\n\nfunction warnForDeletedHydratableElement$1(parentNode, child) {\n  {\n    if (didWarnInvalidHydration) {\n      return;\n    }\n    didWarnInvalidHydration = true;\n    warning(false, 'Did not expect server HTML to contain a <%s> in <%s>.', child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());\n  }\n}\n\nfunction warnForDeletedHydratableText$1(parentNode, child) {\n  {\n    if (didWarnInvalidHydration) {\n      return;\n    }\n    didWarnInvalidHydration = true;\n    warning(false, 'Did not expect server HTML to contain the text node \"%s\" in <%s>.', child.nodeValue, parentNode.nodeName.toLowerCase());\n  }\n}\n\nfunction warnForInsertedHydratedElement$1(parentNode, tag, props) {\n  {\n    if (didWarnInvalidHydration) {\n      return;\n    }\n    didWarnInvalidHydration = true;\n    warning(false, 'Expected server HTML to contain a matching <%s> in <%s>.', tag, parentNode.nodeName.toLowerCase());\n  }\n}\n\nfunction warnForInsertedHydratedText$1(parentNode, text) {\n  {\n    if (text === '') {\n      // We expect to insert empty text nodes since they're not represented in\n      // the HTML.\n      // TODO: Remove this special case if we can just avoid inserting empty\n      // text nodes.\n      return;\n    }\n    if (didWarnInvalidHydration) {\n      return;\n    }\n    didWarnInvalidHydration = true;\n    warning(false, 'Expected server HTML to contain a matching text node for \"%s\" in <%s>.', text, parentNode.nodeName.toLowerCase());\n  }\n}\n\nfunction restoreControlledState(domElement, tag, props) {\n  switch (tag) {\n    case 'input':\n      restoreControlledState$1(domElement, props);\n      return;\n    case 'textarea':\n      restoreControlledState$3(domElement, props);\n      return;\n    case 'select':\n      restoreControlledState$2(domElement, props);\n      return;\n  }\n}\n\nvar ReactDOMFiberComponent = Object.freeze({\n\tcreateElement: createElement$1,\n\tcreateTextNode: createTextNode$1,\n\tsetInitialProperties: setInitialProperties$1,\n\tdiffProperties: diffProperties$1,\n\tupdateProperties: updateProperties$1,\n\tdiffHydratedProperties: diffHydratedProperties$1,\n\tdiffHydratedText: diffHydratedText$1,\n\twarnForUnmatchedText: warnForUnmatchedText$1,\n\twarnForDeletedHydratableElement: warnForDeletedHydratableElement$1,\n\twarnForDeletedHydratableText: warnForDeletedHydratableText$1,\n\twarnForInsertedHydratedElement: warnForInsertedHydratedElement$1,\n\twarnForInsertedHydratedText: warnForInsertedHydratedText$1,\n\trestoreControlledState: restoreControlledState\n});\n\n// TODO: direct imports like some-package/src/* are bad. Fix me.\nvar getCurrentFiberStackAddendum$6 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;\n\nvar validateDOMNesting = emptyFunction;\n\n{\n  // This validation code was written based on the HTML5 parsing spec:\n  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope\n  //\n  // Note: this does not catch all invalid nesting, nor does it try to (as it's\n  // not clear what practical benefit doing so provides); instead, we warn only\n  // for cases where the parser will give a parse tree differing from what React\n  // intended. For example, <b><div></div></b> is invalid but we don't warn\n  // because it still parses correctly; we do warn for other cases like nested\n  // <p> tags where the beginning of the second element implicitly closes the\n  // first, causing a confusing mess.\n\n  // https://html.spec.whatwg.org/multipage/syntax.html#special\n  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];\n\n  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope\n  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',\n\n  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point\n  // TODO: Distinguish by namespace here -- for <title>, including it here\n  // errs on the side of fewer warnings\n  'foreignObject', 'desc', 'title'];\n\n  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope\n  var buttonScopeTags = inScopeTags.concat(['button']);\n\n  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags\n  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];\n\n  var emptyAncestorInfo = {\n    current: null,\n\n    formTag: null,\n    aTagInScope: null,\n    buttonTagInScope: null,\n    nobrTagInScope: null,\n    pTagInButtonScope: null,\n\n    listItemTagAutoclosing: null,\n    dlItemTagAutoclosing: null\n  };\n\n  var updatedAncestorInfo$1 = function (oldInfo, tag, instance) {\n    var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);\n    var info = { tag: tag, instance: instance };\n\n    if (inScopeTags.indexOf(tag) !== -1) {\n      ancestorInfo.aTagInScope = null;\n      ancestorInfo.buttonTagInScope = null;\n      ancestorInfo.nobrTagInScope = null;\n    }\n    if (buttonScopeTags.indexOf(tag) !== -1) {\n      ancestorInfo.pTagInButtonScope = null;\n    }\n\n    // See rules for 'li', 'dd', 'dt' start tags in\n    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody\n    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {\n      ancestorInfo.listItemTagAutoclosing = null;\n      ancestorInfo.dlItemTagAutoclosing = null;\n    }\n\n    ancestorInfo.current = info;\n\n    if (tag === 'form') {\n      ancestorInfo.formTag = info;\n    }\n    if (tag === 'a') {\n      ancestorInfo.aTagInScope = info;\n    }\n    if (tag === 'button') {\n      ancestorInfo.buttonTagInScope = info;\n    }\n    if (tag === 'nobr') {\n      ancestorInfo.nobrTagInScope = info;\n    }\n    if (tag === 'p') {\n      ancestorInfo.pTagInButtonScope = info;\n    }\n    if (tag === 'li') {\n      ancestorInfo.listItemTagAutoclosing = info;\n    }\n    if (tag === 'dd' || tag === 'dt') {\n      ancestorInfo.dlItemTagAutoclosing = info;\n    }\n\n    return ancestorInfo;\n  };\n\n  /**\n   * Returns whether\n   */\n  var isTagValidWithParent = function (tag, parentTag) {\n    // First, let's check if we're in an unusual parsing mode...\n    switch (parentTag) {\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect\n      case 'select':\n        return tag === 'option' || tag === 'optgroup' || tag === '#text';\n      case 'optgroup':\n        return tag === 'option' || tag === '#text';\n      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>\n      // but\n      case 'option':\n        return tag === '#text';\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption\n      // No special behavior since these rules fall back to \"in body\" mode for\n      // all except special table nodes which cause bad parsing behavior anyway.\n\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr\n      case 'tr':\n        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody\n      case 'tbody':\n      case 'thead':\n      case 'tfoot':\n        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup\n      case 'colgroup':\n        return tag === 'col' || tag === 'template';\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable\n      case 'table':\n        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead\n      case 'head':\n        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';\n      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element\n      case 'html':\n        return tag === 'head' || tag === 'body';\n      case '#document':\n        return tag === 'html';\n    }\n\n    // Probably in the \"in body\" parsing mode, so we outlaw only tag combos\n    // where the parsing rules cause implicit opens or closes to be added.\n    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody\n    switch (tag) {\n      case 'h1':\n      case 'h2':\n      case 'h3':\n      case 'h4':\n      case 'h5':\n      case 'h6':\n        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';\n\n      case 'rp':\n      case 'rt':\n        return impliedEndTags.indexOf(parentTag) === -1;\n\n      case 'body':\n      case 'caption':\n      case 'col':\n      case 'colgroup':\n      case 'frame':\n      case 'head':\n      case 'html':\n      case 'tbody':\n      case 'td':\n      case 'tfoot':\n      case 'th':\n      case 'thead':\n      case 'tr':\n        // These tags are only valid with a few parents that have special child\n        // parsing rules -- if we're down here, then none of those matched and\n        // so we allow it only if we don't know what the parent is, as all other\n        // cases are invalid.\n        return parentTag == null;\n    }\n\n    return true;\n  };\n\n  /**\n   * Returns whether\n   */\n  var findInvalidAncestorForTag = function (tag, ancestorInfo) {\n    switch (tag) {\n      case 'address':\n      case 'article':\n      case 'aside':\n      case 'blockquote':\n      case 'center':\n      case 'details':\n      case 'dialog':\n      case 'dir':\n      case 'div':\n      case 'dl':\n      case 'fieldset':\n      case 'figcaption':\n      case 'figure':\n      case 'footer':\n      case 'header':\n      case 'hgroup':\n      case 'main':\n      case 'menu':\n      case 'nav':\n      case 'ol':\n      case 'p':\n      case 'section':\n      case 'summary':\n      case 'ul':\n      case 'pre':\n      case 'listing':\n      case 'table':\n      case 'hr':\n      case 'xmp':\n      case 'h1':\n      case 'h2':\n      case 'h3':\n      case 'h4':\n      case 'h5':\n      case 'h6':\n        return ancestorInfo.pTagInButtonScope;\n\n      case 'form':\n        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;\n\n      case 'li':\n        return ancestorInfo.listItemTagAutoclosing;\n\n      case 'dd':\n      case 'dt':\n        return ancestorInfo.dlItemTagAutoclosing;\n\n      case 'button':\n        return ancestorInfo.buttonTagInScope;\n\n      case 'a':\n        // Spec says something about storing a list of markers, but it sounds\n        // equivalent to this check.\n        return ancestorInfo.aTagInScope;\n\n      case 'nobr':\n        return ancestorInfo.nobrTagInScope;\n    }\n\n    return null;\n  };\n\n  var didWarn = {};\n\n  validateDOMNesting = function (childTag, childText, ancestorInfo) {\n    ancestorInfo = ancestorInfo || emptyAncestorInfo;\n    var parentInfo = ancestorInfo.current;\n    var parentTag = parentInfo && parentInfo.tag;\n\n    if (childText != null) {\n      warning(childTag == null, 'validateDOMNesting: when childText is passed, childTag should be null');\n      childTag = '#text';\n    }\n\n    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;\n    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);\n    var invalidParentOrAncestor = invalidParent || invalidAncestor;\n    if (!invalidParentOrAncestor) {\n      return;\n    }\n\n    var ancestorTag = invalidParentOrAncestor.tag;\n    var addendum = getCurrentFiberStackAddendum$6();\n\n    var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + addendum;\n    if (didWarn[warnKey]) {\n      return;\n    }\n    didWarn[warnKey] = true;\n\n    var tagDisplayName = childTag;\n    var whitespaceInfo = '';\n    if (childTag === '#text') {\n      if (/\\S/.test(childText)) {\n        tagDisplayName = 'Text nodes';\n      } else {\n        tagDisplayName = 'Whitespace text nodes';\n        whitespaceInfo = \" Make sure you don't have any extra whitespace between tags on \" + 'each line of your source code.';\n      }\n    } else {\n      tagDisplayName = '<' + childTag + '>';\n    }\n\n    if (invalidParent) {\n      var info = '';\n      if (ancestorTag === 'table' && childTag === 'tr') {\n        info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';\n      }\n      warning(false, 'validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s%s', tagDisplayName, ancestorTag, whitespaceInfo, info, addendum);\n    } else {\n      warning(false, 'validateDOMNesting(...): %s cannot appear as a descendant of ' + '<%s>.%s', tagDisplayName, ancestorTag, addendum);\n    }\n  };\n\n  // TODO: turn this into a named export\n  validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo$1;\n\n  // For testing\n  validateDOMNesting.isTagValidInContext = function (tag, ancestorInfo) {\n    ancestorInfo = ancestorInfo || emptyAncestorInfo;\n    var parentInfo = ancestorInfo.current;\n    var parentTag = parentInfo && parentInfo.tag;\n    return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);\n  };\n}\n\nvar validateDOMNesting$1 = validateDOMNesting;\n\n// TODO: direct imports like some-package/src/* are bad. Fix me.\nvar createElement = createElement$1;\nvar createTextNode = createTextNode$1;\nvar setInitialProperties = setInitialProperties$1;\nvar diffProperties = diffProperties$1;\nvar updateProperties = updateProperties$1;\nvar diffHydratedProperties = diffHydratedProperties$1;\nvar diffHydratedText = diffHydratedText$1;\nvar warnForUnmatchedText = warnForUnmatchedText$1;\nvar warnForDeletedHydratableElement = warnForDeletedHydratableElement$1;\nvar warnForDeletedHydratableText = warnForDeletedHydratableText$1;\nvar warnForInsertedHydratedElement = warnForInsertedHydratedElement$1;\nvar warnForInsertedHydratedText = warnForInsertedHydratedText$1;\nvar updatedAncestorInfo = validateDOMNesting$1.updatedAncestorInfo;\nvar precacheFiberNode = precacheFiberNode$1;\nvar updateFiberProps = updateFiberProps$1;\n\n\n{\n  var SUPPRESS_HYDRATION_WARNING = 'suppressHydrationWarning';\n  if (typeof Map !== 'function' || Map.prototype == null || typeof Map.prototype.forEach !== 'function' || typeof Set !== 'function' || Set.prototype == null || typeof Set.prototype.clear !== 'function' || typeof Set.prototype.forEach !== 'function') {\n    warning(false, 'React depends on Map and Set built-in types. Make sure that you load a ' + 'polyfill in older browsers. http://fb.me/react-polyfills');\n  }\n}\n\ninjection$3.injectFiberControlledHostComponent(ReactDOMFiberComponent);\n\nvar eventsEnabled = null;\nvar selectionInformation = null;\n\n/**\n * True if the supplied DOM node is a valid node element.\n *\n * @param {?DOMElement} node The candidate DOM node.\n * @return {boolean} True if the DOM is a valid DOM node.\n * @internal\n */\nfunction isValidContainer(node) {\n  return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || node.nodeType === COMMENT_NODE && node.nodeValue === ' react-mount-point-unstable '));\n}\n\nfunction getReactRootElementInContainer(container) {\n  if (!container) {\n    return null;\n  }\n\n  if (container.nodeType === DOCUMENT_NODE) {\n    return container.documentElement;\n  } else {\n    return container.firstChild;\n  }\n}\n\nfunction shouldHydrateDueToLegacyHeuristic(container) {\n  var rootElement = getReactRootElementInContainer(container);\n  return !!(rootElement && rootElement.nodeType === ELEMENT_NODE && rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME));\n}\n\nfunction shouldAutoFocusHostComponent(type, props) {\n  switch (type) {\n    case 'button':\n    case 'input':\n    case 'select':\n    case 'textarea':\n      return !!props.autoFocus;\n  }\n  return false;\n}\n\nvar DOMRenderer = reactReconciler({\n  getRootHostContext: function (rootContainerInstance) {\n    var type = void 0;\n    var namespace = void 0;\n    var nodeType = rootContainerInstance.nodeType;\n    switch (nodeType) {\n      case DOCUMENT_NODE:\n      case DOCUMENT_FRAGMENT_NODE:\n        {\n          type = nodeType === DOCUMENT_NODE ? '#document' : '#fragment';\n          var root = rootContainerInstance.documentElement;\n          namespace = root ? root.namespaceURI : getChildNamespace(null, '');\n          break;\n        }\n      default:\n        {\n          var container = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;\n          var ownNamespace = container.namespaceURI || null;\n          type = container.tagName;\n          namespace = getChildNamespace(ownNamespace, type);\n          break;\n        }\n    }\n    {\n      var validatedTag = type.toLowerCase();\n      var _ancestorInfo = updatedAncestorInfo(null, validatedTag, null);\n      return { namespace: namespace, ancestorInfo: _ancestorInfo };\n    }\n    return namespace;\n  },\n  getChildHostContext: function (parentHostContext, type) {\n    {\n      var parentHostContextDev = parentHostContext;\n      var _namespace = getChildNamespace(parentHostContextDev.namespace, type);\n      var _ancestorInfo2 = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type, null);\n      return { namespace: _namespace, ancestorInfo: _ancestorInfo2 };\n    }\n    var parentNamespace = parentHostContext;\n    return getChildNamespace(parentNamespace, type);\n  },\n  getPublicInstance: function (instance) {\n    return instance;\n  },\n  prepareForCommit: function () {\n    eventsEnabled = isEnabled();\n    selectionInformation = getSelectionInformation();\n    setEnabled(false);\n  },\n  resetAfterCommit: function () {\n    restoreSelection(selectionInformation);\n    selectionInformation = null;\n    setEnabled(eventsEnabled);\n    eventsEnabled = null;\n  },\n  createInstance: function (type, props, rootContainerInstance, hostContext, internalInstanceHandle) {\n    var parentNamespace = void 0;\n    {\n      // TODO: take namespace into account when validating.\n      var hostContextDev = hostContext;\n      validateDOMNesting$1(type, null, hostContextDev.ancestorInfo);\n      if (typeof props.children === 'string' || typeof props.children === 'number') {\n        var string = '' + props.children;\n        var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type, null);\n        validateDOMNesting$1(null, string, ownAncestorInfo);\n      }\n      parentNamespace = hostContextDev.namespace;\n    }\n    var domElement = createElement(type, props, rootContainerInstance, parentNamespace);\n    precacheFiberNode(internalInstanceHandle, domElement);\n    updateFiberProps(domElement, props);\n    return domElement;\n  },\n  appendInitialChild: function (parentInstance, child) {\n    parentInstance.appendChild(child);\n  },\n  finalizeInitialChildren: function (domElement, type, props, rootContainerInstance) {\n    setInitialProperties(domElement, type, props, rootContainerInstance);\n    return shouldAutoFocusHostComponent(type, props);\n  },\n  prepareUpdate: function (domElement, type, oldProps, newProps, rootContainerInstance, hostContext) {\n    {\n      var hostContextDev = hostContext;\n      if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === 'string' || typeof newProps.children === 'number')) {\n        var string = '' + newProps.children;\n        var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type, null);\n        validateDOMNesting$1(null, string, ownAncestorInfo);\n      }\n    }\n    return diffProperties(domElement, type, oldProps, newProps, rootContainerInstance);\n  },\n  shouldSetTextContent: function (type, props) {\n    return type === 'textarea' || typeof props.children === 'string' || typeof props.children === 'number' || typeof props.dangerouslySetInnerHTML === 'object' && props.dangerouslySetInnerHTML !== null && typeof props.dangerouslySetInnerHTML.__html === 'string';\n  },\n  shouldDeprioritizeSubtree: function (type, props) {\n    return !!props.hidden;\n  },\n  createTextInstance: function (text, rootContainerInstance, hostContext, internalInstanceHandle) {\n    {\n      var hostContextDev = hostContext;\n      validateDOMNesting$1(null, text, hostContextDev.ancestorInfo);\n    }\n    var textNode = createTextNode(text, rootContainerInstance);\n    precacheFiberNode(internalInstanceHandle, textNode);\n    return textNode;\n  },\n\n\n  now: now,\n\n  mutation: {\n    commitMount: function (domElement, type, newProps, internalInstanceHandle) {\n      domElement.focus();\n    },\n    commitUpdate: function (domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {\n      // Update the props handle so that we know which props are the ones with\n      // with current event handlers.\n      updateFiberProps(domElement, newProps);\n      // Apply the diff to the DOM node.\n      updateProperties(domElement, updatePayload, type, oldProps, newProps);\n    },\n    resetTextContent: function (domElement) {\n      domElement.textContent = '';\n    },\n    commitTextUpdate: function (textInstance, oldText, newText) {\n      textInstance.nodeValue = newText;\n    },\n    appendChild: function (parentInstance, child) {\n      parentInstance.appendChild(child);\n    },\n    appendChildToContainer: function (container, child) {\n      if (container.nodeType === COMMENT_NODE) {\n        container.parentNode.insertBefore(child, container);\n      } else {\n        container.appendChild(child);\n      }\n    },\n    insertBefore: function (parentInstance, child, beforeChild) {\n      parentInstance.insertBefore(child, beforeChild);\n    },\n    insertInContainerBefore: function (container, child, beforeChild) {\n      if (container.nodeType === COMMENT_NODE) {\n        container.parentNode.insertBefore(child, beforeChild);\n      } else {\n        container.insertBefore(child, beforeChild);\n      }\n    },\n    removeChild: function (parentInstance, child) {\n      parentInstance.removeChild(child);\n    },\n    removeChildFromContainer: function (container, child) {\n      if (container.nodeType === COMMENT_NODE) {\n        container.parentNode.removeChild(child);\n      } else {\n        container.removeChild(child);\n      }\n    }\n  },\n\n  hydration: {\n    canHydrateInstance: function (instance, type, props) {\n      if (instance.nodeType !== ELEMENT_NODE || type.toLowerCase() !== instance.nodeName.toLowerCase()) {\n        return null;\n      }\n      // This has now been refined to an element node.\n      return instance;\n    },\n    canHydrateTextInstance: function (instance, text) {\n      if (text === '' || instance.nodeType !== TEXT_NODE) {\n        // Empty strings are not parsed by HTML so there won't be a correct match here.\n        return null;\n      }\n      // This has now been refined to a text node.\n      return instance;\n    },\n    getNextHydratableSibling: function (instance) {\n      var node = instance.nextSibling;\n      // Skip non-hydratable nodes.\n      while (node && node.nodeType !== ELEMENT_NODE && node.nodeType !== TEXT_NODE) {\n        node = node.nextSibling;\n      }\n      return node;\n    },\n    getFirstHydratableChild: function (parentInstance) {\n      var next = parentInstance.firstChild;\n      // Skip non-hydratable nodes.\n      while (next && next.nodeType !== ELEMENT_NODE && next.nodeType !== TEXT_NODE) {\n        next = next.nextSibling;\n      }\n      return next;\n    },\n    hydrateInstance: function (instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle) {\n      precacheFiberNode(internalInstanceHandle, instance);\n      // TODO: Possibly defer this until the commit phase where all the events\n      // get attached.\n      updateFiberProps(instance, props);\n      var parentNamespace = void 0;\n      {\n        var hostContextDev = hostContext;\n        parentNamespace = hostContextDev.namespace;\n      }\n      return diffHydratedProperties(instance, type, props, parentNamespace, rootContainerInstance);\n    },\n    hydrateTextInstance: function (textInstance, text, internalInstanceHandle) {\n      precacheFiberNode(internalInstanceHandle, textInstance);\n      return diffHydratedText(textInstance, text);\n    },\n    didNotMatchHydratedContainerTextInstance: function (parentContainer, textInstance, text) {\n      {\n        warnForUnmatchedText(textInstance, text);\n      }\n    },\n    didNotMatchHydratedTextInstance: function (parentType, parentProps, parentInstance, textInstance, text) {\n      if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n        warnForUnmatchedText(textInstance, text);\n      }\n    },\n    didNotHydrateContainerInstance: function (parentContainer, instance) {\n      {\n        if (instance.nodeType === 1) {\n          warnForDeletedHydratableElement(parentContainer, instance);\n        } else {\n          warnForDeletedHydratableText(parentContainer, instance);\n        }\n      }\n    },\n    didNotHydrateInstance: function (parentType, parentProps, parentInstance, instance) {\n      if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n        if (instance.nodeType === 1) {\n          warnForDeletedHydratableElement(parentInstance, instance);\n        } else {\n          warnForDeletedHydratableText(parentInstance, instance);\n        }\n      }\n    },\n    didNotFindHydratableContainerInstance: function (parentContainer, type, props) {\n      {\n        warnForInsertedHydratedElement(parentContainer, type, props);\n      }\n    },\n    didNotFindHydratableContainerTextInstance: function (parentContainer, text) {\n      {\n        warnForInsertedHydratedText(parentContainer, text);\n      }\n    },\n    didNotFindHydratableInstance: function (parentType, parentProps, parentInstance, type, props) {\n      if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n        warnForInsertedHydratedElement(parentInstance, type, props);\n      }\n    },\n    didNotFindHydratableTextInstance: function (parentType, parentProps, parentInstance, text) {\n      if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n        warnForInsertedHydratedText(parentInstance, text);\n      }\n    }\n  },\n\n  scheduleDeferredCallback: rIC,\n  cancelDeferredCallback: cIC,\n\n  useSyncScheduling: !enableAsyncSchedulingByDefaultInReactDOM\n});\n\ninjection$4.injectFiberBatchedUpdates(DOMRenderer.batchedUpdates);\n\nvar warnedAboutHydrateAPI = false;\n\nfunction renderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {\n  !isValidContainer(container) ? invariant(false, 'Target container is not a DOM element.') : void 0;\n\n  {\n    if (container._reactRootContainer && container.nodeType !== COMMENT_NODE) {\n      var hostInstance = DOMRenderer.findHostInstanceWithNoPortals(container._reactRootContainer.current);\n      if (hostInstance) {\n        warning(hostInstance.parentNode === container, 'render(...): It looks like the React-rendered content of this ' + 'container was removed without using React. This is not ' + 'supported and will cause errors. Instead, call ' + 'ReactDOM.unmountComponentAtNode to empty a container.');\n      }\n    }\n\n    var isRootRenderedBySomeReact = !!container._reactRootContainer;\n    var rootEl = getReactRootElementInContainer(container);\n    var hasNonRootReactChild = !!(rootEl && getInstanceFromNode$1(rootEl));\n\n    warning(!hasNonRootReactChild || isRootRenderedBySomeReact, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.');\n\n    warning(container.nodeType !== ELEMENT_NODE || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.');\n  }\n\n  var root = container._reactRootContainer;\n  if (!root) {\n    var shouldHydrate = forceHydrate || shouldHydrateDueToLegacyHeuristic(container);\n    // First clear any existing content.\n    if (!shouldHydrate) {\n      var warned = false;\n      var rootSibling = void 0;\n      while (rootSibling = container.lastChild) {\n        {\n          if (!warned && rootSibling.nodeType === ELEMENT_NODE && rootSibling.hasAttribute(ROOT_ATTRIBUTE_NAME)) {\n            warned = true;\n            warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.');\n          }\n        }\n        container.removeChild(rootSibling);\n      }\n    }\n    {\n      if (shouldHydrate && !forceHydrate && !warnedAboutHydrateAPI) {\n        warnedAboutHydrateAPI = true;\n        lowPriorityWarning$1(false, 'render(): Calling ReactDOM.render() to hydrate server-rendered markup ' + 'will stop working in React v17. Replace the ReactDOM.render() call ' + 'with ReactDOM.hydrate() if you want React to attach to the server HTML.');\n      }\n    }\n    var newRoot = DOMRenderer.createContainer(container, shouldHydrate);\n    root = container._reactRootContainer = newRoot;\n    // Initial mount should not be batched.\n    DOMRenderer.unbatchedUpdates(function () {\n      DOMRenderer.updateContainer(children, newRoot, parentComponent, callback);\n    });\n  } else {\n    DOMRenderer.updateContainer(children, root, parentComponent, callback);\n  }\n  return DOMRenderer.getPublicRootInstance(root);\n}\n\nfunction createPortal(children, container) {\n  var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n  !isValidContainer(container) ? invariant(false, 'Target container is not a DOM element.') : void 0;\n  // TODO: pass ReactDOM portal implementation as third argument\n  return createPortal$1(children, container, null, key);\n}\n\nfunction ReactRoot(container, hydrate) {\n  var root = DOMRenderer.createContainer(container, hydrate);\n  this._reactRootContainer = root;\n}\nReactRoot.prototype.render = function (children, callback) {\n  var root = this._reactRootContainer;\n  DOMRenderer.updateContainer(children, root, null, callback);\n};\nReactRoot.prototype.unmount = function (callback) {\n  var root = this._reactRootContainer;\n  DOMRenderer.updateContainer(null, root, null, callback);\n};\n\nvar ReactDOM = {\n  createPortal: createPortal,\n\n  findDOMNode: function (componentOrElement) {\n    {\n      var owner = ReactCurrentOwner.current;\n      if (owner !== null) {\n        var warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;\n        warning(warnedAboutRefsInRender, '%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentName(owner) || 'A component');\n        owner.stateNode._warnedAboutRefsInRender = true;\n      }\n    }\n    if (componentOrElement == null) {\n      return null;\n    }\n    if (componentOrElement.nodeType === ELEMENT_NODE) {\n      return componentOrElement;\n    }\n\n    var inst = get(componentOrElement);\n    if (inst) {\n      return DOMRenderer.findHostInstance(inst);\n    }\n\n    if (typeof componentOrElement.render === 'function') {\n      invariant(false, 'Unable to find node on an unmounted component.');\n    } else {\n      invariant(false, 'Element appears to be neither ReactComponent nor DOMNode. Keys: %s', Object.keys(componentOrElement));\n    }\n  },\n  hydrate: function (element, container, callback) {\n    // TODO: throw or warn if we couldn't hydrate?\n    return renderSubtreeIntoContainer(null, element, container, true, callback);\n  },\n  render: function (element, container, callback) {\n    return renderSubtreeIntoContainer(null, element, container, false, callback);\n  },\n  unstable_renderSubtreeIntoContainer: function (parentComponent, element, containerNode, callback) {\n    !(parentComponent != null && has(parentComponent)) ? invariant(false, 'parentComponent must be a valid React Component') : void 0;\n    return renderSubtreeIntoContainer(parentComponent, element, containerNode, false, callback);\n  },\n  unmountComponentAtNode: function (container) {\n    !isValidContainer(container) ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : void 0;\n\n    if (container._reactRootContainer) {\n      {\n        var rootEl = getReactRootElementInContainer(container);\n        var renderedByDifferentReact = rootEl && !getInstanceFromNode$1(rootEl);\n        warning(!renderedByDifferentReact, \"unmountComponentAtNode(): The node you're attempting to unmount \" + 'was rendered by another copy of React.');\n      }\n\n      // Unmount should not be batched.\n      DOMRenderer.unbatchedUpdates(function () {\n        renderSubtreeIntoContainer(null, null, container, false, function () {\n          container._reactRootContainer = null;\n        });\n      });\n      // If you call unmountComponentAtNode twice in quick succession, you'll\n      // get `true` twice. That's probably fine?\n      return true;\n    } else {\n      {\n        var _rootEl = getReactRootElementInContainer(container);\n        var hasNonRootReactChild = !!(_rootEl && getInstanceFromNode$1(_rootEl));\n\n        // Check if the container itself is a React root node.\n        var isContainerReactRoot = container.nodeType === 1 && isValidContainer(container.parentNode) && !!container.parentNode._reactRootContainer;\n\n        warning(!hasNonRootReactChild, \"unmountComponentAtNode(): The node you're attempting to unmount \" + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.');\n      }\n\n      return false;\n    }\n  },\n\n\n  // Temporary alias since we already shipped React 16 RC with it.\n  // TODO: remove in React 17.\n  unstable_createPortal: createPortal,\n\n  unstable_batchedUpdates: batchedUpdates,\n\n  unstable_deferredUpdates: DOMRenderer.deferredUpdates,\n\n  flushSync: DOMRenderer.flushSync,\n\n  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {\n    // For TapEventPlugin which is popular in open source\n    EventPluginHub: EventPluginHub,\n    // Used by test-utils\n    EventPluginRegistry: EventPluginRegistry,\n    EventPropagators: EventPropagators,\n    ReactControlledComponent: ReactControlledComponent,\n    ReactDOMComponentTree: ReactDOMComponentTree,\n    ReactDOMEventListener: ReactDOMEventListener\n  }\n};\n\nif (enableCreateRoot) {\n  ReactDOM.createRoot = function createRoot(container, options) {\n    var hydrate = options != null && options.hydrate === true;\n    return new ReactRoot(container, hydrate);\n  };\n}\n\nvar foundDevTools = DOMRenderer.injectIntoDevTools({\n  findFiberByHostInstance: getClosestInstanceFromNode,\n  bundleType: 1,\n  version: ReactVersion,\n  rendererPackageName: 'react-dom'\n});\n\n{\n  if (!foundDevTools && ExecutionEnvironment.canUseDOM && window.top === window.self) {\n    // If we're in Chrome or Firefox, provide a download link if not installed.\n    if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {\n      var protocol = window.location.protocol;\n      // Don't warn in exotic cases like chrome-extension://.\n      if (/^(https?|file):$/.test(protocol)) {\n        console.info('%cDownload the React DevTools ' + 'for a better development experience: ' + 'https://fb.me/react-devtools' + (protocol === 'file:' ? '\\nYou might need to use a local HTTP server (instead of file://): ' + 'https://fb.me/react-devtools-faq' : ''), 'font-weight:bold');\n      }\n    }\n  }\n}\n\n\n\nvar ReactDOM$2 = Object.freeze({\n\tdefault: ReactDOM\n});\n\nvar ReactDOM$3 = ( ReactDOM$2 && ReactDOM ) || ReactDOM$2;\n\n// TODO: decide on the top-level export form.\n// This is hacky but makes it work with both Rollup and Jest.\nvar reactDom = ReactDOM$3['default'] ? ReactDOM$3['default'] : ReactDOM$3;\n\nmodule.exports = reactDom;\n  })();\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2Nqcy9yZWFjdC1kb20uZGV2ZWxvcG1lbnQuanM/Y2FkYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjIuMFxuICogcmVhY3QtZG9tLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIEV2ZW50TGlzdGVuZXIgPSByZXF1aXJlKCdmYmpzL2xpYi9FdmVudExpc3RlbmVyJyk7XG52YXIgZ2V0QWN0aXZlRWxlbWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL2dldEFjdGl2ZUVsZW1lbnQnKTtcbnZhciBzaGFsbG93RXF1YWwgPSByZXF1aXJlKCdmYmpzL2xpYi9zaGFsbG93RXF1YWwnKTtcbnZhciBjb250YWluc05vZGUgPSByZXF1aXJlKCdmYmpzL2xpYi9jb250YWluc05vZGUnKTtcbnZhciBmb2N1c05vZGUgPSByZXF1aXJlKCdmYmpzL2xpYi9mb2N1c05vZGUnKTtcbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG52YXIgY2hlY2tQcm9wVHlwZXMgPSByZXF1aXJlKCdwcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzJyk7XG52YXIgaHlwaGVuYXRlU3R5bGVOYW1lID0gcmVxdWlyZSgnZmJqcy9saWIvaHlwaGVuYXRlU3R5bGVOYW1lJyk7XG52YXIgY2FtZWxpemVTdHlsZU5hbWUgPSByZXF1aXJlKCdmYmpzL2xpYi9jYW1lbGl6ZVN0eWxlTmFtZScpO1xuXG4vKipcbiAqIFdBUk5JTkc6IERPIE5PVCBtYW51YWxseSByZXF1aXJlIHRoaXMgbW9kdWxlLlxuICogVGhpcyBpcyBhIHJlcGxhY2VtZW50IGZvciBgaW52YXJpYW50KC4uLilgIHVzZWQgYnkgdGhlIGVycm9yIGNvZGUgc3lzdGVtXG4gKiBhbmQgd2lsbCBfb25seV8gYmUgcmVxdWlyZWQgYnkgdGhlIGNvcnJlc3BvbmRpbmcgYmFiZWwgcGFzcy5cbiAqIEl0IGFsd2F5cyB0aHJvd3MuXG4gKi9cblxuIVJlYWN0ID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RET00gd2FzIGxvYWRlZCBiZWZvcmUgUmVhY3QuIE1ha2Ugc3VyZSB5b3UgbG9hZCB0aGUgUmVhY3QgcGFja2FnZSBiZWZvcmUgbG9hZGluZyBSZWFjdERPTS4nKSA6IHZvaWQgMDtcblxuLy8gVGhlc2UgYXR0cmlidXRlcyBzaG91bGQgYmUgYWxsIGxvd2VyY2FzZSB0byBhbGxvdyBmb3Jcbi8vIGNhc2UgaW5zZW5zaXRpdmUgY2hlY2tzXG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGNoaWxkcmVuOiB0cnVlLFxuICBkYW5nZXJvdXNseVNldElubmVySFRNTDogdHJ1ZSxcbiAgZGVmYXVsdFZhbHVlOiB0cnVlLFxuICBkZWZhdWx0Q2hlY2tlZDogdHJ1ZSxcbiAgaW5uZXJIVE1MOiB0cnVlLFxuICBzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmc6IHRydWUsXG4gIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZzogdHJ1ZSxcbiAgc3R5bGU6IHRydWVcbn07XG5cbmZ1bmN0aW9uIGNoZWNrTWFzayh2YWx1ZSwgYml0bWFzaykge1xuICByZXR1cm4gKHZhbHVlICYgYml0bWFzaykgPT09IGJpdG1hc2s7XG59XG5cbnZhciBET01Qcm9wZXJ0eUluamVjdGlvbiA9IHtcbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSBub3JtYWxpemVkLCBjYW1lbGNhc2VkIHByb3BlcnR5IG5hbWVzIHRvIGEgY29uZmlndXJhdGlvbiB0aGF0XG4gICAqIHNwZWNpZmllcyBob3cgdGhlIGFzc29jaWF0ZWQgRE9NIHByb3BlcnR5IHNob3VsZCBiZSBhY2Nlc3NlZCBvciByZW5kZXJlZC5cbiAgICovXG4gIE1VU1RfVVNFX1BST1BFUlRZOiAweDEsXG4gIEhBU19CT09MRUFOX1ZBTFVFOiAweDQsXG4gIEhBU19OVU1FUklDX1ZBTFVFOiAweDgsXG4gIEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFOiAweDEwIHwgMHg4LFxuICBIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFOiAweDIwLFxuICBIQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUU6IDB4NDAsXG5cbiAgLyoqXG4gICAqIEluamVjdCBzb21lIHNwZWNpYWxpemVkIGtub3dsZWRnZSBhYm91dCB0aGUgRE9NLiBUaGlzIHRha2VzIGEgY29uZmlnIG9iamVjdFxuICAgKiB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogUHJvcGVydGllczogb2JqZWN0IG1hcHBpbmcgRE9NIHByb3BlcnR5IG5hbWUgdG8gb25lIG9mIHRoZVxuICAgKiBET01Qcm9wZXJ0eUluamVjdGlvbiBjb25zdGFudHMgb3IgbnVsbC4gSWYgeW91ciBhdHRyaWJ1dGUgaXNuJ3QgaW4gaGVyZSxcbiAgICogaXQgd29uJ3QgZ2V0IHdyaXR0ZW4gdG8gdGhlIERPTS5cbiAgICpcbiAgICogRE9NQXR0cmlidXRlTmFtZXM6IG9iamVjdCBtYXBwaW5nIFJlYWN0IGF0dHJpYnV0ZSBuYW1lIHRvIHRoZSBET01cbiAgICogYXR0cmlidXRlIG5hbWUuIEF0dHJpYnV0ZSBuYW1lcyBub3Qgc3BlY2lmaWVkIHVzZSB0aGUgKipsb3dlcmNhc2UqKlxuICAgKiBub3JtYWxpemVkIG5hbWUuXG4gICAqXG4gICAqIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXM6IG9iamVjdCBtYXBwaW5nIFJlYWN0IGF0dHJpYnV0ZSBuYW1lIHRvIHRoZSBET01cbiAgICogYXR0cmlidXRlIG5hbWVzcGFjZSBVUkwuIChBdHRyaWJ1dGUgbmFtZXMgbm90IHNwZWNpZmllZCB1c2Ugbm8gbmFtZXNwYWNlLilcbiAgICpcbiAgICogRE9NUHJvcGVydHlOYW1lczogc2ltaWxhciB0byBET01BdHRyaWJ1dGVOYW1lcyBidXQgZm9yIERPTSBwcm9wZXJ0aWVzLlxuICAgKiBQcm9wZXJ0eSBuYW1lcyBub3Qgc3BlY2lmaWVkIHVzZSB0aGUgbm9ybWFsaXplZCBuYW1lLlxuICAgKlxuICAgKiBET01NdXRhdGlvbk1ldGhvZHM6IFByb3BlcnRpZXMgdGhhdCByZXF1aXJlIHNwZWNpYWwgbXV0YXRpb24gbWV0aG9kcy4gSWZcbiAgICogYHZhbHVlYCBpcyB1bmRlZmluZWQsIHRoZSBtdXRhdGlvbiBtZXRob2Qgc2hvdWxkIHVuc2V0IHRoZSBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGRvbVByb3BlcnR5Q29uZmlnIHRoZSBjb25maWcgYXMgZGVzY3JpYmVkIGFib3ZlLlxuICAgKi9cbiAgaW5qZWN0RE9NUHJvcGVydHlDb25maWc6IGZ1bmN0aW9uIChkb21Qcm9wZXJ0eUNvbmZpZykge1xuICAgIHZhciBJbmplY3Rpb24gPSBET01Qcm9wZXJ0eUluamVjdGlvbjtcbiAgICB2YXIgUHJvcGVydGllcyA9IGRvbVByb3BlcnR5Q29uZmlnLlByb3BlcnRpZXMgfHwge307XG4gICAgdmFyIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5ET01BdHRyaWJ1dGVOYW1lc3BhY2VzIHx8IHt9O1xuICAgIHZhciBET01BdHRyaWJ1dGVOYW1lcyA9IGRvbVByb3BlcnR5Q29uZmlnLkRPTUF0dHJpYnV0ZU5hbWVzIHx8IHt9O1xuICAgIHZhciBET01NdXRhdGlvbk1ldGhvZHMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5ET01NdXRhdGlvbk1ldGhvZHMgfHwge307XG5cbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBQcm9wZXJ0aWVzKSB7XG4gICAgICAhIXByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpID8gaW52YXJpYW50KGZhbHNlLCBcImluamVjdERPTVByb3BlcnR5Q29uZmlnKC4uLik6IFlvdSdyZSB0cnlpbmcgdG8gaW5qZWN0IERPTSBwcm9wZXJ0eSAnJXMnIHdoaWNoIGhhcyBhbHJlYWR5IGJlZW4gaW5qZWN0ZWQuIFlvdSBtYXkgYmUgYWNjaWRlbnRhbGx5IGluamVjdGluZyB0aGUgc2FtZSBET00gcHJvcGVydHkgY29uZmlnIHR3aWNlLCBvciB5b3UgbWF5IGJlIGluamVjdGluZyB0d28gY29uZmlncyB0aGF0IGhhdmUgY29uZmxpY3RpbmcgcHJvcGVydHkgbmFtZXMuXCIsIHByb3BOYW1lKSA6IHZvaWQgMDtcblxuICAgICAgdmFyIGxvd2VyQ2FzZWQgPSBwcm9wTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIHByb3BDb25maWcgPSBQcm9wZXJ0aWVzW3Byb3BOYW1lXTtcblxuICAgICAgdmFyIHByb3BlcnR5SW5mbyA9IHtcbiAgICAgICAgYXR0cmlidXRlTmFtZTogbG93ZXJDYXNlZCxcbiAgICAgICAgYXR0cmlidXRlTmFtZXNwYWNlOiBudWxsLFxuICAgICAgICBwcm9wZXJ0eU5hbWU6IHByb3BOYW1lLFxuICAgICAgICBtdXRhdGlvbk1ldGhvZDogbnVsbCxcblxuICAgICAgICBtdXN0VXNlUHJvcGVydHk6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uTVVTVF9VU0VfUFJPUEVSVFkpLFxuICAgICAgICBoYXNCb29sZWFuVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX0JPT0xFQU5fVkFMVUUpLFxuICAgICAgICBoYXNOdW1lcmljVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX05VTUVSSUNfVkFMVUUpLFxuICAgICAgICBoYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5IQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSksXG4gICAgICAgIGhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSksXG4gICAgICAgIGhhc1N0cmluZ0Jvb2xlYW5WYWx1ZTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5IQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUpXG4gICAgICB9O1xuICAgICAgIShwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlICsgcHJvcGVydHlJbmZvLmhhc051bWVyaWNWYWx1ZSArIHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlIDw9IDEpID8gaW52YXJpYW50KGZhbHNlLCBcIkRPTVByb3BlcnR5OiBWYWx1ZSBjYW4gYmUgb25lIG9mIGJvb2xlYW4sIG92ZXJsb2FkZWQgYm9vbGVhbiwgb3IgbnVtZXJpYyB2YWx1ZSwgYnV0IG5vdCBhIGNvbWJpbmF0aW9uOiAlc1wiLCBwcm9wTmFtZSkgOiB2b2lkIDA7XG5cbiAgICAgIGlmIChET01BdHRyaWJ1dGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBET01BdHRyaWJ1dGVOYW1lc1twcm9wTmFtZV07XG5cbiAgICAgICAgcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWUgPSBhdHRyaWJ1dGVOYW1lO1xuICAgICAgfVxuXG4gICAgICBpZiAoRE9NQXR0cmlidXRlTmFtZXNwYWNlcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWVzcGFjZSA9IERPTUF0dHJpYnV0ZU5hbWVzcGFjZXNbcHJvcE5hbWVdO1xuICAgICAgfVxuXG4gICAgICBpZiAoRE9NTXV0YXRpb25NZXRob2RzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wZXJ0eUluZm8ubXV0YXRpb25NZXRob2QgPSBET01NdXRhdGlvbk1ldGhvZHNbcHJvcE5hbWVdO1xuICAgICAgfVxuXG4gICAgICAvLyBEb3duY2FzZSByZWZlcmVuY2VzIHRvIHdoaXRlbGlzdCBwcm9wZXJ0aWVzIHRvIGNoZWNrIGZvciBtZW1iZXJzaGlwXG4gICAgICAvLyB3aXRob3V0IGNhc2Utc2Vuc2l0aXZpdHkuIFRoaXMgYWxsb3dzIHRoZSB3aGl0ZWxpc3QgdG8gcGljayB1cFxuICAgICAgLy8gYGFsbG93ZnVsbHNjcmVlbmAsIHdoaWNoIHNob3VsZCBiZSB3cml0dGVuIHVzaW5nIHRoZSBwcm9wZXJ0eSBjb25maWd1cmF0aW9uXG4gICAgICAvLyBmb3IgYGFsbG93RnVsbHNjcmVlbmBcbiAgICAgIHByb3BlcnRpZXNbcHJvcE5hbWVdID0gcHJvcGVydHlJbmZvO1xuICAgIH1cbiAgfVxufTtcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xudmFyIEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIgPSBcIjpBLVpfYS16XFxcXHUwMEMwLVxcXFx1MDBENlxcXFx1MDBEOC1cXFxcdTAwRjZcXFxcdTAwRjgtXFxcXHUwMkZGXFxcXHUwMzcwLVxcXFx1MDM3RFxcXFx1MDM3Ri1cXFxcdTFGRkZcXFxcdTIwMEMtXFxcXHUyMDBEXFxcXHUyMDcwLVxcXFx1MjE4RlxcXFx1MkMwMC1cXFxcdTJGRUZcXFxcdTMwMDEtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRkRcIjtcbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xudmFyIEFUVFJJQlVURV9OQU1FX0NIQVIgPSBBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSICsgXCJcXFxcLS4wLTlcXFxcdTAwQjdcXFxcdTAzMDAtXFxcXHUwMzZGXFxcXHUyMDNGLVxcXFx1MjA0MFwiO1xuXG5cbnZhciBST09UX0FUVFJJQlVURV9OQU1FID0gJ2RhdGEtcmVhY3Ryb290JztcblxuLyoqXG4gKiBNYXAgZnJvbSBwcm9wZXJ0eSBcInN0YW5kYXJkIG5hbWVcIiB0byBhbiBvYmplY3Qgd2l0aCBpbmZvIGFib3V0IGhvdyB0byBzZXRcbiAqIHRoZSBwcm9wZXJ0eSBpbiB0aGUgRE9NLiBFYWNoIG9iamVjdCBjb250YWluczpcbiAqXG4gKiBhdHRyaWJ1dGVOYW1lOlxuICogICBVc2VkIHdoZW4gcmVuZGVyaW5nIG1hcmt1cCBvciB3aXRoIGAqQXR0cmlidXRlKClgLlxuICogYXR0cmlidXRlTmFtZXNwYWNlXG4gKiBwcm9wZXJ0eU5hbWU6XG4gKiAgIFVzZWQgb24gRE9NIG5vZGUgaW5zdGFuY2VzLiAoVGhpcyBpbmNsdWRlcyBwcm9wZXJ0aWVzIHRoYXQgbXV0YXRlIGR1ZSB0b1xuICogICBleHRlcm5hbCBmYWN0b3JzLilcbiAqIG11dGF0aW9uTWV0aG9kOlxuICogICBJZiBub24tbnVsbCwgdXNlZCBpbnN0ZWFkIG9mIHRoZSBwcm9wZXJ0eSBvciBgc2V0QXR0cmlidXRlKClgIGFmdGVyXG4gKiAgIGluaXRpYWwgcmVuZGVyLlxuICogbXVzdFVzZVByb3BlcnR5OlxuICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBtdXN0IGJlIGFjY2Vzc2VkIGFuZCBtdXRhdGVkIGFzIGFuIG9iamVjdCBwcm9wZXJ0eS5cbiAqIGhhc0Jvb2xlYW5WYWx1ZTpcbiAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgc2hvdWxkIGJlIHJlbW92ZWQgd2hlbiBzZXQgdG8gYSBmYWxzZXkgdmFsdWUuXG4gKiBoYXNOdW1lcmljVmFsdWU6XG4gKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIG51bWVyaWMgYW5kIHNob3VsZCBiZVxuICogICByZW1vdmVkIHdoZW4gc2V0IHRvIGEgZmFsc2V5IHZhbHVlLlxuICogaGFzUG9zaXRpdmVOdW1lcmljVmFsdWU6XG4gKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgcG9zaXRpdmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIHBvc2l0aXZlXG4gKiAgIG51bWVyaWMgYW5kIHNob3VsZCBiZSByZW1vdmVkIHdoZW4gc2V0IHRvIGEgZmFsc2V5IHZhbHVlLlxuICogaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZTpcbiAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgY2FuIGJlIHVzZWQgYXMgYSBmbGFnIGFzIHdlbGwgYXMgd2l0aCBhIHZhbHVlLlxuICogICBSZW1vdmVkIHdoZW4gc3RyaWN0bHkgZXF1YWwgdG8gZmFsc2U7IHByZXNlbnQgd2l0aG91dCBhIHZhbHVlIHdoZW5cbiAqICAgc3RyaWN0bHkgZXF1YWwgdG8gdHJ1ZTsgcHJlc2VudCB3aXRoIGEgdmFsdWUgb3RoZXJ3aXNlLlxuICovXG52YXIgcHJvcGVydGllcyA9IHt9O1xuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgcHJvcGVydHkgbmFtZSBpcyBhIHdyaXRlYWJsZSBhdHRyaWJ1dGUuXG4gKiBAbWV0aG9kXG4gKi9cbmZ1bmN0aW9uIHNob3VsZFNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSkge1xuICBpZiAoaXNSZXNlcnZlZFByb3AobmFtZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKG5hbWUubGVuZ3RoID4gMiAmJiAobmFtZVswXSA9PT0gJ28nIHx8IG5hbWVbMF0gPT09ICdPJykgJiYgKG5hbWVbMV0gPT09ICduJyB8fCBuYW1lWzFdID09PSAnTicpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gc2hvdWxkQXR0cmlidXRlQWNjZXB0Qm9vbGVhblZhbHVlKG5hbWUpO1xuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gZnVuY3Rpb24sIHN5bWJvbFxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFByb3BlcnR5SW5mbyhuYW1lKSB7XG4gIHJldHVybiBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpID8gcHJvcGVydGllc1tuYW1lXSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIHNob3VsZEF0dHJpYnV0ZUFjY2VwdEJvb2xlYW5WYWx1ZShuYW1lKSB7XG4gIGlmIChpc1Jlc2VydmVkUHJvcChuYW1lKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBwcm9wZXJ0eUluZm8gPSBnZXRQcm9wZXJ0eUluZm8obmFtZSk7XG4gIGlmIChwcm9wZXJ0eUluZm8pIHtcbiAgICByZXR1cm4gcHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSB8fCBwcm9wZXJ0eUluZm8uaGFzU3RyaW5nQm9vbGVhblZhbHVlIHx8IHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlO1xuICB9XG4gIHZhciBwcmVmaXggPSBuYW1lLnRvTG93ZXJDYXNlKCkuc2xpY2UoMCwgNSk7XG4gIHJldHVybiBwcmVmaXggPT09ICdkYXRhLScgfHwgcHJlZml4ID09PSAnYXJpYS0nO1xufVxuXG4vKipcbiAqIENoZWNrcyB0byBzZWUgaWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHdpdGhpbiB0aGUgbGlzdCBvZiBwcm9wZXJ0aWVzXG4gKiByZXNlcnZlZCBmb3IgaW50ZXJuYWwgUmVhY3Qgb3BlcmF0aW9ucy4gVGhlc2UgcHJvcGVydGllcyBzaG91bGRcbiAqIG5vdCBiZSBzZXQgb24gYW4gSFRNTCBlbGVtZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Ym9vbGVhbn0gSWYgdGhlIG5hbWUgaXMgd2l0aGluIHJlc2VydmVkIHByb3BzXG4gKi9cbmZ1bmN0aW9uIGlzUmVzZXJ2ZWRQcm9wKG5hbWUpIHtcbiAgcmV0dXJuIFJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KG5hbWUpO1xufVxuXG52YXIgaW5qZWN0aW9uID0gRE9NUHJvcGVydHlJbmplY3Rpb247XG5cbnZhciBNVVNUX1VTRV9QUk9QRVJUWSA9IGluamVjdGlvbi5NVVNUX1VTRV9QUk9QRVJUWTtcbnZhciBIQVNfQk9PTEVBTl9WQUxVRSA9IGluamVjdGlvbi5IQVNfQk9PTEVBTl9WQUxVRTtcbnZhciBIQVNfTlVNRVJJQ19WQUxVRSA9IGluamVjdGlvbi5IQVNfTlVNRVJJQ19WQUxVRTtcbnZhciBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSA9IGluamVjdGlvbi5IQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRTtcbnZhciBIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFID0gaW5qZWN0aW9uLkhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUU7XG52YXIgSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFID0gaW5qZWN0aW9uLkhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRTtcblxudmFyIEhUTUxET01Qcm9wZXJ0eUNvbmZpZyA9IHtcbiAgLy8gV2hlbiBhZGRpbmcgYXR0cmlidXRlcyB0byB0aGlzIGxpc3QsIGJlIHN1cmUgdG8gYWxzbyBhZGQgdGhlbSB0b1xuICAvLyB0aGUgYHBvc3NpYmxlU3RhbmRhcmROYW1lc2AgbW9kdWxlIHRvIGVuc3VyZSBjYXNpbmcgYW5kIGluY29ycmVjdFxuICAvLyBuYW1lIHdhcm5pbmdzLlxuICBQcm9wZXJ0aWVzOiB7XG4gICAgYWxsb3dGdWxsU2NyZWVuOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICAvLyBzcGVjaWZpZXMgdGFyZ2V0IGNvbnRleHQgZm9yIGxpbmtzIHdpdGggYHByZWxvYWRgIHR5cGVcbiAgICBhc3luYzogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgLy8gTm90ZTogdGhlcmUgaXMgYSBzcGVjaWFsIGNhc2UgdGhhdCBwcmV2ZW50cyBpdCBmcm9tIGJlaW5nIHdyaXR0ZW4gdG8gdGhlIERPTVxuICAgIC8vIG9uIHRoZSBjbGllbnQgc2lkZSBiZWNhdXNlIHRoZSBicm93c2VycyBhcmUgaW5jb25zaXN0ZW50LiBJbnN0ZWFkIHdlIGNhbGwgZm9jdXMoKS5cbiAgICBhdXRvRm9jdXM6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGF1dG9QbGF5OiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBjYXB0dXJlOiBIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFLFxuICAgIGNoZWNrZWQ6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgY29sczogSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXG4gICAgY29udGVudEVkaXRhYmxlOiBIQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUsXG4gICAgY29udHJvbHM6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgICdkZWZhdWx0JzogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgZGVmZXI6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGRpc2FibGVkOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBkb3dubG9hZDogSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSxcbiAgICBkcmFnZ2FibGU6IEhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRSxcbiAgICBmb3JtTm9WYWxpZGF0ZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgaGlkZGVuOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBsb29wOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICAvLyBDYXV0aW9uOyBgb3B0aW9uLnNlbGVjdGVkYCBpcyBub3QgdXBkYXRlZCBpZiBgc2VsZWN0Lm11bHRpcGxlYCBpc1xuICAgIC8vIGRpc2FibGVkIHdpdGggYHJlbW92ZUF0dHJpYnV0ZWAuXG4gICAgbXVsdGlwbGU6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgbXV0ZWQ6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgbm9WYWxpZGF0ZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgb3BlbjogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgcGxheXNJbmxpbmU6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHJlYWRPbmx5OiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICByZXF1aXJlZDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgcmV2ZXJzZWQ6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHJvd3M6IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIHJvd1NwYW46IEhBU19OVU1FUklDX1ZBTFVFLFxuICAgIHNjb3BlZDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgc2VhbWxlc3M6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHNlbGVjdGVkOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHNpemU6IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIHN0YXJ0OiBIQVNfTlVNRVJJQ19WQUxVRSxcbiAgICAvLyBzdXBwb3J0IGZvciBwcm9qZWN0aW5nIHJlZ3VsYXIgRE9NIEVsZW1lbnRzIHZpYSBWMSBuYW1lZCBzbG90cyAoIHNoYWRvdyBkb20gKVxuICAgIHNwYW46IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIHNwZWxsQ2hlY2s6IEhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRSxcbiAgICAvLyBTdHlsZSBtdXN0IGJlIGV4cGxpY2l0bHkgc2V0IGluIHRoZSBhdHRyaWJ1dGUgbGlzdC4gUmVhY3QgY29tcG9uZW50c1xuICAgIC8vIGV4cGVjdCBhIHN0eWxlIG9iamVjdFxuICAgIHN0eWxlOiAwLFxuICAgIC8vIEtlZXAgaXQgaW4gdGhlIHdoaXRlbGlzdCBiZWNhdXNlIGl0IGlzIGNhc2Utc2Vuc2l0aXZlIGZvciBTVkcuXG4gICAgdGFiSW5kZXg6IDAsXG4gICAgLy8gaXRlbVNjb3BlIGlzIGZvciBmb3IgTWljcm9kYXRhIHN1cHBvcnQuXG4gICAgLy8gU2VlIGh0dHA6Ly9zY2hlbWEub3JnL2RvY3MvZ3MuaHRtbFxuICAgIGl0ZW1TY29wZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgLy8gVGhlc2UgYXR0cmlidXRlcyBtdXN0IHN0YXkgaW4gdGhlIHdoaXRlLWxpc3QgYmVjYXVzZSB0aGV5IGhhdmVcbiAgICAvLyBkaWZmZXJlbnQgYXR0cmlidXRlIG5hbWVzIChzZWUgRE9NQXR0cmlidXRlTmFtZXMgYmVsb3cpXG4gICAgYWNjZXB0Q2hhcnNldDogMCxcbiAgICBjbGFzc05hbWU6IDAsXG4gICAgaHRtbEZvcjogMCxcbiAgICBodHRwRXF1aXY6IDAsXG4gICAgLy8gQXR0cmlidXRlcyB3aXRoIG11dGF0aW9uIG1ldGhvZHMgbXVzdCBiZSBzcGVjaWZpZWQgaW4gdGhlIHdoaXRlbGlzdFxuICAgIC8vIFNldCB0aGUgc3RyaW5nIGJvb2xlYW4gZmxhZyB0byBhbGxvdyB0aGUgYmVoYXZpb3JcbiAgICB2YWx1ZTogSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFXG4gIH0sXG4gIERPTUF0dHJpYnV0ZU5hbWVzOiB7XG4gICAgYWNjZXB0Q2hhcnNldDogJ2FjY2VwdC1jaGFyc2V0JyxcbiAgICBjbGFzc05hbWU6ICdjbGFzcycsXG4gICAgaHRtbEZvcjogJ2ZvcicsXG4gICAgaHR0cEVxdWl2OiAnaHR0cC1lcXVpdidcbiAgfSxcbiAgRE9NTXV0YXRpb25NZXRob2RzOiB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIChub2RlLCB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUucmVtb3ZlQXR0cmlidXRlKCd2YWx1ZScpO1xuICAgICAgfVxuXG4gICAgICAvLyBOdW1iZXIgaW5wdXRzIGdldCBzcGVjaWFsIHRyZWF0bWVudCBkdWUgdG8gc29tZSBlZGdlIGNhc2VzIGluXG4gICAgICAvLyBDaHJvbWUuIExldCBldmVyeXRoaW5nIGVsc2UgYXNzaWduIHRoZSB2YWx1ZSBhdHRyaWJ1dGUgYXMgbm9ybWFsLlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MjUzI2lzc3VlY29tbWVudC0yMzYwNzQzMjZcbiAgICAgIGlmIChub2RlLnR5cGUgIT09ICdudW1iZXInIHx8IG5vZGUuaGFzQXR0cmlidXRlKCd2YWx1ZScpID09PSBmYWxzZSkge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgndmFsdWUnLCAnJyArIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS52YWxpZGl0eSAmJiAhbm9kZS52YWxpZGl0eS5iYWRJbnB1dCAmJiBub2RlLm93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gbm9kZSkge1xuICAgICAgICAvLyBEb24ndCBhc3NpZ24gYW4gYXR0cmlidXRlIGlmIHZhbGlkYXRpb24gcmVwb3J0cyBiYWRcbiAgICAgICAgLy8gaW5wdXQuIENocm9tZSB3aWxsIGNsZWFyIHRoZSB2YWx1ZS4gQWRkaXRpb25hbGx5LCBkb24ndFxuICAgICAgICAvLyBvcGVyYXRlIG9uIGlucHV0cyB0aGF0IGhhdmUgZm9jdXMsIG90aGVyd2lzZSBDaHJvbWUgbWlnaHRcbiAgICAgICAgLy8gc3RyaXAgb2ZmIHRyYWlsaW5nIGRlY2ltYWwgcGxhY2VzIGFuZCBjYXVzZSB0aGUgdXNlcidzXG4gICAgICAgIC8vIGN1cnNvciBwb3NpdGlvbiB0byBqdW1wIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGlucHV0LlxuICAgICAgICAvL1xuICAgICAgICAvLyBJbiBSZWFjdERPTUlucHV0LCB3ZSBoYXZlIGFuIG9uQmx1ciBldmVudCB0aGF0IHdpbGwgdHJpZ2dlclxuICAgICAgICAvLyB0aGlzIGZ1bmN0aW9uIGFnYWluIHdoZW4gZm9jdXMgaXMgbG9zdC5cbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgJycgKyB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFJDEgPSBpbmplY3Rpb24uSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFO1xuXG5cbnZhciBOUyA9IHtcbiAgeGxpbms6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyxcbiAgeG1sOiAnaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlJ1xufTtcblxuLyoqXG4gKiBUaGlzIGlzIGEgbGlzdCBvZiBhbGwgU1ZHIGF0dHJpYnV0ZXMgdGhhdCBuZWVkIHNwZWNpYWwgY2FzaW5nLFxuICogbmFtZXNwYWNpbmcsIG9yIGJvb2xlYW4gdmFsdWUgYXNzaWdubWVudC5cbiAqXG4gKiBXaGVuIGFkZGluZyBhdHRyaWJ1dGVzIHRvIHRoaXMgbGlzdCwgYmUgc3VyZSB0byBhbHNvIGFkZCB0aGVtIHRvXG4gKiB0aGUgYHBvc3NpYmxlU3RhbmRhcmROYW1lc2AgbW9kdWxlIHRvIGVuc3VyZSBjYXNpbmcgYW5kIGluY29ycmVjdFxuICogbmFtZSB3YXJuaW5ncy5cbiAqXG4gKiBTVkcgQXR0cmlidXRlcyBMaXN0OlxuICogaHR0cHM6Ly93d3cudzMub3JnL1RSL1NWRy9hdHRpbmRleC5odG1sXG4gKiBTTUlMIFNwZWM6XG4gKiBodHRwczovL3d3dy53My5vcmcvVFIvc21pbFxuICovXG52YXIgQVRUUlMgPSBbJ2FjY2VudC1oZWlnaHQnLCAnYWxpZ25tZW50LWJhc2VsaW5lJywgJ2FyYWJpYy1mb3JtJywgJ2Jhc2VsaW5lLXNoaWZ0JywgJ2NhcC1oZWlnaHQnLCAnY2xpcC1wYXRoJywgJ2NsaXAtcnVsZScsICdjb2xvci1pbnRlcnBvbGF0aW9uJywgJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycycsICdjb2xvci1wcm9maWxlJywgJ2NvbG9yLXJlbmRlcmluZycsICdkb21pbmFudC1iYXNlbGluZScsICdlbmFibGUtYmFja2dyb3VuZCcsICdmaWxsLW9wYWNpdHknLCAnZmlsbC1ydWxlJywgJ2Zsb29kLWNvbG9yJywgJ2Zsb29kLW9wYWNpdHknLCAnZm9udC1mYW1pbHknLCAnZm9udC1zaXplJywgJ2ZvbnQtc2l6ZS1hZGp1c3QnLCAnZm9udC1zdHJldGNoJywgJ2ZvbnQtc3R5bGUnLCAnZm9udC12YXJpYW50JywgJ2ZvbnQtd2VpZ2h0JywgJ2dseXBoLW5hbWUnLCAnZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCcsICdnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCcsICdob3Jpei1hZHYteCcsICdob3Jpei1vcmlnaW4teCcsICdpbWFnZS1yZW5kZXJpbmcnLCAnbGV0dGVyLXNwYWNpbmcnLCAnbGlnaHRpbmctY29sb3InLCAnbWFya2VyLWVuZCcsICdtYXJrZXItbWlkJywgJ21hcmtlci1zdGFydCcsICdvdmVybGluZS1wb3NpdGlvbicsICdvdmVybGluZS10aGlja25lc3MnLCAncGFpbnQtb3JkZXInLCAncGFub3NlLTEnLCAncG9pbnRlci1ldmVudHMnLCAncmVuZGVyaW5nLWludGVudCcsICdzaGFwZS1yZW5kZXJpbmcnLCAnc3RvcC1jb2xvcicsICdzdG9wLW9wYWNpdHknLCAnc3RyaWtldGhyb3VnaC1wb3NpdGlvbicsICdzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcycsICdzdHJva2UtZGFzaGFycmF5JywgJ3N0cm9rZS1kYXNob2Zmc2V0JywgJ3N0cm9rZS1saW5lY2FwJywgJ3N0cm9rZS1saW5lam9pbicsICdzdHJva2UtbWl0ZXJsaW1pdCcsICdzdHJva2Utb3BhY2l0eScsICdzdHJva2Utd2lkdGgnLCAndGV4dC1hbmNob3InLCAndGV4dC1kZWNvcmF0aW9uJywgJ3RleHQtcmVuZGVyaW5nJywgJ3VuZGVybGluZS1wb3NpdGlvbicsICd1bmRlcmxpbmUtdGhpY2tuZXNzJywgJ3VuaWNvZGUtYmlkaScsICd1bmljb2RlLXJhbmdlJywgJ3VuaXRzLXBlci1lbScsICd2LWFscGhhYmV0aWMnLCAndi1oYW5naW5nJywgJ3YtaWRlb2dyYXBoaWMnLCAndi1tYXRoZW1hdGljYWwnLCAndmVjdG9yLWVmZmVjdCcsICd2ZXJ0LWFkdi15JywgJ3ZlcnQtb3JpZ2luLXgnLCAndmVydC1vcmlnaW4teScsICd3b3JkLXNwYWNpbmcnLCAnd3JpdGluZy1tb2RlJywgJ3gtaGVpZ2h0JywgJ3hsaW5rOmFjdHVhdGUnLCAneGxpbms6YXJjcm9sZScsICd4bGluazpocmVmJywgJ3hsaW5rOnJvbGUnLCAneGxpbms6c2hvdycsICd4bGluazp0aXRsZScsICd4bGluazp0eXBlJywgJ3htbDpiYXNlJywgJ3htbG5zOnhsaW5rJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZSddO1xuXG52YXIgU1ZHRE9NUHJvcGVydHlDb25maWcgPSB7XG4gIFByb3BlcnRpZXM6IHtcbiAgICBhdXRvUmV2ZXJzZTogSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFJDEsXG4gICAgZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZDogSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFJDEsXG4gICAgcHJlc2VydmVBbHBoYTogSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFJDFcbiAgfSxcbiAgRE9NQXR0cmlidXRlTmFtZXM6IHtcbiAgICBhdXRvUmV2ZXJzZTogJ2F1dG9SZXZlcnNlJyxcbiAgICBleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkOiAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsXG4gICAgcHJlc2VydmVBbHBoYTogJ3ByZXNlcnZlQWxwaGEnXG4gIH0sXG4gIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXM6IHtcbiAgICB4bGlua0FjdHVhdGU6IE5TLnhsaW5rLFxuICAgIHhsaW5rQXJjcm9sZTogTlMueGxpbmssXG4gICAgeGxpbmtIcmVmOiBOUy54bGluayxcbiAgICB4bGlua1JvbGU6IE5TLnhsaW5rLFxuICAgIHhsaW5rU2hvdzogTlMueGxpbmssXG4gICAgeGxpbmtUaXRsZTogTlMueGxpbmssXG4gICAgeGxpbmtUeXBlOiBOUy54bGluayxcbiAgICB4bWxCYXNlOiBOUy54bWwsXG4gICAgeG1sTGFuZzogTlMueG1sLFxuICAgIHhtbFNwYWNlOiBOUy54bWxcbiAgfVxufTtcblxudmFyIENBTUVMSVpFID0gL1tcXC1cXDpdKFthLXpdKS9nO1xudmFyIGNhcGl0YWxpemUgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuWzFdLnRvVXBwZXJDYXNlKCk7XG59O1xuXG5BVFRSUy5mb3JFYWNoKGZ1bmN0aW9uIChvcmlnaW5hbCkge1xuICB2YXIgcmVhY3ROYW1lID0gb3JpZ2luYWwucmVwbGFjZShDQU1FTElaRSwgY2FwaXRhbGl6ZSk7XG5cbiAgU1ZHRE9NUHJvcGVydHlDb25maWcuUHJvcGVydGllc1tyZWFjdE5hbWVdID0gMDtcbiAgU1ZHRE9NUHJvcGVydHlDb25maWcuRE9NQXR0cmlidXRlTmFtZXNbcmVhY3ROYW1lXSA9IG9yaWdpbmFsO1xufSk7XG5cbmluamVjdGlvbi5pbmplY3RET01Qcm9wZXJ0eUNvbmZpZyhIVE1MRE9NUHJvcGVydHlDb25maWcpO1xuaW5qZWN0aW9uLmluamVjdERPTVByb3BlcnR5Q29uZmlnKFNWR0RPTVByb3BlcnR5Q29uZmlnKTtcblxudmFyIFJlYWN0RXJyb3JVdGlscyA9IHtcbiAgLy8gVXNlZCBieSBGaWJlciB0byBzaW11bGF0ZSBhIHRyeS1jYXRjaC5cbiAgX2NhdWdodEVycm9yOiBudWxsLFxuICBfaGFzQ2F1Z2h0RXJyb3I6IGZhbHNlLFxuXG4gIC8vIFVzZWQgYnkgZXZlbnQgc3lzdGVtIHRvIGNhcHR1cmUvcmV0aHJvdyB0aGUgZmlyc3QgZXJyb3IuXG4gIF9yZXRocm93RXJyb3I6IG51bGwsXG4gIF9oYXNSZXRocm93RXJyb3I6IGZhbHNlLFxuXG4gIGluamVjdGlvbjoge1xuICAgIGluamVjdEVycm9yVXRpbHM6IGZ1bmN0aW9uIChpbmplY3RlZEVycm9yVXRpbHMpIHtcbiAgICAgICEodHlwZW9mIGluamVjdGVkRXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2sgPT09ICdmdW5jdGlvbicpID8gaW52YXJpYW50KGZhbHNlLCAnSW5qZWN0ZWQgaW52b2tlR3VhcmRlZENhbGxiYWNrKCkgbXVzdCBiZSBhIGZ1bmN0aW9uLicpIDogdm9pZCAwO1xuICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrID0gaW5qZWN0ZWRFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFjaztcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGwgYSBmdW5jdGlvbiB3aGlsZSBndWFyZGluZyBhZ2FpbnN0IGVycm9ycyB0aGF0IGhhcHBlbnMgd2l0aGluIGl0LlxuICAgKiBSZXR1cm5zIGFuIGVycm9yIGlmIGl0IHRocm93cywgb3RoZXJ3aXNlIG51bGwuXG4gICAqXG4gICAqIEluIHByb2R1Y3Rpb24sIHRoaXMgaXMgaW1wbGVtZW50ZWQgdXNpbmcgYSB0cnktY2F0Y2guIFRoZSByZWFzb24gd2UgZG9uJ3RcbiAgICogdXNlIGEgdHJ5LWNhdGNoIGRpcmVjdGx5IGlzIHNvIHRoYXQgd2UgY2FuIHN3YXAgb3V0IGEgZGlmZmVyZW50XG4gICAqIGltcGxlbWVudGF0aW9uIGluIERFViBtb2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiB0aGUgZ3VhcmQgdG8gdXNlIGZvciBsb2dnaW5nIG9yIGRlYnVnZ2luZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2VcbiAgICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIHVzZSB3aGVuIGNhbGxpbmcgdGhlIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcmd1bWVudHMgZm9yIGZ1bmN0aW9uXG4gICAqL1xuICBpbnZva2VHdWFyZGVkQ2FsbGJhY2s6IGZ1bmN0aW9uIChuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgaW52b2tlR3VhcmRlZENhbGxiYWNrLmFwcGx5KFJlYWN0RXJyb3JVdGlscywgYXJndW1lbnRzKTtcbiAgfSxcblxuICAvKipcbiAgICogU2FtZSBhcyBpbnZva2VHdWFyZGVkQ2FsbGJhY2ssIGJ1dCBpbnN0ZWFkIG9mIHJldHVybmluZyBhbiBlcnJvciwgaXQgc3RvcmVzXG4gICAqIGl0IGluIGEgZ2xvYmFsIHNvIGl0IGNhbiBiZSByZXRocm93biBieSBgcmV0aHJvd0NhdWdodEVycm9yYCBsYXRlci5cbiAgICogVE9ETzogU2VlIGlmIF9jYXVnaHRFcnJvciBhbmQgX3JldGhyb3dFcnJvciBjYW4gYmUgdW5pZmllZC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgdGhlIGd1YXJkIHRvIHVzZSBmb3IgbG9nZ2luZyBvciBkZWJ1Z2dpbmdcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlXG4gICAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byB1c2Ugd2hlbiBjYWxsaW5nIHRoZSBmdW5jdGlvblxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3MgQXJndW1lbnRzIGZvciBmdW5jdGlvblxuICAgKi9cbiAgaW52b2tlR3VhcmRlZENhbGxiYWNrQW5kQ2F0Y2hGaXJzdEVycm9yOiBmdW5jdGlvbiAobmFtZSwgZnVuYywgY29udGV4dCwgYSwgYiwgYywgZCwgZSwgZikge1xuICAgIFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoUmVhY3RFcnJvclV0aWxzLmhhc0NhdWdodEVycm9yKCkpIHtcbiAgICAgIHZhciBlcnJvciA9IFJlYWN0RXJyb3JVdGlscy5jbGVhckNhdWdodEVycm9yKCk7XG4gICAgICBpZiAoIVJlYWN0RXJyb3JVdGlscy5faGFzUmV0aHJvd0Vycm9yKSB7XG4gICAgICAgIFJlYWN0RXJyb3JVdGlscy5faGFzUmV0aHJvd0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgUmVhY3RFcnJvclV0aWxzLl9yZXRocm93RXJyb3IgPSBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIER1cmluZyBleGVjdXRpb24gb2YgZ3VhcmRlZCBmdW5jdGlvbnMgd2Ugd2lsbCBjYXB0dXJlIHRoZSBmaXJzdCBlcnJvciB3aGljaFxuICAgKiB3ZSB3aWxsIHJldGhyb3cgdG8gYmUgaGFuZGxlZCBieSB0aGUgdG9wIGxldmVsIGVycm9yIGhhbmRsZXIuXG4gICAqL1xuICByZXRocm93Q2F1Z2h0RXJyb3I6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmV0aHJvd0NhdWdodEVycm9yLmFwcGx5KFJlYWN0RXJyb3JVdGlscywgYXJndW1lbnRzKTtcbiAgfSxcblxuICBoYXNDYXVnaHRFcnJvcjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBSZWFjdEVycm9yVXRpbHMuX2hhc0NhdWdodEVycm9yO1xuICB9LFxuXG4gIGNsZWFyQ2F1Z2h0RXJyb3I6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoUmVhY3RFcnJvclV0aWxzLl9oYXNDYXVnaHRFcnJvcikge1xuICAgICAgdmFyIGVycm9yID0gUmVhY3RFcnJvclV0aWxzLl9jYXVnaHRFcnJvcjtcbiAgICAgIFJlYWN0RXJyb3JVdGlscy5fY2F1Z2h0RXJyb3IgPSBudWxsO1xuICAgICAgUmVhY3RFcnJvclV0aWxzLl9oYXNDYXVnaHRFcnJvciA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdjbGVhckNhdWdodEVycm9yIHdhcyBjYWxsZWQgYnV0IG5vIGVycm9yIHdhcyBjYXB0dXJlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBpbnZva2VHdWFyZGVkQ2FsbGJhY2sgPSBmdW5jdGlvbiAobmFtZSwgZnVuYywgY29udGV4dCwgYSwgYiwgYywgZCwgZSwgZikge1xuICBSZWFjdEVycm9yVXRpbHMuX2hhc0NhdWdodEVycm9yID0gZmFsc2U7XG4gIFJlYWN0RXJyb3JVdGlscy5fY2F1Z2h0RXJyb3IgPSBudWxsO1xuICB2YXIgZnVuY0FyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDMpO1xuICB0cnkge1xuICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgZnVuY0FyZ3MpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIFJlYWN0RXJyb3JVdGlscy5fY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgICBSZWFjdEVycm9yVXRpbHMuX2hhc0NhdWdodEVycm9yID0gdHJ1ZTtcbiAgfVxufTtcblxue1xuICAvLyBJbiBERVYgbW9kZSwgd2Ugc3dhcCBvdXQgaW52b2tlR3VhcmRlZENhbGxiYWNrIGZvciBhIHNwZWNpYWwgdmVyc2lvblxuICAvLyB0aGF0IHBsYXlzIG1vcmUgbmljZWx5IHdpdGggdGhlIGJyb3dzZXIncyBEZXZUb29scy4gVGhlIGlkZWEgaXMgdG8gcHJlc2VydmVcbiAgLy8gXCJQYXVzZSBvbiBleGNlcHRpb25zXCIgYmVoYXZpb3IuIEJlY2F1c2UgUmVhY3Qgd3JhcHMgYWxsIHVzZXItcHJvdmlkZWRcbiAgLy8gZnVuY3Rpb25zIGluIGludm9rZUd1YXJkZWRDYWxsYmFjaywgYW5kIHRoZSBwcm9kdWN0aW9uIHZlcnNpb24gb2ZcbiAgLy8gaW52b2tlR3VhcmRlZENhbGxiYWNrIHVzZXMgYSB0cnktY2F0Y2gsIGFsbCB1c2VyIGV4Y2VwdGlvbnMgYXJlIHRyZWF0ZWRcbiAgLy8gbGlrZSBjYXVnaHQgZXhjZXB0aW9ucywgYW5kIHRoZSBEZXZUb29scyB3b24ndCBwYXVzZSB1bmxlc3MgdGhlIGRldmVsb3BlclxuICAvLyB0YWtlcyB0aGUgZXh0cmEgc3RlcCBvZiBlbmFibGluZyBwYXVzZSBvbiBjYXVnaHQgZXhjZXB0aW9ucy4gVGhpcyBpc1xuICAvLyB1bnRpbnR1aXRpdmUsIHRob3VnaCwgYmVjYXVzZSBldmVuIHRob3VnaCBSZWFjdCBoYXMgY2F1Z2h0IHRoZSBlcnJvciwgZnJvbVxuICAvLyB0aGUgZGV2ZWxvcGVyJ3MgcGVyc3BlY3RpdmUsIHRoZSBlcnJvciBpcyB1bmNhdWdodC5cbiAgLy9cbiAgLy8gVG8gcHJlc2VydmUgdGhlIGV4cGVjdGVkIFwiUGF1c2Ugb24gZXhjZXB0aW9uc1wiIGJlaGF2aW9yLCB3ZSBkb24ndCB1c2UgYVxuICAvLyB0cnktY2F0Y2ggaW4gREVWLiBJbnN0ZWFkLCB3ZSBzeW5jaHJvbm91c2x5IGRpc3BhdGNoIGEgZmFrZSBldmVudCB0byBhIGZha2VcbiAgLy8gRE9NIG5vZGUsIGFuZCBjYWxsIHRoZSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrIGZyb20gaW5zaWRlIGFuIGV2ZW50IGhhbmRsZXJcbiAgLy8gZm9yIHRoYXQgZmFrZSBldmVudC4gSWYgdGhlIGNhbGxiYWNrIHRocm93cywgdGhlIGVycm9yIGlzIFwiY2FwdHVyZWRcIiB1c2luZ1xuICAvLyBhIGdsb2JhbCBldmVudCBoYW5kbGVyLiBCdXQgYmVjYXVzZSB0aGUgZXJyb3IgaGFwcGVucyBpbiBhIGRpZmZlcmVudFxuICAvLyBldmVudCBsb29wIGNvbnRleHQsIGl0IGRvZXMgbm90IGludGVycnVwdCB0aGUgbm9ybWFsIHByb2dyYW0gZmxvdy5cbiAgLy8gRWZmZWN0aXZlbHksIHRoaXMgZ2l2ZXMgdXMgdHJ5LWNhdGNoIGJlaGF2aW9yIHdpdGhvdXQgYWN0dWFsbHkgdXNpbmdcbiAgLy8gdHJ5LWNhdGNoLiBOZWF0IVxuXG4gIC8vIENoZWNrIHRoYXQgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhlIEFQSXMgd2UgbmVlZCB0byBpbXBsZW1lbnQgb3VyIHNwZWNpYWxcbiAgLy8gREVWIHZlcnNpb24gb2YgaW52b2tlR3VhcmRlZENhbGxiYWNrXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRpc3BhdGNoRXZlbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZmFrZU5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdyZWFjdCcpO1xuXG4gICAgdmFyIGludm9rZUd1YXJkZWRDYWxsYmFja0RldiA9IGZ1bmN0aW9uIChuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgICAvLyBLZWVwcyB0cmFjayBvZiB3aGV0aGVyIHRoZSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrIHRocmV3IGFuIGVycm9yLiBXZVxuICAgICAgLy8gc2V0IHRoaXMgdG8gdHJ1ZSBhdCB0aGUgYmVnaW5uaW5nLCB0aGVuIHNldCBpdCB0byBmYWxzZSByaWdodCBhZnRlclxuICAgICAgLy8gY2FsbGluZyB0aGUgZnVuY3Rpb24uIElmIHRoZSBmdW5jdGlvbiBlcnJvcnMsIGBkaWRFcnJvcmAgd2lsbCBuZXZlciBiZVxuICAgICAgLy8gc2V0IHRvIGZhbHNlLiBUaGlzIHN0cmF0ZWd5IHdvcmtzIGV2ZW4gaWYgdGhlIGJyb3dzZXIgaXMgZmxha3kgYW5kXG4gICAgICAvLyBmYWlscyB0byBjYWxsIG91ciBnbG9iYWwgZXJyb3IgaGFuZGxlciwgYmVjYXVzZSBpdCBkb2Vzbid0IHJlbHkgb25cbiAgICAgIC8vIHRoZSBlcnJvciBldmVudCBhdCBhbGwuXG4gICAgICB2YXIgZGlkRXJyb3IgPSB0cnVlO1xuXG4gICAgICAvLyBDcmVhdGUgYW4gZXZlbnQgaGFuZGxlciBmb3Igb3VyIGZha2UgZXZlbnQuIFdlIHdpbGwgc3luY2hyb25vdXNseVxuICAgICAgLy8gZGlzcGF0Y2ggb3VyIGZha2UgZXZlbnQgdXNpbmcgYGRpc3BhdGNoRXZlbnRgLiBJbnNpZGUgdGhlIGhhbmRsZXIsIHdlXG4gICAgICAvLyBjYWxsIHRoZSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrLlxuICAgICAgdmFyIGZ1bmNBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAzKTtcbiAgICAgIGZ1bmN0aW9uIGNhbGxDYWxsYmFjaygpIHtcbiAgICAgICAgLy8gV2UgaW1tZWRpYXRlbHkgcmVtb3ZlIHRoZSBjYWxsYmFjayBmcm9tIGV2ZW50IGxpc3RlbmVycyBzbyB0aGF0XG4gICAgICAgIC8vIG5lc3RlZCBgaW52b2tlR3VhcmRlZENhbGxiYWNrYCBjYWxscyBkbyBub3QgY2xhc2guIE90aGVyd2lzZSwgYVxuICAgICAgICAvLyBuZXN0ZWQgY2FsbCB3b3VsZCB0cmlnZ2VyIHRoZSBmYWtlIGV2ZW50IGhhbmRsZXJzIG9mIGFueSBjYWxsIGhpZ2hlclxuICAgICAgICAvLyBpbiB0aGUgc3RhY2suXG4gICAgICAgIGZha2VOb2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgY2FsbENhbGxiYWNrLCBmYWxzZSk7XG4gICAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgZnVuY0FyZ3MpO1xuICAgICAgICBkaWRFcnJvciA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgYSBnbG9iYWwgZXJyb3IgZXZlbnQgaGFuZGxlci4gV2UgdXNlIHRoaXMgdG8gY2FwdHVyZSB0aGUgdmFsdWVcbiAgICAgIC8vIHRoYXQgd2FzIHRocm93bi4gSXQncyBwb3NzaWJsZSB0aGF0IHRoaXMgZXJyb3IgaGFuZGxlciB3aWxsIGZpcmUgbW9yZVxuICAgICAgLy8gdGhhbiBvbmNlOyBmb3IgZXhhbXBsZSwgaWYgbm9uLVJlYWN0IGNvZGUgYWxzbyBjYWxscyBgZGlzcGF0Y2hFdmVudGBcbiAgICAgIC8vIGFuZCBhIGhhbmRsZXIgZm9yIHRoYXQgZXZlbnQgdGhyb3dzLiBXZSBzaG91bGQgYmUgcmVzaWxpZW50IHRvIG1vc3Qgb2ZcbiAgICAgIC8vIHRob3NlIGNhc2VzLiBFdmVuIGlmIG91ciBlcnJvciBldmVudCBoYW5kbGVyIGZpcmVzIG1vcmUgdGhhbiBvbmNlLCB0aGVcbiAgICAgIC8vIGxhc3QgZXJyb3IgZXZlbnQgaXMgYWx3YXlzIHVzZWQuIElmIHRoZSBjYWxsYmFjayBhY3R1YWxseSBkb2VzIGVycm9yLFxuICAgICAgLy8gd2Uga25vdyB0aGF0IHRoZSBsYXN0IGVycm9yIGV2ZW50IGlzIHRoZSBjb3JyZWN0IG9uZSwgYmVjYXVzZSBpdCdzIG5vdFxuICAgICAgLy8gcG9zc2libGUgZm9yIGFueXRoaW5nIGVsc2UgdG8gaGF2ZSBoYXBwZW5lZCBpbiBiZXR3ZWVuIG91ciBjYWxsYmFja1xuICAgICAgLy8gZXJyb3JpbmcgYW5kIHRoZSBjb2RlIHRoYXQgZm9sbG93cyB0aGUgYGRpc3BhdGNoRXZlbnRgIGNhbGwgYmVsb3cuIElmXG4gICAgICAvLyB0aGUgY2FsbGJhY2sgZG9lc24ndCBlcnJvciwgYnV0IHRoZSBlcnJvciBldmVudCB3YXMgZmlyZWQsIHdlIGtub3cgdG9cbiAgICAgIC8vIGlnbm9yZSBpdCBiZWNhdXNlIGBkaWRFcnJvcmAgd2lsbCBiZSBmYWxzZSwgYXMgZGVzY3JpYmVkIGFib3ZlLlxuICAgICAgdmFyIGVycm9yID0gdm9pZCAwO1xuICAgICAgLy8gVXNlIHRoaXMgdG8gdHJhY2sgd2hldGhlciB0aGUgZXJyb3IgZXZlbnQgaXMgZXZlciBjYWxsZWQuXG4gICAgICB2YXIgZGlkU2V0RXJyb3IgPSBmYWxzZTtcbiAgICAgIHZhciBpc0Nyb3NzT3JpZ2luRXJyb3IgPSBmYWxzZTtcblxuICAgICAgZnVuY3Rpb24gb25FcnJvcihldmVudCkge1xuICAgICAgICBlcnJvciA9IGV2ZW50LmVycm9yO1xuICAgICAgICBkaWRTZXRFcnJvciA9IHRydWU7XG4gICAgICAgIGlmIChlcnJvciA9PT0gbnVsbCAmJiBldmVudC5jb2xubyA9PT0gMCAmJiBldmVudC5saW5lbm8gPT09IDApIHtcbiAgICAgICAgICBpc0Nyb3NzT3JpZ2luRXJyb3IgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSBhIGZha2UgZXZlbnQgdHlwZS5cbiAgICAgIHZhciBldnRUeXBlID0gJ3JlYWN0LScgKyAobmFtZSA/IG5hbWUgOiAnaW52b2tlZ3VhcmRlZGNhbGxiYWNrJyk7XG5cbiAgICAgIC8vIEF0dGFjaCBvdXIgZXZlbnQgaGFuZGxlcnNcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpO1xuICAgICAgZmFrZU5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBjYWxsQ2FsbGJhY2ssIGZhbHNlKTtcblxuICAgICAgLy8gU3luY2hyb25vdXNseSBkaXNwYXRjaCBvdXIgZmFrZSBldmVudC4gSWYgdGhlIHVzZXItcHJvdmlkZWQgZnVuY3Rpb25cbiAgICAgIC8vIGVycm9ycywgaXQgd2lsbCB0cmlnZ2VyIG91ciBnbG9iYWwgZXJyb3IgaGFuZGxlci5cbiAgICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICAgIGV2dC5pbml0RXZlbnQoZXZ0VHlwZSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgIGZha2VOb2RlLmRpc3BhdGNoRXZlbnQoZXZ0KTtcblxuICAgICAgaWYgKGRpZEVycm9yKSB7XG4gICAgICAgIGlmICghZGlkU2V0RXJyb3IpIHtcbiAgICAgICAgICAvLyBUaGUgY2FsbGJhY2sgZXJyb3JlZCwgYnV0IHRoZSBlcnJvciBldmVudCBuZXZlciBmaXJlZC5cbiAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcignQW4gZXJyb3Igd2FzIHRocm93biBpbnNpZGUgb25lIG9mIHlvdXIgY29tcG9uZW50cywgYnV0IFJlYWN0ICcgKyBcImRvZXNuJ3Qga25vdyB3aGF0IGl0IHdhcy4gVGhpcyBpcyBsaWtlbHkgZHVlIHRvIGJyb3dzZXIgXCIgKyAnZmxha2luZXNzLiBSZWFjdCBkb2VzIGl0cyBiZXN0IHRvIHByZXNlcnZlIHRoZSBcIlBhdXNlIG9uICcgKyAnZXhjZXB0aW9uc1wiIGJlaGF2aW9yIG9mIHRoZSBEZXZUb29scywgd2hpY2ggcmVxdWlyZXMgc29tZSAnICsgXCJERVYtbW9kZSBvbmx5IHRyaWNrcy4gSXQncyBwb3NzaWJsZSB0aGF0IHRoZXNlIGRvbid0IHdvcmsgaW4gXCIgKyAneW91ciBicm93c2VyLiBUcnkgdHJpZ2dlcmluZyB0aGUgZXJyb3IgaW4gcHJvZHVjdGlvbiBtb2RlLCAnICsgJ29yIHN3aXRjaGluZyB0byBhIG1vZGVybiBicm93c2VyLiBJZiB5b3Ugc3VzcGVjdCB0aGF0IHRoaXMgaXMgJyArICdhY3R1YWxseSBhbiBpc3N1ZSB3aXRoIFJlYWN0LCBwbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0Nyb3NzT3JpZ2luRXJyb3IpIHtcbiAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihcIkEgY3Jvc3Mtb3JpZ2luIGVycm9yIHdhcyB0aHJvd24uIFJlYWN0IGRvZXNuJ3QgaGF2ZSBhY2Nlc3MgdG8gXCIgKyAndGhlIGFjdHVhbCBlcnJvciBvYmplY3QgaW4gZGV2ZWxvcG1lbnQuICcgKyAnU2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtY3Jvc3NvcmlnaW4tZXJyb3IgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyk7XG4gICAgICAgIH1cbiAgICAgICAgUmVhY3RFcnJvclV0aWxzLl9oYXNDYXVnaHRFcnJvciA9IHRydWU7XG4gICAgICAgIFJlYWN0RXJyb3JVdGlscy5fY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFJlYWN0RXJyb3JVdGlscy5faGFzQ2F1Z2h0RXJyb3IgPSBmYWxzZTtcbiAgICAgICAgUmVhY3RFcnJvclV0aWxzLl9jYXVnaHRFcnJvciA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSBvdXIgZXZlbnQgbGlzdGVuZXJzXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTtcbiAgICB9O1xuXG4gICAgaW52b2tlR3VhcmRlZENhbGxiYWNrID0gaW52b2tlR3VhcmRlZENhbGxiYWNrRGV2O1xuICB9XG59XG5cbnZhciByZXRocm93Q2F1Z2h0RXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChSZWFjdEVycm9yVXRpbHMuX2hhc1JldGhyb3dFcnJvcikge1xuICAgIHZhciBlcnJvciA9IFJlYWN0RXJyb3JVdGlscy5fcmV0aHJvd0Vycm9yO1xuICAgIFJlYWN0RXJyb3JVdGlscy5fcmV0aHJvd0Vycm9yID0gbnVsbDtcbiAgICBSZWFjdEVycm9yVXRpbHMuX2hhc1JldGhyb3dFcnJvciA9IGZhbHNlO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG4vKipcbiAqIEluamVjdGFibGUgb3JkZXJpbmcgb2YgZXZlbnQgcGx1Z2lucy5cbiAqL1xudmFyIGV2ZW50UGx1Z2luT3JkZXIgPSBudWxsO1xuXG4vKipcbiAqIEluamVjdGFibGUgbWFwcGluZyBmcm9tIG5hbWVzIHRvIGV2ZW50IHBsdWdpbiBtb2R1bGVzLlxuICovXG52YXIgbmFtZXNUb1BsdWdpbnMgPSB7fTtcblxuLyoqXG4gKiBSZWNvbXB1dGVzIHRoZSBwbHVnaW4gbGlzdCB1c2luZyB0aGUgaW5qZWN0ZWQgcGx1Z2lucyBhbmQgcGx1Z2luIG9yZGVyaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCkge1xuICBpZiAoIWV2ZW50UGx1Z2luT3JkZXIpIHtcbiAgICAvLyBXYWl0IHVudGlsIGFuIGBldmVudFBsdWdpbk9yZGVyYCBpcyBpbmplY3RlZC5cbiAgICByZXR1cm47XG4gIH1cbiAgZm9yICh2YXIgcGx1Z2luTmFtZSBpbiBuYW1lc1RvUGx1Z2lucykge1xuICAgIHZhciBwbHVnaW5Nb2R1bGUgPSBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXTtcbiAgICB2YXIgcGx1Z2luSW5kZXggPSBldmVudFBsdWdpbk9yZGVyLmluZGV4T2YocGx1Z2luTmFtZSk7XG4gICAgIShwbHVnaW5JbmRleCA+IC0xKSA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgZXZlbnQgcGx1Z2lucyB0aGF0IGRvIG5vdCBleGlzdCBpbiB0aGUgcGx1Z2luIG9yZGVyaW5nLCBgJXNgLicsIHBsdWdpbk5hbWUpIDogdm9pZCAwO1xuICAgIGlmIChwbHVnaW5zW3BsdWdpbkluZGV4XSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgICFwbHVnaW5Nb2R1bGUuZXh0cmFjdEV2ZW50cyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IEV2ZW50IHBsdWdpbnMgbXVzdCBpbXBsZW1lbnQgYW4gYGV4dHJhY3RFdmVudHNgIG1ldGhvZCwgYnV0IGAlc2AgZG9lcyBub3QuJywgcGx1Z2luTmFtZSkgOiB2b2lkIDA7XG4gICAgcGx1Z2luc1twbHVnaW5JbmRleF0gPSBwbHVnaW5Nb2R1bGU7XG4gICAgdmFyIHB1Ymxpc2hlZEV2ZW50cyA9IHBsdWdpbk1vZHVsZS5ldmVudFR5cGVzO1xuICAgIGZvciAodmFyIGV2ZW50TmFtZSBpbiBwdWJsaXNoZWRFdmVudHMpIHtcbiAgICAgICFwdWJsaXNoRXZlbnRGb3JQbHVnaW4ocHVibGlzaGVkRXZlbnRzW2V2ZW50TmFtZV0sIHBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKSA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IEZhaWxlZCB0byBwdWJsaXNoIGV2ZW50IGAlc2AgZm9yIHBsdWdpbiBgJXNgLicsIGV2ZW50TmFtZSwgcGx1Z2luTmFtZSkgOiB2b2lkIDA7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUHVibGlzaGVzIGFuIGV2ZW50IHNvIHRoYXQgaXQgY2FuIGJlIGRpc3BhdGNoZWQgYnkgdGhlIHN1cHBsaWVkIHBsdWdpbi5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgRGlzcGF0Y2ggY29uZmlndXJhdGlvbiBmb3IgdGhlIGV2ZW50LlxuICogQHBhcmFtIHtvYmplY3R9IFBsdWdpbk1vZHVsZSBQbHVnaW4gcHVibGlzaGluZyB0aGUgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCB3YXMgc3VjY2Vzc2Z1bGx5IHB1Ymxpc2hlZC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHB1Ymxpc2hFdmVudEZvclBsdWdpbihkaXNwYXRjaENvbmZpZywgcGx1Z2luTW9kdWxlLCBldmVudE5hbWUpIHtcbiAgISFldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luSHViOiBNb3JlIHRoYW4gb25lIHBsdWdpbiBhdHRlbXB0ZWQgdG8gcHVibGlzaCB0aGUgc2FtZSBldmVudCBuYW1lLCBgJXNgLicsIGV2ZW50TmFtZSkgOiB2b2lkIDA7XG4gIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlnc1tldmVudE5hbWVdID0gZGlzcGF0Y2hDb25maWc7XG5cbiAgdmFyIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzID0gZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM7XG4gIGlmIChwaGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgIGZvciAodmFyIHBoYXNlTmFtZSBpbiBwaGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgICAgaWYgKHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzLmhhc093blByb3BlcnR5KHBoYXNlTmFtZSkpIHtcbiAgICAgICAgdmFyIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWUgPSBwaGFzZWRSZWdpc3RyYXRpb25OYW1lc1twaGFzZU5hbWVdO1xuICAgICAgICBwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZShwaGFzZWRSZWdpc3RyYXRpb25OYW1lLCBwbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICBwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZShkaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lLCBwbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFB1Ymxpc2hlcyBhIHJlZ2lzdHJhdGlvbiBuYW1lIHRoYXQgaXMgdXNlZCB0byBpZGVudGlmeSBkaXNwYXRjaGVkIGV2ZW50cy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBSZWdpc3RyYXRpb24gbmFtZSB0byBhZGQuXG4gKiBAcGFyYW0ge29iamVjdH0gUGx1Z2luTW9kdWxlIFBsdWdpbiBwdWJsaXNoaW5nIHRoZSBldmVudC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lKHJlZ2lzdHJhdGlvbk5hbWUsIHBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKSB7XG4gICEhcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV0gPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpbkh1YjogTW9yZSB0aGFuIG9uZSBwbHVnaW4gYXR0ZW1wdGVkIHRvIHB1Ymxpc2ggdGhlIHNhbWUgcmVnaXN0cmF0aW9uIG5hbWUsIGAlc2AuJywgcmVnaXN0cmF0aW9uTmFtZSkgOiB2b2lkIDA7XG4gIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdID0gcGx1Z2luTW9kdWxlO1xuICByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdID0gcGx1Z2luTW9kdWxlLmV2ZW50VHlwZXNbZXZlbnROYW1lXS5kZXBlbmRlbmNpZXM7XG5cbiAge1xuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IHJlZ2lzdHJhdGlvbk5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzW2xvd2VyQ2FzZWROYW1lXSA9IHJlZ2lzdHJhdGlvbk5hbWU7XG5cbiAgICBpZiAocmVnaXN0cmF0aW9uTmFtZSA9PT0gJ29uRG91YmxlQ2xpY2snKSB7XG4gICAgICBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzLm9uZGJsY2xpY2sgPSByZWdpc3RyYXRpb25OYW1lO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlZ2lzdGVycyBwbHVnaW5zIHNvIHRoYXQgdGhleSBjYW4gZXh0cmFjdCBhbmQgZGlzcGF0Y2ggZXZlbnRzLlxuICpcbiAqIEBzZWUge0V2ZW50UGx1Z2luSHVifVxuICovXG5cbi8qKlxuICogT3JkZXJlZCBsaXN0IG9mIGluamVjdGVkIHBsdWdpbnMuXG4gKi9cbnZhciBwbHVnaW5zID0gW107XG5cbi8qKlxuICogTWFwcGluZyBmcm9tIGV2ZW50IG5hbWUgdG8gZGlzcGF0Y2ggY29uZmlnXG4gKi9cbnZhciBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MgPSB7fTtcblxuLyoqXG4gKiBNYXBwaW5nIGZyb20gcmVnaXN0cmF0aW9uIG5hbWUgdG8gcGx1Z2luIG1vZHVsZVxuICovXG52YXIgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMgPSB7fTtcblxuLyoqXG4gKiBNYXBwaW5nIGZyb20gcmVnaXN0cmF0aW9uIG5hbWUgdG8gZXZlbnQgbmFtZVxuICovXG52YXIgcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyA9IHt9O1xuXG4vKipcbiAqIE1hcHBpbmcgZnJvbSBsb3dlcmNhc2UgcmVnaXN0cmF0aW9uIG5hbWVzIHRvIHRoZSBwcm9wZXJseSBjYXNlZCB2ZXJzaW9uLFxuICogdXNlZCB0byB3YXJuIGluIHRoZSBjYXNlIG9mIG1pc3NpbmcgZXZlbnQgaGFuZGxlcnMuIEF2YWlsYWJsZVxuICogb25seSBpbiB0cnVlLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xudmFyIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMgPSB7fTtcbi8vIFRydXN0IHRoZSBkZXZlbG9wZXIgdG8gb25seSB1c2UgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcyBpbiB0cnVlXG5cbi8qKlxuICogSW5qZWN0cyBhbiBvcmRlcmluZyBvZiBwbHVnaW5zIChieSBwbHVnaW4gbmFtZSkuIFRoaXMgYWxsb3dzIHRoZSBvcmRlcmluZ1xuICogdG8gYmUgZGVjb3VwbGVkIGZyb20gaW5qZWN0aW9uIG9mIHRoZSBhY3R1YWwgcGx1Z2lucyBzbyB0aGF0IG9yZGVyaW5nIGlzXG4gKiBhbHdheXMgZGV0ZXJtaW5pc3RpYyByZWdhcmRsZXNzIG9mIHBhY2thZ2luZywgb24tdGhlLWZseSBpbmplY3Rpb24sIGV0Yy5cbiAqXG4gKiBAcGFyYW0ge2FycmF5fSBJbmplY3RlZEV2ZW50UGx1Z2luT3JkZXJcbiAqIEBpbnRlcm5hbFxuICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLmluamVjdEV2ZW50UGx1Z2luT3JkZXJ9XG4gKi9cbmZ1bmN0aW9uIGluamVjdEV2ZW50UGx1Z2luT3JkZXIoaW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyKSB7XG4gICEhZXZlbnRQbHVnaW5PcmRlciA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgZXZlbnQgcGx1Z2luIG9yZGVyaW5nIG1vcmUgdGhhbiBvbmNlLiBZb3UgYXJlIGxpa2VseSB0cnlpbmcgdG8gbG9hZCBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QuJykgOiB2b2lkIDA7XG4gIC8vIENsb25lIHRoZSBvcmRlcmluZyBzbyBpdCBjYW5ub3QgYmUgZHluYW1pY2FsbHkgbXV0YXRlZC5cbiAgZXZlbnRQbHVnaW5PcmRlciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGluamVjdGVkRXZlbnRQbHVnaW5PcmRlcik7XG4gIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCk7XG59XG5cbi8qKlxuICogSW5qZWN0cyBwbHVnaW5zIHRvIGJlIHVzZWQgYnkgYEV2ZW50UGx1Z2luSHViYC4gVGhlIHBsdWdpbiBuYW1lcyBtdXN0IGJlXG4gKiBpbiB0aGUgb3JkZXJpbmcgaW5qZWN0ZWQgYnkgYGluamVjdEV2ZW50UGx1Z2luT3JkZXJgLlxuICpcbiAqIFBsdWdpbnMgY2FuIGJlIGluamVjdGVkIGFzIHBhcnQgb2YgcGFnZSBpbml0aWFsaXphdGlvbiBvciBvbi10aGUtZmx5LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zIE1hcCBmcm9tIG5hbWVzIHRvIHBsdWdpbiBtb2R1bGVzLlxuICogQGludGVybmFsXG4gKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lfVxuICovXG5mdW5jdGlvbiBpbmplY3RFdmVudFBsdWdpbnNCeU5hbWUoaW5qZWN0ZWROYW1lc1RvUGx1Z2lucykge1xuICB2YXIgaXNPcmRlcmluZ0RpcnR5ID0gZmFsc2U7XG4gIGZvciAodmFyIHBsdWdpbk5hbWUgaW4gaW5qZWN0ZWROYW1lc1RvUGx1Z2lucykge1xuICAgIGlmICghaW5qZWN0ZWROYW1lc1RvUGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShwbHVnaW5OYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBwbHVnaW5Nb2R1bGUgPSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdO1xuICAgIGlmICghbmFtZXNUb1BsdWdpbnMuaGFzT3duUHJvcGVydHkocGx1Z2luTmFtZSkgfHwgbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV0gIT09IHBsdWdpbk1vZHVsZSkge1xuICAgICAgISFuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgdHdvIGRpZmZlcmVudCBldmVudCBwbHVnaW5zIHVzaW5nIHRoZSBzYW1lIG5hbWUsIGAlc2AuJywgcGx1Z2luTmFtZSkgOiB2b2lkIDA7XG4gICAgICBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSA9IHBsdWdpbk1vZHVsZTtcbiAgICAgIGlzT3JkZXJpbmdEaXJ0eSA9IHRydWU7XG4gICAgfVxuICB9XG4gIGlmIChpc09yZGVyaW5nRGlydHkpIHtcbiAgICByZWNvbXB1dGVQbHVnaW5PcmRlcmluZygpO1xuICB9XG59XG5cbnZhciBFdmVudFBsdWdpblJlZ2lzdHJ5ID0gT2JqZWN0LmZyZWV6ZSh7XG5cdHBsdWdpbnM6IHBsdWdpbnMsXG5cdGV2ZW50TmFtZURpc3BhdGNoQ29uZmlnczogZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzLFxuXHRyZWdpc3RyYXRpb25OYW1lTW9kdWxlczogcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMsXG5cdHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXM6IHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMsXG5cdHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXM6IHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMsXG5cdGluamVjdEV2ZW50UGx1Z2luT3JkZXI6IGluamVjdEV2ZW50UGx1Z2luT3JkZXIsXG5cdGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZTogaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lXG59KTtcblxudmFyIGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUgPSBudWxsO1xudmFyIGdldEluc3RhbmNlRnJvbU5vZGUgPSBudWxsO1xudmFyIGdldE5vZGVGcm9tSW5zdGFuY2UgPSBudWxsO1xuXG52YXIgaW5qZWN0aW9uJDIgPSB7XG4gIGluamVjdENvbXBvbmVudFRyZWU6IGZ1bmN0aW9uIChJbmplY3RlZCkge1xuICAgIGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUgPSBJbmplY3RlZC5nZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlO1xuICAgIGdldEluc3RhbmNlRnJvbU5vZGUgPSBJbmplY3RlZC5nZXRJbnN0YW5jZUZyb21Ob2RlO1xuICAgIGdldE5vZGVGcm9tSW5zdGFuY2UgPSBJbmplY3RlZC5nZXROb2RlRnJvbUluc3RhbmNlO1xuXG4gICAge1xuICAgICAgd2FybmluZyhnZXROb2RlRnJvbUluc3RhbmNlICYmIGdldEluc3RhbmNlRnJvbU5vZGUsICdFdmVudFBsdWdpblV0aWxzLmluamVjdGlvbi5pbmplY3RDb21wb25lbnRUcmVlKC4uLik6IEluamVjdGVkICcgKyAnbW9kdWxlIGlzIG1pc3NpbmcgZ2V0Tm9kZUZyb21JbnN0YW5jZSBvciBnZXRJbnN0YW5jZUZyb21Ob2RlLicpO1xuICAgIH1cbiAgfVxufTtcblxuXG5cblxuXG5cbnZhciB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcztcbntcbiAgdmFsaWRhdGVFdmVudERpc3BhdGNoZXMgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgZGlzcGF0Y2hMaXN0ZW5lcnMgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gICAgdmFyIGRpc3BhdGNoSW5zdGFuY2VzID0gZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzO1xuXG4gICAgdmFyIGxpc3RlbmVyc0lzQXJyID0gQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycyk7XG4gICAgdmFyIGxpc3RlbmVyc0xlbiA9IGxpc3RlbmVyc0lzQXJyID8gZGlzcGF0Y2hMaXN0ZW5lcnMubGVuZ3RoIDogZGlzcGF0Y2hMaXN0ZW5lcnMgPyAxIDogMDtcblxuICAgIHZhciBpbnN0YW5jZXNJc0FyciA9IEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hJbnN0YW5jZXMpO1xuICAgIHZhciBpbnN0YW5jZXNMZW4gPSBpbnN0YW5jZXNJc0FyciA/IGRpc3BhdGNoSW5zdGFuY2VzLmxlbmd0aCA6IGRpc3BhdGNoSW5zdGFuY2VzID8gMSA6IDA7XG5cbiAgICB3YXJuaW5nKGluc3RhbmNlc0lzQXJyID09PSBsaXN0ZW5lcnNJc0FyciAmJiBpbnN0YW5jZXNMZW4gPT09IGxpc3RlbmVyc0xlbiwgJ0V2ZW50UGx1Z2luVXRpbHM6IEludmFsaWQgYGV2ZW50YC4nKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBEaXNwYXRjaCB0aGUgZXZlbnQgdG8gdGhlIGxpc3RlbmVyLlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnQgU3ludGhldGljRXZlbnQgdG8gaGFuZGxlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNpbXVsYXRlZCBJZiB0aGUgZXZlbnQgaXMgc2ltdWxhdGVkIChjaGFuZ2VzIGV4biBiZWhhdmlvcilcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIEFwcGxpY2F0aW9uLWxldmVsIGNhbGxiYWNrXG4gKiBAcGFyYW0geyp9IGluc3QgSW50ZXJuYWwgY29tcG9uZW50IGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaChldmVudCwgc2ltdWxhdGVkLCBsaXN0ZW5lciwgaW5zdCkge1xuICB2YXIgdHlwZSA9IGV2ZW50LnR5cGUgfHwgJ3Vua25vd24tZXZlbnQnO1xuICBldmVudC5jdXJyZW50VGFyZ2V0ID0gZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcbiAgUmVhY3RFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFja0FuZENhdGNoRmlyc3RFcnJvcih0eXBlLCBsaXN0ZW5lciwgdW5kZWZpbmVkLCBldmVudCk7XG4gIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBudWxsO1xufVxuXG4vKipcbiAqIFN0YW5kYXJkL3NpbXBsZSBpdGVyYXRpb24gdGhyb3VnaCBhbiBldmVudCdzIGNvbGxlY3RlZCBkaXNwYXRjaGVzLlxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXIoZXZlbnQsIHNpbXVsYXRlZCkge1xuICB2YXIgZGlzcGF0Y2hMaXN0ZW5lcnMgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gIHZhciBkaXNwYXRjaEluc3RhbmNlcyA9IGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcztcbiAge1xuICAgIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzKGV2ZW50KTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycykpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIExpc3RlbmVycyBhbmQgSW5zdGFuY2VzIGFyZSB0d28gcGFyYWxsZWwgYXJyYXlzIHRoYXQgYXJlIGFsd2F5cyBpbiBzeW5jLlxuICAgICAgZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBzaW11bGF0ZWQsIGRpc3BhdGNoTGlzdGVuZXJzW2ldLCBkaXNwYXRjaEluc3RhbmNlc1tpXSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGRpc3BhdGNoTGlzdGVuZXJzKSB7XG4gICAgZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBzaW11bGF0ZWQsIGRpc3BhdGNoTGlzdGVuZXJzLCBkaXNwYXRjaEluc3RhbmNlcyk7XG4gIH1cbiAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gbnVsbDtcbiAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gbnVsbDtcbn1cblxuLyoqXG4gKiBAc2VlIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsXG4gKi9cblxuXG4vKipcbiAqIEV4ZWN1dGlvbiBvZiBhIFwiZGlyZWN0XCIgZGlzcGF0Y2ggLSB0aGVyZSBtdXN0IGJlIGF0IG1vc3Qgb25lIGRpc3BhdGNoXG4gKiBhY2N1bXVsYXRlZCBvbiB0aGUgZXZlbnQgb3IgaXQgaXMgY29uc2lkZXJlZCBhbiBlcnJvci4gSXQgZG9lc24ndCByZWFsbHkgbWFrZVxuICogc2Vuc2UgZm9yIGFuIGV2ZW50IHdpdGggbXVsdGlwbGUgZGlzcGF0Y2hlcyAoYnViYmxlZCkgdG8ga2VlcCB0cmFjayBvZiB0aGVcbiAqIHJldHVybiB2YWx1ZXMgYXQgZWFjaCBkaXNwYXRjaCBleGVjdXRpb24sIGJ1dCBpdCBkb2VzIHRlbmQgdG8gbWFrZSBzZW5zZSB3aGVuXG4gKiBkZWFsaW5nIHdpdGggXCJkaXJlY3RcIiBkaXNwYXRjaGVzLlxuICpcbiAqIEByZXR1cm4geyp9IFRoZSByZXR1cm4gdmFsdWUgb2YgZXhlY3V0aW5nIHRoZSBzaW5nbGUgZGlzcGF0Y2guXG4gKi9cblxuXG4vKipcbiAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmZiBudW1iZXIgb2YgZGlzcGF0Y2hlcyBhY2N1bXVsYXRlZCBpcyBncmVhdGVyIHRoYW4gMC5cbiAqL1xuXG4vKipcbiAqIEFjY3VtdWxhdGVzIGl0ZW1zIHRoYXQgbXVzdCBub3QgYmUgbnVsbCBvciB1bmRlZmluZWQgaW50byB0aGUgZmlyc3Qgb25lLiBUaGlzXG4gKiBpcyB1c2VkIHRvIGNvbnNlcnZlIG1lbW9yeSBieSBhdm9pZGluZyBhcnJheSBhbGxvY2F0aW9ucywgYW5kIHRodXMgc2FjcmlmaWNlc1xuICogQVBJIGNsZWFubmVzcy4gU2luY2UgYGN1cnJlbnRgIGNhbiBiZSBudWxsIGJlZm9yZSBiZWluZyBwYXNzZWQgaW4gYW5kIG5vdFxuICogbnVsbCBhZnRlciB0aGlzIGZ1bmN0aW9uLCBtYWtlIHN1cmUgdG8gYXNzaWduIGl0IGJhY2sgdG8gYGN1cnJlbnRgOlxuICpcbiAqIGBhID0gYWNjdW11bGF0ZUludG8oYSwgYik7YFxuICpcbiAqIFRoaXMgQVBJIHNob3VsZCBiZSBzcGFyaW5nbHkgdXNlZC4gVHJ5IGBhY2N1bXVsYXRlYCBmb3Igc29tZXRoaW5nIGNsZWFuZXIuXG4gKlxuICogQHJldHVybiB7KnxhcnJheTwqPn0gQW4gYWNjdW11bGF0aW9uIG9mIGl0ZW1zLlxuICovXG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVJbnRvKGN1cnJlbnQsIG5leHQpIHtcbiAgIShuZXh0ICE9IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnYWNjdW11bGF0ZUludG8oLi4uKTogQWNjdW11bGF0ZWQgaXRlbXMgbXVzdCBub3QgYmUgbnVsbCBvciB1bmRlZmluZWQuJykgOiB2b2lkIDA7XG5cbiAgaWYgKGN1cnJlbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBuZXh0O1xuICB9XG5cbiAgLy8gQm90aCBhcmUgbm90IGVtcHR5LiBXYXJuaW5nOiBOZXZlciBjYWxsIHguY29uY2F0KHkpIHdoZW4geW91IGFyZSBub3RcbiAgLy8gY2VydGFpbiB0aGF0IHggaXMgYW4gQXJyYXkgKHggY291bGQgYmUgYSBzdHJpbmcgd2l0aCBjb25jYXQgbWV0aG9kKS5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudCkpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShuZXh0KSkge1xuICAgICAgY3VycmVudC5wdXNoLmFwcGx5KGN1cnJlbnQsIG5leHQpO1xuICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfVxuICAgIGN1cnJlbnQucHVzaChuZXh0KTtcbiAgICByZXR1cm4gY3VycmVudDtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KG5leHQpKSB7XG4gICAgLy8gQSBiaXQgdG9vIGRhbmdlcm91cyB0byBtdXRhdGUgYG5leHRgLlxuICAgIHJldHVybiBbY3VycmVudF0uY29uY2F0KG5leHQpO1xuICB9XG5cbiAgcmV0dXJuIFtjdXJyZW50LCBuZXh0XTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FycmF5fSBhcnIgYW4gXCJhY2N1bXVsYXRpb25cIiBvZiBpdGVtcyB3aGljaCBpcyBlaXRoZXIgYW4gQXJyYXkgb3JcbiAqIGEgc2luZ2xlIGl0ZW0uIFVzZWZ1bCB3aGVuIHBhaXJlZCB3aXRoIHRoZSBgYWNjdW11bGF0ZWAgbW9kdWxlLiBUaGlzIGlzIGFcbiAqIHNpbXBsZSB1dGlsaXR5IHRoYXQgYWxsb3dzIHVzIHRvIHJlYXNvbiBhYm91dCBhIGNvbGxlY3Rpb24gb2YgaXRlbXMsIGJ1dFxuICogaGFuZGxpbmcgdGhlIGNhc2Ugd2hlbiB0aGVyZSBpcyBleGFjdGx5IG9uZSBpdGVtIChhbmQgd2UgZG8gbm90IG5lZWQgdG9cbiAqIGFsbG9jYXRlIGFuIGFycmF5KS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNiIENhbGxiYWNrIGludm9rZWQgd2l0aCBlYWNoIGVsZW1lbnQgb3IgYSBjb2xsZWN0aW9uLlxuICogQHBhcmFtIHs/fSBbc2NvcGVdIFNjb3BlIHVzZWQgYXMgYHRoaXNgIGluIGEgY2FsbGJhY2suXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2hBY2N1bXVsYXRlZChhcnIsIGNiLCBzY29wZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgYXJyLmZvckVhY2goY2IsIHNjb3BlKTtcbiAgfSBlbHNlIGlmIChhcnIpIHtcbiAgICBjYi5jYWxsKHNjb3BlLCBhcnIpO1xuICB9XG59XG5cbi8qKlxuICogSW50ZXJuYWwgcXVldWUgb2YgZXZlbnRzIHRoYXQgaGF2ZSBhY2N1bXVsYXRlZCB0aGVpciBkaXNwYXRjaGVzIGFuZCBhcmVcbiAqIHdhaXRpbmcgdG8gaGF2ZSB0aGVpciBkaXNwYXRjaGVzIGV4ZWN1dGVkLlxuICovXG52YXIgZXZlbnRRdWV1ZSA9IG51bGw7XG5cbi8qKlxuICogRGlzcGF0Y2hlcyBhbiBldmVudCBhbmQgcmVsZWFzZXMgaXQgYmFjayBpbnRvIHRoZSBwb29sLCB1bmxlc3MgcGVyc2lzdGVudC5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IGV2ZW50IFN5bnRoZXRpYyBldmVudCB0byBiZSBkaXNwYXRjaGVkLlxuICogQHBhcmFtIHtib29sZWFufSBzaW11bGF0ZWQgSWYgdGhlIGV2ZW50IGlzIHNpbXVsYXRlZCAoY2hhbmdlcyBleG4gYmVoYXZpb3IpXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlID0gZnVuY3Rpb24gKGV2ZW50LCBzaW11bGF0ZWQpIHtcbiAgaWYgKGV2ZW50KSB7XG4gICAgZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyKGV2ZW50LCBzaW11bGF0ZWQpO1xuXG4gICAgaWYgKCFldmVudC5pc1BlcnNpc3RlbnQoKSkge1xuICAgICAgZXZlbnQuY29uc3RydWN0b3IucmVsZWFzZShldmVudCk7XG4gICAgfVxuICB9XG59O1xudmFyIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVNpbXVsYXRlZCA9IGZ1bmN0aW9uIChlKSB7XG4gIHJldHVybiBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UoZSwgdHJ1ZSk7XG59O1xudmFyIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVRvcExldmVsID0gZnVuY3Rpb24gKGUpIHtcbiAgcmV0dXJuIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZShlLCBmYWxzZSk7XG59O1xuXG5mdW5jdGlvbiBpc0ludGVyYWN0aXZlKHRhZykge1xuICByZXR1cm4gdGFnID09PSAnYnV0dG9uJyB8fCB0YWcgPT09ICdpbnB1dCcgfHwgdGFnID09PSAnc2VsZWN0JyB8fCB0YWcgPT09ICd0ZXh0YXJlYSc7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFByZXZlbnRNb3VzZUV2ZW50KG5hbWUsIHR5cGUsIHByb3BzKSB7XG4gIHN3aXRjaCAobmFtZSkge1xuICAgIGNhc2UgJ29uQ2xpY2snOlxuICAgIGNhc2UgJ29uQ2xpY2tDYXB0dXJlJzpcbiAgICBjYXNlICdvbkRvdWJsZUNsaWNrJzpcbiAgICBjYXNlICdvbkRvdWJsZUNsaWNrQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZURvd24nOlxuICAgIGNhc2UgJ29uTW91c2VEb3duQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZU1vdmUnOlxuICAgIGNhc2UgJ29uTW91c2VNb3ZlQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZVVwJzpcbiAgICBjYXNlICdvbk1vdXNlVXBDYXB0dXJlJzpcbiAgICAgIHJldHVybiAhIShwcm9wcy5kaXNhYmxlZCAmJiBpc0ludGVyYWN0aXZlKHR5cGUpKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBpcyBhIHVuaWZpZWQgaW50ZXJmYWNlIGZvciBldmVudCBwbHVnaW5zIHRvIGJlIGluc3RhbGxlZCBhbmQgY29uZmlndXJlZC5cbiAqXG4gKiBFdmVudCBwbHVnaW5zIGNhbiBpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgYGV4dHJhY3RFdmVudHNgIHtmdW5jdGlvbihzdHJpbmcsIERPTUV2ZW50VGFyZ2V0LCBzdHJpbmcsIG9iamVjdCk6ICp9XG4gKiAgICAgUmVxdWlyZWQuIFdoZW4gYSB0b3AtbGV2ZWwgZXZlbnQgaXMgZmlyZWQsIHRoaXMgbWV0aG9kIGlzIGV4cGVjdGVkIHRvXG4gKiAgICAgZXh0cmFjdCBzeW50aGV0aWMgZXZlbnRzIHRoYXQgd2lsbCBpbiB0dXJuIGJlIHF1ZXVlZCBhbmQgZGlzcGF0Y2hlZC5cbiAqXG4gKiAgIGBldmVudFR5cGVzYCB7b2JqZWN0fVxuICogICAgIE9wdGlvbmFsLCBwbHVnaW5zIHRoYXQgZmlyZSBldmVudHMgbXVzdCBwdWJsaXNoIGEgbWFwcGluZyBvZiByZWdpc3RyYXRpb25cbiAqICAgICBuYW1lcyB0aGF0IGFyZSB1c2VkIHRvIHJlZ2lzdGVyIGxpc3RlbmVycy4gVmFsdWVzIG9mIHRoaXMgbWFwcGluZyBtdXN0XG4gKiAgICAgYmUgb2JqZWN0cyB0aGF0IGNvbnRhaW4gYHJlZ2lzdHJhdGlvbk5hbWVgIG9yIGBwaGFzZWRSZWdpc3RyYXRpb25OYW1lc2AuXG4gKlxuICogICBgZXhlY3V0ZURpc3BhdGNoYCB7ZnVuY3Rpb24ob2JqZWN0LCBmdW5jdGlvbiwgc3RyaW5nKX1cbiAqICAgICBPcHRpb25hbCwgYWxsb3dzIHBsdWdpbnMgdG8gb3ZlcnJpZGUgaG93IGFuIGV2ZW50IGdldHMgZGlzcGF0Y2hlZC4gQnlcbiAqICAgICBkZWZhdWx0LCB0aGUgbGlzdGVuZXIgaXMgc2ltcGx5IGludm9rZWQuXG4gKlxuICogRWFjaCBwbHVnaW4gdGhhdCBpcyBpbmplY3RlZCBpbnRvIGBFdmVudHNQbHVnaW5IdWJgIGlzIGltbWVkaWF0ZWx5IG9wZXJhYmxlLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIE1ldGhvZHMgZm9yIGluamVjdGluZyBkZXBlbmRlbmNpZXMuXG4gKi9cbnZhciBpbmplY3Rpb24kMSA9IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7YXJyYXl9IEluamVjdGVkRXZlbnRQbHVnaW5PcmRlclxuICAgKiBAcHVibGljXG4gICAqL1xuICBpbmplY3RFdmVudFBsdWdpbk9yZGVyOiBpbmplY3RFdmVudFBsdWdpbk9yZGVyLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5qZWN0ZWROYW1lc1RvUGx1Z2lucyBNYXAgZnJvbSBuYW1lcyB0byBwbHVnaW4gbW9kdWxlcy5cbiAgICovXG4gIGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZTogaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBpbnN0IFRoZSBpbnN0YW5jZSwgd2hpY2ggaXMgdGhlIHNvdXJjZSBvZiBldmVudHMuXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gKiBAcmV0dXJuIHs/ZnVuY3Rpb259IFRoZSBzdG9yZWQgY2FsbGJhY2suXG4gKi9cbmZ1bmN0aW9uIGdldExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgdmFyIGxpc3RlbmVyO1xuXG4gIC8vIFRPRE86IHNob3VsZFByZXZlbnRNb3VzZUV2ZW50IGlzIERPTS1zcGVjaWZpYyBhbmQgZGVmaW5pdGVseSBzaG91bGQgbm90XG4gIC8vIGxpdmUgaGVyZTsgbmVlZHMgdG8gYmUgbW92ZWQgdG8gYSBiZXR0ZXIgcGxhY2Ugc29vblxuICB2YXIgc3RhdGVOb2RlID0gaW5zdC5zdGF0ZU5vZGU7XG4gIGlmICghc3RhdGVOb2RlKSB7XG4gICAgLy8gV29yayBpbiBwcm9ncmVzcyAoZXg6IG9ubG9hZCBldmVudHMgaW4gaW5jcmVtZW50YWwgbW9kZSkuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHByb3BzID0gZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZShzdGF0ZU5vZGUpO1xuICBpZiAoIXByb3BzKSB7XG4gICAgLy8gV29yayBpbiBwcm9ncmVzcy5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBsaXN0ZW5lciA9IHByb3BzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICBpZiAoc2hvdWxkUHJldmVudE1vdXNlRXZlbnQocmVnaXN0cmF0aW9uTmFtZSwgaW5zdC50eXBlLCBwcm9wcykpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAhKCFsaXN0ZW5lciB8fCB0eXBlb2YgbGlzdGVuZXIgPT09ICdmdW5jdGlvbicpID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgYCVzYCBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLCBpbnN0ZWFkIGdvdCBhIHZhbHVlIG9mIGAlc2AgdHlwZS4nLCByZWdpc3RyYXRpb25OYW1lLCB0eXBlb2YgbGlzdGVuZXIpIDogdm9pZCAwO1xuICByZXR1cm4gbGlzdGVuZXI7XG59XG5cbi8qKlxuICogQWxsb3dzIHJlZ2lzdGVyZWQgcGx1Z2lucyBhbiBvcHBvcnR1bml0eSB0byBleHRyYWN0IGV2ZW50cyBmcm9tIHRvcC1sZXZlbFxuICogbmF0aXZlIGJyb3dzZXIgZXZlbnRzLlxuICpcbiAqIEByZXR1cm4geyp9IEFuIGFjY3VtdWxhdGlvbiBvZiBzeW50aGV0aWMgZXZlbnRzLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RFdmVudHModG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgdmFyIGV2ZW50cztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gTm90IGV2ZXJ5IHBsdWdpbiBpbiB0aGUgb3JkZXJpbmcgbWF5IGJlIGxvYWRlZCBhdCBydW50aW1lLlxuICAgIHZhciBwb3NzaWJsZVBsdWdpbiA9IHBsdWdpbnNbaV07XG4gICAgaWYgKHBvc3NpYmxlUGx1Z2luKSB7XG4gICAgICB2YXIgZXh0cmFjdGVkRXZlbnRzID0gcG9zc2libGVQbHVnaW4uZXh0cmFjdEV2ZW50cyh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgICBpZiAoZXh0cmFjdGVkRXZlbnRzKSB7XG4gICAgICAgIGV2ZW50cyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50cywgZXh0cmFjdGVkRXZlbnRzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGV2ZW50cztcbn1cblxuLyoqXG4gKiBFbnF1ZXVlcyBhIHN5bnRoZXRpYyBldmVudCB0aGF0IHNob3VsZCBiZSBkaXNwYXRjaGVkIHdoZW5cbiAqIGBwcm9jZXNzRXZlbnRRdWV1ZWAgaXMgaW52b2tlZC5cbiAqXG4gKiBAcGFyYW0geyp9IGV2ZW50cyBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBlbnF1ZXVlRXZlbnRzKGV2ZW50cykge1xuICBpZiAoZXZlbnRzKSB7XG4gICAgZXZlbnRRdWV1ZSA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50UXVldWUsIGV2ZW50cyk7XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNwYXRjaGVzIGFsbCBzeW50aGV0aWMgZXZlbnRzIG9uIHRoZSBldmVudCBxdWV1ZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gcHJvY2Vzc0V2ZW50UXVldWUoc2ltdWxhdGVkKSB7XG4gIC8vIFNldCBgZXZlbnRRdWV1ZWAgdG8gbnVsbCBiZWZvcmUgcHJvY2Vzc2luZyBpdCBzbyB0aGF0IHdlIGNhbiB0ZWxsIGlmIG1vcmVcbiAgLy8gZXZlbnRzIGdldCBlbnF1ZXVlZCB3aGlsZSBwcm9jZXNzaW5nLlxuICB2YXIgcHJvY2Vzc2luZ0V2ZW50UXVldWUgPSBldmVudFF1ZXVlO1xuICBldmVudFF1ZXVlID0gbnVsbDtcblxuICBpZiAoIXByb2Nlc3NpbmdFdmVudFF1ZXVlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHNpbXVsYXRlZCkge1xuICAgIGZvckVhY2hBY2N1bXVsYXRlZChwcm9jZXNzaW5nRXZlbnRRdWV1ZSwgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlU2ltdWxhdGVkKTtcbiAgfSBlbHNlIHtcbiAgICBmb3JFYWNoQWNjdW11bGF0ZWQocHJvY2Vzc2luZ0V2ZW50UXVldWUsIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVRvcExldmVsKTtcbiAgfVxuICAhIWV2ZW50UXVldWUgPyBpbnZhcmlhbnQoZmFsc2UsICdwcm9jZXNzRXZlbnRRdWV1ZSgpOiBBZGRpdGlvbmFsIGV2ZW50cyB3ZXJlIGVucXVldWVkIHdoaWxlIHByb2Nlc3NpbmcgYW4gZXZlbnQgcXVldWUuIFN1cHBvcnQgZm9yIHRoaXMgaGFzIG5vdCB5ZXQgYmVlbiBpbXBsZW1lbnRlZC4nKSA6IHZvaWQgMDtcbiAgLy8gVGhpcyB3b3VsZCBiZSBhIGdvb2QgdGltZSB0byByZXRocm93IGlmIGFueSBvZiB0aGUgZXZlbnQgaGFuZGxlcnMgdGhyZXcuXG4gIFJlYWN0RXJyb3JVdGlscy5yZXRocm93Q2F1Z2h0RXJyb3IoKTtcbn1cblxudmFyIEV2ZW50UGx1Z2luSHViID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGluamVjdGlvbjogaW5qZWN0aW9uJDEsXG5cdGdldExpc3RlbmVyOiBnZXRMaXN0ZW5lcixcblx0ZXh0cmFjdEV2ZW50czogZXh0cmFjdEV2ZW50cyxcblx0ZW5xdWV1ZUV2ZW50czogZW5xdWV1ZUV2ZW50cyxcblx0cHJvY2Vzc0V2ZW50UXVldWU6IHByb2Nlc3NFdmVudFF1ZXVlXG59KTtcblxudmFyIEluZGV0ZXJtaW5hdGVDb21wb25lbnQgPSAwOyAvLyBCZWZvcmUgd2Uga25vdyB3aGV0aGVyIGl0IGlzIGZ1bmN0aW9uYWwgb3IgY2xhc3NcbnZhciBGdW5jdGlvbmFsQ29tcG9uZW50ID0gMTtcbnZhciBDbGFzc0NvbXBvbmVudCA9IDI7XG52YXIgSG9zdFJvb3QgPSAzOyAvLyBSb290IG9mIGEgaG9zdCB0cmVlLiBDb3VsZCBiZSBuZXN0ZWQgaW5zaWRlIGFub3RoZXIgbm9kZS5cbnZhciBIb3N0UG9ydGFsID0gNDsgLy8gQSBzdWJ0cmVlLiBDb3VsZCBiZSBhbiBlbnRyeSBwb2ludCB0byBhIGRpZmZlcmVudCByZW5kZXJlci5cbnZhciBIb3N0Q29tcG9uZW50ID0gNTtcbnZhciBIb3N0VGV4dCA9IDY7XG52YXIgQ2FsbENvbXBvbmVudCA9IDc7XG52YXIgQ2FsbEhhbmRsZXJQaGFzZSA9IDg7XG52YXIgUmV0dXJuQ29tcG9uZW50ID0gOTtcbnZhciBGcmFnbWVudCA9IDEwO1xuXG52YXIgcmFuZG9tS2V5ID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG52YXIgaW50ZXJuYWxJbnN0YW5jZUtleSA9ICdfX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSQnICsgcmFuZG9tS2V5O1xudmFyIGludGVybmFsRXZlbnRIYW5kbGVyc0tleSA9ICdfX3JlYWN0RXZlbnRIYW5kbGVycyQnICsgcmFuZG9tS2V5O1xuXG5mdW5jdGlvbiBwcmVjYWNoZUZpYmVyTm9kZSQxKGhvc3RJbnN0LCBub2RlKSB7XG4gIG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0gPSBob3N0SW5zdDtcbn1cblxuLyoqXG4gKiBHaXZlbiBhIERPTSBub2RlLCByZXR1cm4gdGhlIGNsb3Nlc3QgUmVhY3RET01Db21wb25lbnQgb3JcbiAqIFJlYWN0RE9NVGV4dENvbXBvbmVudCBpbnN0YW5jZSBhbmNlc3Rvci5cbiAqL1xuZnVuY3Rpb24gZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUobm9kZSkge1xuICBpZiAobm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSkge1xuICAgIHJldHVybiBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldO1xuICB9XG5cbiAgLy8gV2FsayB1cCB0aGUgdHJlZSB1bnRpbCB3ZSBmaW5kIGFuIGFuY2VzdG9yIHdob3NlIGluc3RhbmNlIHdlIGhhdmUgY2FjaGVkLlxuICB2YXIgcGFyZW50cyA9IFtdO1xuICB3aGlsZSAoIW5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0pIHtcbiAgICBwYXJlbnRzLnB1c2gobm9kZSk7XG4gICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVG9wIG9mIHRoZSB0cmVlLiBUaGlzIG5vZGUgbXVzdCBub3QgYmUgcGFydCBvZiBhIFJlYWN0IHRyZWUgKG9yIGlzXG4gICAgICAvLyB1bm1vdW50ZWQsIHBvdGVudGlhbGx5KS5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjbG9zZXN0ID0gdm9pZCAwO1xuICB2YXIgaW5zdCA9IG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV07XG4gIGlmIChpbnN0LnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBpbnN0LnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAvLyBJbiBGaWJlciwgdGhpcyB3aWxsIGFsd2F5cyBiZSB0aGUgZGVlcGVzdCByb290LlxuICAgIHJldHVybiBpbnN0O1xuICB9XG4gIGZvciAoOyBub2RlICYmIChpbnN0ID0gbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSk7IG5vZGUgPSBwYXJlbnRzLnBvcCgpKSB7XG4gICAgY2xvc2VzdCA9IGluc3Q7XG4gIH1cblxuICByZXR1cm4gY2xvc2VzdDtcbn1cblxuLyoqXG4gKiBHaXZlbiBhIERPTSBub2RlLCByZXR1cm4gdGhlIFJlYWN0RE9NQ29tcG9uZW50IG9yIFJlYWN0RE9NVGV4dENvbXBvbmVudFxuICogaW5zdGFuY2UsIG9yIG51bGwgaWYgdGhlIG5vZGUgd2FzIG5vdCByZW5kZXJlZCBieSB0aGlzIFJlYWN0LlxuICovXG5mdW5jdGlvbiBnZXRJbnN0YW5jZUZyb21Ob2RlJDEobm9kZSkge1xuICB2YXIgaW5zdCA9IG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV07XG4gIGlmIChpbnN0KSB7XG4gICAgaWYgKGluc3QudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IGluc3QudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgcmV0dXJuIGluc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBHaXZlbiBhIFJlYWN0RE9NQ29tcG9uZW50IG9yIFJlYWN0RE9NVGV4dENvbXBvbmVudCwgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nXG4gKiBET00gbm9kZS5cbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZUZyb21JbnN0YW5jZSQxKGluc3QpIHtcbiAgaWYgKGluc3QudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IGluc3QudGFnID09PSBIb3N0VGV4dCkge1xuICAgIC8vIEluIEZpYmVyIHRoaXMsIGlzIGp1c3QgdGhlIHN0YXRlIG5vZGUgcmlnaHQgbm93LiBXZSBhc3N1bWUgaXQgd2lsbCBiZVxuICAgIC8vIGEgaG9zdCBjb21wb25lbnQgb3IgaG9zdCB0ZXh0LlxuICAgIHJldHVybiBpbnN0LnN0YXRlTm9kZTtcbiAgfVxuXG4gIC8vIFdpdGhvdXQgdGhpcyBmaXJzdCBpbnZhcmlhbnQsIHBhc3NpbmcgYSBub24tRE9NLWNvbXBvbmVudCB0cmlnZ2VycyB0aGUgbmV4dFxuICAvLyBpbnZhcmlhbnQgZm9yIGEgbWlzc2luZyBwYXJlbnQsIHdoaWNoIGlzIHN1cGVyIGNvbmZ1c2luZy5cbiAgaW52YXJpYW50KGZhbHNlLCAnZ2V0Tm9kZUZyb21JbnN0YW5jZTogSW52YWxpZCBhcmd1bWVudC4nKTtcbn1cblxuZnVuY3Rpb24gZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZSQxKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGVbaW50ZXJuYWxFdmVudEhhbmRsZXJzS2V5XSB8fCBudWxsO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVGaWJlclByb3BzJDEobm9kZSwgcHJvcHMpIHtcbiAgbm9kZVtpbnRlcm5hbEV2ZW50SGFuZGxlcnNLZXldID0gcHJvcHM7XG59XG5cbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSBPYmplY3QuZnJlZXplKHtcblx0cHJlY2FjaGVGaWJlck5vZGU6IHByZWNhY2hlRmliZXJOb2RlJDEsXG5cdGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlOiBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZSxcblx0Z2V0SW5zdGFuY2VGcm9tTm9kZTogZ2V0SW5zdGFuY2VGcm9tTm9kZSQxLFxuXHRnZXROb2RlRnJvbUluc3RhbmNlOiBnZXROb2RlRnJvbUluc3RhbmNlJDEsXG5cdGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGU6IGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUkMSxcblx0dXBkYXRlRmliZXJQcm9wczogdXBkYXRlRmliZXJQcm9wcyQxXG59KTtcblxuZnVuY3Rpb24gZ2V0UGFyZW50KGluc3QpIHtcbiAgZG8ge1xuICAgIGluc3QgPSBpbnN0WydyZXR1cm4nXTtcbiAgICAvLyBUT0RPOiBJZiB0aGlzIGlzIGEgSG9zdFJvb3Qgd2UgbWlnaHQgd2FudCB0byBiYWlsIG91dC5cbiAgICAvLyBUaGF0IGlzIGRlcGVuZGluZyBvbiBpZiB3ZSB3YW50IG5lc3RlZCBzdWJ0cmVlcyAobGF5ZXJzKSB0byBidWJibGVcbiAgICAvLyBldmVudHMgdG8gdGhlaXIgcGFyZW50LiBXZSBjb3VsZCBhbHNvIGdvIHRocm91Z2ggcGFyZW50Tm9kZSBvbiB0aGVcbiAgICAvLyBob3N0IG5vZGUgYnV0IHRoYXQgd291bGRuJ3Qgd29yayBmb3IgUmVhY3QgTmF0aXZlIGFuZCBkb2Vzbid0IGxldCB1c1xuICAgIC8vIGRvIHRoZSBwb3J0YWwgZmVhdHVyZS5cbiAgfSB3aGlsZSAoaW5zdCAmJiBpbnN0LnRhZyAhPT0gSG9zdENvbXBvbmVudCk7XG4gIGlmIChpbnN0KSB7XG4gICAgcmV0dXJuIGluc3Q7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBsb3dlc3QgY29tbW9uIGFuY2VzdG9yIG9mIEEgYW5kIEIsIG9yIG51bGwgaWYgdGhleSBhcmUgaW5cbiAqIGRpZmZlcmVudCB0cmVlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IoaW5zdEEsIGluc3RCKSB7XG4gIHZhciBkZXB0aEEgPSAwO1xuICBmb3IgKHZhciB0ZW1wQSA9IGluc3RBOyB0ZW1wQTsgdGVtcEEgPSBnZXRQYXJlbnQodGVtcEEpKSB7XG4gICAgZGVwdGhBKys7XG4gIH1cbiAgdmFyIGRlcHRoQiA9IDA7XG4gIGZvciAodmFyIHRlbXBCID0gaW5zdEI7IHRlbXBCOyB0ZW1wQiA9IGdldFBhcmVudCh0ZW1wQikpIHtcbiAgICBkZXB0aEIrKztcbiAgfVxuXG4gIC8vIElmIEEgaXMgZGVlcGVyLCBjcmF3bCB1cC5cbiAgd2hpbGUgKGRlcHRoQSAtIGRlcHRoQiA+IDApIHtcbiAgICBpbnN0QSA9IGdldFBhcmVudChpbnN0QSk7XG4gICAgZGVwdGhBLS07XG4gIH1cblxuICAvLyBJZiBCIGlzIGRlZXBlciwgY3Jhd2wgdXAuXG4gIHdoaWxlIChkZXB0aEIgLSBkZXB0aEEgPiAwKSB7XG4gICAgaW5zdEIgPSBnZXRQYXJlbnQoaW5zdEIpO1xuICAgIGRlcHRoQi0tO1xuICB9XG5cbiAgLy8gV2FsayBpbiBsb2Nrc3RlcCB1bnRpbCB3ZSBmaW5kIGEgbWF0Y2guXG4gIHZhciBkZXB0aCA9IGRlcHRoQTtcbiAgd2hpbGUgKGRlcHRoLS0pIHtcbiAgICBpZiAoaW5zdEEgPT09IGluc3RCIHx8IGluc3RBID09PSBpbnN0Qi5hbHRlcm5hdGUpIHtcbiAgICAgIHJldHVybiBpbnN0QTtcbiAgICB9XG4gICAgaW5zdEEgPSBnZXRQYXJlbnQoaW5zdEEpO1xuICAgIGluc3RCID0gZ2V0UGFyZW50KGluc3RCKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gaWYgQSBpcyBhbiBhbmNlc3RvciBvZiBCLlxuICovXG5cblxuLyoqXG4gKiBSZXR1cm4gdGhlIHBhcmVudCBpbnN0YW5jZSBvZiB0aGUgcGFzc2VkLWluIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBnZXRQYXJlbnRJbnN0YW5jZShpbnN0KSB7XG4gIHJldHVybiBnZXRQYXJlbnQoaW5zdCk7XG59XG5cbi8qKlxuICogU2ltdWxhdGVzIHRoZSB0cmF2ZXJzYWwgb2YgYSB0d28tcGhhc2UsIGNhcHR1cmUvYnViYmxlIGV2ZW50IGRpc3BhdGNoLlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZVR3b1BoYXNlKGluc3QsIGZuLCBhcmcpIHtcbiAgdmFyIHBhdGggPSBbXTtcbiAgd2hpbGUgKGluc3QpIHtcbiAgICBwYXRoLnB1c2goaW5zdCk7XG4gICAgaW5zdCA9IGdldFBhcmVudChpbnN0KTtcbiAgfVxuICB2YXIgaTtcbiAgZm9yIChpID0gcGF0aC5sZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgZm4ocGF0aFtpXSwgJ2NhcHR1cmVkJywgYXJnKTtcbiAgfVxuICBmb3IgKGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgIGZuKHBhdGhbaV0sICdidWJibGVkJywgYXJnKTtcbiAgfVxufVxuXG4vKipcbiAqIFRyYXZlcnNlcyB0aGUgSUQgaGllcmFyY2h5IGFuZCBpbnZva2VzIHRoZSBzdXBwbGllZCBgY2JgIG9uIGFueSBJRHMgdGhhdFxuICogc2hvdWxkIHdvdWxkIHJlY2VpdmUgYSBgbW91c2VFbnRlcmAgb3IgYG1vdXNlTGVhdmVgIGV2ZW50LlxuICpcbiAqIERvZXMgbm90IGludm9rZSB0aGUgY2FsbGJhY2sgb24gdGhlIG5lYXJlc3QgY29tbW9uIGFuY2VzdG9yIGJlY2F1c2Ugbm90aGluZ1xuICogXCJlbnRlcmVkXCIgb3IgXCJsZWZ0XCIgdGhhdCBlbGVtZW50LlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZUVudGVyTGVhdmUoZnJvbSwgdG8sIGZuLCBhcmdGcm9tLCBhcmdUbykge1xuICB2YXIgY29tbW9uID0gZnJvbSAmJiB0byA/IGdldExvd2VzdENvbW1vbkFuY2VzdG9yKGZyb20sIHRvKSA6IG51bGw7XG4gIHZhciBwYXRoRnJvbSA9IFtdO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmICghZnJvbSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChmcm9tID09PSBjb21tb24pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2YXIgYWx0ZXJuYXRlID0gZnJvbS5hbHRlcm5hdGU7XG4gICAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCAmJiBhbHRlcm5hdGUgPT09IGNvbW1vbikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHBhdGhGcm9tLnB1c2goZnJvbSk7XG4gICAgZnJvbSA9IGdldFBhcmVudChmcm9tKTtcbiAgfVxuICB2YXIgcGF0aFRvID0gW107XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKCF0bykge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICh0byA9PT0gY29tbW9uKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdmFyIF9hbHRlcm5hdGUgPSB0by5hbHRlcm5hdGU7XG4gICAgaWYgKF9hbHRlcm5hdGUgIT09IG51bGwgJiYgX2FsdGVybmF0ZSA9PT0gY29tbW9uKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcGF0aFRvLnB1c2godG8pO1xuICAgIHRvID0gZ2V0UGFyZW50KHRvKTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhGcm9tLmxlbmd0aDsgaSsrKSB7XG4gICAgZm4ocGF0aEZyb21baV0sICdidWJibGVkJywgYXJnRnJvbSk7XG4gIH1cbiAgZm9yICh2YXIgX2kgPSBwYXRoVG8ubGVuZ3RoOyBfaS0tID4gMDspIHtcbiAgICBmbihwYXRoVG9bX2ldLCAnY2FwdHVyZWQnLCBhcmdUbyk7XG4gIH1cbn1cblxuLyoqXG4gKiBTb21lIGV2ZW50IHR5cGVzIGhhdmUgYSBub3Rpb24gb2YgZGlmZmVyZW50IHJlZ2lzdHJhdGlvbiBuYW1lcyBmb3IgZGlmZmVyZW50XG4gKiBcInBoYXNlc1wiIG9mIHByb3BhZ2F0aW9uLiBUaGlzIGZpbmRzIGxpc3RlbmVycyBieSBhIGdpdmVuIHBoYXNlLlxuICovXG5mdW5jdGlvbiBsaXN0ZW5lckF0UGhhc2UoaW5zdCwgZXZlbnQsIHByb3BhZ2F0aW9uUGhhc2UpIHtcbiAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBldmVudC5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lc1twcm9wYWdhdGlvblBoYXNlXTtcbiAgcmV0dXJuIGdldExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpO1xufVxuXG4vKipcbiAqIEEgc21hbGwgc2V0IG9mIHByb3BhZ2F0aW9uIHBhdHRlcm5zLCBlYWNoIG9mIHdoaWNoIHdpbGwgYWNjZXB0IGEgc21hbGwgYW1vdW50XG4gKiBvZiBpbmZvcm1hdGlvbiwgYW5kIGdlbmVyYXRlIGEgc2V0IG9mIFwiZGlzcGF0Y2ggcmVhZHkgZXZlbnQgb2JqZWN0c1wiIC0gd2hpY2hcbiAqIGFyZSBzZXRzIG9mIGV2ZW50cyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIGFubm90YXRlZCB3aXRoIGEgc2V0IG9mIGRpc3BhdGNoZWRcbiAqIGxpc3RlbmVyIGZ1bmN0aW9ucy9pZHMuIFRoZSBBUEkgaXMgZGVzaWduZWQgdGhpcyB3YXkgdG8gZGlzY291cmFnZSB0aGVzZVxuICogcHJvcGFnYXRpb24gc3RyYXRlZ2llcyBmcm9tIGFjdHVhbGx5IGV4ZWN1dGluZyB0aGUgZGlzcGF0Y2hlcywgc2luY2Ugd2VcbiAqIGFsd2F5cyB3YW50IHRvIGNvbGxlY3QgdGhlIGVudGlyZSBzZXQgb2YgZGlzcGF0Y2hlcyBiZWZvcmUgZXhlY3V0aW5nIGV2ZW4gYVxuICogc2luZ2xlIG9uZS5cbiAqL1xuXG4vKipcbiAqIFRhZ3MgYSBgU3ludGhldGljRXZlbnRgIHdpdGggZGlzcGF0Y2hlZCBsaXN0ZW5lcnMuIENyZWF0aW5nIHRoaXMgZnVuY3Rpb25cbiAqIGhlcmUsIGFsbG93cyB1cyB0byBub3QgaGF2ZSB0byBiaW5kIG9yIGNyZWF0ZSBmdW5jdGlvbnMgZm9yIGVhY2ggZXZlbnQuXG4gKiBNdXRhdGluZyB0aGUgZXZlbnQncyBtZW1iZXJzIGFsbG93cyB1cyB0byBub3QgaGF2ZSB0byBjcmVhdGUgYSB3cmFwcGluZ1xuICogXCJkaXNwYXRjaFwiIG9iamVjdCB0aGF0IHBhaXJzIHRoZSBldmVudCB3aXRoIHRoZSBsaXN0ZW5lci5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcyhpbnN0LCBwaGFzZSwgZXZlbnQpIHtcbiAge1xuICAgIHdhcm5pbmcoaW5zdCwgJ0Rpc3BhdGNoaW5nIGluc3QgbXVzdCBub3QgYmUgbnVsbCcpO1xuICB9XG4gIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyQXRQaGFzZShpbnN0LCBldmVudCwgcGhhc2UpO1xuICBpZiAobGlzdGVuZXIpIHtcbiAgICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMsIGxpc3RlbmVyKTtcbiAgICBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMsIGluc3QpO1xuICB9XG59XG5cbi8qKlxuICogQ29sbGVjdCBkaXNwYXRjaGVzIChtdXN0IGJlIGVudGlyZWx5IGNvbGxlY3RlZCBiZWZvcmUgZGlzcGF0Y2hpbmcgLSBzZWUgdW5pdFxuICogdGVzdHMpLiBMYXppbHkgYWxsb2NhdGUgdGhlIGFycmF5IHRvIGNvbnNlcnZlIG1lbW9yeS4gIFdlIG11c3QgbG9vcCB0aHJvdWdoXG4gKiBlYWNoIGV2ZW50IGFuZCBwZXJmb3JtIHRoZSB0cmF2ZXJzYWwgZm9yIGVhY2ggb25lLiBXZSBjYW5ub3QgcGVyZm9ybSBhXG4gKiBzaW5nbGUgdHJhdmVyc2FsIGZvciB0aGUgZW50aXJlIGNvbGxlY3Rpb24gb2YgZXZlbnRzIGJlY2F1c2UgZWFjaCBldmVudCBtYXlcbiAqIGhhdmUgYSBkaWZmZXJlbnQgdGFyZ2V0LlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlKGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgIHRyYXZlcnNlVHdvUGhhc2UoZXZlbnQuX3RhcmdldEluc3QsIGFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMsIGV2ZW50KTtcbiAgfVxufVxuXG4vKipcbiAqIFNhbWUgYXMgYGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVgLCBidXQgc2tpcHMgb3ZlciB0aGUgdGFyZ2V0SUQuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVTa2lwVGFyZ2V0KGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgIHZhciB0YXJnZXRJbnN0ID0gZXZlbnQuX3RhcmdldEluc3Q7XG4gICAgdmFyIHBhcmVudEluc3QgPSB0YXJnZXRJbnN0ID8gZ2V0UGFyZW50SW5zdGFuY2UodGFyZ2V0SW5zdCkgOiBudWxsO1xuICAgIHRyYXZlcnNlVHdvUGhhc2UocGFyZW50SW5zdCwgYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcywgZXZlbnQpO1xuICB9XG59XG5cbi8qKlxuICogQWNjdW11bGF0ZXMgd2l0aG91dCByZWdhcmQgdG8gZGlyZWN0aW9uLCBkb2VzIG5vdCBsb29rIGZvciBwaGFzZWRcbiAqIHJlZ2lzdHJhdGlvbiBuYW1lcy4gU2FtZSBhcyBgYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGVgIGJ1dCB3aXRob3V0XG4gKiByZXF1aXJpbmcgdGhhdCB0aGUgYGRpc3BhdGNoTWFya2VyYCBiZSB0aGUgc2FtZSBhcyB0aGUgZGlzcGF0Y2hlZCBJRC5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZURpc3BhdGNoZXMoaW5zdCwgaWdub3JlZERpcmVjdGlvbiwgZXZlbnQpIHtcbiAgaWYgKGluc3QgJiYgZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIHZhciByZWdpc3RyYXRpb25OYW1lID0gZXZlbnQuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZTtcbiAgICB2YXIgbGlzdGVuZXIgPSBnZXRMaXN0ZW5lcihpbnN0LCByZWdpc3RyYXRpb25OYW1lKTtcbiAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycywgbGlzdGVuZXIpO1xuICAgICAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzLCBpbnN0KTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBY2N1bXVsYXRlcyBkaXNwYXRjaGVzIG9uIGFuIGBTeW50aGV0aWNFdmVudGAsIGJ1dCBvbmx5IGZvciB0aGVcbiAqIGBkaXNwYXRjaE1hcmtlcmAuXG4gKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudFxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZShldmVudCkge1xuICBpZiAoZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIGFjY3VtdWxhdGVEaXNwYXRjaGVzKGV2ZW50Ll90YXJnZXRJbnN0LCBudWxsLCBldmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudHMpIHtcbiAgZm9yRWFjaEFjY3VtdWxhdGVkKGV2ZW50cywgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZSk7XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0KGV2ZW50cykge1xuICBmb3JFYWNoQWNjdW11bGF0ZWQoZXZlbnRzLCBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlU2tpcFRhcmdldCk7XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlcyhsZWF2ZSwgZW50ZXIsIGZyb20sIHRvKSB7XG4gIHRyYXZlcnNlRW50ZXJMZWF2ZShmcm9tLCB0bywgYWNjdW11bGF0ZURpc3BhdGNoZXMsIGxlYXZlLCBlbnRlcik7XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzKGV2ZW50cykge1xuICBmb3JFYWNoQWNjdW11bGF0ZWQoZXZlbnRzLCBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZSk7XG59XG5cbnZhciBFdmVudFByb3BhZ2F0b3JzID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXM6IGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMsXG5cdGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0OiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2tpcFRhcmdldCxcblx0YWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzOiBhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXMsXG5cdGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzOiBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1xufSk7XG5cbnZhciBjb250ZW50S2V5ID0gbnVsbDtcblxuLyoqXG4gKiBHZXRzIHRoZSBrZXkgdXNlZCB0byBhY2Nlc3MgdGV4dCBjb250ZW50IG9uIGEgRE9NIG5vZGUuXG4gKlxuICogQHJldHVybiB7P3N0cmluZ30gS2V5IHVzZWQgdG8gYWNjZXNzIHRleHQgY29udGVudC5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBnZXRUZXh0Q29udGVudEFjY2Vzc29yKCkge1xuICBpZiAoIWNvbnRlbnRLZXkgJiYgRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gICAgLy8gUHJlZmVyIHRleHRDb250ZW50IHRvIGlubmVyVGV4dCBiZWNhdXNlIG1hbnkgYnJvd3NlcnMgc3VwcG9ydCBib3RoIGJ1dFxuICAgIC8vIFNWRyA8dGV4dD4gZWxlbWVudHMgZG9uJ3Qgc3VwcG9ydCBpbm5lclRleHQgZXZlbiB3aGVuIDxkaXY+IGRvZXMuXG4gICAgY29udGVudEtleSA9ICd0ZXh0Q29udGVudCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ID8gJ3RleHRDb250ZW50JyA6ICdpbm5lclRleHQnO1xuICB9XG4gIHJldHVybiBjb250ZW50S2V5O1xufVxuXG4vKipcbiAqIFRoaXMgaGVscGVyIG9iamVjdCBzdG9yZXMgaW5mb3JtYXRpb24gYWJvdXQgdGV4dCBjb250ZW50IG9mIGEgdGFyZ2V0IG5vZGUsXG4gKiBhbGxvd2luZyBjb21wYXJpc29uIG9mIGNvbnRlbnQgYmVmb3JlIGFuZCBhZnRlciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIElkZW50aWZ5IHRoZSBub2RlIHdoZXJlIHNlbGVjdGlvbiBjdXJyZW50bHkgYmVnaW5zLCB0aGVuIG9ic2VydmVcbiAqIGJvdGggaXRzIHRleHQgY29udGVudCBhbmQgaXRzIGN1cnJlbnQgcG9zaXRpb24gaW4gdGhlIERPTS4gU2luY2UgdGhlXG4gKiBicm93c2VyIG1heSBuYXRpdmVseSByZXBsYWNlIHRoZSB0YXJnZXQgbm9kZSBkdXJpbmcgY29tcG9zaXRpb24sIHdlIGNhblxuICogdXNlIGl0cyBwb3NpdGlvbiB0byBmaW5kIGl0cyByZXBsYWNlbWVudC5cbiAqXG4gKlxuICovXG52YXIgY29tcG9zaXRpb25TdGF0ZSA9IHtcbiAgX3Jvb3Q6IG51bGwsXG4gIF9zdGFydFRleHQ6IG51bGwsXG4gIF9mYWxsYmFja1RleHQ6IG51bGxcbn07XG5cbmZ1bmN0aW9uIGluaXRpYWxpemUobmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgY29tcG9zaXRpb25TdGF0ZS5fcm9vdCA9IG5hdGl2ZUV2ZW50VGFyZ2V0O1xuICBjb21wb3NpdGlvblN0YXRlLl9zdGFydFRleHQgPSBnZXRUZXh0KCk7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZXNldCgpIHtcbiAgY29tcG9zaXRpb25TdGF0ZS5fcm9vdCA9IG51bGw7XG4gIGNvbXBvc2l0aW9uU3RhdGUuX3N0YXJ0VGV4dCA9IG51bGw7XG4gIGNvbXBvc2l0aW9uU3RhdGUuX2ZhbGxiYWNrVGV4dCA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldERhdGEoKSB7XG4gIGlmIChjb21wb3NpdGlvblN0YXRlLl9mYWxsYmFja1RleHQpIHtcbiAgICByZXR1cm4gY29tcG9zaXRpb25TdGF0ZS5fZmFsbGJhY2tUZXh0O1xuICB9XG5cbiAgdmFyIHN0YXJ0O1xuICB2YXIgc3RhcnRWYWx1ZSA9IGNvbXBvc2l0aW9uU3RhdGUuX3N0YXJ0VGV4dDtcbiAgdmFyIHN0YXJ0TGVuZ3RoID0gc3RhcnRWYWx1ZS5sZW5ndGg7XG4gIHZhciBlbmQ7XG4gIHZhciBlbmRWYWx1ZSA9IGdldFRleHQoKTtcbiAgdmFyIGVuZExlbmd0aCA9IGVuZFZhbHVlLmxlbmd0aDtcblxuICBmb3IgKHN0YXJ0ID0gMDsgc3RhcnQgPCBzdGFydExlbmd0aDsgc3RhcnQrKykge1xuICAgIGlmIChzdGFydFZhbHVlW3N0YXJ0XSAhPT0gZW5kVmFsdWVbc3RhcnRdKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB2YXIgbWluRW5kID0gc3RhcnRMZW5ndGggLSBzdGFydDtcbiAgZm9yIChlbmQgPSAxOyBlbmQgPD0gbWluRW5kOyBlbmQrKykge1xuICAgIGlmIChzdGFydFZhbHVlW3N0YXJ0TGVuZ3RoIC0gZW5kXSAhPT0gZW5kVmFsdWVbZW5kTGVuZ3RoIC0gZW5kXSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIHNsaWNlVGFpbCA9IGVuZCA+IDEgPyAxIC0gZW5kIDogdW5kZWZpbmVkO1xuICBjb21wb3NpdGlvblN0YXRlLl9mYWxsYmFja1RleHQgPSBlbmRWYWx1ZS5zbGljZShzdGFydCwgc2xpY2VUYWlsKTtcbiAgcmV0dXJuIGNvbXBvc2l0aW9uU3RhdGUuX2ZhbGxiYWNrVGV4dDtcbn1cblxuZnVuY3Rpb24gZ2V0VGV4dCgpIHtcbiAgaWYgKCd2YWx1ZScgaW4gY29tcG9zaXRpb25TdGF0ZS5fcm9vdCkge1xuICAgIHJldHVybiBjb21wb3NpdGlvblN0YXRlLl9yb290LnZhbHVlO1xuICB9XG4gIHJldHVybiBjb21wb3NpdGlvblN0YXRlLl9yb290W2dldFRleHRDb250ZW50QWNjZXNzb3IoKV07XG59XG5cbi8qIGVzbGludCB2YWxpZC10eXBlb2Y6IDAgKi9cblxudmFyIGRpZFdhcm5Gb3JBZGRlZE5ld1Byb3BlcnR5ID0gZmFsc2U7XG52YXIgaXNQcm94eVN1cHBvcnRlZCA9IHR5cGVvZiBQcm94eSA9PT0gJ2Z1bmN0aW9uJztcbnZhciBFVkVOVF9QT09MX1NJWkUgPSAxMDtcblxudmFyIHNob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzID0gWydkaXNwYXRjaENvbmZpZycsICdfdGFyZ2V0SW5zdCcsICduYXRpdmVFdmVudCcsICdpc0RlZmF1bHRQcmV2ZW50ZWQnLCAnaXNQcm9wYWdhdGlvblN0b3BwZWQnLCAnX2Rpc3BhdGNoTGlzdGVuZXJzJywgJ19kaXNwYXRjaEluc3RhbmNlcyddO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHR5cGU6IG51bGwsXG4gIHRhcmdldDogbnVsbCxcbiAgLy8gY3VycmVudFRhcmdldCBpcyBzZXQgd2hlbiBkaXNwYXRjaGluZzsgbm8gdXNlIGluIGNvcHlpbmcgaXQgaGVyZVxuICBjdXJyZW50VGFyZ2V0OiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCxcbiAgZXZlbnRQaGFzZTogbnVsbCxcbiAgYnViYmxlczogbnVsbCxcbiAgY2FuY2VsYWJsZTogbnVsbCxcbiAgdGltZVN0YW1wOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQudGltZVN0YW1wIHx8IERhdGUubm93KCk7XG4gIH0sXG4gIGRlZmF1bHRQcmV2ZW50ZWQ6IG51bGwsXG4gIGlzVHJ1c3RlZDogbnVsbFxufTtcblxuLyoqXG4gKiBTeW50aGV0aWMgZXZlbnRzIGFyZSBkaXNwYXRjaGVkIGJ5IGV2ZW50IHBsdWdpbnMsIHR5cGljYWxseSBpbiByZXNwb25zZSB0byBhXG4gKiB0b3AtbGV2ZWwgZXZlbnQgZGVsZWdhdGlvbiBoYW5kbGVyLlxuICpcbiAqIFRoZXNlIHN5c3RlbXMgc2hvdWxkIGdlbmVyYWxseSB1c2UgcG9vbGluZyB0byByZWR1Y2UgdGhlIGZyZXF1ZW5jeSBvZiBnYXJiYWdlXG4gKiBjb2xsZWN0aW9uLiBUaGUgc3lzdGVtIHNob3VsZCBjaGVjayBgaXNQZXJzaXN0ZW50YCB0byBkZXRlcm1pbmUgd2hldGhlciB0aGVcbiAqIGV2ZW50IHNob3VsZCBiZSByZWxlYXNlZCBpbnRvIHRoZSBwb29sIGFmdGVyIGJlaW5nIGRpc3BhdGNoZWQuIFVzZXJzIHRoYXRcbiAqIG5lZWQgYSBwZXJzaXN0ZWQgZXZlbnQgc2hvdWxkIGludm9rZSBgcGVyc2lzdGAuXG4gKlxuICogU3ludGhldGljIGV2ZW50cyAoYW5kIHN1YmNsYXNzZXMpIGltcGxlbWVudCB0aGUgRE9NIExldmVsIDMgRXZlbnRzIEFQSSBieVxuICogbm9ybWFsaXppbmcgYnJvd3NlciBxdWlya3MuIFN1YmNsYXNzZXMgZG8gbm90IG5lY2Vzc2FyaWx5IGhhdmUgdG8gaW1wbGVtZW50IGFcbiAqIERPTSBpbnRlcmZhY2U7IGN1c3RvbSBhcHBsaWNhdGlvbi1zcGVjaWZpYyBldmVudHMgY2FuIGFsc28gc3ViY2xhc3MgdGhpcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0geyp9IHRhcmdldEluc3QgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSBuYXRpdmVFdmVudFRhcmdldCBUYXJnZXQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljRXZlbnQoZGlzcGF0Y2hDb25maWcsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB7XG4gICAgLy8gdGhlc2UgaGF2ZSBhIGdldHRlci9zZXR0ZXIgZm9yIHdhcm5pbmdzXG4gICAgZGVsZXRlIHRoaXMubmF0aXZlRXZlbnQ7XG4gICAgZGVsZXRlIHRoaXMucHJldmVudERlZmF1bHQ7XG4gICAgZGVsZXRlIHRoaXMuc3RvcFByb3BhZ2F0aW9uO1xuICB9XG5cbiAgdGhpcy5kaXNwYXRjaENvbmZpZyA9IGRpc3BhdGNoQ29uZmlnO1xuICB0aGlzLl90YXJnZXRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgdGhpcy5uYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50O1xuXG4gIHZhciBJbnRlcmZhY2UgPSB0aGlzLmNvbnN0cnVjdG9yLkludGVyZmFjZTtcbiAgZm9yICh2YXIgcHJvcE5hbWUgaW4gSW50ZXJmYWNlKSB7XG4gICAgaWYgKCFJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAge1xuICAgICAgZGVsZXRlIHRoaXNbcHJvcE5hbWVdOyAvLyB0aGlzIGhhcyBhIGdldHRlci9zZXR0ZXIgZm9yIHdhcm5pbmdzXG4gICAgfVxuICAgIHZhciBub3JtYWxpemUgPSBJbnRlcmZhY2VbcHJvcE5hbWVdO1xuICAgIGlmIChub3JtYWxpemUpIHtcbiAgICAgIHRoaXNbcHJvcE5hbWVdID0gbm9ybWFsaXplKG5hdGl2ZUV2ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb3BOYW1lID09PSAndGFyZ2V0Jykge1xuICAgICAgICB0aGlzLnRhcmdldCA9IG5hdGl2ZUV2ZW50VGFyZ2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc1twcm9wTmFtZV0gPSBuYXRpdmVFdmVudFtwcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGRlZmF1bHRQcmV2ZW50ZWQgPSBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkICE9IG51bGwgPyBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkIDogbmF0aXZlRXZlbnQucmV0dXJuVmFsdWUgPT09IGZhbHNlO1xuICBpZiAoZGVmYXVsdFByZXZlbnRlZCkge1xuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2U7XG4gIH1cbiAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbl9hc3NpZ24oU3ludGhldGljRXZlbnQucHJvdG90eXBlLCB7XG4gIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcbiAgICB2YXIgZXZlbnQgPSB0aGlzLm5hdGl2ZUV2ZW50O1xuICAgIGlmICghZXZlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQucHJldmVudERlZmF1bHQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXZlbnQucmV0dXJuVmFsdWUgIT09ICd1bmtub3duJykge1xuICAgICAgZXZlbnQucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSxcblxuICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXZlbnQgPSB0aGlzLm5hdGl2ZUV2ZW50O1xuICAgIGlmICghZXZlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQuc3RvcFByb3BhZ2F0aW9uKSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBldmVudC5jYW5jZWxCdWJibGUgIT09ICd1bmtub3duJykge1xuICAgICAgLy8gVGhlIENoYW5nZUV2ZW50UGx1Z2luIHJlZ2lzdGVycyBhIFwicHJvcGVydHljaGFuZ2VcIiBldmVudCBmb3JcbiAgICAgIC8vIElFLiBUaGlzIGV2ZW50IGRvZXMgbm90IHN1cHBvcnQgYnViYmxpbmcgb3IgY2FuY2VsbGluZywgYW5kXG4gICAgICAvLyBhbnkgcmVmZXJlbmNlcyB0byBjYW5jZWxCdWJibGUgdGhyb3cgXCJNZW1iZXIgbm90IGZvdW5kXCIuICBBXG4gICAgICAvLyB0eXBlb2YgY2hlY2sgb2YgXCJ1bmtub3duXCIgY2lyY3VtdmVudHMgdGhpcyBpc3N1ZSAoYW5kIGlzIGFsc29cbiAgICAgIC8vIElFIHNwZWNpZmljKS5cbiAgICAgIGV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXZSByZWxlYXNlIGFsbCBkaXNwYXRjaGVkIGBTeW50aGV0aWNFdmVudGBzIGFmdGVyIGVhY2ggZXZlbnQgbG9vcCwgYWRkaW5nXG4gICAqIHRoZW0gYmFjayBpbnRvIHRoZSBwb29sLiBUaGlzIGFsbG93cyBhIHdheSB0byBob2xkIG9udG8gYSByZWZlcmVuY2UgdGhhdFxuICAgKiB3b24ndCBiZSBhZGRlZCBiYWNrIGludG8gdGhlIHBvb2wuXG4gICAqL1xuICBwZXJzaXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pc1BlcnNpc3RlbnQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoaXMgZXZlbnQgc2hvdWxkIGJlIHJlbGVhc2VkIGJhY2sgaW50byB0aGUgcG9vbC5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGlzIHNob3VsZCBub3QgYmUgcmVsZWFzZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGlzUGVyc2lzdGVudDogZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlLFxuXG4gIC8qKlxuICAgKiBgUG9vbGVkQ2xhc3NgIGxvb2tzIGZvciBgZGVzdHJ1Y3RvcmAgb24gZWFjaCBpbnN0YW5jZSBpdCByZWxlYXNlcy5cbiAgICovXG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgSW50ZXJmYWNlID0gdGhpcy5jb25zdHJ1Y3Rvci5JbnRlcmZhY2U7XG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gSW50ZXJmYWNlKSB7XG4gICAgICB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBwcm9wTmFtZSwgZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbihwcm9wTmFtZSwgSW50ZXJmYWNlW3Byb3BOYW1lXSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzW3Nob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzW2ldXSA9IG51bGw7XG4gICAgfVxuICAgIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbmF0aXZlRXZlbnQnLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKCduYXRpdmVFdmVudCcsIG51bGwpKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncHJldmVudERlZmF1bHQnLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKCdwcmV2ZW50RGVmYXVsdCcsIGVtcHR5RnVuY3Rpb24pKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc3RvcFByb3BhZ2F0aW9uJywgZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbignc3RvcFByb3BhZ2F0aW9uJywgZW1wdHlGdW5jdGlvbikpO1xuICAgIH1cbiAgfVxufSk7XG5cblN5bnRoZXRpY0V2ZW50LkludGVyZmFjZSA9IEV2ZW50SW50ZXJmYWNlO1xuXG4vKipcbiAqIEhlbHBlciB0byByZWR1Y2UgYm9pbGVycGxhdGUgd2hlbiBjcmVhdGluZyBzdWJjbGFzc2VzLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IENsYXNzXG4gKiBAcGFyYW0gez9vYmplY3R9IEludGVyZmFjZVxuICovXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MgPSBmdW5jdGlvbiAoQ2xhc3MsIEludGVyZmFjZSkge1xuICB2YXIgU3VwZXIgPSB0aGlzO1xuXG4gIHZhciBFID0gZnVuY3Rpb24gKCkge307XG4gIEUucHJvdG90eXBlID0gU3VwZXIucHJvdG90eXBlO1xuICB2YXIgcHJvdG90eXBlID0gbmV3IEUoKTtcblxuICBfYXNzaWduKHByb3RvdHlwZSwgQ2xhc3MucHJvdG90eXBlKTtcbiAgQ2xhc3MucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICBDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDbGFzcztcblxuICBDbGFzcy5JbnRlcmZhY2UgPSBfYXNzaWduKHt9LCBTdXBlci5JbnRlcmZhY2UsIEludGVyZmFjZSk7XG4gIENsYXNzLmF1Z21lbnRDbGFzcyA9IFN1cGVyLmF1Z21lbnRDbGFzcztcbiAgYWRkRXZlbnRQb29saW5nVG8oQ2xhc3MpO1xufTtcblxuLyoqIFByb3h5aW5nIGFmdGVyIGV2ZXJ5dGhpbmcgc2V0IG9uIFN5bnRoZXRpY0V2ZW50XG4gKiB0byByZXNvbHZlIFByb3h5IGlzc3VlIG9uIHNvbWUgV2ViS2l0IGJyb3dzZXJzXG4gKiBpbiB3aGljaCBzb21lIEV2ZW50IHByb3BlcnRpZXMgYXJlIHNldCB0byB1bmRlZmluZWQgKEdIIzEwMDEwKVxuICovXG57XG4gIGlmIChpc1Byb3h5U3VwcG9ydGVkKSB7XG4gICAgLyplc2xpbnQtZGlzYWJsZSBuby1mdW5jLWFzc2lnbiAqL1xuICAgIFN5bnRoZXRpY0V2ZW50ID0gbmV3IFByb3h5KFN5bnRoZXRpY0V2ZW50LCB7XG4gICAgICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uICh0YXJnZXQsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHkodGFyZ2V0LCBPYmplY3QuY3JlYXRlKHRhcmdldC5wcm90b3R5cGUpLCBhcmdzKTtcbiAgICAgIH0sXG4gICAgICBhcHBseTogZnVuY3Rpb24gKGNvbnN0cnVjdG9yLCB0aGF0LCBhcmdzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJveHkoY29uc3RydWN0b3IuYXBwbHkodGhhdCwgYXJncyksIHtcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0YXJnZXQsIHByb3AsIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAocHJvcCAhPT0gJ2lzUGVyc2lzdGVudCcgJiYgIXRhcmdldC5jb25zdHJ1Y3Rvci5JbnRlcmZhY2UuaGFzT3duUHJvcGVydHkocHJvcCkgJiYgc2hvdWxkQmVSZWxlYXNlZFByb3BlcnRpZXMuaW5kZXhPZihwcm9wKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgd2FybmluZyhkaWRXYXJuRm9yQWRkZWROZXdQcm9wZXJ0eSB8fCB0YXJnZXQuaXNQZXJzaXN0ZW50KCksIFwiVGhpcyBzeW50aGV0aWMgZXZlbnQgaXMgcmV1c2VkIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLiBJZiB5b3UncmUgXCIgKyBcInNlZWluZyB0aGlzLCB5b3UncmUgYWRkaW5nIGEgbmV3IHByb3BlcnR5IGluIHRoZSBzeW50aGV0aWMgZXZlbnQgb2JqZWN0LiBcIiArICdUaGUgcHJvcGVydHkgaXMgbmV2ZXIgcmVsZWFzZWQuIFNlZSAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtZXZlbnQtcG9vbGluZyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKTtcbiAgICAgICAgICAgICAgZGlkV2FybkZvckFkZGVkTmV3UHJvcGVydHkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFyZ2V0W3Byb3BdID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8qZXNsaW50LWVuYWJsZSBuby1mdW5jLWFzc2lnbiAqL1xuICB9XG59XG5cbmFkZEV2ZW50UG9vbGluZ1RvKFN5bnRoZXRpY0V2ZW50KTtcblxuLyoqXG4gKiBIZWxwZXIgdG8gbnVsbGlmeSBzeW50aGV0aWNFdmVudCBpbnN0YW5jZSBwcm9wZXJ0aWVzIHdoZW4gZGVzdHJ1Y3RpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcE5hbWVcbiAqIEBwYXJhbSB7P29iamVjdH0gZ2V0VmFsXG4gKiBAcmV0dXJuIHtvYmplY3R9IGRlZmluZVByb3BlcnR5IG9iamVjdFxuICovXG5mdW5jdGlvbiBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKHByb3BOYW1lLCBnZXRWYWwpIHtcbiAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2YgZ2V0VmFsID09PSAnZnVuY3Rpb24nO1xuICByZXR1cm4ge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBzZXQ6IHNldCxcbiAgICBnZXQ6IGdldFxuICB9O1xuXG4gIGZ1bmN0aW9uIHNldCh2YWwpIHtcbiAgICB2YXIgYWN0aW9uID0gaXNGdW5jdGlvbiA/ICdzZXR0aW5nIHRoZSBtZXRob2QnIDogJ3NldHRpbmcgdGhlIHByb3BlcnR5JztcbiAgICB3YXJuKGFjdGlvbiwgJ1RoaXMgaXMgZWZmZWN0aXZlbHkgYSBuby1vcCcpO1xuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICBmdW5jdGlvbiBnZXQoKSB7XG4gICAgdmFyIGFjdGlvbiA9IGlzRnVuY3Rpb24gPyAnYWNjZXNzaW5nIHRoZSBtZXRob2QnIDogJ2FjY2Vzc2luZyB0aGUgcHJvcGVydHknO1xuICAgIHZhciByZXN1bHQgPSBpc0Z1bmN0aW9uID8gJ1RoaXMgaXMgYSBuby1vcCBmdW5jdGlvbicgOiAnVGhpcyBpcyBzZXQgdG8gbnVsbCc7XG4gICAgd2FybihhY3Rpb24sIHJlc3VsdCk7XG4gICAgcmV0dXJuIGdldFZhbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdhcm4oYWN0aW9uLCByZXN1bHQpIHtcbiAgICB2YXIgd2FybmluZ0NvbmRpdGlvbiA9IGZhbHNlO1xuICAgIHdhcm5pbmcod2FybmluZ0NvbmRpdGlvbiwgXCJUaGlzIHN5bnRoZXRpYyBldmVudCBpcyByZXVzZWQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuIElmIHlvdSdyZSBzZWVpbmcgdGhpcywgXCIgKyBcInlvdSdyZSAlcyBgJXNgIG9uIGEgcmVsZWFzZWQvbnVsbGlmaWVkIHN5bnRoZXRpYyBldmVudC4gJXMuIFwiICsgJ0lmIHlvdSBtdXN0IGtlZXAgdGhlIG9yaWdpbmFsIHN5bnRoZXRpYyBldmVudCBhcm91bmQsIHVzZSBldmVudC5wZXJzaXN0KCkuICcgKyAnU2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtZXZlbnQtcG9vbGluZyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCBhY3Rpb24sIHByb3BOYW1lLCByZXN1bHQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFBvb2xlZEV2ZW50KGRpc3BhdGNoQ29uZmlnLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlSW5zdCkge1xuICB2YXIgRXZlbnRDb25zdHJ1Y3RvciA9IHRoaXM7XG4gIGlmIChFdmVudENvbnN0cnVjdG9yLmV2ZW50UG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBFdmVudENvbnN0cnVjdG9yLmV2ZW50UG9vbC5wb3AoKTtcbiAgICBFdmVudENvbnN0cnVjdG9yLmNhbGwoaW5zdGFuY2UsIGRpc3BhdGNoQ29uZmlnLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlSW5zdCk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9XG4gIHJldHVybiBuZXcgRXZlbnRDb25zdHJ1Y3RvcihkaXNwYXRjaENvbmZpZywgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUluc3QpO1xufVxuXG5mdW5jdGlvbiByZWxlYXNlUG9vbGVkRXZlbnQoZXZlbnQpIHtcbiAgdmFyIEV2ZW50Q29uc3RydWN0b3IgPSB0aGlzO1xuICAhKGV2ZW50IGluc3RhbmNlb2YgRXZlbnRDb25zdHJ1Y3RvcikgPyBpbnZhcmlhbnQoZmFsc2UsICdUcnlpbmcgdG8gcmVsZWFzZSBhbiBldmVudCBpbnN0YW5jZSAgaW50byBhIHBvb2wgb2YgYSBkaWZmZXJlbnQgdHlwZS4nKSA6IHZvaWQgMDtcbiAgZXZlbnQuZGVzdHJ1Y3RvcigpO1xuICBpZiAoRXZlbnRDb25zdHJ1Y3Rvci5ldmVudFBvb2wubGVuZ3RoIDwgRVZFTlRfUE9PTF9TSVpFKSB7XG4gICAgRXZlbnRDb25zdHJ1Y3Rvci5ldmVudFBvb2wucHVzaChldmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkRXZlbnRQb29saW5nVG8oRXZlbnRDb25zdHJ1Y3Rvcikge1xuICBFdmVudENvbnN0cnVjdG9yLmV2ZW50UG9vbCA9IFtdO1xuICBFdmVudENvbnN0cnVjdG9yLmdldFBvb2xlZCA9IGdldFBvb2xlZEV2ZW50O1xuICBFdmVudENvbnN0cnVjdG9yLnJlbGVhc2UgPSByZWxlYXNlUG9vbGVkRXZlbnQ7XG59XG5cbnZhciBTeW50aGV0aWNFdmVudCQxID0gU3ludGhldGljRXZlbnQ7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50cy1jb21wb3NpdGlvbmV2ZW50c1xuICovXG52YXIgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZSA9IHtcbiAgZGF0YTogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50JDEuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50JDEuYXVnbWVudENsYXNzKFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQsIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAxMzExMDVcbiAqICAgICAgLyNldmVudHMtaW5wdXRldmVudHNcbiAqL1xudmFyIElucHV0RXZlbnRJbnRlcmZhY2UgPSB7XG4gIGRhdGE6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNJbnB1dEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudCQxLmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudCQxLmF1Z21lbnRDbGFzcyhTeW50aGV0aWNJbnB1dEV2ZW50LCBJbnB1dEV2ZW50SW50ZXJmYWNlKTtcblxudmFyIEVORF9LRVlDT0RFUyA9IFs5LCAxMywgMjcsIDMyXTsgLy8gVGFiLCBSZXR1cm4sIEVzYywgU3BhY2VcbnZhciBTVEFSVF9LRVlDT0RFID0gMjI5O1xuXG52YXIgY2FuVXNlQ29tcG9zaXRpb25FdmVudCA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnQ29tcG9zaXRpb25FdmVudCcgaW4gd2luZG93O1xuXG52YXIgZG9jdW1lbnRNb2RlID0gbnVsbDtcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQpIHtcbiAgZG9jdW1lbnRNb2RlID0gZG9jdW1lbnQuZG9jdW1lbnRNb2RlO1xufVxuXG4vLyBXZWJraXQgb2ZmZXJzIGEgdmVyeSB1c2VmdWwgYHRleHRJbnB1dGAgZXZlbnQgdGhhdCBjYW4gYmUgdXNlZCB0b1xuLy8gZGlyZWN0bHkgcmVwcmVzZW50IGBiZWZvcmVJbnB1dGAuIFRoZSBJRSBgdGV4dGlucHV0YCBldmVudCBpcyBub3QgYXNcbi8vIHVzZWZ1bCwgc28gd2UgZG9uJ3QgdXNlIGl0LlxudmFyIGNhblVzZVRleHRJbnB1dEV2ZW50ID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdUZXh0RXZlbnQnIGluIHdpbmRvdyAmJiAhZG9jdW1lbnRNb2RlICYmICFpc1ByZXN0bygpO1xuXG4vLyBJbiBJRTkrLCB3ZSBoYXZlIGFjY2VzcyB0byBjb21wb3NpdGlvbiBldmVudHMsIGJ1dCB0aGUgZGF0YSBzdXBwbGllZFxuLy8gYnkgdGhlIG5hdGl2ZSBjb21wb3NpdGlvbmVuZCBldmVudCBtYXkgYmUgaW5jb3JyZWN0LiBKYXBhbmVzZSBpZGVvZ3JhcGhpY1xuLy8gc3BhY2VzLCBmb3IgaW5zdGFuY2UgKFxcdTMwMDApIGFyZSBub3QgcmVjb3JkZWQgY29ycmVjdGx5LlxudmFyIHVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICghY2FuVXNlQ29tcG9zaXRpb25FdmVudCB8fCBkb2N1bWVudE1vZGUgJiYgZG9jdW1lbnRNb2RlID4gOCAmJiBkb2N1bWVudE1vZGUgPD0gMTEpO1xuXG4vKipcbiAqIE9wZXJhIDw9IDEyIGluY2x1ZGVzIFRleHRFdmVudCBpbiB3aW5kb3csIGJ1dCBkb2VzIG5vdCBmaXJlXG4gKiB0ZXh0IGlucHV0IGV2ZW50cy4gUmVseSBvbiBrZXlwcmVzcyBpbnN0ZWFkLlxuICovXG5mdW5jdGlvbiBpc1ByZXN0bygpIHtcbiAgdmFyIG9wZXJhID0gd2luZG93Lm9wZXJhO1xuICByZXR1cm4gdHlwZW9mIG9wZXJhID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb3BlcmEudmVyc2lvbiA9PT0gJ2Z1bmN0aW9uJyAmJiBwYXJzZUludChvcGVyYS52ZXJzaW9uKCksIDEwKSA8PSAxMjtcbn1cblxudmFyIFNQQUNFQkFSX0NPREUgPSAzMjtcbnZhciBTUEFDRUJBUl9DSEFSID0gU3RyaW5nLmZyb21DaGFyQ29kZShTUEFDRUJBUl9DT0RFKTtcblxuLy8gRXZlbnRzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIHByb3BlcnR5IG5hbWVzLlxudmFyIGV2ZW50VHlwZXMgPSB7XG4gIGJlZm9yZUlucHV0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvbkJlZm9yZUlucHV0JyxcbiAgICAgIGNhcHR1cmVkOiAnb25CZWZvcmVJbnB1dENhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wQ29tcG9zaXRpb25FbmQnLCAndG9wS2V5UHJlc3MnLCAndG9wVGV4dElucHV0JywgJ3RvcFBhc3RlJ11cbiAgfSxcbiAgY29tcG9zaXRpb25FbmQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogJ29uQ29tcG9zaXRpb25FbmQnLFxuICAgICAgY2FwdHVyZWQ6ICdvbkNvbXBvc2l0aW9uRW5kQ2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BCbHVyJywgJ3RvcENvbXBvc2l0aW9uRW5kJywgJ3RvcEtleURvd24nLCAndG9wS2V5UHJlc3MnLCAndG9wS2V5VXAnLCAndG9wTW91c2VEb3duJ11cbiAgfSxcbiAgY29tcG9zaXRpb25TdGFydDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25Db21wb3NpdGlvblN0YXJ0JyxcbiAgICAgIGNhcHR1cmVkOiAnb25Db21wb3NpdGlvblN0YXJ0Q2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BCbHVyJywgJ3RvcENvbXBvc2l0aW9uU3RhcnQnLCAndG9wS2V5RG93bicsICd0b3BLZXlQcmVzcycsICd0b3BLZXlVcCcsICd0b3BNb3VzZURvd24nXVxuICB9LFxuICBjb21wb3NpdGlvblVwZGF0ZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25Db21wb3NpdGlvblVwZGF0ZScsXG4gICAgICBjYXB0dXJlZDogJ29uQ29tcG9zaXRpb25VcGRhdGVDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcEJsdXInLCAndG9wQ29tcG9zaXRpb25VcGRhdGUnLCAndG9wS2V5RG93bicsICd0b3BLZXlQcmVzcycsICd0b3BLZXlVcCcsICd0b3BNb3VzZURvd24nXVxuICB9XG59O1xuXG4vLyBUcmFjayB3aGV0aGVyIHdlJ3ZlIGV2ZXIgaGFuZGxlZCBhIGtleXByZXNzIG9uIHRoZSBzcGFjZSBrZXkuXG52YXIgaGFzU3BhY2VLZXlwcmVzcyA9IGZhbHNlO1xuXG4vKipcbiAqIFJldHVybiB3aGV0aGVyIGEgbmF0aXZlIGtleXByZXNzIGV2ZW50IGlzIGFzc3VtZWQgdG8gYmUgYSBjb21tYW5kLlxuICogVGhpcyBpcyByZXF1aXJlZCBiZWNhdXNlIEZpcmVmb3ggZmlyZXMgYGtleXByZXNzYCBldmVudHMgZm9yIGtleSBjb21tYW5kc1xuICogKGN1dCwgY29weSwgc2VsZWN0LWFsbCwgZXRjLikgZXZlbiB0aG91Z2ggbm8gY2hhcmFjdGVyIGlzIGluc2VydGVkLlxuICovXG5mdW5jdGlvbiBpc0tleXByZXNzQ29tbWFuZChuYXRpdmVFdmVudCkge1xuICByZXR1cm4gKG5hdGl2ZUV2ZW50LmN0cmxLZXkgfHwgbmF0aXZlRXZlbnQuYWx0S2V5IHx8IG5hdGl2ZUV2ZW50Lm1ldGFLZXkpICYmXG4gIC8vIGN0cmxLZXkgJiYgYWx0S2V5IGlzIGVxdWl2YWxlbnQgdG8gQWx0R3IsIGFuZCBpcyBub3QgYSBjb21tYW5kLlxuICAhKG5hdGl2ZUV2ZW50LmN0cmxLZXkgJiYgbmF0aXZlRXZlbnQuYWx0S2V5KTtcbn1cblxuLyoqXG4gKiBUcmFuc2xhdGUgbmF0aXZlIHRvcCBsZXZlbCBldmVudHMgaW50byBldmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldENvbXBvc2l0aW9uRXZlbnRUeXBlKHRvcExldmVsVHlwZSkge1xuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgJ3RvcENvbXBvc2l0aW9uU3RhcnQnOlxuICAgICAgcmV0dXJuIGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydDtcbiAgICBjYXNlICd0b3BDb21wb3NpdGlvbkVuZCc6XG4gICAgICByZXR1cm4gZXZlbnRUeXBlcy5jb21wb3NpdGlvbkVuZDtcbiAgICBjYXNlICd0b3BDb21wb3NpdGlvblVwZGF0ZSc6XG4gICAgICByZXR1cm4gZXZlbnRUeXBlcy5jb21wb3NpdGlvblVwZGF0ZTtcbiAgfVxufVxuXG4vKipcbiAqIERvZXMgb3VyIGZhbGxiYWNrIGJlc3QtZ3Vlc3MgbW9kZWwgdGhpbmsgdGhpcyBldmVudCBzaWduaWZpZXMgdGhhdFxuICogY29tcG9zaXRpb24gaGFzIGJlZ3VuP1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNGYWxsYmFja0NvbXBvc2l0aW9uU3RhcnQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICByZXR1cm4gdG9wTGV2ZWxUeXBlID09PSAndG9wS2V5RG93bicgJiYgbmF0aXZlRXZlbnQua2V5Q29kZSA9PT0gU1RBUlRfS0VZQ09ERTtcbn1cblxuLyoqXG4gKiBEb2VzIG91ciBmYWxsYmFjayBtb2RlIHRoaW5rIHRoYXQgdGhpcyBldmVudCBpcyB0aGUgZW5kIG9mIGNvbXBvc2l0aW9uP1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICBjYXNlICd0b3BLZXlVcCc6XG4gICAgICAvLyBDb21tYW5kIGtleXMgaW5zZXJ0IG9yIGNsZWFyIElNRSBpbnB1dC5cbiAgICAgIHJldHVybiBFTkRfS0VZQ09ERVMuaW5kZXhPZihuYXRpdmVFdmVudC5rZXlDb2RlKSAhPT0gLTE7XG4gICAgY2FzZSAndG9wS2V5RG93bic6XG4gICAgICAvLyBFeHBlY3QgSU1FIGtleUNvZGUgb24gZWFjaCBrZXlkb3duLiBJZiB3ZSBnZXQgYW55IG90aGVyXG4gICAgICAvLyBjb2RlIHdlIG11c3QgaGF2ZSBleGl0ZWQgZWFybGllci5cbiAgICAgIHJldHVybiBuYXRpdmVFdmVudC5rZXlDb2RlICE9PSBTVEFSVF9LRVlDT0RFO1xuICAgIGNhc2UgJ3RvcEtleVByZXNzJzpcbiAgICBjYXNlICd0b3BNb3VzZURvd24nOlxuICAgIGNhc2UgJ3RvcEJsdXInOlxuICAgICAgLy8gRXZlbnRzIGFyZSBub3QgcG9zc2libGUgd2l0aG91dCBjYW5jZWxsaW5nIElNRS5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBHb29nbGUgSW5wdXQgVG9vbHMgcHJvdmlkZXMgY29tcG9zaXRpb24gZGF0YSB2aWEgYSBDdXN0b21FdmVudCxcbiAqIHdpdGggdGhlIGBkYXRhYCBwcm9wZXJ0eSBwb3B1bGF0ZWQgaW4gdGhlIGBkZXRhaWxgIG9iamVjdC4gSWYgdGhpc1xuICogaXMgYXZhaWxhYmxlIG9uIHRoZSBldmVudCBvYmplY3QsIHVzZSBpdC4gSWYgbm90LCB0aGlzIGlzIGEgcGxhaW5cbiAqIGNvbXBvc2l0aW9uIGV2ZW50IGFuZCB3ZSBoYXZlIG5vdGhpbmcgc3BlY2lhbCB0byBleHRyYWN0LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7P3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCkge1xuICB2YXIgZGV0YWlsID0gbmF0aXZlRXZlbnQuZGV0YWlsO1xuICBpZiAodHlwZW9mIGRldGFpbCA9PT0gJ29iamVjdCcgJiYgJ2RhdGEnIGluIGRldGFpbCkge1xuICAgIHJldHVybiBkZXRhaWwuZGF0YTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gVHJhY2sgdGhlIGN1cnJlbnQgSU1FIGNvbXBvc2l0aW9uIHN0YXR1cywgaWYgYW55LlxudmFyIGlzQ29tcG9zaW5nID0gZmFsc2U7XG5cbi8qKlxuICogQHJldHVybiB7P29iamVjdH0gQSBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LlxuICovXG5mdW5jdGlvbiBleHRyYWN0Q29tcG9zaXRpb25FdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB2YXIgZXZlbnRUeXBlO1xuICB2YXIgZmFsbGJhY2tEYXRhO1xuXG4gIGlmIChjYW5Vc2VDb21wb3NpdGlvbkV2ZW50KSB7XG4gICAgZXZlbnRUeXBlID0gZ2V0Q29tcG9zaXRpb25FdmVudFR5cGUodG9wTGV2ZWxUeXBlKTtcbiAgfSBlbHNlIGlmICghaXNDb21wb3NpbmcpIHtcbiAgICBpZiAoaXNGYWxsYmFja0NvbXBvc2l0aW9uU3RhcnQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkpIHtcbiAgICAgIGV2ZW50VHlwZSA9IGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpKSB7XG4gICAgZXZlbnRUeXBlID0gZXZlbnRUeXBlcy5jb21wb3NpdGlvbkVuZDtcbiAgfVxuXG4gIGlmICghZXZlbnRUeXBlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAodXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEpIHtcbiAgICAvLyBUaGUgY3VycmVudCBjb21wb3NpdGlvbiBpcyBzdG9yZWQgc3RhdGljYWxseSBhbmQgbXVzdCBub3QgYmVcbiAgICAvLyBvdmVyd3JpdHRlbiB3aGlsZSBjb21wb3NpdGlvbiBjb250aW51ZXMuXG4gICAgaWYgKCFpc0NvbXBvc2luZyAmJiBldmVudFR5cGUgPT09IGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydCkge1xuICAgICAgaXNDb21wb3NpbmcgPSBpbml0aWFsaXplKG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50VHlwZSA9PT0gZXZlbnRUeXBlcy5jb21wb3NpdGlvbkVuZCkge1xuICAgICAgaWYgKGlzQ29tcG9zaW5nKSB7XG4gICAgICAgIGZhbGxiYWNrRGF0YSA9IGdldERhdGEoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZXZlbnQgPSBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LmdldFBvb2xlZChldmVudFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgaWYgKGZhbGxiYWNrRGF0YSkge1xuICAgIC8vIEluamVjdCBkYXRhIGdlbmVyYXRlZCBmcm9tIGZhbGxiYWNrIHBhdGggaW50byB0aGUgc3ludGhldGljIGV2ZW50LlxuICAgIC8vIFRoaXMgbWF0Y2hlcyB0aGUgcHJvcGVydHkgb2YgbmF0aXZlIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UuXG4gICAgZXZlbnQuZGF0YSA9IGZhbGxiYWNrRGF0YTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VzdG9tRGF0YSA9IGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpO1xuICAgIGlmIChjdXN0b21EYXRhICE9PSBudWxsKSB7XG4gICAgICBldmVudC5kYXRhID0gY3VzdG9tRGF0YTtcbiAgICB9XG4gIH1cblxuICBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgcmV0dXJuIGV2ZW50O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VG9wTGV2ZWxUeXBlc30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBCcm93c2VyRXZlbnRDb25zdGFudHNgLlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7P3N0cmluZ30gVGhlIHN0cmluZyBjb3JyZXNwb25kaW5nIHRvIHRoaXMgYGJlZm9yZUlucHV0YCBldmVudC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSAndG9wQ29tcG9zaXRpb25FbmQnOlxuICAgICAgcmV0dXJuIGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpO1xuICAgIGNhc2UgJ3RvcEtleVByZXNzJzpcbiAgICAgIC8qKlxuICAgICAgICogSWYgbmF0aXZlIGB0ZXh0SW5wdXRgIGV2ZW50cyBhcmUgYXZhaWxhYmxlLCBvdXIgZ29hbCBpcyB0byBtYWtlXG4gICAgICAgKiB1c2Ugb2YgdGhlbS4gSG93ZXZlciwgdGhlcmUgaXMgYSBzcGVjaWFsIGNhc2U6IHRoZSBzcGFjZWJhciBrZXkuXG4gICAgICAgKiBJbiBXZWJraXQsIHByZXZlbnRpbmcgZGVmYXVsdCBvbiBhIHNwYWNlYmFyIGB0ZXh0SW5wdXRgIGV2ZW50XG4gICAgICAgKiBjYW5jZWxzIGNoYXJhY3RlciBpbnNlcnRpb24sIGJ1dCBpdCAqYWxzbyogY2F1c2VzIHRoZSBicm93c2VyXG4gICAgICAgKiB0byBmYWxsIGJhY2sgdG8gaXRzIGRlZmF1bHQgc3BhY2ViYXIgYmVoYXZpb3Igb2Ygc2Nyb2xsaW5nIHRoZVxuICAgICAgICogcGFnZS5cbiAgICAgICAqXG4gICAgICAgKiBUcmFja2luZyBhdDpcbiAgICAgICAqIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNTUxMDNcbiAgICAgICAqXG4gICAgICAgKiBUbyBhdm9pZCB0aGlzIGlzc3VlLCB1c2UgdGhlIGtleXByZXNzIGV2ZW50IGFzIGlmIG5vIGB0ZXh0SW5wdXRgXG4gICAgICAgKiBldmVudCBpcyBhdmFpbGFibGUuXG4gICAgICAgKi9cbiAgICAgIHZhciB3aGljaCA9IG5hdGl2ZUV2ZW50LndoaWNoO1xuICAgICAgaWYgKHdoaWNoICE9PSBTUEFDRUJBUl9DT0RFKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBoYXNTcGFjZUtleXByZXNzID0gdHJ1ZTtcbiAgICAgIHJldHVybiBTUEFDRUJBUl9DSEFSO1xuXG4gICAgY2FzZSAndG9wVGV4dElucHV0JzpcbiAgICAgIC8vIFJlY29yZCB0aGUgY2hhcmFjdGVycyB0byBiZSBhZGRlZCB0byB0aGUgRE9NLlxuICAgICAgdmFyIGNoYXJzID0gbmF0aXZlRXZlbnQuZGF0YTtcblxuICAgICAgLy8gSWYgaXQncyBhIHNwYWNlYmFyIGNoYXJhY3RlciwgYXNzdW1lIHRoYXQgd2UgaGF2ZSBhbHJlYWR5IGhhbmRsZWRcbiAgICAgIC8vIGl0IGF0IHRoZSBrZXlwcmVzcyBsZXZlbCBhbmQgYmFpbCBpbW1lZGlhdGVseS4gQW5kcm9pZCBDaHJvbWVcbiAgICAgIC8vIGRvZXNuJ3QgZ2l2ZSB1cyBrZXljb2Rlcywgc28gd2UgbmVlZCB0byBibGFja2xpc3QgaXQuXG4gICAgICBpZiAoY2hhcnMgPT09IFNQQUNFQkFSX0NIQVIgJiYgaGFzU3BhY2VLZXlwcmVzcykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNoYXJzO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIEZvciBvdGhlciBuYXRpdmUgZXZlbnQgdHlwZXMsIGRvIG5vdGhpbmcuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEZvciBicm93c2VycyB0aGF0IGRvIG5vdCBwcm92aWRlIHRoZSBgdGV4dElucHV0YCBldmVudCwgZXh0cmFjdCB0aGVcbiAqIGFwcHJvcHJpYXRlIHN0cmluZyB0byB1c2UgZm9yIFN5bnRoZXRpY0lucHV0RXZlbnQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgQnJvd3NlckV2ZW50Q29uc3RhbnRzYC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4gez9zdHJpbmd9IFRoZSBmYWxsYmFjayBzdHJpbmcgZm9yIHRoaXMgYGJlZm9yZUlucHV0YCBldmVudC5cbiAqL1xuZnVuY3Rpb24gZ2V0RmFsbGJhY2tCZWZvcmVJbnB1dENoYXJzKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgLy8gSWYgd2UgYXJlIGN1cnJlbnRseSBjb21wb3NpbmcgKElNRSkgYW5kIHVzaW5nIGEgZmFsbGJhY2sgdG8gZG8gc28sXG4gIC8vIHRyeSB0byBleHRyYWN0IHRoZSBjb21wb3NlZCBjaGFyYWN0ZXJzIGZyb20gdGhlIGZhbGxiYWNrIG9iamVjdC5cbiAgLy8gSWYgY29tcG9zaXRpb24gZXZlbnQgaXMgYXZhaWxhYmxlLCB3ZSBleHRyYWN0IGEgc3RyaW5nIG9ubHkgYXRcbiAgLy8gY29tcG9zaXRpb25ldmVudCwgb3RoZXJ3aXNlIGV4dHJhY3QgaXQgYXQgZmFsbGJhY2sgZXZlbnRzLlxuICBpZiAoaXNDb21wb3NpbmcpIHtcbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wQ29tcG9zaXRpb25FbmQnIHx8ICFjYW5Vc2VDb21wb3NpdGlvbkV2ZW50ICYmIGlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSkge1xuICAgICAgdmFyIGNoYXJzID0gZ2V0RGF0YSgpO1xuICAgICAgcmVzZXQoKTtcbiAgICAgIGlzQ29tcG9zaW5nID0gZmFsc2U7XG4gICAgICByZXR1cm4gY2hhcnM7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICBjYXNlICd0b3BQYXN0ZSc6XG4gICAgICAvLyBJZiBhIHBhc3RlIGV2ZW50IG9jY3VycyBhZnRlciBhIGtleXByZXNzLCB0aHJvdyBvdXQgdGhlIGlucHV0XG4gICAgICAvLyBjaGFycy4gUGFzdGUgZXZlbnRzIHNob3VsZCBub3QgbGVhZCB0byBCZWZvcmVJbnB1dCBldmVudHMuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlICd0b3BLZXlQcmVzcyc6XG4gICAgICAvKipcbiAgICAgICAqIEFzIG9mIHYyNywgRmlyZWZveCBtYXkgZmlyZSBrZXlwcmVzcyBldmVudHMgZXZlbiB3aGVuIG5vIGNoYXJhY3RlclxuICAgICAgICogd2lsbCBiZSBpbnNlcnRlZC4gQSBmZXcgcG9zc2liaWxpdGllczpcbiAgICAgICAqXG4gICAgICAgKiAtIGB3aGljaGAgaXMgYDBgLiBBcnJvdyBrZXlzLCBFc2Mga2V5LCBldGMuXG4gICAgICAgKlxuICAgICAgICogLSBgd2hpY2hgIGlzIHRoZSBwcmVzc2VkIGtleSBjb2RlLCBidXQgbm8gY2hhciBpcyBhdmFpbGFibGUuXG4gICAgICAgKiAgIEV4OiAnQWx0R3IgKyBkYCBpbiBQb2xpc2guIFRoZXJlIGlzIG5vIG1vZGlmaWVkIGNoYXJhY3RlciBmb3JcbiAgICAgICAqICAgdGhpcyBrZXkgY29tYmluYXRpb24gYW5kIG5vIGNoYXJhY3RlciBpcyBpbnNlcnRlZCBpbnRvIHRoZVxuICAgICAgICogICBkb2N1bWVudCwgYnV0IEZGIGZpcmVzIHRoZSBrZXlwcmVzcyBmb3IgY2hhciBjb2RlIGAxMDBgIGFueXdheS5cbiAgICAgICAqICAgTm8gYGlucHV0YCBldmVudCB3aWxsIG9jY3VyLlxuICAgICAgICpcbiAgICAgICAqIC0gYHdoaWNoYCBpcyB0aGUgcHJlc3NlZCBrZXkgY29kZSwgYnV0IGEgY29tbWFuZCBjb21iaW5hdGlvbiBpc1xuICAgICAgICogICBiZWluZyB1c2VkLiBFeDogYENtZCtDYC4gTm8gY2hhcmFjdGVyIGlzIGluc2VydGVkLCBhbmQgbm9cbiAgICAgICAqICAgYGlucHV0YCBldmVudCB3aWxsIG9jY3VyLlxuICAgICAgICovXG4gICAgICBpZiAoIWlzS2V5cHJlc3NDb21tYW5kKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAvLyBJRSBmaXJlcyB0aGUgYGtleXByZXNzYCBldmVudCB3aGVuIGEgdXNlciB0eXBlcyBhbiBlbW9qaSB2aWFcbiAgICAgICAgLy8gVG91Y2gga2V5Ym9hcmQgb2YgV2luZG93cy4gIEluIHN1Y2ggYSBjYXNlLCB0aGUgYGNoYXJgIHByb3BlcnR5XG4gICAgICAgIC8vIGhvbGRzIGFuIGVtb2ppIGNoYXJhY3RlciBsaWtlIGBcXHVEODNEXFx1REUwQWAuICBCZWNhdXNlIGl0cyBsZW5ndGhcbiAgICAgICAgLy8gaXMgMiwgdGhlIHByb3BlcnR5IGB3aGljaGAgZG9lcyBub3QgcmVwcmVzZW50IGFuIGVtb2ppIGNvcnJlY3RseS5cbiAgICAgICAgLy8gSW4gc3VjaCBhIGNhc2UsIHdlIGRpcmVjdGx5IHJldHVybiB0aGUgYGNoYXJgIHByb3BlcnR5IGluc3RlYWQgb2ZcbiAgICAgICAgLy8gdXNpbmcgYHdoaWNoYC5cbiAgICAgICAgaWYgKG5hdGl2ZUV2ZW50LmNoYXIgJiYgbmF0aXZlRXZlbnQuY2hhci5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgcmV0dXJuIG5hdGl2ZUV2ZW50LmNoYXI7XG4gICAgICAgIH0gZWxzZSBpZiAobmF0aXZlRXZlbnQud2hpY2gpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShuYXRpdmVFdmVudC53aGljaCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgJ3RvcENvbXBvc2l0aW9uRW5kJzpcbiAgICAgIHJldHVybiB1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSA/IG51bGwgOiBuYXRpdmVFdmVudC5kYXRhO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEV4dHJhY3QgYSBTeW50aGV0aWNJbnB1dEV2ZW50IGZvciBgYmVmb3JlSW5wdXRgLCBiYXNlZCBvbiBlaXRoZXIgbmF0aXZlXG4gKiBgdGV4dElucHV0YCBvciBmYWxsYmFjayBiZWhhdmlvci5cbiAqXG4gKiBAcmV0dXJuIHs/b2JqZWN0fSBBIFN5bnRoZXRpY0lucHV0RXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RCZWZvcmVJbnB1dEV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHZhciBjaGFycztcblxuICBpZiAoY2FuVXNlVGV4dElucHV0RXZlbnQpIHtcbiAgICBjaGFycyA9IGdldE5hdGl2ZUJlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCk7XG4gIH0gZWxzZSB7XG4gICAgY2hhcnMgPSBnZXRGYWxsYmFja0JlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCk7XG4gIH1cblxuICAvLyBJZiBubyBjaGFyYWN0ZXJzIGFyZSBiZWluZyBpbnNlcnRlZCwgbm8gQmVmb3JlSW5wdXQgZXZlbnQgc2hvdWxkXG4gIC8vIGJlIGZpcmVkLlxuICBpZiAoIWNoYXJzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZXZlbnQgPSBTeW50aGV0aWNJbnB1dEV2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLmJlZm9yZUlucHV0LCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gIGV2ZW50LmRhdGEgPSBjaGFycztcbiAgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG4gIHJldHVybiBldmVudDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gYG9uQmVmb3JlSW5wdXRgIGV2ZW50IHRvIG1hdGNoXG4gKiBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDEzMTEwNS8jZXZlbnRzLWlucHV0ZXZlbnRzLlxuICpcbiAqIFRoaXMgZXZlbnQgcGx1Z2luIGlzIGJhc2VkIG9uIHRoZSBuYXRpdmUgYHRleHRJbnB1dGAgZXZlbnRcbiAqIGF2YWlsYWJsZSBpbiBDaHJvbWUsIFNhZmFyaSwgT3BlcmEsIGFuZCBJRS4gVGhpcyBldmVudCBmaXJlcyBhZnRlclxuICogYG9uS2V5UHJlc3NgIGFuZCBgb25Db21wb3NpdGlvbkVuZGAsIGJ1dCBiZWZvcmUgYG9uSW5wdXRgLlxuICpcbiAqIGBiZWZvcmVJbnB1dGAgaXMgc3BlYydkIGJ1dCBub3QgaW1wbGVtZW50ZWQgaW4gYW55IGJyb3dzZXJzLCBhbmRcbiAqIHRoZSBgaW5wdXRgIGV2ZW50IGRvZXMgbm90IHByb3ZpZGUgYW55IHVzZWZ1bCBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGhhc1xuICogYWN0dWFsbHkgYmVlbiBhZGRlZCwgY29udHJhcnkgdG8gdGhlIHNwZWMuIFRodXMsIGB0ZXh0SW5wdXRgIGlzIHRoZSBiZXN0XG4gKiBhdmFpbGFibGUgZXZlbnQgdG8gaWRlbnRpZnkgdGhlIGNoYXJhY3RlcnMgdGhhdCBoYXZlIGFjdHVhbGx5IGJlZW4gaW5zZXJ0ZWRcbiAqIGludG8gdGhlIHRhcmdldCBub2RlLlxuICpcbiAqIFRoaXMgcGx1Z2luIGlzIGFsc28gcmVzcG9uc2libGUgZm9yIGVtaXR0aW5nIGBjb21wb3NpdGlvbmAgZXZlbnRzLCB0aHVzXG4gKiBhbGxvd2luZyB1cyB0byBzaGFyZSBjb21wb3NpdGlvbiBmYWxsYmFjayBjb2RlIGZvciBib3RoIGBiZWZvcmVJbnB1dGAgYW5kXG4gKiBgY29tcG9zaXRpb25gIGV2ZW50IHR5cGVzLlxuICovXG52YXIgQmVmb3JlSW5wdXRFdmVudFBsdWdpbiA9IHtcbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICByZXR1cm4gW2V4dHJhY3RDb21wb3NpdGlvbkV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSwgZXh0cmFjdEJlZm9yZUlucHV0RXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpXTtcbiAgfVxufTtcblxuLy8gVXNlIHRvIHJlc3RvcmUgY29udHJvbGxlZCBzdGF0ZSBhZnRlciBhIGNoYW5nZSBldmVudCBoYXMgZmlyZWQuXG5cbnZhciBmaWJlckhvc3RDb21wb25lbnQgPSBudWxsO1xuXG52YXIgUmVhY3RDb250cm9sbGVkQ29tcG9uZW50SW5qZWN0aW9uID0ge1xuICBpbmplY3RGaWJlckNvbnRyb2xsZWRIb3N0Q29tcG9uZW50OiBmdW5jdGlvbiAoaG9zdENvbXBvbmVudEltcGwpIHtcbiAgICAvLyBUaGUgZmliZXIgaW1wbGVtZW50YXRpb24gZG9lc24ndCB1c2UgZHluYW1pYyBkaXNwYXRjaCBzbyB3ZSBuZWVkIHRvXG4gICAgLy8gaW5qZWN0IHRoZSBpbXBsZW1lbnRhdGlvbi5cbiAgICBmaWJlckhvc3RDb21wb25lbnQgPSBob3N0Q29tcG9uZW50SW1wbDtcbiAgfVxufTtcblxudmFyIHJlc3RvcmVUYXJnZXQgPSBudWxsO1xudmFyIHJlc3RvcmVRdWV1ZSA9IG51bGw7XG5cbmZ1bmN0aW9uIHJlc3RvcmVTdGF0ZU9mVGFyZ2V0KHRhcmdldCkge1xuICAvLyBXZSBwZXJmb3JtIHRoaXMgdHJhbnNsYXRpb24gYXQgdGhlIGVuZCBvZiB0aGUgZXZlbnQgbG9vcCBzbyB0aGF0IHdlXG4gIC8vIGFsd2F5cyByZWNlaXZlIHRoZSBjb3JyZWN0IGZpYmVyIGhlcmVcbiAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnN0YW5jZUZyb21Ob2RlKHRhcmdldCk7XG4gIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgIC8vIFVubW91bnRlZFxuICAgIHJldHVybjtcbiAgfVxuICAhKGZpYmVySG9zdENvbXBvbmVudCAmJiB0eXBlb2YgZmliZXJIb3N0Q29tcG9uZW50LnJlc3RvcmVDb250cm9sbGVkU3RhdGUgPT09ICdmdW5jdGlvbicpID8gaW52YXJpYW50KGZhbHNlLCAnRmliZXIgbmVlZHMgdG8gYmUgaW5qZWN0ZWQgdG8gaGFuZGxlIGEgZmliZXIgdGFyZ2V0IGZvciBjb250cm9sbGVkIGV2ZW50cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgdmFyIHByb3BzID0gZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZShpbnRlcm5hbEluc3RhbmNlLnN0YXRlTm9kZSk7XG4gIGZpYmVySG9zdENvbXBvbmVudC5yZXN0b3JlQ29udHJvbGxlZFN0YXRlKGludGVybmFsSW5zdGFuY2Uuc3RhdGVOb2RlLCBpbnRlcm5hbEluc3RhbmNlLnR5cGUsIHByb3BzKTtcbn1cblxudmFyIGluamVjdGlvbiQzID0gUmVhY3RDb250cm9sbGVkQ29tcG9uZW50SW5qZWN0aW9uO1xuXG5mdW5jdGlvbiBlbnF1ZXVlU3RhdGVSZXN0b3JlKHRhcmdldCkge1xuICBpZiAocmVzdG9yZVRhcmdldCkge1xuICAgIGlmIChyZXN0b3JlUXVldWUpIHtcbiAgICAgIHJlc3RvcmVRdWV1ZS5wdXNoKHRhcmdldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3RvcmVRdWV1ZSA9IFt0YXJnZXRdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXN0b3JlVGFyZ2V0ID0gdGFyZ2V0O1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3RvcmVTdGF0ZUlmTmVlZGVkKCkge1xuICBpZiAoIXJlc3RvcmVUYXJnZXQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHRhcmdldCA9IHJlc3RvcmVUYXJnZXQ7XG4gIHZhciBxdWV1ZWRUYXJnZXRzID0gcmVzdG9yZVF1ZXVlO1xuICByZXN0b3JlVGFyZ2V0ID0gbnVsbDtcbiAgcmVzdG9yZVF1ZXVlID0gbnVsbDtcblxuICByZXN0b3JlU3RhdGVPZlRhcmdldCh0YXJnZXQpO1xuICBpZiAocXVldWVkVGFyZ2V0cykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWVkVGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzdG9yZVN0YXRlT2ZUYXJnZXQocXVldWVkVGFyZ2V0c1tpXSk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdENvbnRyb2xsZWRDb21wb25lbnQgPSBPYmplY3QuZnJlZXplKHtcblx0aW5qZWN0aW9uOiBpbmplY3Rpb24kMyxcblx0ZW5xdWV1ZVN0YXRlUmVzdG9yZTogZW5xdWV1ZVN0YXRlUmVzdG9yZSxcblx0cmVzdG9yZVN0YXRlSWZOZWVkZWQ6IHJlc3RvcmVTdGF0ZUlmTmVlZGVkXG59KTtcblxuLy8gVXNlZCBhcyBhIHdheSB0byBjYWxsIGJhdGNoZWRVcGRhdGVzIHdoZW4gd2UgZG9uJ3QgaGF2ZSBhIHJlZmVyZW5jZSB0b1xuLy8gdGhlIHJlbmRlcmVyLiBTdWNoIGFzIHdoZW4gd2UncmUgZGlzcGF0Y2hpbmcgZXZlbnRzIG9yIGlmIHRoaXJkIHBhcnR5XG4vLyBsaWJyYXJpZXMgbmVlZCB0byBjYWxsIGJhdGNoZWRVcGRhdGVzLiBFdmVudHVhbGx5LCB0aGlzIEFQSSB3aWxsIGdvIGF3YXkgd2hlblxuLy8gZXZlcnl0aGluZyBpcyBiYXRjaGVkIGJ5IGRlZmF1bHQuIFdlJ2xsIHRoZW4gaGF2ZSBhIHNpbWlsYXIgQVBJIHRvIG9wdC1vdXQgb2Zcbi8vIHNjaGVkdWxlZCB3b3JrIGFuZCBpbnN0ZWFkIGRvIHN5bmNocm9ub3VzIHdvcmsuXG5cbi8vIERlZmF1bHRzXG52YXIgZmliZXJCYXRjaGVkVXBkYXRlcyA9IGZ1bmN0aW9uIChmbiwgYm9va2tlZXBpbmcpIHtcbiAgcmV0dXJuIGZuKGJvb2trZWVwaW5nKTtcbn07XG5cbnZhciBpc05lc3RpbmdCYXRjaGVkID0gZmFsc2U7XG5mdW5jdGlvbiBiYXRjaGVkVXBkYXRlcyhmbiwgYm9va2tlZXBpbmcpIHtcbiAgaWYgKGlzTmVzdGluZ0JhdGNoZWQpIHtcbiAgICAvLyBJZiB3ZSBhcmUgY3VycmVudGx5IGluc2lkZSBhbm90aGVyIGJhdGNoLCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXRcbiAgICAvLyBmdWxseSBjb21wbGV0ZXMgYmVmb3JlIHJlc3RvcmluZyBzdGF0ZS4gVGhlcmVmb3JlLCB3ZSBhZGQgdGhlIHRhcmdldCB0b1xuICAgIC8vIGEgcXVldWUgb2Ygd29yay5cbiAgICByZXR1cm4gZmliZXJCYXRjaGVkVXBkYXRlcyhmbiwgYm9va2tlZXBpbmcpO1xuICB9XG4gIGlzTmVzdGluZ0JhdGNoZWQgPSB0cnVlO1xuICB0cnkge1xuICAgIHJldHVybiBmaWJlckJhdGNoZWRVcGRhdGVzKGZuLCBib29ra2VlcGluZyk7XG4gIH0gZmluYWxseSB7XG4gICAgLy8gSGVyZSB3ZSB3YWl0IHVudGlsIGFsbCB1cGRhdGVzIGhhdmUgcHJvcGFnYXRlZCwgd2hpY2ggaXMgaW1wb3J0YW50XG4gICAgLy8gd2hlbiB1c2luZyBjb250cm9sbGVkIGNvbXBvbmVudHMgd2l0aGluIGxheWVyczpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE2OThcbiAgICAvLyBUaGVuIHdlIHJlc3RvcmUgc3RhdGUgb2YgYW55IGNvbnRyb2xsZWQgY29tcG9uZW50LlxuICAgIGlzTmVzdGluZ0JhdGNoZWQgPSBmYWxzZTtcbiAgICByZXN0b3JlU3RhdGVJZk5lZWRlZCgpO1xuICB9XG59XG5cbnZhciBSZWFjdEdlbmVyaWNCYXRjaGluZ0luamVjdGlvbiA9IHtcbiAgaW5qZWN0RmliZXJCYXRjaGVkVXBkYXRlczogZnVuY3Rpb24gKF9iYXRjaGVkVXBkYXRlcykge1xuICAgIGZpYmVyQmF0Y2hlZFVwZGF0ZXMgPSBfYmF0Y2hlZFVwZGF0ZXM7XG4gIH1cbn07XG5cbnZhciBpbmplY3Rpb24kNCA9IFJlYWN0R2VuZXJpY0JhdGNoaW5nSW5qZWN0aW9uO1xuXG4vKipcbiAqIEBzZWUgaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLWlucHV0LWVsZW1lbnQuaHRtbCNpbnB1dC10eXBlLWF0dHItc3VtbWFyeVxuICovXG52YXIgc3VwcG9ydGVkSW5wdXRUeXBlcyA9IHtcbiAgY29sb3I6IHRydWUsXG4gIGRhdGU6IHRydWUsXG4gIGRhdGV0aW1lOiB0cnVlLFxuICAnZGF0ZXRpbWUtbG9jYWwnOiB0cnVlLFxuICBlbWFpbDogdHJ1ZSxcbiAgbW9udGg6IHRydWUsXG4gIG51bWJlcjogdHJ1ZSxcbiAgcGFzc3dvcmQ6IHRydWUsXG4gIHJhbmdlOiB0cnVlLFxuICBzZWFyY2g6IHRydWUsXG4gIHRlbDogdHJ1ZSxcbiAgdGV4dDogdHJ1ZSxcbiAgdGltZTogdHJ1ZSxcbiAgdXJsOiB0cnVlLFxuICB3ZWVrOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBpc1RleHRJbnB1dEVsZW1lbnQoZWxlbSkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtICYmIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gIGlmIChub2RlTmFtZSA9PT0gJ2lucHV0Jykge1xuICAgIHJldHVybiAhIXN1cHBvcnRlZElucHV0VHlwZXNbZWxlbS50eXBlXTtcbiAgfVxuXG4gIGlmIChub2RlTmFtZSA9PT0gJ3RleHRhcmVhJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEhUTUwgbm9kZVR5cGUgdmFsdWVzIHRoYXQgcmVwcmVzZW50IHRoZSB0eXBlIG9mIHRoZSBub2RlXG4gKi9cblxudmFyIEVMRU1FTlRfTk9ERSA9IDE7XG52YXIgVEVYVF9OT0RFID0gMztcbnZhciBDT01NRU5UX05PREUgPSA4O1xudmFyIERPQ1VNRU5UX05PREUgPSA5O1xudmFyIERPQ1VNRU5UX0ZSQUdNRU5UX05PREUgPSAxMTtcblxuLyoqXG4gKiBHZXRzIHRoZSB0YXJnZXQgbm9kZSBmcm9tIGEgbmF0aXZlIGJyb3dzZXIgZXZlbnQgYnkgYWNjb3VudGluZyBmb3JcbiAqIGluY29uc2lzdGVuY2llcyBpbiBicm93c2VyIERPTSBBUElzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge0RPTUV2ZW50VGFyZ2V0fSBUYXJnZXQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpIHtcbiAgdmFyIHRhcmdldCA9IG5hdGl2ZUV2ZW50LnRhcmdldCB8fCBuYXRpdmVFdmVudC5zcmNFbGVtZW50IHx8IHdpbmRvdztcblxuICAvLyBOb3JtYWxpemUgU1ZHIDx1c2U+IGVsZW1lbnQgZXZlbnRzICM0OTYzXG4gIGlmICh0YXJnZXQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQpIHtcbiAgICB0YXJnZXQgPSB0YXJnZXQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQ7XG4gIH1cblxuICAvLyBTYWZhcmkgbWF5IGZpcmUgZXZlbnRzIG9uIHRleHQgbm9kZXMgKE5vZGUuVEVYVF9OT0RFIGlzIDMpLlxuICAvLyBAc2VlIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvanMvZXZlbnRzX3Byb3BlcnRpZXMuaHRtbFxuICByZXR1cm4gdGFyZ2V0Lm5vZGVUeXBlID09PSBURVhUX05PREUgPyB0YXJnZXQucGFyZW50Tm9kZSA6IHRhcmdldDtcbn1cblxudmFyIHVzZUhhc0ZlYXR1cmU7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHVzZUhhc0ZlYXR1cmUgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbiAmJiBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlICYmXG4gIC8vIGFsd2F5cyByZXR1cm5zIHRydWUgaW4gbmV3ZXIgYnJvd3NlcnMgYXMgcGVyIHRoZSBzdGFuZGFyZC5cbiAgLy8gQHNlZSBodHRwOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLWRvbWltcGxlbWVudGF0aW9uLWhhc2ZlYXR1cmVcbiAgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZSgnJywgJycpICE9PSB0cnVlO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhbiBldmVudCBpcyBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGVudmlyb25tZW50LlxuICpcbiAqIE5PVEU6IFRoaXMgd2lsbCBub3Qgd29yayBjb3JyZWN0bHkgZm9yIG5vbi1nZW5lcmljIGV2ZW50cyBzdWNoIGFzIGBjaGFuZ2VgLFxuICogYHJlc2V0YCwgYGxvYWRgLCBgZXJyb3JgLCBhbmQgYHNlbGVjdGAuXG4gKlxuICogQm9ycm93cyBmcm9tIE1vZGVybml6ci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lU3VmZml4IEV2ZW50IG5hbWUsIGUuZy4gXCJjbGlja1wiLlxuICogQHBhcmFtIHs/Ym9vbGVhbn0gY2FwdHVyZSBDaGVjayBpZiB0aGUgY2FwdHVyZSBwaGFzZSBpcyBzdXBwb3J0ZWQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCBpcyBzdXBwb3J0ZWQuXG4gKiBAaW50ZXJuYWxcbiAqIEBsaWNlbnNlIE1vZGVybml6ciAzLjAuMHByZSAoQ3VzdG9tIEJ1aWxkKSB8IE1JVFxuICovXG5mdW5jdGlvbiBpc0V2ZW50U3VwcG9ydGVkKGV2ZW50TmFtZVN1ZmZpeCwgY2FwdHVyZSkge1xuICBpZiAoIUV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSB8fCBjYXB0dXJlICYmICEoJ2FkZEV2ZW50TGlzdGVuZXInIGluIGRvY3VtZW50KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBldmVudE5hbWUgPSAnb24nICsgZXZlbnROYW1lU3VmZml4O1xuICB2YXIgaXNTdXBwb3J0ZWQgPSBldmVudE5hbWUgaW4gZG9jdW1lbnQ7XG5cbiAgaWYgKCFpc1N1cHBvcnRlZCkge1xuICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoZXZlbnROYW1lLCAncmV0dXJuOycpO1xuICAgIGlzU3VwcG9ydGVkID0gdHlwZW9mIGVsZW1lbnRbZXZlbnROYW1lXSA9PT0gJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIGlmICghaXNTdXBwb3J0ZWQgJiYgdXNlSGFzRmVhdHVyZSAmJiBldmVudE5hbWVTdWZmaXggPT09ICd3aGVlbCcpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBvbmx5IHdheSB0byB0ZXN0IHN1cHBvcnQgZm9yIHRoZSBgd2hlZWxgIGV2ZW50IGluIElFOSsuXG4gICAgaXNTdXBwb3J0ZWQgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKCdFdmVudHMud2hlZWwnLCAnMy4wJyk7XG4gIH1cblxuICByZXR1cm4gaXNTdXBwb3J0ZWQ7XG59XG5cbmZ1bmN0aW9uIGlzQ2hlY2thYmxlKGVsZW0pIHtcbiAgdmFyIHR5cGUgPSBlbGVtLnR5cGU7XG4gIHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWU7XG4gIHJldHVybiBub2RlTmFtZSAmJiBub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnICYmICh0eXBlID09PSAnY2hlY2tib3gnIHx8IHR5cGUgPT09ICdyYWRpbycpO1xufVxuXG5mdW5jdGlvbiBnZXRUcmFja2VyKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuX3ZhbHVlVHJhY2tlcjtcbn1cblxuZnVuY3Rpb24gZGV0YWNoVHJhY2tlcihub2RlKSB7XG4gIG5vZGUuX3ZhbHVlVHJhY2tlciA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlRnJvbU5vZGUobm9kZSkge1xuICB2YXIgdmFsdWUgPSAnJztcbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgaWYgKGlzQ2hlY2thYmxlKG5vZGUpKSB7XG4gICAgdmFsdWUgPSBub2RlLmNoZWNrZWQgPyAndHJ1ZScgOiAnZmFsc2UnO1xuICB9IGVsc2Uge1xuICAgIHZhbHVlID0gbm9kZS52YWx1ZTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gdHJhY2tWYWx1ZU9uTm9kZShub2RlKSB7XG4gIHZhciB2YWx1ZUZpZWxkID0gaXNDaGVja2FibGUobm9kZSkgPyAnY2hlY2tlZCcgOiAndmFsdWUnO1xuICB2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iobm9kZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHZhbHVlRmllbGQpO1xuXG4gIHZhciBjdXJyZW50VmFsdWUgPSAnJyArIG5vZGVbdmFsdWVGaWVsZF07XG5cbiAgLy8gaWYgc29tZW9uZSBoYXMgYWxyZWFkeSBkZWZpbmVkIGEgdmFsdWUgb3IgU2FmYXJpLCB0aGVuIGJhaWxcbiAgLy8gYW5kIGRvbid0IHRyYWNrIHZhbHVlIHdpbGwgY2F1c2Ugb3ZlciByZXBvcnRpbmcgb2YgY2hhbmdlcyxcbiAgLy8gYnV0IGl0J3MgYmV0dGVyIHRoZW4gYSBoYXJkIGZhaWx1cmVcbiAgLy8gKG5lZWRlZCBmb3IgY2VydGFpbiB0ZXN0cyB0aGF0IHNweU9uIGlucHV0IHZhbHVlcyBhbmQgU2FmYXJpKVxuICBpZiAobm9kZS5oYXNPd25Qcm9wZXJ0eSh2YWx1ZUZpZWxkKSB8fCB0eXBlb2YgZGVzY3JpcHRvci5nZXQgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGRlc2NyaXB0b3Iuc2V0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5vZGUsIHZhbHVlRmllbGQsIHtcbiAgICBlbnVtZXJhYmxlOiBkZXNjcmlwdG9yLmVudW1lcmFibGUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGRlc2NyaXB0b3IuZ2V0LmNhbGwodGhpcyk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgY3VycmVudFZhbHVlID0gJycgKyB2YWx1ZTtcbiAgICAgIGRlc2NyaXB0b3Iuc2V0LmNhbGwodGhpcywgdmFsdWUpO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIHRyYWNrZXIgPSB7XG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBjdXJyZW50VmFsdWU7XG4gICAgfSxcbiAgICBzZXRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBjdXJyZW50VmFsdWUgPSAnJyArIHZhbHVlO1xuICAgIH0sXG4gICAgc3RvcFRyYWNraW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICBkZXRhY2hUcmFja2VyKG5vZGUpO1xuICAgICAgZGVsZXRlIG5vZGVbdmFsdWVGaWVsZF07XG4gICAgfVxuICB9O1xuICByZXR1cm4gdHJhY2tlcjtcbn1cblxuZnVuY3Rpb24gdHJhY2sobm9kZSkge1xuICBpZiAoZ2V0VHJhY2tlcihub2RlKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFRPRE86IE9uY2UgaXQncyBqdXN0IEZpYmVyIHdlIGNhbiBtb3ZlIHRoaXMgdG8gbm9kZS5fd3JhcHBlclN0YXRlXG4gIG5vZGUuX3ZhbHVlVHJhY2tlciA9IHRyYWNrVmFsdWVPbk5vZGUobm9kZSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVZhbHVlSWZDaGFuZ2VkKG5vZGUpIHtcbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHRyYWNrZXIgPSBnZXRUcmFja2VyKG5vZGUpO1xuICAvLyBpZiB0aGVyZSBpcyBubyB0cmFja2VyIGF0IHRoaXMgcG9pbnQgaXQncyB1bmxpa2VseVxuICAvLyB0aGF0IHRyeWluZyBhZ2FpbiB3aWxsIHN1Y2NlZWRcbiAgaWYgKCF0cmFja2VyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgbGFzdFZhbHVlID0gdHJhY2tlci5nZXRWYWx1ZSgpO1xuICB2YXIgbmV4dFZhbHVlID0gZ2V0VmFsdWVGcm9tTm9kZShub2RlKTtcbiAgaWYgKG5leHRWYWx1ZSAhPT0gbGFzdFZhbHVlKSB7XG4gICAgdHJhY2tlci5zZXRWYWx1ZShuZXh0VmFsdWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIGV2ZW50VHlwZXMkMSA9IHtcbiAgY2hhbmdlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvbkNoYW5nZScsXG4gICAgICBjYXB0dXJlZDogJ29uQ2hhbmdlQ2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BCbHVyJywgJ3RvcENoYW5nZScsICd0b3BDbGljaycsICd0b3BGb2N1cycsICd0b3BJbnB1dCcsICd0b3BLZXlEb3duJywgJ3RvcEtleVVwJywgJ3RvcFNlbGVjdGlvbkNoYW5nZSddXG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUFuZEFjY3VtdWxhdGVDaGFuZ2VFdmVudChpbnN0LCBuYXRpdmVFdmVudCwgdGFyZ2V0KSB7XG4gIHZhciBldmVudCA9IFN5bnRoZXRpY0V2ZW50JDEuZ2V0UG9vbGVkKGV2ZW50VHlwZXMkMS5jaGFuZ2UsIGluc3QsIG5hdGl2ZUV2ZW50LCB0YXJnZXQpO1xuICBldmVudC50eXBlID0gJ2NoYW5nZSc7XG4gIC8vIEZsYWcgdGhpcyBldmVudCBsb29wIGFzIG5lZWRpbmcgc3RhdGUgcmVzdG9yZS5cbiAgZW5xdWV1ZVN0YXRlUmVzdG9yZSh0YXJnZXQpO1xuICBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgcmV0dXJuIGV2ZW50O1xufVxuLyoqXG4gKiBGb3IgSUUgc2hpbXNcbiAqL1xudmFyIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRJbnN0ID0gbnVsbDtcblxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGNoYW5nZWAgZXZlbnRcbiAqL1xuZnVuY3Rpb24gc2hvdWxkVXNlQ2hhbmdlRXZlbnQoZWxlbSkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIG5vZGVOYW1lID09PSAnc2VsZWN0JyB8fCBub2RlTmFtZSA9PT0gJ2lucHV0JyAmJiBlbGVtLnR5cGUgPT09ICdmaWxlJztcbn1cblxuZnVuY3Rpb24gbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudChuYXRpdmVFdmVudCkge1xuICB2YXIgZXZlbnQgPSBjcmVhdGVBbmRBY2N1bXVsYXRlQ2hhbmdlRXZlbnQoYWN0aXZlRWxlbWVudEluc3QsIG5hdGl2ZUV2ZW50LCBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCkpO1xuXG4gIC8vIElmIGNoYW5nZSBhbmQgcHJvcGVydHljaGFuZ2UgYnViYmxlZCwgd2UnZCBqdXN0IGJpbmQgdG8gaXQgbGlrZSBhbGwgdGhlXG4gIC8vIG90aGVyIGV2ZW50cyBhbmQgaGF2ZSBpdCBnbyB0aHJvdWdoIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci4gU2luY2UgaXRcbiAgLy8gZG9lc24ndCwgd2UgbWFudWFsbHkgbGlzdGVuIGZvciB0aGUgZXZlbnRzIGFuZCBzbyB3ZSBoYXZlIHRvIGVucXVldWUgYW5kXG4gIC8vIHByb2Nlc3MgdGhlIGFic3RyYWN0IGV2ZW50IG1hbnVhbGx5LlxuICAvL1xuICAvLyBCYXRjaGluZyBpcyBuZWNlc3NhcnkgaGVyZSBpbiBvcmRlciB0byBlbnN1cmUgdGhhdCBhbGwgZXZlbnQgaGFuZGxlcnMgcnVuXG4gIC8vIGJlZm9yZSB0aGUgbmV4dCByZXJlbmRlciAoaW5jbHVkaW5nIGV2ZW50IGhhbmRsZXJzIGF0dGFjaGVkIHRvIGFuY2VzdG9yXG4gIC8vIGVsZW1lbnRzIGluc3RlYWQgb2YgZGlyZWN0bHkgb24gdGhlIGlucHV0KS4gV2l0aG91dCB0aGlzLCBjb250cm9sbGVkXG4gIC8vIGNvbXBvbmVudHMgZG9uJ3Qgd29yayBwcm9wZXJseSBpbiBjb25qdW5jdGlvbiB3aXRoIGV2ZW50IGJ1YmJsaW5nIGJlY2F1c2VcbiAgLy8gdGhlIGNvbXBvbmVudCBpcyByZXJlbmRlcmVkIGFuZCB0aGUgdmFsdWUgcmV2ZXJ0ZWQgYmVmb3JlIGFsbCB0aGUgZXZlbnRcbiAgLy8gaGFuZGxlcnMgY2FuIHJ1bi4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzA4LlxuICBiYXRjaGVkVXBkYXRlcyhydW5FdmVudEluQmF0Y2gsIGV2ZW50KTtcbn1cblxuZnVuY3Rpb24gcnVuRXZlbnRJbkJhdGNoKGV2ZW50KSB7XG4gIGVucXVldWVFdmVudHMoZXZlbnQpO1xuICBwcm9jZXNzRXZlbnRRdWV1ZShmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIGdldEluc3RJZlZhbHVlQ2hhbmdlZCh0YXJnZXRJbnN0KSB7XG4gIHZhciB0YXJnZXROb2RlID0gZ2V0Tm9kZUZyb21JbnN0YW5jZSQxKHRhcmdldEluc3QpO1xuICBpZiAodXBkYXRlVmFsdWVJZkNoYW5nZWQodGFyZ2V0Tm9kZSkpIHtcbiAgICByZXR1cm4gdGFyZ2V0SW5zdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9yQ2hhbmdlRXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BDaGFuZ2UnKSB7XG4gICAgcmV0dXJuIHRhcmdldEluc3Q7XG4gIH1cbn1cblxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGlucHV0YCBldmVudFxuICovXG52YXIgaXNJbnB1dEV2ZW50U3VwcG9ydGVkID0gZmFsc2U7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIC8vIElFOSBjbGFpbXMgdG8gc3VwcG9ydCB0aGUgaW5wdXQgZXZlbnQgYnV0IGZhaWxzIHRvIHRyaWdnZXIgaXQgd2hlblxuICAvLyBkZWxldGluZyB0ZXh0LCBzbyB3ZSBpZ25vcmUgaXRzIGlucHV0IGV2ZW50cy5cbiAgaXNJbnB1dEV2ZW50U3VwcG9ydGVkID0gaXNFdmVudFN1cHBvcnRlZCgnaW5wdXQnKSAmJiAoIWRvY3VtZW50LmRvY3VtZW50TW9kZSB8fCBkb2N1bWVudC5kb2N1bWVudE1vZGUgPiA5KTtcbn1cblxuLyoqXG4gKiAoRm9yIElFIDw9OSkgU3RhcnRzIHRyYWNraW5nIHByb3BlcnR5Y2hhbmdlIGV2ZW50cyBvbiB0aGUgcGFzc2VkLWluIGVsZW1lbnRcbiAqIGFuZCBvdmVycmlkZSB0aGUgdmFsdWUgcHJvcGVydHkgc28gdGhhdCB3ZSBjYW4gZGlzdGluZ3Vpc2ggdXNlciBldmVudHMgZnJvbVxuICogdmFsdWUgY2hhbmdlcyBpbiBKUy5cbiAqL1xuZnVuY3Rpb24gc3RhcnRXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKHRhcmdldCwgdGFyZ2V0SW5zdCkge1xuICBhY3RpdmVFbGVtZW50ID0gdGFyZ2V0O1xuICBhY3RpdmVFbGVtZW50SW5zdCA9IHRhcmdldEluc3Q7XG4gIGFjdGl2ZUVsZW1lbnQuYXR0YWNoRXZlbnQoJ29ucHJvcGVydHljaGFuZ2UnLCBoYW5kbGVQcm9wZXJ0eUNoYW5nZSk7XG59XG5cbi8qKlxuICogKEZvciBJRSA8PTkpIFJlbW92ZXMgdGhlIGV2ZW50IGxpc3RlbmVycyBmcm9tIHRoZSBjdXJyZW50bHktdHJhY2tlZCBlbGVtZW50LFxuICogaWYgYW55IGV4aXN0cy5cbiAqL1xuZnVuY3Rpb24gc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKSB7XG4gIGlmICghYWN0aXZlRWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBhY3RpdmVFbGVtZW50LmRldGFjaEV2ZW50KCdvbnByb3BlcnR5Y2hhbmdlJywgaGFuZGxlUHJvcGVydHlDaGFuZ2UpO1xuICBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgYWN0aXZlRWxlbWVudEluc3QgPSBudWxsO1xufVxuXG4vKipcbiAqIChGb3IgSUUgPD05KSBIYW5kbGVzIGEgcHJvcGVydHljaGFuZ2UgZXZlbnQsIHNlbmRpbmcgYSBgY2hhbmdlYCBldmVudCBpZlxuICogdGhlIHZhbHVlIG9mIHRoZSBhY3RpdmUgZWxlbWVudCBoYXMgY2hhbmdlZC5cbiAqL1xuZnVuY3Rpb24gaGFuZGxlUHJvcGVydHlDaGFuZ2UobmF0aXZlRXZlbnQpIHtcbiAgaWYgKG5hdGl2ZUV2ZW50LnByb3BlcnR5TmFtZSAhPT0gJ3ZhbHVlJykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKGFjdGl2ZUVsZW1lbnRJbnN0KSkge1xuICAgIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQobmF0aXZlRXZlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRQb2x5ZmlsbCh0b3BMZXZlbFR5cGUsIHRhcmdldCwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wRm9jdXMnKSB7XG4gICAgLy8gSW4gSUU5LCBwcm9wZXJ0eWNoYW5nZSBmaXJlcyBmb3IgbW9zdCBpbnB1dCBldmVudHMgYnV0IGlzIGJ1Z2d5IGFuZFxuICAgIC8vIGRvZXNuJ3QgZmlyZSB3aGVuIHRleHQgaXMgZGVsZXRlZCwgYnV0IGNvbnZlbmllbnRseSwgc2VsZWN0aW9uY2hhbmdlXG4gICAgLy8gYXBwZWFycyB0byBmaXJlIGluIGFsbCBvZiB0aGUgcmVtYWluaW5nIGNhc2VzIHNvIHdlIGNhdGNoIHRob3NlIGFuZFxuICAgIC8vIGZvcndhcmQgdGhlIGV2ZW50IGlmIHRoZSB2YWx1ZSBoYXMgY2hhbmdlZFxuICAgIC8vIEluIGVpdGhlciBjYXNlLCB3ZSBkb24ndCB3YW50IHRvIGNhbGwgdGhlIGV2ZW50IGhhbmRsZXIgaWYgdGhlIHZhbHVlXG4gICAgLy8gaXMgY2hhbmdlZCBmcm9tIEpTIHNvIHdlIHJlZGVmaW5lIGEgc2V0dGVyIGZvciBgLnZhbHVlYCB0aGF0IHVwZGF0ZXNcbiAgICAvLyBvdXIgYWN0aXZlRWxlbWVudFZhbHVlIHZhcmlhYmxlLCBhbGxvd2luZyB1cyB0byBpZ25vcmUgdGhvc2UgY2hhbmdlc1xuICAgIC8vXG4gICAgLy8gc3RvcFdhdGNoaW5nKCkgc2hvdWxkIGJlIGEgbm9vcCBoZXJlIGJ1dCB3ZSBjYWxsIGl0IGp1c3QgaW4gY2FzZSB3ZVxuICAgIC8vIG1pc3NlZCBhIGJsdXIgZXZlbnQgc29tZWhvdy5cbiAgICBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpO1xuICAgIHN0YXJ0V2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSh0YXJnZXQsIHRhcmdldEluc3QpO1xuICB9IGVsc2UgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcEJsdXInKSB7XG4gICAgc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKTtcbiAgfVxufVxuXG4vLyBGb3IgSUU4IGFuZCBJRTkuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudFBvbHlmaWxsKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wU2VsZWN0aW9uQ2hhbmdlJyB8fCB0b3BMZXZlbFR5cGUgPT09ICd0b3BLZXlVcCcgfHwgdG9wTGV2ZWxUeXBlID09PSAndG9wS2V5RG93bicpIHtcbiAgICAvLyBPbiB0aGUgc2VsZWN0aW9uY2hhbmdlIGV2ZW50LCB0aGUgdGFyZ2V0IGlzIGp1c3QgZG9jdW1lbnQgd2hpY2ggaXNuJ3RcbiAgICAvLyBoZWxwZnVsIGZvciB1cyBzbyBqdXN0IGNoZWNrIGFjdGl2ZUVsZW1lbnQgaW5zdGVhZC5cbiAgICAvL1xuICAgIC8vIDk5JSBvZiB0aGUgdGltZSwga2V5ZG93biBhbmQga2V5dXAgYXJlbid0IG5lY2Vzc2FyeS4gSUU4IGZhaWxzIHRvIGZpcmVcbiAgICAvLyBwcm9wZXJ0eWNoYW5nZSBvbiB0aGUgZmlyc3QgaW5wdXQgZXZlbnQgYWZ0ZXIgc2V0dGluZyBgdmFsdWVgIGZyb20gYVxuICAgIC8vIHNjcmlwdCBhbmQgZmlyZXMgb25seSBrZXlkb3duLCBrZXlwcmVzcywga2V5dXAuIENhdGNoaW5nIGtleXVwIHVzdWFsbHlcbiAgICAvLyBnZXRzIGl0IGFuZCBjYXRjaGluZyBrZXlkb3duIGxldHMgdXMgZmlyZSBhbiBldmVudCBmb3IgdGhlIGZpcnN0XG4gICAgLy8ga2V5c3Ryb2tlIGlmIHVzZXIgZG9lcyBhIGtleSByZXBlYXQgKGl0J2xsIGJlIGEgbGl0dGxlIGRlbGF5ZWQ6IHJpZ2h0XG4gICAgLy8gYmVmb3JlIHRoZSBzZWNvbmQga2V5c3Ryb2tlKS4gT3RoZXIgaW5wdXQgbWV0aG9kcyAoZS5nLiwgcGFzdGUpIHNlZW0gdG9cbiAgICAvLyBmaXJlIHNlbGVjdGlvbmNoYW5nZSBub3JtYWxseS5cbiAgICByZXR1cm4gZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKGFjdGl2ZUVsZW1lbnRJbnN0KTtcbiAgfVxufVxuXG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgY2xpY2tgIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIHNob3VsZFVzZUNsaWNrRXZlbnQoZWxlbSkge1xuICAvLyBVc2UgdGhlIGBjbGlja2AgZXZlbnQgdG8gZGV0ZWN0IGNoYW5nZXMgdG8gY2hlY2tib3ggYW5kIHJhZGlvIGlucHV0cy5cbiAgLy8gVGhpcyBhcHByb2FjaCB3b3JrcyBhY3Jvc3MgYWxsIGJyb3dzZXJzLCB3aGVyZWFzIGBjaGFuZ2VgIGRvZXMgbm90IGZpcmVcbiAgLy8gdW50aWwgYGJsdXJgIGluIElFOC5cbiAgdmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZTtcbiAgcmV0dXJuIG5vZGVOYW1lICYmIG5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcgJiYgKGVsZW0udHlwZSA9PT0gJ2NoZWNrYm94JyB8fCBlbGVtLnR5cGUgPT09ICdyYWRpbycpO1xufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9yQ2xpY2tFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcENsaWNrJykge1xuICAgIHJldHVybiBnZXRJbnN0SWZWYWx1ZUNoYW5nZWQodGFyZ2V0SW5zdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VGFyZ2V0SW5zdEZvcklucHV0T3JDaGFuZ2VFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcElucHV0JyB8fCB0b3BMZXZlbFR5cGUgPT09ICd0b3BDaGFuZ2UnKSB7XG4gICAgcmV0dXJuIGdldEluc3RJZlZhbHVlQ2hhbmdlZCh0YXJnZXRJbnN0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVDb250cm9sbGVkSW5wdXRCbHVyKGluc3QsIG5vZGUpIHtcbiAgLy8gVE9ETzogSW4gSUUsIGluc3QgaXMgb2NjYXNpb25hbGx5IG51bGwuIFdoeT9cbiAgaWYgKGluc3QgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEZpYmVyIGFuZCBSZWFjdERPTSBrZWVwIHdyYXBwZXIgc3RhdGUgaW4gc2VwYXJhdGUgcGxhY2VzXG4gIHZhciBzdGF0ZSA9IGluc3QuX3dyYXBwZXJTdGF0ZSB8fCBub2RlLl93cmFwcGVyU3RhdGU7XG5cbiAgaWYgKCFzdGF0ZSB8fCAhc3RhdGUuY29udHJvbGxlZCB8fCBub2RlLnR5cGUgIT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSWYgY29udHJvbGxlZCwgYXNzaWduIHRoZSB2YWx1ZSBhdHRyaWJ1dGUgdG8gdGhlIGN1cnJlbnQgdmFsdWUgb24gYmx1clxuICB2YXIgdmFsdWUgPSAnJyArIG5vZGUudmFsdWU7XG4gIGlmIChub2RlLmdldEF0dHJpYnV0ZSgndmFsdWUnKSAhPT0gdmFsdWUpIHtcbiAgICBub2RlLnNldEF0dHJpYnV0ZSgndmFsdWUnLCB2YWx1ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIHBsdWdpbiBjcmVhdGVzIGFuIGBvbkNoYW5nZWAgZXZlbnQgdGhhdCBub3JtYWxpemVzIGNoYW5nZSBldmVudHNcbiAqIGFjcm9zcyBmb3JtIGVsZW1lbnRzLiBUaGlzIGV2ZW50IGZpcmVzIGF0IGEgdGltZSB3aGVuIGl0J3MgcG9zc2libGUgdG9cbiAqIGNoYW5nZSB0aGUgZWxlbWVudCdzIHZhbHVlIHdpdGhvdXQgc2VlaW5nIGEgZmxpY2tlci5cbiAqXG4gKiBTdXBwb3J0ZWQgZWxlbWVudHMgYXJlOlxuICogLSBpbnB1dCAoc2VlIGBpc1RleHRJbnB1dEVsZW1lbnRgKVxuICogLSB0ZXh0YXJlYVxuICogLSBzZWxlY3RcbiAqL1xudmFyIENoYW5nZUV2ZW50UGx1Z2luID0ge1xuICBldmVudFR5cGVzOiBldmVudFR5cGVzJDEsXG5cbiAgX2lzSW5wdXRFdmVudFN1cHBvcnRlZDogaXNJbnB1dEV2ZW50U3VwcG9ydGVkLFxuXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHZhciB0YXJnZXROb2RlID0gdGFyZ2V0SW5zdCA/IGdldE5vZGVGcm9tSW5zdGFuY2UkMSh0YXJnZXRJbnN0KSA6IHdpbmRvdztcblxuICAgIHZhciBnZXRUYXJnZXRJbnN0RnVuYywgaGFuZGxlRXZlbnRGdW5jO1xuICAgIGlmIChzaG91bGRVc2VDaGFuZ2VFdmVudCh0YXJnZXROb2RlKSkge1xuICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9yQ2hhbmdlRXZlbnQ7XG4gICAgfSBlbHNlIGlmIChpc1RleHRJbnB1dEVsZW1lbnQodGFyZ2V0Tm9kZSkpIHtcbiAgICAgIGlmIChpc0lucHV0RXZlbnRTdXBwb3J0ZWQpIHtcbiAgICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRPckNoYW5nZUV2ZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudFBvbHlmaWxsO1xuICAgICAgICBoYW5kbGVFdmVudEZ1bmMgPSBoYW5kbGVFdmVudHNGb3JJbnB1dEV2ZW50UG9seWZpbGw7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzaG91bGRVc2VDbGlja0V2ZW50KHRhcmdldE5vZGUpKSB7XG4gICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JDbGlja0V2ZW50O1xuICAgIH1cblxuICAgIGlmIChnZXRUYXJnZXRJbnN0RnVuYykge1xuICAgICAgdmFyIGluc3QgPSBnZXRUYXJnZXRJbnN0RnVuYyh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpO1xuICAgICAgaWYgKGluc3QpIHtcbiAgICAgICAgdmFyIGV2ZW50ID0gY3JlYXRlQW5kQWNjdW11bGF0ZUNoYW5nZUV2ZW50KGluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGFuZGxlRXZlbnRGdW5jKSB7XG4gICAgICBoYW5kbGVFdmVudEZ1bmModG9wTGV2ZWxUeXBlLCB0YXJnZXROb2RlLCB0YXJnZXRJbnN0KTtcbiAgICB9XG5cbiAgICAvLyBXaGVuIGJsdXJyaW5nLCBzZXQgdGhlIHZhbHVlIGF0dHJpYnV0ZSBmb3IgbnVtYmVyIGlucHV0c1xuICAgIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BCbHVyJykge1xuICAgICAgaGFuZGxlQ29udHJvbGxlZElucHV0Qmx1cih0YXJnZXRJbnN0LCB0YXJnZXROb2RlKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogTW9kdWxlIHRoYXQgaXMgaW5qZWN0YWJsZSBpbnRvIGBFdmVudFBsdWdpbkh1YmAsIHRoYXQgc3BlY2lmaWVzIGFcbiAqIGRldGVybWluaXN0aWMgb3JkZXJpbmcgb2YgYEV2ZW50UGx1Z2luYHMuIEEgY29udmVuaWVudCB3YXkgdG8gcmVhc29uIGFib3V0XG4gKiBwbHVnaW5zLCB3aXRob3V0IGhhdmluZyB0byBwYWNrYWdlIGV2ZXJ5IG9uZSBvZiB0aGVtLiBUaGlzIGlzIGJldHRlciB0aGFuXG4gKiBoYXZpbmcgcGx1Z2lucyBiZSBvcmRlcmVkIGluIHRoZSBzYW1lIG9yZGVyIHRoYXQgdGhleSBhcmUgaW5qZWN0ZWQgYmVjYXVzZVxuICogdGhhdCBvcmRlcmluZyB3b3VsZCBiZSBpbmZsdWVuY2VkIGJ5IHRoZSBwYWNrYWdpbmcgb3JkZXIuXG4gKiBgUmVzcG9uZGVyRXZlbnRQbHVnaW5gIG11c3Qgb2NjdXIgYmVmb3JlIGBTaW1wbGVFdmVudFBsdWdpbmAgc28gdGhhdFxuICogcHJldmVudGluZyBkZWZhdWx0IG9uIGV2ZW50cyBpcyBjb252ZW5pZW50IGluIGBTaW1wbGVFdmVudFBsdWdpbmAgaGFuZGxlcnMuXG4gKi9cbnZhciBET01FdmVudFBsdWdpbk9yZGVyID0gWydSZXNwb25kZXJFdmVudFBsdWdpbicsICdTaW1wbGVFdmVudFBsdWdpbicsICdUYXBFdmVudFBsdWdpbicsICdFbnRlckxlYXZlRXZlbnRQbHVnaW4nLCAnQ2hhbmdlRXZlbnRQbHVnaW4nLCAnU2VsZWN0RXZlbnRQbHVnaW4nLCAnQmVmb3JlSW5wdXRFdmVudFBsdWdpbiddO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgVUlFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBVSUV2ZW50SW50ZXJmYWNlID0ge1xuICB2aWV3OiBudWxsLFxuICBkZXRhaWw6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNVSUV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudCQxLmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudCQxLmF1Z21lbnRDbGFzcyhTeW50aGV0aWNVSUV2ZW50LCBVSUV2ZW50SW50ZXJmYWNlKTtcblxuLyoqXG4gKiBUcmFuc2xhdGlvbiBmcm9tIG1vZGlmaWVyIGtleSB0byB0aGUgYXNzb2NpYXRlZCBwcm9wZXJ0eSBpbiB0aGUgZXZlbnQuXG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8ja2V5cy1Nb2RpZmllcnNcbiAqL1xuXG52YXIgbW9kaWZpZXJLZXlUb1Byb3AgPSB7XG4gIEFsdDogJ2FsdEtleScsXG4gIENvbnRyb2w6ICdjdHJsS2V5JyxcbiAgTWV0YTogJ21ldGFLZXknLFxuICBTaGlmdDogJ3NoaWZ0S2V5J1xufTtcblxuLy8gSUU4IGRvZXMgbm90IGltcGxlbWVudCBnZXRNb2RpZmllclN0YXRlIHNvIHdlIHNpbXBseSBtYXAgaXQgdG8gdGhlIG9ubHlcbi8vIG1vZGlmaWVyIGtleXMgZXhwb3NlZCBieSB0aGUgZXZlbnQgaXRzZWxmLCBkb2VzIG5vdCBzdXBwb3J0IExvY2sta2V5cy5cbi8vIEN1cnJlbnRseSwgYWxsIG1ham9yIGJyb3dzZXJzIGV4Y2VwdCBDaHJvbWUgc2VlbXMgdG8gc3VwcG9ydCBMb2NrLWtleXMuXG5mdW5jdGlvbiBtb2RpZmllclN0YXRlR2V0dGVyKGtleUFyZykge1xuICB2YXIgc3ludGhldGljRXZlbnQgPSB0aGlzO1xuICB2YXIgbmF0aXZlRXZlbnQgPSBzeW50aGV0aWNFdmVudC5uYXRpdmVFdmVudDtcbiAgaWYgKG5hdGl2ZUV2ZW50LmdldE1vZGlmaWVyU3RhdGUpIHtcbiAgICByZXR1cm4gbmF0aXZlRXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZShrZXlBcmcpO1xuICB9XG4gIHZhciBrZXlQcm9wID0gbW9kaWZpZXJLZXlUb1Byb3Bba2V5QXJnXTtcbiAgcmV0dXJuIGtleVByb3AgPyAhIW5hdGl2ZUV2ZW50W2tleVByb3BdIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldEV2ZW50TW9kaWZpZXJTdGF0ZShuYXRpdmVFdmVudCkge1xuICByZXR1cm4gbW9kaWZpZXJTdGF0ZUdldHRlcjtcbn1cblxuLyoqXG4gKiBAaW50ZXJmYWNlIE1vdXNlRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgTW91c2VFdmVudEludGVyZmFjZSA9IHtcbiAgc2NyZWVuWDogbnVsbCxcbiAgc2NyZWVuWTogbnVsbCxcbiAgY2xpZW50WDogbnVsbCxcbiAgY2xpZW50WTogbnVsbCxcbiAgcGFnZVg6IG51bGwsXG4gIHBhZ2VZOiBudWxsLFxuICBjdHJsS2V5OiBudWxsLFxuICBzaGlmdEtleTogbnVsbCxcbiAgYWx0S2V5OiBudWxsLFxuICBtZXRhS2V5OiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGUsXG4gIGJ1dHRvbjogbnVsbCxcbiAgYnV0dG9uczogbnVsbCxcbiAgcmVsYXRlZFRhcmdldDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgKGV2ZW50LmZyb21FbGVtZW50ID09PSBldmVudC5zcmNFbGVtZW50ID8gZXZlbnQudG9FbGVtZW50IDogZXZlbnQuZnJvbUVsZW1lbnQpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNNb3VzZUV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNNb3VzZUV2ZW50LCBNb3VzZUV2ZW50SW50ZXJmYWNlKTtcblxudmFyIGV2ZW50VHlwZXMkMiA9IHtcbiAgbW91c2VFbnRlcjoge1xuICAgIHJlZ2lzdHJhdGlvbk5hbWU6ICdvbk1vdXNlRW50ZXInLFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BNb3VzZU91dCcsICd0b3BNb3VzZU92ZXInXVxuICB9LFxuICBtb3VzZUxlYXZlOiB7XG4gICAgcmVnaXN0cmF0aW9uTmFtZTogJ29uTW91c2VMZWF2ZScsXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcE1vdXNlT3V0JywgJ3RvcE1vdXNlT3ZlciddXG4gIH1cbn07XG5cbnZhciBFbnRlckxlYXZlRXZlbnRQbHVnaW4gPSB7XG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMkMixcblxuICAvKipcbiAgICogRm9yIGFsbW9zdCBldmVyeSBpbnRlcmFjdGlvbiB3ZSBjYXJlIGFib3V0LCB0aGVyZSB3aWxsIGJlIGJvdGggYSB0b3AtbGV2ZWxcbiAgICogYG1vdXNlb3ZlcmAgYW5kIGBtb3VzZW91dGAgZXZlbnQgdGhhdCBvY2N1cnMuIE9ubHkgdXNlIGBtb3VzZW91dGAgc28gdGhhdFxuICAgKiB3ZSBkbyBub3QgZXh0cmFjdCBkdXBsaWNhdGUgZXZlbnRzLiBIb3dldmVyLCBtb3ZpbmcgdGhlIG1vdXNlIGludG8gdGhlXG4gICAqIGJyb3dzZXIgZnJvbSBvdXRzaWRlIHdpbGwgbm90IGZpcmUgYSBgbW91c2VvdXRgIGV2ZW50LiBJbiB0aGlzIGNhc2UsIHdlIHVzZVxuICAgKiB0aGUgYG1vdXNlb3ZlcmAgdG9wLWxldmVsIGV2ZW50LlxuICAgKi9cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcE1vdXNlT3ZlcicgJiYgKG5hdGl2ZUV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgbmF0aXZlRXZlbnQuZnJvbUVsZW1lbnQpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRvcExldmVsVHlwZSAhPT0gJ3RvcE1vdXNlT3V0JyAmJiB0b3BMZXZlbFR5cGUgIT09ICd0b3BNb3VzZU92ZXInKSB7XG4gICAgICAvLyBNdXN0IG5vdCBiZSBhIG1vdXNlIGluIG9yIG1vdXNlIG91dCAtIGlnbm9yaW5nLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHdpbjtcbiAgICBpZiAobmF0aXZlRXZlbnRUYXJnZXQud2luZG93ID09PSBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgICAgLy8gYG5hdGl2ZUV2ZW50VGFyZ2V0YCBpcyBwcm9iYWJseSBhIHdpbmRvdyBvYmplY3QuXG4gICAgICB3aW4gPSBuYXRpdmVFdmVudFRhcmdldDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVE9ETzogRmlndXJlIG91dCB3aHkgYG93bmVyRG9jdW1lbnRgIGlzIHNvbWV0aW1lcyB1bmRlZmluZWQgaW4gSUU4LlxuICAgICAgdmFyIGRvYyA9IG5hdGl2ZUV2ZW50VGFyZ2V0Lm93bmVyRG9jdW1lbnQ7XG4gICAgICBpZiAoZG9jKSB7XG4gICAgICAgIHdpbiA9IGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luID0gd2luZG93O1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBmcm9tO1xuICAgIHZhciB0bztcbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wTW91c2VPdXQnKSB7XG4gICAgICBmcm9tID0gdGFyZ2V0SW5zdDtcbiAgICAgIHZhciByZWxhdGVkID0gbmF0aXZlRXZlbnQucmVsYXRlZFRhcmdldCB8fCBuYXRpdmVFdmVudC50b0VsZW1lbnQ7XG4gICAgICB0byA9IHJlbGF0ZWQgPyBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShyZWxhdGVkKSA6IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE1vdmluZyB0byBhIG5vZGUgZnJvbSBvdXRzaWRlIHRoZSB3aW5kb3cuXG4gICAgICBmcm9tID0gbnVsbDtcbiAgICAgIHRvID0gdGFyZ2V0SW5zdDtcbiAgICB9XG5cbiAgICBpZiAoZnJvbSA9PT0gdG8pIHtcbiAgICAgIC8vIE5vdGhpbmcgcGVydGFpbnMgdG8gb3VyIG1hbmFnZWQgY29tcG9uZW50cy5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBmcm9tTm9kZSA9IGZyb20gPT0gbnVsbCA/IHdpbiA6IGdldE5vZGVGcm9tSW5zdGFuY2UkMShmcm9tKTtcbiAgICB2YXIgdG9Ob2RlID0gdG8gPT0gbnVsbCA/IHdpbiA6IGdldE5vZGVGcm9tSW5zdGFuY2UkMSh0byk7XG5cbiAgICB2YXIgbGVhdmUgPSBTeW50aGV0aWNNb3VzZUV2ZW50LmdldFBvb2xlZChldmVudFR5cGVzJDIubW91c2VMZWF2ZSwgZnJvbSwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBsZWF2ZS50eXBlID0gJ21vdXNlbGVhdmUnO1xuICAgIGxlYXZlLnRhcmdldCA9IGZyb21Ob2RlO1xuICAgIGxlYXZlLnJlbGF0ZWRUYXJnZXQgPSB0b05vZGU7XG5cbiAgICB2YXIgZW50ZXIgPSBTeW50aGV0aWNNb3VzZUV2ZW50LmdldFBvb2xlZChldmVudFR5cGVzJDIubW91c2VFbnRlciwgdG8sIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgZW50ZXIudHlwZSA9ICdtb3VzZWVudGVyJztcbiAgICBlbnRlci50YXJnZXQgPSB0b05vZGU7XG4gICAgZW50ZXIucmVsYXRlZFRhcmdldCA9IGZyb21Ob2RlO1xuXG4gICAgYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzKGxlYXZlLCBlbnRlciwgZnJvbSwgdG8pO1xuXG4gICAgcmV0dXJuIFtsZWF2ZSwgZW50ZXJdO1xuICB9XG59O1xuXG4vKipcbiAqIGBSZWFjdEluc3RhbmNlTWFwYCBtYWludGFpbnMgYSBtYXBwaW5nIGZyb20gYSBwdWJsaWMgZmFjaW5nIHN0YXRlZnVsXG4gKiBpbnN0YW5jZSAoa2V5KSBhbmQgdGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uICh2YWx1ZSkuIFRoaXMgYWxsb3dzIHB1YmxpY1xuICogbWV0aG9kcyB0byBhY2NlcHQgdGhlIHVzZXIgZmFjaW5nIGluc3RhbmNlIGFzIGFuIGFyZ3VtZW50IGFuZCBtYXAgdGhlbSBiYWNrXG4gKiB0byBpbnRlcm5hbCBtZXRob2RzLlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIG1vZHVsZSBpcyBjdXJyZW50bHkgc2hhcmVkIGFuZCBhc3N1bWVkIHRvIGJlIHN0YXRlbGVzcy5cbiAqIElmIHRoaXMgYmVjb21lcyBhbiBhY3R1YWwgTWFwLCB0aGF0IHdpbGwgYnJlYWsuXG4gKi9cblxuLyoqXG4gKiBUaGlzIEFQSSBzaG91bGQgYmUgY2FsbGVkIGBkZWxldGVgIGJ1dCB3ZSdkIGhhdmUgdG8gbWFrZSBzdXJlIHRvIGFsd2F5c1xuICogdHJhbnNmb3JtIHRoZXNlIHRvIHN0cmluZ3MgZm9yIElFIHN1cHBvcnQuIFdoZW4gdGhpcyB0cmFuc2Zvcm0gaXMgZnVsbHlcbiAqIHN1cHBvcnRlZCB3ZSBjYW4gcmVuYW1lIGl0LlxuICovXG5cblxuZnVuY3Rpb24gZ2V0KGtleSkge1xuICByZXR1cm4ga2V5Ll9yZWFjdEludGVybmFsRmliZXI7XG59XG5cbmZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgcmV0dXJuIGtleS5fcmVhY3RJbnRlcm5hbEZpYmVyICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gIGtleS5fcmVhY3RJbnRlcm5hbEZpYmVyID0gdmFsdWU7XG59XG5cbnZhciBSZWFjdEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZShmaWJlcikge1xuICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gRG9uJ3QgY2hhbmdlIHRoZXNlIHR3byB2YWx1ZXM6XG52YXIgTm9FZmZlY3QgPSAwOyAvLyAgICAgICAgICAgMGIwMDAwMDAwMFxudmFyIFBlcmZvcm1lZFdvcmsgPSAxOyAvLyAgICAgIDBiMDAwMDAwMDFcblxuLy8gWW91IGNhbiBjaGFuZ2UgdGhlIHJlc3QgKGFuZCBhZGQgbW9yZSkuXG52YXIgUGxhY2VtZW50ID0gMjsgLy8gICAgICAgICAgMGIwMDAwMDAxMFxudmFyIFVwZGF0ZSA9IDQ7IC8vICAgICAgICAgICAgIDBiMDAwMDAxMDBcbnZhciBQbGFjZW1lbnRBbmRVcGRhdGUgPSA2OyAvLyAwYjAwMDAwMTEwXG52YXIgRGVsZXRpb24gPSA4OyAvLyAgICAgICAgICAgMGIwMDAwMTAwMFxudmFyIENvbnRlbnRSZXNldCA9IDE2OyAvLyAgICAgIDBiMDAwMTAwMDBcbnZhciBDYWxsYmFjayA9IDMyOyAvLyAgICAgICAgICAwYjAwMTAwMDAwXG52YXIgRXJyID0gNjQ7IC8vICAgICAgICAgICAgICAgMGIwMTAwMDAwMFxudmFyIFJlZiA9IDEyODsgLy8gICAgICAgICAgICAgIDBiMTAwMDAwMDBcblxudmFyIE1PVU5USU5HID0gMTtcbnZhciBNT1VOVEVEID0gMjtcbnZhciBVTk1PVU5URUQgPSAzO1xuXG5mdW5jdGlvbiBpc0ZpYmVyTW91bnRlZEltcGwoZmliZXIpIHtcbiAgdmFyIG5vZGUgPSBmaWJlcjtcbiAgaWYgKCFmaWJlci5hbHRlcm5hdGUpIHtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBhbHRlcm5hdGUsIHRoaXMgbWlnaHQgYmUgYSBuZXcgdHJlZSB0aGF0IGlzbid0IGluc2VydGVkXG4gICAgLy8geWV0LiBJZiBpdCBpcywgdGhlbiBpdCB3aWxsIGhhdmUgYSBwZW5kaW5nIGluc2VydGlvbiBlZmZlY3Qgb24gaXQuXG4gICAgaWYgKChub2RlLmVmZmVjdFRhZyAmIFBsYWNlbWVudCkgIT09IE5vRWZmZWN0KSB7XG4gICAgICByZXR1cm4gTU9VTlRJTkc7XG4gICAgfVxuICAgIHdoaWxlIChub2RlWydyZXR1cm4nXSkge1xuICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgaWYgKChub2RlLmVmZmVjdFRhZyAmIFBsYWNlbWVudCkgIT09IE5vRWZmZWN0KSB7XG4gICAgICAgIHJldHVybiBNT1VOVElORztcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKG5vZGVbJ3JldHVybiddKSB7XG4gICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgfVxuICB9XG4gIGlmIChub2RlLnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAvLyBUT0RPOiBDaGVjayBpZiB0aGlzIHdhcyBhIG5lc3RlZCBIb3N0Um9vdCB3aGVuIHVzZWQgd2l0aFxuICAgIC8vIHJlbmRlckNvbnRhaW5lckludG9TdWJ0cmVlLlxuICAgIHJldHVybiBNT1VOVEVEO1xuICB9XG4gIC8vIElmIHdlIGRpZG4ndCBoaXQgdGhlIHJvb3QsIHRoYXQgbWVhbnMgdGhhdCB3ZSdyZSBpbiBhbiBkaXNjb25uZWN0ZWQgdHJlZVxuICAvLyB0aGF0IGhhcyBiZWVuIHVubW91bnRlZC5cbiAgcmV0dXJuIFVOTU9VTlRFRDtcbn1cblxuZnVuY3Rpb24gaXNGaWJlck1vdW50ZWQoZmliZXIpIHtcbiAgcmV0dXJuIGlzRmliZXJNb3VudGVkSW1wbChmaWJlcikgPT09IE1PVU5URUQ7XG59XG5cbmZ1bmN0aW9uIGlzTW91bnRlZChjb21wb25lbnQpIHtcbiAge1xuICAgIHZhciBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgaWYgKG93bmVyICE9PSBudWxsICYmIG93bmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgIHZhciBvd25lckZpYmVyID0gb3duZXI7XG4gICAgICB2YXIgaW5zdGFuY2UgPSBvd25lckZpYmVyLnN0YXRlTm9kZTtcbiAgICAgIHdhcm5pbmcoaW5zdGFuY2UuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyLCAnJXMgaXMgYWNjZXNzaW5nIGlzTW91bnRlZCBpbnNpZGUgaXRzIHJlbmRlcigpIGZ1bmN0aW9uLiAnICsgJ3JlbmRlcigpIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLiBJdCBzaG91bGQgJyArICduZXZlciBhY2Nlc3Mgc29tZXRoaW5nIHRoYXQgcmVxdWlyZXMgc3RhbGUgZGF0YSBmcm9tIHRoZSBwcmV2aW91cyAnICsgJ3JlbmRlciwgc3VjaCBhcyByZWZzLiBNb3ZlIHRoaXMgbG9naWMgdG8gY29tcG9uZW50RGlkTW91bnQgYW5kICcgKyAnY29tcG9uZW50RGlkVXBkYXRlIGluc3RlYWQuJywgZ2V0Q29tcG9uZW50TmFtZShvd25lckZpYmVyKSB8fCAnQSBjb21wb25lbnQnKTtcbiAgICAgIGluc3RhbmNlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGZpYmVyID0gZ2V0KGNvbXBvbmVudCk7XG4gIGlmICghZmliZXIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzRmliZXJNb3VudGVkSW1wbChmaWJlcikgPT09IE1PVU5URUQ7XG59XG5cbmZ1bmN0aW9uIGFzc2VydElzTW91bnRlZChmaWJlcikge1xuICAhKGlzRmliZXJNb3VudGVkSW1wbChmaWJlcikgPT09IE1PVU5URUQpID8gaW52YXJpYW50KGZhbHNlLCAnVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpIDogdm9pZCAwO1xufVxuXG5mdW5jdGlvbiBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aChmaWJlcikge1xuICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuICBpZiAoIWFsdGVybmF0ZSkge1xuICAgIC8vIElmIHRoZXJlIGlzIG5vIGFsdGVybmF0ZSwgdGhlbiB3ZSBvbmx5IG5lZWQgdG8gY2hlY2sgaWYgaXQgaXMgbW91bnRlZC5cbiAgICB2YXIgc3RhdGUgPSBpc0ZpYmVyTW91bnRlZEltcGwoZmliZXIpO1xuICAgICEoc3RhdGUgIT09IFVOTU9VTlRFRCkgPyBpbnZhcmlhbnQoZmFsc2UsICdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJykgOiB2b2lkIDA7XG4gICAgaWYgKHN0YXRlID09PSBNT1VOVElORykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBmaWJlcjtcbiAgfVxuICAvLyBJZiB3ZSBoYXZlIHR3byBwb3NzaWJsZSBicmFuY2hlcywgd2UnbGwgd2FsayBiYWNrd2FyZHMgdXAgdG8gdGhlIHJvb3RcbiAgLy8gdG8gc2VlIHdoYXQgcGF0aCB0aGUgcm9vdCBwb2ludHMgdG8uIE9uIHRoZSB3YXkgd2UgbWF5IGhpdCBvbmUgb2YgdGhlXG4gIC8vIHNwZWNpYWwgY2FzZXMgYW5kIHdlJ2xsIGRlYWwgd2l0aCB0aGVtLlxuICB2YXIgYSA9IGZpYmVyO1xuICB2YXIgYiA9IGFsdGVybmF0ZTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgcGFyZW50QSA9IGFbJ3JldHVybiddO1xuICAgIHZhciBwYXJlbnRCID0gcGFyZW50QSA/IHBhcmVudEEuYWx0ZXJuYXRlIDogbnVsbDtcbiAgICBpZiAoIXBhcmVudEEgfHwgIXBhcmVudEIpIHtcbiAgICAgIC8vIFdlJ3JlIGF0IHRoZSByb290LlxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gSWYgYm90aCBjb3BpZXMgb2YgdGhlIHBhcmVudCBmaWJlciBwb2ludCB0byB0aGUgc2FtZSBjaGlsZCwgd2UgY2FuXG4gICAgLy8gYXNzdW1lIHRoYXQgdGhlIGNoaWxkIGlzIGN1cnJlbnQuIFRoaXMgaGFwcGVucyB3aGVuIHdlIGJhaWxvdXQgb24gbG93XG4gICAgLy8gcHJpb3JpdHk6IHRoZSBiYWlsZWQgb3V0IGZpYmVyJ3MgY2hpbGQgcmV1c2VzIHRoZSBjdXJyZW50IGNoaWxkLlxuICAgIGlmIChwYXJlbnRBLmNoaWxkID09PSBwYXJlbnRCLmNoaWxkKSB7XG4gICAgICB2YXIgY2hpbGQgPSBwYXJlbnRBLmNoaWxkO1xuICAgICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICAgIGlmIChjaGlsZCA9PT0gYSkge1xuICAgICAgICAgIC8vIFdlJ3ZlIGRldGVybWluZWQgdGhhdCBBIGlzIHRoZSBjdXJyZW50IGJyYW5jaC5cbiAgICAgICAgICBhc3NlcnRJc01vdW50ZWQocGFyZW50QSk7XG4gICAgICAgICAgcmV0dXJuIGZpYmVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZCA9PT0gYikge1xuICAgICAgICAgIC8vIFdlJ3ZlIGRldGVybWluZWQgdGhhdCBCIGlzIHRoZSBjdXJyZW50IGJyYW5jaC5cbiAgICAgICAgICBhc3NlcnRJc01vdW50ZWQocGFyZW50QSk7XG4gICAgICAgICAgcmV0dXJuIGFsdGVybmF0ZTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgICB9XG4gICAgICAvLyBXZSBzaG91bGQgbmV2ZXIgaGF2ZSBhbiBhbHRlcm5hdGUgZm9yIGFueSBtb3VudGluZyBub2RlLiBTbyB0aGUgb25seVxuICAgICAgLy8gd2F5IHRoaXMgY291bGQgcG9zc2libHkgaGFwcGVuIGlzIGlmIHRoaXMgd2FzIHVubW91bnRlZCwgaWYgYXQgYWxsLlxuICAgICAgaW52YXJpYW50KGZhbHNlLCAnVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpO1xuICAgIH1cblxuICAgIGlmIChhWydyZXR1cm4nXSAhPT0gYlsncmV0dXJuJ10pIHtcbiAgICAgIC8vIFRoZSByZXR1cm4gcG9pbnRlciBvZiBBIGFuZCB0aGUgcmV0dXJuIHBvaW50ZXIgb2YgQiBwb2ludCB0byBkaWZmZXJlbnRcbiAgICAgIC8vIGZpYmVycy4gV2UgYXNzdW1lIHRoYXQgcmV0dXJuIHBvaW50ZXJzIG5ldmVyIGNyaXNzLWNyb3NzLCBzbyBBIG11c3RcbiAgICAgIC8vIGJlbG9uZyB0byB0aGUgY2hpbGQgc2V0IG9mIEEucmV0dXJuLCBhbmQgQiBtdXN0IGJlbG9uZyB0byB0aGUgY2hpbGRcbiAgICAgIC8vIHNldCBvZiBCLnJldHVybi5cbiAgICAgIGEgPSBwYXJlbnRBO1xuICAgICAgYiA9IHBhcmVudEI7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSByZXR1cm4gcG9pbnRlcnMgcG9pbnQgdG8gdGhlIHNhbWUgZmliZXIuIFdlJ2xsIGhhdmUgdG8gdXNlIHRoZVxuICAgICAgLy8gZGVmYXVsdCwgc2xvdyBwYXRoOiBzY2FuIHRoZSBjaGlsZCBzZXRzIG9mIGVhY2ggcGFyZW50IGFsdGVybmF0ZSB0byBzZWVcbiAgICAgIC8vIHdoaWNoIGNoaWxkIGJlbG9uZ3MgdG8gd2hpY2ggc2V0LlxuICAgICAgLy9cbiAgICAgIC8vIFNlYXJjaCBwYXJlbnQgQSdzIGNoaWxkIHNldFxuICAgICAgdmFyIGRpZEZpbmRDaGlsZCA9IGZhbHNlO1xuICAgICAgdmFyIF9jaGlsZCA9IHBhcmVudEEuY2hpbGQ7XG4gICAgICB3aGlsZSAoX2NoaWxkKSB7XG4gICAgICAgIGlmIChfY2hpbGQgPT09IGEpIHtcbiAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgIGEgPSBwYXJlbnRBO1xuICAgICAgICAgIGIgPSBwYXJlbnRCO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfY2hpbGQgPT09IGIpIHtcbiAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgIGIgPSBwYXJlbnRBO1xuICAgICAgICAgIGEgPSBwYXJlbnRCO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIF9jaGlsZCA9IF9jaGlsZC5zaWJsaW5nO1xuICAgICAgfVxuICAgICAgaWYgKCFkaWRGaW5kQ2hpbGQpIHtcbiAgICAgICAgLy8gU2VhcmNoIHBhcmVudCBCJ3MgY2hpbGQgc2V0XG4gICAgICAgIF9jaGlsZCA9IHBhcmVudEIuY2hpbGQ7XG4gICAgICAgIHdoaWxlIChfY2hpbGQpIHtcbiAgICAgICAgICBpZiAoX2NoaWxkID09PSBhKSB7XG4gICAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgICAgYSA9IHBhcmVudEI7XG4gICAgICAgICAgICBiID0gcGFyZW50QTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoX2NoaWxkID09PSBiKSB7XG4gICAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgICAgYiA9IHBhcmVudEI7XG4gICAgICAgICAgICBhID0gcGFyZW50QTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfY2hpbGQgPSBfY2hpbGQuc2libGluZztcbiAgICAgICAgfVxuICAgICAgICAhZGlkRmluZENoaWxkID8gaW52YXJpYW50KGZhbHNlLCAnQ2hpbGQgd2FzIG5vdCBmb3VuZCBpbiBlaXRoZXIgcGFyZW50IHNldC4gVGhpcyBpbmRpY2F0ZXMgYSBidWcgaW4gUmVhY3QgcmVsYXRlZCB0byB0aGUgcmV0dXJuIHBvaW50ZXIuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH1cblxuICAgICEoYS5hbHRlcm5hdGUgPT09IGIpID8gaW52YXJpYW50KGZhbHNlLCAnUmV0dXJuIGZpYmVycyBzaG91bGQgYWx3YXlzIGJlIGVhY2ggb3RoZXJzXFwnIGFsdGVybmF0ZXMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gIH1cbiAgLy8gSWYgdGhlIHJvb3QgaXMgbm90IGEgaG9zdCBjb250YWluZXIsIHdlJ3JlIGluIGEgZGlzY29ubmVjdGVkIHRyZWUuIEkuZS5cbiAgLy8gdW5tb3VudGVkLlxuICAhKGEudGFnID09PSBIb3N0Um9vdCkgPyBpbnZhcmlhbnQoZmFsc2UsICdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJykgOiB2b2lkIDA7XG4gIGlmIChhLnN0YXRlTm9kZS5jdXJyZW50ID09PSBhKSB7XG4gICAgLy8gV2UndmUgZGV0ZXJtaW5lZCB0aGF0IEEgaXMgdGhlIGN1cnJlbnQgYnJhbmNoLlxuICAgIHJldHVybiBmaWJlcjtcbiAgfVxuICAvLyBPdGhlcndpc2UgQiBoYXMgdG8gYmUgY3VycmVudCBicmFuY2guXG4gIHJldHVybiBhbHRlcm5hdGU7XG59XG5cbmZ1bmN0aW9uIGZpbmRDdXJyZW50SG9zdEZpYmVyKHBhcmVudCkge1xuICB2YXIgY3VycmVudFBhcmVudCA9IGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKHBhcmVudCk7XG4gIGlmICghY3VycmVudFBhcmVudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gTmV4dCB3ZSdsbCBkcmlsbCBkb3duIHRoaXMgY29tcG9uZW50IHRvIGZpbmQgdGhlIGZpcnN0IEhvc3RDb21wb25lbnQvVGV4dC5cbiAgdmFyIG5vZGUgPSBjdXJyZW50UGFyZW50O1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCkge1xuICAgICAgbm9kZS5jaGlsZFsncmV0dXJuJ10gPSBub2RlO1xuICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKG5vZGUgPT09IGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB3aGlsZSAoIW5vZGUuc2libGluZykge1xuICAgICAgaWYgKCFub2RlWydyZXR1cm4nXSB8fCBub2RlWydyZXR1cm4nXSA9PT0gY3VycmVudFBhcmVudCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICB9XG4gICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gIH1cbiAgLy8gRmxvdyBuZWVkcyB0aGUgcmV0dXJuIG51bGwgaGVyZSwgYnV0IEVTTGludCBjb21wbGFpbnMgYWJvdXQgaXQuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnJlYWNoYWJsZVxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzKHBhcmVudCkge1xuICB2YXIgY3VycmVudFBhcmVudCA9IGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKHBhcmVudCk7XG4gIGlmICghY3VycmVudFBhcmVudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gTmV4dCB3ZSdsbCBkcmlsbCBkb3duIHRoaXMgY29tcG9uZW50IHRvIGZpbmQgdGhlIGZpcnN0IEhvc3RDb21wb25lbnQvVGV4dC5cbiAgdmFyIG5vZGUgPSBjdXJyZW50UGFyZW50O1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCAmJiBub2RlLnRhZyAhPT0gSG9zdFBvcnRhbCkge1xuICAgICAgbm9kZS5jaGlsZFsncmV0dXJuJ10gPSBub2RlO1xuICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKG5vZGUgPT09IGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB3aGlsZSAoIW5vZGUuc2libGluZykge1xuICAgICAgaWYgKCFub2RlWydyZXR1cm4nXSB8fCBub2RlWydyZXR1cm4nXSA9PT0gY3VycmVudFBhcmVudCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICB9XG4gICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gIH1cbiAgLy8gRmxvdyBuZWVkcyB0aGUgcmV0dXJuIG51bGwgaGVyZSwgYnV0IEVTTGludCBjb21wbGFpbnMgYWJvdXQgaXQuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnJlYWNoYWJsZVxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIENBTExCQUNLX0JPT0tLRUVQSU5HX1BPT0xfU0laRSA9IDEwO1xudmFyIGNhbGxiYWNrQm9va2tlZXBpbmdQb29sID0gW107XG5cbi8qKlxuICogRmluZCB0aGUgZGVlcGVzdCBSZWFjdCBjb21wb25lbnQgY29tcGxldGVseSBjb250YWluaW5nIHRoZSByb290IG9mIHRoZVxuICogcGFzc2VkLWluIGluc3RhbmNlIChmb3IgdXNlIHdoZW4gZW50aXJlIFJlYWN0IHRyZWVzIGFyZSBuZXN0ZWQgd2l0aGluIGVhY2hcbiAqIG90aGVyKS4gSWYgUmVhY3QgdHJlZXMgYXJlIG5vdCBuZXN0ZWQsIHJldHVybnMgbnVsbC5cbiAqL1xuZnVuY3Rpb24gZmluZFJvb3RDb250YWluZXJOb2RlKGluc3QpIHtcbiAgLy8gVE9ETzogSXQgbWF5IGJlIGEgZ29vZCBpZGVhIHRvIGNhY2hlIHRoaXMgdG8gcHJldmVudCB1bm5lY2Vzc2FyeSBET01cbiAgLy8gdHJhdmVyc2FsLCBidXQgY2FjaGluZyBpcyBkaWZmaWN1bHQgdG8gZG8gY29ycmVjdGx5IHdpdGhvdXQgdXNpbmcgYVxuICAvLyBtdXRhdGlvbiBvYnNlcnZlciB0byBsaXN0ZW4gZm9yIGFsbCBET00gY2hhbmdlcy5cbiAgd2hpbGUgKGluc3RbJ3JldHVybiddKSB7XG4gICAgaW5zdCA9IGluc3RbJ3JldHVybiddO1xuICB9XG4gIGlmIChpbnN0LnRhZyAhPT0gSG9zdFJvb3QpIHtcbiAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgd2UncmUgaW4gYSBkZXRhY2hlZCB0cmVlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBpbnN0LnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xufVxuXG4vLyBVc2VkIHRvIHN0b3JlIGFuY2VzdG9yIGhpZXJhcmNoeSBpbiB0b3AgbGV2ZWwgY2FsbGJhY2tcbmZ1bmN0aW9uIGdldFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50LCB0YXJnZXRJbnN0KSB7XG4gIGlmIChjYWxsYmFja0Jvb2trZWVwaW5nUG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBjYWxsYmFja0Jvb2trZWVwaW5nUG9vbC5wb3AoKTtcbiAgICBpbnN0YW5jZS50b3BMZXZlbFR5cGUgPSB0b3BMZXZlbFR5cGU7XG4gICAgaW5zdGFuY2UubmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudDtcbiAgICBpbnN0YW5jZS50YXJnZXRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0b3BMZXZlbFR5cGU6IHRvcExldmVsVHlwZSxcbiAgICBuYXRpdmVFdmVudDogbmF0aXZlRXZlbnQsXG4gICAgdGFyZ2V0SW5zdDogdGFyZ2V0SW5zdCxcbiAgICBhbmNlc3RvcnM6IFtdXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlbGVhc2VUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcoaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UudG9wTGV2ZWxUeXBlID0gbnVsbDtcbiAgaW5zdGFuY2UubmF0aXZlRXZlbnQgPSBudWxsO1xuICBpbnN0YW5jZS50YXJnZXRJbnN0ID0gbnVsbDtcbiAgaW5zdGFuY2UuYW5jZXN0b3JzLmxlbmd0aCA9IDA7XG4gIGlmIChjYWxsYmFja0Jvb2trZWVwaW5nUG9vbC5sZW5ndGggPCBDQUxMQkFDS19CT09LS0VFUElOR19QT09MX1NJWkUpIHtcbiAgICBjYWxsYmFja0Jvb2trZWVwaW5nUG9vbC5wdXNoKGluc3RhbmNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVUb3BMZXZlbEltcGwoYm9va0tlZXBpbmcpIHtcbiAgdmFyIHRhcmdldEluc3QgPSBib29rS2VlcGluZy50YXJnZXRJbnN0O1xuXG4gIC8vIExvb3AgdGhyb3VnaCB0aGUgaGllcmFyY2h5LCBpbiBjYXNlIHRoZXJlJ3MgYW55IG5lc3RlZCBjb21wb25lbnRzLlxuICAvLyBJdCdzIGltcG9ydGFudCB0aGF0IHdlIGJ1aWxkIHRoZSBhcnJheSBvZiBhbmNlc3RvcnMgYmVmb3JlIGNhbGxpbmcgYW55XG4gIC8vIGV2ZW50IGhhbmRsZXJzLCBiZWNhdXNlIGV2ZW50IGhhbmRsZXJzIGNhbiBtb2RpZnkgdGhlIERPTSwgbGVhZGluZyB0b1xuICAvLyBpbmNvbnNpc3RlbmNpZXMgd2l0aCBSZWFjdE1vdW50J3Mgbm9kZSBjYWNoZS4gU2VlICMxMTA1LlxuICB2YXIgYW5jZXN0b3IgPSB0YXJnZXRJbnN0O1xuICBkbyB7XG4gICAgaWYgKCFhbmNlc3Rvcikge1xuICAgICAgYm9va0tlZXBpbmcuYW5jZXN0b3JzLnB1c2goYW5jZXN0b3IpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHZhciByb290ID0gZmluZFJvb3RDb250YWluZXJOb2RlKGFuY2VzdG9yKTtcbiAgICBpZiAoIXJvb3QpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBib29rS2VlcGluZy5hbmNlc3RvcnMucHVzaChhbmNlc3Rvcik7XG4gICAgYW5jZXN0b3IgPSBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShyb290KTtcbiAgfSB3aGlsZSAoYW5jZXN0b3IpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYm9va0tlZXBpbmcuYW5jZXN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGFyZ2V0SW5zdCA9IGJvb2tLZWVwaW5nLmFuY2VzdG9yc1tpXTtcbiAgICBfaGFuZGxlVG9wTGV2ZWwoYm9va0tlZXBpbmcudG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBib29rS2VlcGluZy5uYXRpdmVFdmVudCwgZ2V0RXZlbnRUYXJnZXQoYm9va0tlZXBpbmcubmF0aXZlRXZlbnQpKTtcbiAgfVxufVxuXG4vLyBUT0RPOiBjYW4gd2Ugc3RvcCBleHBvcnRpbmcgdGhlc2U/XG52YXIgX2VuYWJsZWQgPSB0cnVlO1xudmFyIF9oYW5kbGVUb3BMZXZlbCA9IHZvaWQgMDtcblxuZnVuY3Rpb24gc2V0SGFuZGxlVG9wTGV2ZWwoaGFuZGxlVG9wTGV2ZWwpIHtcbiAgX2hhbmRsZVRvcExldmVsID0gaGFuZGxlVG9wTGV2ZWw7XG59XG5cbmZ1bmN0aW9uIHNldEVuYWJsZWQoZW5hYmxlZCkge1xuICBfZW5hYmxlZCA9ICEhZW5hYmxlZDtcbn1cblxuZnVuY3Rpb24gaXNFbmFibGVkKCkge1xuICByZXR1cm4gX2VuYWJsZWQ7XG59XG5cbi8qKlxuICogVHJhcHMgdG9wLWxldmVsIGV2ZW50cyBieSB1c2luZyBldmVudCBidWJibGluZy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBCcm93c2VyRXZlbnRDb25zdGFudHNgLlxuICogQHBhcmFtIHtzdHJpbmd9IGhhbmRsZXJCYXNlTmFtZSBFdmVudCBuYW1lIChlLmcuIFwiY2xpY2tcIikuXG4gKiBAcGFyYW0ge29iamVjdH0gZWxlbWVudCBFbGVtZW50IG9uIHdoaWNoIHRvIGF0dGFjaCBsaXN0ZW5lci5cbiAqIEByZXR1cm4gez9vYmplY3R9IEFuIG9iamVjdCB3aXRoIGEgcmVtb3ZlIGZ1bmN0aW9uIHdoaWNoIHdpbGwgZm9yY2VmdWxseVxuICogICAgICAgICAgICAgICAgICByZW1vdmUgdGhlIGxpc3RlbmVyLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHRyYXBCdWJibGVkRXZlbnQodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGVsZW1lbnQpIHtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIEV2ZW50TGlzdGVuZXIubGlzdGVuKGVsZW1lbnQsIGhhbmRsZXJCYXNlTmFtZSwgZGlzcGF0Y2hFdmVudC5iaW5kKG51bGwsIHRvcExldmVsVHlwZSkpO1xufVxuXG4vKipcbiAqIFRyYXBzIGEgdG9wLWxldmVsIGV2ZW50IGJ5IHVzaW5nIGV2ZW50IGNhcHR1cmluZy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBCcm93c2VyRXZlbnRDb25zdGFudHNgLlxuICogQHBhcmFtIHtzdHJpbmd9IGhhbmRsZXJCYXNlTmFtZSBFdmVudCBuYW1lIChlLmcuIFwiY2xpY2tcIikuXG4gKiBAcGFyYW0ge29iamVjdH0gZWxlbWVudCBFbGVtZW50IG9uIHdoaWNoIHRvIGF0dGFjaCBsaXN0ZW5lci5cbiAqIEByZXR1cm4gez9vYmplY3R9IEFuIG9iamVjdCB3aXRoIGEgcmVtb3ZlIGZ1bmN0aW9uIHdoaWNoIHdpbGwgZm9yY2VmdWxseVxuICogICAgICAgICAgICAgICAgICByZW1vdmUgdGhlIGxpc3RlbmVyLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHRyYXBDYXB0dXJlZEV2ZW50KHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBlbGVtZW50KSB7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBFdmVudExpc3RlbmVyLmNhcHR1cmUoZWxlbWVudCwgaGFuZGxlckJhc2VOYW1lLCBkaXNwYXRjaEV2ZW50LmJpbmQobnVsbCwgdG9wTGV2ZWxUeXBlKSk7XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICBpZiAoIV9lbmFibGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG5hdGl2ZUV2ZW50VGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpO1xuICB2YXIgdGFyZ2V0SW5zdCA9IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgaWYgKHRhcmdldEluc3QgIT09IG51bGwgJiYgdHlwZW9mIHRhcmdldEluc3QudGFnID09PSAnbnVtYmVyJyAmJiAhaXNGaWJlck1vdW50ZWQodGFyZ2V0SW5zdCkpIHtcbiAgICAvLyBJZiB3ZSBnZXQgYW4gZXZlbnQgKGV4OiBpbWcgb25sb2FkKSBiZWZvcmUgY29tbWl0dGluZyB0aGF0XG4gICAgLy8gY29tcG9uZW50J3MgbW91bnQsIGlnbm9yZSBpdCBmb3Igbm93ICh0aGF0IGlzLCB0cmVhdCBpdCBhcyBpZiBpdCB3YXMgYW5cbiAgICAvLyBldmVudCBvbiBhIG5vbi1SZWFjdCB0cmVlKS4gV2UgbWlnaHQgYWxzbyBjb25zaWRlciBxdWV1ZWluZyBldmVudHMgYW5kXG4gICAgLy8gZGlzcGF0Y2hpbmcgdGhlbSBhZnRlciB0aGUgbW91bnQuXG4gICAgdGFyZ2V0SW5zdCA9IG51bGw7XG4gIH1cblxuICB2YXIgYm9va0tlZXBpbmcgPSBnZXRUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCwgdGFyZ2V0SW5zdCk7XG5cbiAgdHJ5IHtcbiAgICAvLyBFdmVudCBxdWV1ZSBiZWluZyBwcm9jZXNzZWQgaW4gdGhlIHNhbWUgY3ljbGUgYWxsb3dzXG4gICAgLy8gYHByZXZlbnREZWZhdWx0YC5cbiAgICBiYXRjaGVkVXBkYXRlcyhoYW5kbGVUb3BMZXZlbEltcGwsIGJvb2tLZWVwaW5nKTtcbiAgfSBmaW5hbGx5IHtcbiAgICByZWxlYXNlVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nKGJvb2tLZWVwaW5nKTtcbiAgfVxufVxuXG52YXIgUmVhY3RET01FdmVudExpc3RlbmVyID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGdldCBfZW5hYmxlZCAoKSB7IHJldHVybiBfZW5hYmxlZDsgfSxcblx0Z2V0IF9oYW5kbGVUb3BMZXZlbCAoKSB7IHJldHVybiBfaGFuZGxlVG9wTGV2ZWw7IH0sXG5cdHNldEhhbmRsZVRvcExldmVsOiBzZXRIYW5kbGVUb3BMZXZlbCxcblx0c2V0RW5hYmxlZDogc2V0RW5hYmxlZCxcblx0aXNFbmFibGVkOiBpc0VuYWJsZWQsXG5cdHRyYXBCdWJibGVkRXZlbnQ6IHRyYXBCdWJibGVkRXZlbnQsXG5cdHRyYXBDYXB0dXJlZEV2ZW50OiB0cmFwQ2FwdHVyZWRFdmVudCxcblx0ZGlzcGF0Y2hFdmVudDogZGlzcGF0Y2hFdmVudFxufSk7XG5cbi8qKlxuICogR2VuZXJhdGUgYSBtYXBwaW5nIG9mIHN0YW5kYXJkIHZlbmRvciBwcmVmaXhlcyB1c2luZyB0aGUgZGVmaW5lZCBzdHlsZSBwcm9wZXJ0eSBhbmQgZXZlbnQgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3R5bGVQcm9wXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gKiBAcmV0dXJucyB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBtYWtlUHJlZml4TWFwKHN0eWxlUHJvcCwgZXZlbnROYW1lKSB7XG4gIHZhciBwcmVmaXhlcyA9IHt9O1xuXG4gIHByZWZpeGVzW3N0eWxlUHJvcC50b0xvd2VyQ2FzZSgpXSA9IGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xuICBwcmVmaXhlc1snV2Via2l0JyArIHN0eWxlUHJvcF0gPSAnd2Via2l0JyArIGV2ZW50TmFtZTtcbiAgcHJlZml4ZXNbJ01veicgKyBzdHlsZVByb3BdID0gJ21veicgKyBldmVudE5hbWU7XG4gIHByZWZpeGVzWydtcycgKyBzdHlsZVByb3BdID0gJ01TJyArIGV2ZW50TmFtZTtcbiAgcHJlZml4ZXNbJ08nICsgc3R5bGVQcm9wXSA9ICdvJyArIGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gIHJldHVybiBwcmVmaXhlcztcbn1cblxuLyoqXG4gKiBBIGxpc3Qgb2YgZXZlbnQgbmFtZXMgdG8gYSBjb25maWd1cmFibGUgbGlzdCBvZiB2ZW5kb3IgcHJlZml4ZXMuXG4gKi9cbnZhciB2ZW5kb3JQcmVmaXhlcyA9IHtcbiAgYW5pbWF0aW9uZW5kOiBtYWtlUHJlZml4TWFwKCdBbmltYXRpb24nLCAnQW5pbWF0aW9uRW5kJyksXG4gIGFuaW1hdGlvbml0ZXJhdGlvbjogbWFrZVByZWZpeE1hcCgnQW5pbWF0aW9uJywgJ0FuaW1hdGlvbkl0ZXJhdGlvbicpLFxuICBhbmltYXRpb25zdGFydDogbWFrZVByZWZpeE1hcCgnQW5pbWF0aW9uJywgJ0FuaW1hdGlvblN0YXJ0JyksXG4gIHRyYW5zaXRpb25lbmQ6IG1ha2VQcmVmaXhNYXAoJ1RyYW5zaXRpb24nLCAnVHJhbnNpdGlvbkVuZCcpXG59O1xuXG4vKipcbiAqIEV2ZW50IG5hbWVzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gZGV0ZWN0ZWQgYW5kIHByZWZpeGVkIChpZiBhcHBsaWNhYmxlKS5cbiAqL1xudmFyIHByZWZpeGVkRXZlbnROYW1lcyA9IHt9O1xuXG4vKipcbiAqIEVsZW1lbnQgdG8gY2hlY2sgZm9yIHByZWZpeGVzIG9uLlxuICovXG52YXIgc3R5bGUgPSB7fTtcblxuLyoqXG4gKiBCb290c3RyYXAgaWYgYSBET00gZXhpc3RzLlxuICovXG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XG5cbiAgLy8gT24gc29tZSBwbGF0Zm9ybXMsIGluIHBhcnRpY3VsYXIgc29tZSByZWxlYXNlcyBvZiBBbmRyb2lkIDQueCxcbiAgLy8gdGhlIHVuLXByZWZpeGVkIFwiYW5pbWF0aW9uXCIgYW5kIFwidHJhbnNpdGlvblwiIHByb3BlcnRpZXMgYXJlIGRlZmluZWQgb24gdGhlXG4gIC8vIHN0eWxlIG9iamVjdCBidXQgdGhlIGV2ZW50cyB0aGF0IGZpcmUgd2lsbCBzdGlsbCBiZSBwcmVmaXhlZCwgc28gd2UgbmVlZFxuICAvLyB0byBjaGVjayBpZiB0aGUgdW4tcHJlZml4ZWQgZXZlbnRzIGFyZSB1c2FibGUsIGFuZCBpZiBub3QgcmVtb3ZlIHRoZW0gZnJvbSB0aGUgbWFwLlxuICBpZiAoISgnQW5pbWF0aW9uRXZlbnQnIGluIHdpbmRvdykpIHtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uZW5kLmFuaW1hdGlvbjtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uaXRlcmF0aW9uLmFuaW1hdGlvbjtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uc3RhcnQuYW5pbWF0aW9uO1xuICB9XG5cbiAgLy8gU2FtZSBhcyBhYm92ZVxuICBpZiAoISgnVHJhbnNpdGlvbkV2ZW50JyBpbiB3aW5kb3cpKSB7XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLnRyYW5zaXRpb25lbmQudHJhbnNpdGlvbjtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHRzIHRvIGRldGVybWluZSB0aGUgY29ycmVjdCB2ZW5kb3IgcHJlZml4ZWQgZXZlbnQgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZShldmVudE5hbWUpIHtcbiAgaWYgKHByZWZpeGVkRXZlbnROYW1lc1tldmVudE5hbWVdKSB7XG4gICAgcmV0dXJuIHByZWZpeGVkRXZlbnROYW1lc1tldmVudE5hbWVdO1xuICB9IGVsc2UgaWYgKCF2ZW5kb3JQcmVmaXhlc1tldmVudE5hbWVdKSB7XG4gICAgcmV0dXJuIGV2ZW50TmFtZTtcbiAgfVxuXG4gIHZhciBwcmVmaXhNYXAgPSB2ZW5kb3JQcmVmaXhlc1tldmVudE5hbWVdO1xuXG4gIGZvciAodmFyIHN0eWxlUHJvcCBpbiBwcmVmaXhNYXApIHtcbiAgICBpZiAocHJlZml4TWFwLmhhc093blByb3BlcnR5KHN0eWxlUHJvcCkgJiYgc3R5bGVQcm9wIGluIHN0eWxlKSB7XG4gICAgICByZXR1cm4gcHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV0gPSBwcmVmaXhNYXBbc3R5bGVQcm9wXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogVHlwZXMgb2YgcmF3IHNpZ25hbHMgZnJvbSB0aGUgYnJvd3NlciBjYXVnaHQgYXQgdGhlIHRvcCBsZXZlbC5cbiAqXG4gKiBGb3IgZXZlbnRzIGxpa2UgJ3N1Ym1pdCcgd2hpY2ggZG9uJ3QgY29uc2lzdGVudGx5IGJ1YmJsZSAod2hpY2ggd2VcbiAqIHRyYXAgYXQgYSBsb3dlciBub2RlIHRoYW4gYGRvY3VtZW50YCksIGJpbmRpbmcgYXQgYGRvY3VtZW50YCB3b3VsZFxuICogY2F1c2UgZHVwbGljYXRlIGV2ZW50cyBzbyB3ZSBkb24ndCBpbmNsdWRlIHRoZW0gaGVyZS5cbiAqL1xudmFyIHRvcExldmVsVHlwZXMkMSA9IHtcbiAgdG9wQWJvcnQ6ICdhYm9ydCcsXG4gIHRvcEFuaW1hdGlvbkVuZDogZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ2FuaW1hdGlvbmVuZCcpIHx8ICdhbmltYXRpb25lbmQnLFxuICB0b3BBbmltYXRpb25JdGVyYXRpb246IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCdhbmltYXRpb25pdGVyYXRpb24nKSB8fCAnYW5pbWF0aW9uaXRlcmF0aW9uJyxcbiAgdG9wQW5pbWF0aW9uU3RhcnQ6IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCdhbmltYXRpb25zdGFydCcpIHx8ICdhbmltYXRpb25zdGFydCcsXG4gIHRvcEJsdXI6ICdibHVyJyxcbiAgdG9wQ2FuY2VsOiAnY2FuY2VsJyxcbiAgdG9wQ2FuUGxheTogJ2NhbnBsYXknLFxuICB0b3BDYW5QbGF5VGhyb3VnaDogJ2NhbnBsYXl0aHJvdWdoJyxcbiAgdG9wQ2hhbmdlOiAnY2hhbmdlJyxcbiAgdG9wQ2xpY2s6ICdjbGljaycsXG4gIHRvcENsb3NlOiAnY2xvc2UnLFxuICB0b3BDb21wb3NpdGlvbkVuZDogJ2NvbXBvc2l0aW9uZW5kJyxcbiAgdG9wQ29tcG9zaXRpb25TdGFydDogJ2NvbXBvc2l0aW9uc3RhcnQnLFxuICB0b3BDb21wb3NpdGlvblVwZGF0ZTogJ2NvbXBvc2l0aW9udXBkYXRlJyxcbiAgdG9wQ29udGV4dE1lbnU6ICdjb250ZXh0bWVudScsXG4gIHRvcENvcHk6ICdjb3B5JyxcbiAgdG9wQ3V0OiAnY3V0JyxcbiAgdG9wRG91YmxlQ2xpY2s6ICdkYmxjbGljaycsXG4gIHRvcERyYWc6ICdkcmFnJyxcbiAgdG9wRHJhZ0VuZDogJ2RyYWdlbmQnLFxuICB0b3BEcmFnRW50ZXI6ICdkcmFnZW50ZXInLFxuICB0b3BEcmFnRXhpdDogJ2RyYWdleGl0JyxcbiAgdG9wRHJhZ0xlYXZlOiAnZHJhZ2xlYXZlJyxcbiAgdG9wRHJhZ092ZXI6ICdkcmFnb3ZlcicsXG4gIHRvcERyYWdTdGFydDogJ2RyYWdzdGFydCcsXG4gIHRvcERyb3A6ICdkcm9wJyxcbiAgdG9wRHVyYXRpb25DaGFuZ2U6ICdkdXJhdGlvbmNoYW5nZScsXG4gIHRvcEVtcHRpZWQ6ICdlbXB0aWVkJyxcbiAgdG9wRW5jcnlwdGVkOiAnZW5jcnlwdGVkJyxcbiAgdG9wRW5kZWQ6ICdlbmRlZCcsXG4gIHRvcEVycm9yOiAnZXJyb3InLFxuICB0b3BGb2N1czogJ2ZvY3VzJyxcbiAgdG9wSW5wdXQ6ICdpbnB1dCcsXG4gIHRvcEtleURvd246ICdrZXlkb3duJyxcbiAgdG9wS2V5UHJlc3M6ICdrZXlwcmVzcycsXG4gIHRvcEtleVVwOiAna2V5dXAnLFxuICB0b3BMb2FkZWREYXRhOiAnbG9hZGVkZGF0YScsXG4gIHRvcExvYWQ6ICdsb2FkJyxcbiAgdG9wTG9hZGVkTWV0YWRhdGE6ICdsb2FkZWRtZXRhZGF0YScsXG4gIHRvcExvYWRTdGFydDogJ2xvYWRzdGFydCcsXG4gIHRvcE1vdXNlRG93bjogJ21vdXNlZG93bicsXG4gIHRvcE1vdXNlTW92ZTogJ21vdXNlbW92ZScsXG4gIHRvcE1vdXNlT3V0OiAnbW91c2VvdXQnLFxuICB0b3BNb3VzZU92ZXI6ICdtb3VzZW92ZXInLFxuICB0b3BNb3VzZVVwOiAnbW91c2V1cCcsXG4gIHRvcFBhc3RlOiAncGFzdGUnLFxuICB0b3BQYXVzZTogJ3BhdXNlJyxcbiAgdG9wUGxheTogJ3BsYXknLFxuICB0b3BQbGF5aW5nOiAncGxheWluZycsXG4gIHRvcFByb2dyZXNzOiAncHJvZ3Jlc3MnLFxuICB0b3BSYXRlQ2hhbmdlOiAncmF0ZWNoYW5nZScsXG4gIHRvcFNjcm9sbDogJ3Njcm9sbCcsXG4gIHRvcFNlZWtlZDogJ3NlZWtlZCcsXG4gIHRvcFNlZWtpbmc6ICdzZWVraW5nJyxcbiAgdG9wU2VsZWN0aW9uQ2hhbmdlOiAnc2VsZWN0aW9uY2hhbmdlJyxcbiAgdG9wU3RhbGxlZDogJ3N0YWxsZWQnLFxuICB0b3BTdXNwZW5kOiAnc3VzcGVuZCcsXG4gIHRvcFRleHRJbnB1dDogJ3RleHRJbnB1dCcsXG4gIHRvcFRpbWVVcGRhdGU6ICd0aW1ldXBkYXRlJyxcbiAgdG9wVG9nZ2xlOiAndG9nZ2xlJyxcbiAgdG9wVG91Y2hDYW5jZWw6ICd0b3VjaGNhbmNlbCcsXG4gIHRvcFRvdWNoRW5kOiAndG91Y2hlbmQnLFxuICB0b3BUb3VjaE1vdmU6ICd0b3VjaG1vdmUnLFxuICB0b3BUb3VjaFN0YXJ0OiAndG91Y2hzdGFydCcsXG4gIHRvcFRyYW5zaXRpb25FbmQ6IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCd0cmFuc2l0aW9uZW5kJykgfHwgJ3RyYW5zaXRpb25lbmQnLFxuICB0b3BWb2x1bWVDaGFuZ2U6ICd2b2x1bWVjaGFuZ2UnLFxuICB0b3BXYWl0aW5nOiAnd2FpdGluZycsXG4gIHRvcFdoZWVsOiAnd2hlZWwnXG59O1xuXG52YXIgQnJvd3NlckV2ZW50Q29uc3RhbnRzID0ge1xuICB0b3BMZXZlbFR5cGVzOiB0b3BMZXZlbFR5cGVzJDFcbn07XG5cbmZ1bmN0aW9uIHJ1bkV2ZW50UXVldWVJbkJhdGNoKGV2ZW50cykge1xuICBlbnF1ZXVlRXZlbnRzKGV2ZW50cyk7XG4gIHByb2Nlc3NFdmVudFF1ZXVlKGZhbHNlKTtcbn1cblxuLyoqXG4gKiBTdHJlYW1zIGEgZmlyZWQgdG9wLWxldmVsIGV2ZW50IHRvIGBFdmVudFBsdWdpbkh1YmAgd2hlcmUgcGx1Z2lucyBoYXZlIHRoZVxuICogb3Bwb3J0dW5pdHkgdG8gY3JlYXRlIGBSZWFjdEV2ZW50YHMgdG8gYmUgZGlzcGF0Y2hlZC5cbiAqL1xuZnVuY3Rpb24gaGFuZGxlVG9wTGV2ZWwodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgdmFyIGV2ZW50cyA9IGV4dHJhY3RFdmVudHModG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICBydW5FdmVudFF1ZXVlSW5CYXRjaChldmVudHMpO1xufVxuXG52YXIgdG9wTGV2ZWxUeXBlcyA9IEJyb3dzZXJFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzO1xuXG4vKipcbiAqIFN1bW1hcnkgb2YgYFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcmAgZXZlbnQgaGFuZGxpbmc6XG4gKlxuICogIC0gVG9wLWxldmVsIGRlbGVnYXRpb24gaXMgdXNlZCB0byB0cmFwIG1vc3QgbmF0aXZlIGJyb3dzZXIgZXZlbnRzLiBUaGlzXG4gKiAgICBtYXkgb25seSBvY2N1ciBpbiB0aGUgbWFpbiB0aHJlYWQgYW5kIGlzIHRoZSByZXNwb25zaWJpbGl0eSBvZlxuICogICAgUmVhY3RET01FdmVudExpc3RlbmVyLCB3aGljaCBpcyBpbmplY3RlZCBhbmQgY2FuIHRoZXJlZm9yZSBzdXBwb3J0XG4gKiAgICBwbHVnZ2FibGUgZXZlbnQgc291cmNlcy4gVGhpcyBpcyB0aGUgb25seSB3b3JrIHRoYXQgb2NjdXJzIGluIHRoZSBtYWluXG4gKiAgICB0aHJlYWQuXG4gKlxuICogIC0gV2Ugbm9ybWFsaXplIGFuZCBkZS1kdXBsaWNhdGUgZXZlbnRzIHRvIGFjY291bnQgZm9yIGJyb3dzZXIgcXVpcmtzLiBUaGlzXG4gKiAgICBtYXkgYmUgZG9uZSBpbiB0aGUgd29ya2VyIHRocmVhZC5cbiAqXG4gKiAgLSBGb3J3YXJkIHRoZXNlIG5hdGl2ZSBldmVudHMgKHdpdGggdGhlIGFzc29jaWF0ZWQgdG9wLWxldmVsIHR5cGUgdXNlZCB0b1xuICogICAgdHJhcCBpdCkgdG8gYEV2ZW50UGx1Z2luSHViYCwgd2hpY2ggaW4gdHVybiB3aWxsIGFzayBwbHVnaW5zIGlmIHRoZXkgd2FudFxuICogICAgdG8gZXh0cmFjdCBhbnkgc3ludGhldGljIGV2ZW50cy5cbiAqXG4gKiAgLSBUaGUgYEV2ZW50UGx1Z2luSHViYCB3aWxsIHRoZW4gcHJvY2VzcyBlYWNoIGV2ZW50IGJ5IGFubm90YXRpbmcgdGhlbSB3aXRoXG4gKiAgICBcImRpc3BhdGNoZXNcIiwgYSBzZXF1ZW5jZSBvZiBsaXN0ZW5lcnMgYW5kIElEcyB0aGF0IGNhcmUgYWJvdXQgdGhhdCBldmVudC5cbiAqXG4gKiAgLSBUaGUgYEV2ZW50UGx1Z2luSHViYCB0aGVuIGRpc3BhdGNoZXMgdGhlIGV2ZW50cy5cbiAqXG4gKiBPdmVydmlldyBvZiBSZWFjdCBhbmQgdGhlIGV2ZW50IHN5c3RlbTpcbiAqXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuXG4gKiB8ICAgIERPTSAgICAgfCAgICAuXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuXG4gKiAgICAgICB8ICAgICAgICAgICAuXG4gKiAgICAgICB2ICAgICAgICAgICAuXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuXG4gKiB8IFJlYWN0RXZlbnQgfCAgICAuXG4gKiB8ICBMaXN0ZW5lciAgfCAgICAuXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLStcbiAqICAgICAgIHwgICAgICAgICAgIC4gICAgICAgICAgICAgICArLS0tLS0tLS0rfFNpbXBsZUV2ZW50fFxuICogICAgICAgfCAgICAgICAgICAgLiAgICAgICAgICAgICAgIHwgICAgICAgICB8UGx1Z2luICAgICB8XG4gKiArLS0tLS18LS0tLS0tKyAgICAuICAgICAgICAgICAgICAgdiAgICAgICAgICstLS0tLS0tLS0tLStcbiAqIHwgICAgIHwgICAgICB8ICAgIC4gICAgKy0tLS0tLS0tLS0tLS0tKyAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLStcbiAqIHwgICAgICstLS0tLS0tLS0tLS4tLS0+fEV2ZW50UGx1Z2luSHVifCAgICAgICAgICAgICAgICAgICAgfCAgICBFdmVudCAgIHxcbiAqIHwgICAgICAgICAgICB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfCAgICAgKy0tLS0tLS0tLS0tKyAgfCBQcm9wYWdhdG9yc3xcbiAqIHwgUmVhY3RFdmVudCB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfCAgICAgfFRhcEV2ZW50ICAgfCAgfC0tLS0tLS0tLS0tLXxcbiAqIHwgIEVtaXR0ZXIgICB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfDwtLS0rfFBsdWdpbiAgICAgfCAgfG90aGVyIHBsdWdpbnxcbiAqIHwgICAgICAgICAgICB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfCAgICAgKy0tLS0tLS0tLS0tKyAgfCAgdXRpbGl0aWVzIHxcbiAqIHwgICAgICstLS0tLS0tLS0tLS4tLS0+fCAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLStcbiAqIHwgICAgIHwgICAgICB8ICAgIC4gICAgKy0tLS0tLS0tLS0tLS0tK1xuICogKy0tLS0tfC0tLS0tLSsgICAgLiAgICAgICAgICAgICAgICBeICAgICAgICArLS0tLS0tLS0tLS0rXG4gKiAgICAgICB8ICAgICAgICAgICAuICAgICAgICAgICAgICAgIHwgICAgICAgIHxFbnRlci9MZWF2ZXxcbiAqICAgICAgICsgICAgICAgICAgIC4gICAgICAgICAgICAgICAgKy0tLS0tLS0rfFBsdWdpbiAgICAgfFxuICogKy0tLS0tLS0tLS0tLS0rICAgLiAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0rXG4gKiB8IGFwcGxpY2F0aW9uIHwgICAuXG4gKiB8LS0tLS0tLS0tLS0tLXwgICAuXG4gKiB8ICAgICAgICAgICAgIHwgICAuXG4gKiB8ICAgICAgICAgICAgIHwgICAuXG4gKiArLS0tLS0tLS0tLS0tLSsgICAuXG4gKiAgICAgICAgICAgICAgICAgICAuXG4gKiAgICBSZWFjdCBDb3JlICAgICAuICBHZW5lcmFsIFB1cnBvc2UgRXZlbnQgUGx1Z2luIFN5c3RlbVxuICovXG5cbnZhciBhbHJlYWR5TGlzdGVuaW5nVG8gPSB7fTtcbnZhciByZWFjdFRvcExpc3RlbmVyc0NvdW50ZXIgPSAwO1xuXG4vKipcbiAqIFRvIGVuc3VyZSBubyBjb25mbGljdHMgd2l0aCBvdGhlciBwb3RlbnRpYWwgUmVhY3QgaW5zdGFuY2VzIG9uIHRoZSBwYWdlXG4gKi9cbnZhciB0b3BMaXN0ZW5lcnNJREtleSA9ICdfcmVhY3RMaXN0ZW5lcnNJRCcgKyAoJycgKyBNYXRoLnJhbmRvbSgpKS5zbGljZSgyKTtcblxuZnVuY3Rpb24gZ2V0TGlzdGVuaW5nRm9yRG9jdW1lbnQobW91bnRBdCkge1xuICAvLyBJbiBJRTgsIGBtb3VudEF0YCBpcyBhIGhvc3Qgb2JqZWN0IGFuZCBkb2Vzbid0IGhhdmUgYGhhc093blByb3BlcnR5YFxuICAvLyBkaXJlY3RseS5cbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW91bnRBdCwgdG9wTGlzdGVuZXJzSURLZXkpKSB7XG4gICAgbW91bnRBdFt0b3BMaXN0ZW5lcnNJREtleV0gPSByZWFjdFRvcExpc3RlbmVyc0NvdW50ZXIrKztcbiAgICBhbHJlYWR5TGlzdGVuaW5nVG9bbW91bnRBdFt0b3BMaXN0ZW5lcnNJREtleV1dID0ge307XG4gIH1cbiAgcmV0dXJuIGFscmVhZHlMaXN0ZW5pbmdUb1ttb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XV07XG59XG5cbi8qKlxuICogV2UgbGlzdGVuIGZvciBidWJibGVkIHRvdWNoIGV2ZW50cyBvbiB0aGUgZG9jdW1lbnQgb2JqZWN0LlxuICpcbiAqIEZpcmVmb3ggdjguMDEgKGFuZCBwb3NzaWJseSBvdGhlcnMpIGV4aGliaXRlZCBzdHJhbmdlIGJlaGF2aW9yIHdoZW5cbiAqIG1vdW50aW5nIGBvbm1vdXNlbW92ZWAgZXZlbnRzIGF0IHNvbWUgbm9kZSB0aGF0IHdhcyBub3QgdGhlIGRvY3VtZW50XG4gKiBlbGVtZW50LiBUaGUgc3ltcHRvbXMgd2VyZSB0aGF0IGlmIHlvdXIgbW91c2UgaXMgbm90IG1vdmluZyBvdmVyIHNvbWV0aGluZ1xuICogY29udGFpbmVkIHdpdGhpbiB0aGF0IG1vdW50IHBvaW50IChmb3IgZXhhbXBsZSBvbiB0aGUgYmFja2dyb3VuZCkgdGhlXG4gKiB0b3AtbGV2ZWwgbGlzdGVuZXJzIGZvciBgb25tb3VzZW1vdmVgIHdvbid0IGJlIGNhbGxlZC4gSG93ZXZlciwgaWYgeW91XG4gKiByZWdpc3RlciB0aGUgYG1vdXNlbW92ZWAgb24gdGhlIGRvY3VtZW50IG9iamVjdCwgdGhlbiBpdCB3aWxsIG9mIGNvdXJzZVxuICogY2F0Y2ggYWxsIGBtb3VzZW1vdmVgcy4gVGhpcyBhbG9uZyB3aXRoIGlPUyBxdWlya3MsIGp1c3RpZmllcyByZXN0cmljdGluZ1xuICogdG9wLWxldmVsIGxpc3RlbmVycyB0byB0aGUgZG9jdW1lbnQgb2JqZWN0IG9ubHksIGF0IGxlYXN0IGZvciB0aGVzZVxuICogbW92ZW1lbnQgdHlwZXMgb2YgZXZlbnRzIGFuZCBwb3NzaWJseSBhbGwgZXZlbnRzLlxuICpcbiAqIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTAvMDkvY2xpY2tfZXZlbnRfZGVsLmh0bWxcbiAqXG4gKiBBbHNvLCBga2V5dXBgL2BrZXlwcmVzc2AvYGtleWRvd25gIGRvIG5vdCBidWJibGUgdG8gdGhlIHdpbmRvdyBvbiBJRSwgYnV0XG4gKiB0aGV5IGJ1YmJsZSB0byBkb2N1bWVudC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gKiBAcGFyYW0ge29iamVjdH0gY29udGVudERvY3VtZW50SGFuZGxlIERvY3VtZW50IHdoaWNoIG93bnMgdGhlIGNvbnRhaW5lclxuICovXG5mdW5jdGlvbiBsaXN0ZW5UbyhyZWdpc3RyYXRpb25OYW1lLCBjb250ZW50RG9jdW1lbnRIYW5kbGUpIHtcbiAgdmFyIG1vdW50QXQgPSBjb250ZW50RG9jdW1lbnRIYW5kbGU7XG4gIHZhciBpc0xpc3RlbmluZyA9IGdldExpc3RlbmluZ0ZvckRvY3VtZW50KG1vdW50QXQpO1xuICB2YXIgZGVwZW5kZW5jaWVzID0gcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llc1tyZWdpc3RyYXRpb25OYW1lXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGRlcGVuZGVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXBlbmRlbmN5ID0gZGVwZW5kZW5jaWVzW2ldO1xuICAgIGlmICghKGlzTGlzdGVuaW5nLmhhc093blByb3BlcnR5KGRlcGVuZGVuY3kpICYmIGlzTGlzdGVuaW5nW2RlcGVuZGVuY3ldKSkge1xuICAgICAgaWYgKGRlcGVuZGVuY3kgPT09ICd0b3BTY3JvbGwnKSB7XG4gICAgICAgIHRyYXBDYXB0dXJlZEV2ZW50KCd0b3BTY3JvbGwnLCAnc2Nyb2xsJywgbW91bnRBdCk7XG4gICAgICB9IGVsc2UgaWYgKGRlcGVuZGVuY3kgPT09ICd0b3BGb2N1cycgfHwgZGVwZW5kZW5jeSA9PT0gJ3RvcEJsdXInKSB7XG4gICAgICAgIHRyYXBDYXB0dXJlZEV2ZW50KCd0b3BGb2N1cycsICdmb2N1cycsIG1vdW50QXQpO1xuICAgICAgICB0cmFwQ2FwdHVyZWRFdmVudCgndG9wQmx1cicsICdibHVyJywgbW91bnRBdCk7XG5cbiAgICAgICAgLy8gdG8gbWFrZSBzdXJlIGJsdXIgYW5kIGZvY3VzIGV2ZW50IGxpc3RlbmVycyBhcmUgb25seSBhdHRhY2hlZCBvbmNlXG4gICAgICAgIGlzTGlzdGVuaW5nLnRvcEJsdXIgPSB0cnVlO1xuICAgICAgICBpc0xpc3RlbmluZy50b3BGb2N1cyA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGRlcGVuZGVuY3kgPT09ICd0b3BDYW5jZWwnKSB7XG4gICAgICAgIGlmIChpc0V2ZW50U3VwcG9ydGVkKCdjYW5jZWwnLCB0cnVlKSkge1xuICAgICAgICAgIHRyYXBDYXB0dXJlZEV2ZW50KCd0b3BDYW5jZWwnLCAnY2FuY2VsJywgbW91bnRBdCk7XG4gICAgICAgIH1cbiAgICAgICAgaXNMaXN0ZW5pbmcudG9wQ2FuY2VsID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZGVwZW5kZW5jeSA9PT0gJ3RvcENsb3NlJykge1xuICAgICAgICBpZiAoaXNFdmVudFN1cHBvcnRlZCgnY2xvc2UnLCB0cnVlKSkge1xuICAgICAgICAgIHRyYXBDYXB0dXJlZEV2ZW50KCd0b3BDbG9zZScsICdjbG9zZScsIG1vdW50QXQpO1xuICAgICAgICB9XG4gICAgICAgIGlzTGlzdGVuaW5nLnRvcENsb3NlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodG9wTGV2ZWxUeXBlcy5oYXNPd25Qcm9wZXJ0eShkZXBlbmRlbmN5KSkge1xuICAgICAgICB0cmFwQnViYmxlZEV2ZW50KGRlcGVuZGVuY3ksIHRvcExldmVsVHlwZXNbZGVwZW5kZW5jeV0sIG1vdW50QXQpO1xuICAgICAgfVxuXG4gICAgICBpc0xpc3RlbmluZ1tkZXBlbmRlbmN5XSA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzTGlzdGVuaW5nVG9BbGxEZXBlbmRlbmNpZXMocmVnaXN0cmF0aW9uTmFtZSwgbW91bnRBdCkge1xuICB2YXIgaXNMaXN0ZW5pbmcgPSBnZXRMaXN0ZW5pbmdGb3JEb2N1bWVudChtb3VudEF0KTtcbiAgdmFyIGRlcGVuZGVuY2llcyA9IHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXNbcmVnaXN0cmF0aW9uTmFtZV07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGVwZW5kZW5jaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlcGVuZGVuY3kgPSBkZXBlbmRlbmNpZXNbaV07XG4gICAgaWYgKCEoaXNMaXN0ZW5pbmcuaGFzT3duUHJvcGVydHkoZGVwZW5kZW5jeSkgJiYgaXNMaXN0ZW5pbmdbZGVwZW5kZW5jeV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEdpdmVuIGFueSBub2RlIHJldHVybiB0aGUgZmlyc3QgbGVhZiBub2RlIHdpdGhvdXQgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcmV0dXJuIHtET01FbGVtZW50fERPTVRleHROb2RlfVxuICovXG5mdW5jdGlvbiBnZXRMZWFmTm9kZShub2RlKSB7XG4gIHdoaWxlIChub2RlICYmIG5vZGUuZmlyc3RDaGlsZCkge1xuICAgIG5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5cbi8qKlxuICogR2V0IHRoZSBuZXh0IHNpYmxpbmcgd2l0aGluIGEgY29udGFpbmVyLiBUaGlzIHdpbGwgd2FsayB1cCB0aGVcbiAqIERPTSBpZiBhIG5vZGUncyBzaWJsaW5ncyBoYXZlIGJlZW4gZXhoYXVzdGVkLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHJldHVybiB7P0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9XG4gKi9cbmZ1bmN0aW9uIGdldFNpYmxpbmdOb2RlKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZS5uZXh0U2libGluZykge1xuICAgICAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmc7XG4gICAgfVxuICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgb2JqZWN0IGRlc2NyaWJpbmcgdGhlIG5vZGVzIHdoaWNoIGNvbnRhaW4gY2hhcmFjdGVycyBhdCBvZmZzZXQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSByb290XG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcmV0dXJuIHs/b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KHJvb3QsIG9mZnNldCkge1xuICB2YXIgbm9kZSA9IGdldExlYWZOb2RlKHJvb3QpO1xuICB2YXIgbm9kZVN0YXJ0ID0gMDtcbiAgdmFyIG5vZGVFbmQgPSAwO1xuXG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IFRFWFRfTk9ERSkge1xuICAgICAgbm9kZUVuZCA9IG5vZGVTdGFydCArIG5vZGUudGV4dENvbnRlbnQubGVuZ3RoO1xuXG4gICAgICBpZiAobm9kZVN0YXJ0IDw9IG9mZnNldCAmJiBub2RlRW5kID49IG9mZnNldCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgICAgb2Zmc2V0OiBvZmZzZXQgLSBub2RlU3RhcnRcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgbm9kZVN0YXJ0ID0gbm9kZUVuZDtcbiAgICB9XG5cbiAgICBub2RlID0gZ2V0TGVhZk5vZGUoZ2V0U2libGluZ05vZGUobm9kZSkpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBvdXRlck5vZGVcbiAqIEByZXR1cm4gez9vYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldE9mZnNldHMob3V0ZXJOb2RlKSB7XG4gIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uICYmIHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcblxuICBpZiAoIXNlbGVjdGlvbiB8fCBzZWxlY3Rpb24ucmFuZ2VDb3VudCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGFuY2hvck5vZGUgPSBzZWxlY3Rpb24uYW5jaG9yTm9kZSxcbiAgICAgIGFuY2hvck9mZnNldCA9IHNlbGVjdGlvbi5hbmNob3JPZmZzZXQsXG4gICAgICBmb2N1c05vZGUkJDEgPSBzZWxlY3Rpb24uZm9jdXNOb2RlLFxuICAgICAgZm9jdXNPZmZzZXQgPSBzZWxlY3Rpb24uZm9jdXNPZmZzZXQ7XG5cbiAgLy8gSW4gRmlyZWZveCwgYW5jaG9yTm9kZSBhbmQgZm9jdXNOb2RlIGNhbiBiZSBcImFub255bW91cyBkaXZzXCIsIGUuZy4gdGhlXG4gIC8vIHVwL2Rvd24gYnV0dG9ucyBvbiBhbiA8aW5wdXQgdHlwZT1cIm51bWJlclwiPi4gQW5vbnltb3VzIGRpdnMgZG8gbm90IHNlZW0gdG9cbiAgLy8gZXhwb3NlIHByb3BlcnRpZXMsIHRyaWdnZXJpbmcgYSBcIlBlcm1pc3Npb24gZGVuaWVkIGVycm9yXCIgaWYgYW55IG9mIGl0c1xuICAvLyBwcm9wZXJ0aWVzIGFyZSBhY2Nlc3NlZC4gVGhlIG9ubHkgc2VlbWluZ2x5IHBvc3NpYmxlIHdheSB0byBhdm9pZCBlcnJvcmluZ1xuICAvLyBpcyB0byBhY2Nlc3MgYSBwcm9wZXJ0eSB0aGF0IHR5cGljYWxseSB3b3JrcyBmb3Igbm9uLWFub255bW91cyBkaXZzIGFuZFxuICAvLyBjYXRjaCBhbnkgZXJyb3IgdGhhdCBtYXkgb3RoZXJ3aXNlIGFyaXNlLiBTZWVcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjA4NDI3XG5cbiAgdHJ5IHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtZXhwcmVzc2lvbnMgKi9cbiAgICBhbmNob3JOb2RlLm5vZGVUeXBlO1xuICAgIGZvY3VzTm9kZSQkMS5ub2RlVHlwZTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC1leHByZXNzaW9ucyAqL1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gZ2V0TW9kZXJuT2Zmc2V0c0Zyb21Qb2ludHMob3V0ZXJOb2RlLCBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSQkMSwgZm9jdXNPZmZzZXQpO1xufVxuXG4vKipcbiAqIFJldHVybnMge3N0YXJ0LCBlbmR9IHdoZXJlIGBzdGFydGAgaXMgdGhlIGNoYXJhY3Rlci9jb2RlcG9pbnQgaW5kZXggb2ZcbiAqIChhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQpIHdpdGhpbiB0aGUgdGV4dENvbnRlbnQgb2YgYG91dGVyTm9kZWAsIGFuZFxuICogYGVuZGAgaXMgdGhlIGluZGV4IG9mIChmb2N1c05vZGUsIGZvY3VzT2Zmc2V0KS5cbiAqXG4gKiBSZXR1cm5zIG51bGwgaWYgeW91IHBhc3MgaW4gZ2FyYmFnZSBpbnB1dCBidXQgd2Ugc2hvdWxkIHByb2JhYmx5IGp1c3QgY3Jhc2guXG4gKlxuICogRXhwb3J0ZWQgb25seSBmb3IgdGVzdGluZy5cbiAqL1xuZnVuY3Rpb24gZ2V0TW9kZXJuT2Zmc2V0c0Zyb21Qb2ludHMob3V0ZXJOb2RlLCBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSQkMSwgZm9jdXNPZmZzZXQpIHtcbiAgdmFyIGxlbmd0aCA9IDA7XG4gIHZhciBzdGFydCA9IC0xO1xuICB2YXIgZW5kID0gLTE7XG4gIHZhciBpbmRleFdpdGhpbkFuY2hvciA9IDA7XG4gIHZhciBpbmRleFdpdGhpbkZvY3VzID0gMDtcbiAgdmFyIG5vZGUgPSBvdXRlck5vZGU7XG4gIHZhciBwYXJlbnROb2RlID0gbnVsbDtcblxuICBvdXRlcjogd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgbmV4dCA9IG51bGw7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKG5vZGUgPT09IGFuY2hvck5vZGUgJiYgKGFuY2hvck9mZnNldCA9PT0gMCB8fCBub2RlLm5vZGVUeXBlID09PSBURVhUX05PREUpKSB7XG4gICAgICAgIHN0YXJ0ID0gbGVuZ3RoICsgYW5jaG9yT2Zmc2V0O1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUgPT09IGZvY3VzTm9kZSQkMSAmJiAoZm9jdXNPZmZzZXQgPT09IDAgfHwgbm9kZS5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFKSkge1xuICAgICAgICBlbmQgPSBsZW5ndGggKyBmb2N1c09mZnNldDtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IFRFWFRfTk9ERSkge1xuICAgICAgICBsZW5ndGggKz0gbm9kZS5ub2RlVmFsdWUubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBpZiAoKG5leHQgPSBub2RlLmZpcnN0Q2hpbGQpID09PSBudWxsKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8gTW92aW5nIGZyb20gYG5vZGVgIHRvIGl0cyBmaXJzdCBjaGlsZCBgbmV4dGAuXG4gICAgICBwYXJlbnROb2RlID0gbm9kZTtcbiAgICAgIG5vZGUgPSBuZXh0O1xuICAgIH1cblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAobm9kZSA9PT0gb3V0ZXJOb2RlKSB7XG4gICAgICAgIC8vIElmIGBvdXRlck5vZGVgIGhhcyBjaGlsZHJlbiwgdGhpcyBpcyBhbHdheXMgdGhlIHNlY29uZCB0aW1lIHZpc2l0aW5nXG4gICAgICAgIC8vIGl0LiBJZiBpdCBoYXMgbm8gY2hpbGRyZW4sIHRoaXMgaXMgc3RpbGwgdGhlIGZpcnN0IGxvb3AsIGFuZCB0aGUgb25seVxuICAgICAgICAvLyB2YWxpZCBzZWxlY3Rpb24gaXMgYW5jaG9yTm9kZSBhbmQgZm9jdXNOb2RlIGJvdGggZXF1YWwgdG8gdGhpcyBub2RlXG4gICAgICAgIC8vIGFuZCBib3RoIG9mZnNldHMgMCwgaW4gd2hpY2ggY2FzZSB3ZSB3aWxsIGhhdmUgaGFuZGxlZCBhYm92ZS5cbiAgICAgICAgYnJlYWsgb3V0ZXI7XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50Tm9kZSA9PT0gYW5jaG9yTm9kZSAmJiArK2luZGV4V2l0aGluQW5jaG9yID09PSBhbmNob3JPZmZzZXQpIHtcbiAgICAgICAgc3RhcnQgPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50Tm9kZSA9PT0gZm9jdXNOb2RlJCQxICYmICsraW5kZXhXaXRoaW5Gb2N1cyA9PT0gZm9jdXNPZmZzZXQpIHtcbiAgICAgICAgZW5kID0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgaWYgKChuZXh0ID0gbm9kZS5uZXh0U2libGluZykgIT09IG51bGwpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBub2RlID0gcGFyZW50Tm9kZTtcbiAgICAgIHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuXG4gICAgLy8gTW92aW5nIGZyb20gYG5vZGVgIHRvIGl0cyBuZXh0IHNpYmxpbmcgYG5leHRgLlxuICAgIG5vZGUgPSBuZXh0O1xuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSAtMSB8fCBlbmQgPT09IC0xKSB7XG4gICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLiAoV291bGQgaGFwcGVuIGlmIHRoZSBhbmNob3IvZm9jdXMgbm9kZXMgYXJlbid0XG4gICAgLy8gYWN0dWFsbHkgaW5zaWRlIHRoZSBwYXNzZWQtaW4gbm9kZS4pXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBzdGFydCxcbiAgICBlbmQ6IGVuZFxuICB9O1xufVxuXG4vKipcbiAqIEluIG1vZGVybiBub24tSUUgYnJvd3NlcnMsIHdlIGNhbiBzdXBwb3J0IGJvdGggZm9yd2FyZCBhbmQgYmFja3dhcmRcbiAqIHNlbGVjdGlvbnMuXG4gKlxuICogTm90ZTogSUUxMCsgc3VwcG9ydHMgdGhlIFNlbGVjdGlvbiBvYmplY3QsIGJ1dCBpdCBkb2VzIG5vdCBzdXBwb3J0XG4gKiB0aGUgYGV4dGVuZGAgbWV0aG9kLCB3aGljaCBtZWFucyB0aGF0IGV2ZW4gaW4gbW9kZXJuIElFLCBpdCdzIG5vdCBwb3NzaWJsZVxuICogdG8gcHJvZ3JhbW1hdGljYWxseSBjcmVhdGUgYSBiYWNrd2FyZCBzZWxlY3Rpb24uIFRodXMsIGZvciBhbGwgSUVcbiAqIHZlcnNpb25zLCB3ZSB1c2UgdGhlIG9sZCBJRSBBUEkgdG8gY3JlYXRlIG91ciBzZWxlY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtvYmplY3R9IG9mZnNldHNcbiAqL1xuZnVuY3Rpb24gc2V0T2Zmc2V0cyhub2RlLCBvZmZzZXRzKSB7XG4gIGlmICghd2luZG93LmdldFNlbGVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gIHZhciBsZW5ndGggPSBub2RlW2dldFRleHRDb250ZW50QWNjZXNzb3IoKV0ubGVuZ3RoO1xuICB2YXIgc3RhcnQgPSBNYXRoLm1pbihvZmZzZXRzLnN0YXJ0LCBsZW5ndGgpO1xuICB2YXIgZW5kID0gb2Zmc2V0cy5lbmQgPT09IHVuZGVmaW5lZCA/IHN0YXJ0IDogTWF0aC5taW4ob2Zmc2V0cy5lbmQsIGxlbmd0aCk7XG5cbiAgLy8gSUUgMTEgdXNlcyBtb2Rlcm4gc2VsZWN0aW9uLCBidXQgZG9lc24ndCBzdXBwb3J0IHRoZSBleHRlbmQgbWV0aG9kLlxuICAvLyBGbGlwIGJhY2t3YXJkIHNlbGVjdGlvbnMsIHNvIHdlIGNhbiBzZXQgd2l0aCBhIHNpbmdsZSByYW5nZS5cbiAgaWYgKCFzZWxlY3Rpb24uZXh0ZW5kICYmIHN0YXJ0ID4gZW5kKSB7XG4gICAgdmFyIHRlbXAgPSBlbmQ7XG4gICAgZW5kID0gc3RhcnQ7XG4gICAgc3RhcnQgPSB0ZW1wO1xuICB9XG5cbiAgdmFyIHN0YXJ0TWFya2VyID0gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChub2RlLCBzdGFydCk7XG4gIHZhciBlbmRNYXJrZXIgPSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KG5vZGUsIGVuZCk7XG5cbiAgaWYgKHN0YXJ0TWFya2VyICYmIGVuZE1hcmtlcikge1xuICAgIGlmIChzZWxlY3Rpb24ucmFuZ2VDb3VudCA9PT0gMSAmJiBzZWxlY3Rpb24uYW5jaG9yTm9kZSA9PT0gc3RhcnRNYXJrZXIubm9kZSAmJiBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0ID09PSBzdGFydE1hcmtlci5vZmZzZXQgJiYgc2VsZWN0aW9uLmZvY3VzTm9kZSA9PT0gZW5kTWFya2VyLm5vZGUgJiYgc2VsZWN0aW9uLmZvY3VzT2Zmc2V0ID09PSBlbmRNYXJrZXIub2Zmc2V0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgcmFuZ2Uuc2V0U3RhcnQoc3RhcnRNYXJrZXIubm9kZSwgc3RhcnRNYXJrZXIub2Zmc2V0KTtcbiAgICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHtcbiAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gICAgICBzZWxlY3Rpb24uZXh0ZW5kKGVuZE1hcmtlci5ub2RlLCBlbmRNYXJrZXIub2Zmc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmFuZ2Uuc2V0RW5kKGVuZE1hcmtlci5ub2RlLCBlbmRNYXJrZXIub2Zmc2V0KTtcbiAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzSW5Eb2N1bWVudChub2RlKSB7XG4gIHJldHVybiBjb250YWluc05vZGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBub2RlKTtcbn1cblxuLyoqXG4gKiBAUmVhY3RJbnB1dFNlbGVjdGlvbjogUmVhY3QgaW5wdXQgc2VsZWN0aW9uIG1vZHVsZS4gQmFzZWQgb24gU2VsZWN0aW9uLmpzLFxuICogYnV0IG1vZGlmaWVkIHRvIGJlIHN1aXRhYmxlIGZvciByZWFjdCBhbmQgaGFzIGEgY291cGxlIG9mIGJ1ZyBmaXhlcyAoZG9lc24ndFxuICogYXNzdW1lIGJ1dHRvbnMgaGF2ZSByYW5nZSBzZWxlY3Rpb25zIGFsbG93ZWQpLlxuICogSW5wdXQgc2VsZWN0aW9uIG1vZHVsZSBmb3IgUmVhY3QuXG4gKi9cblxuZnVuY3Rpb24gaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKGVsZW0pIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbSAmJiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIG5vZGVOYW1lICYmIChub2RlTmFtZSA9PT0gJ2lucHV0JyAmJiBlbGVtLnR5cGUgPT09ICd0ZXh0JyB8fCBub2RlTmFtZSA9PT0gJ3RleHRhcmVhJyB8fCBlbGVtLmNvbnRlbnRFZGl0YWJsZSA9PT0gJ3RydWUnKTtcbn1cblxuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uSW5mb3JtYXRpb24oKSB7XG4gIHZhciBmb2N1c2VkRWxlbSA9IGdldEFjdGl2ZUVsZW1lbnQoKTtcbiAgcmV0dXJuIHtcbiAgICBmb2N1c2VkRWxlbTogZm9jdXNlZEVsZW0sXG4gICAgc2VsZWN0aW9uUmFuZ2U6IGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhmb2N1c2VkRWxlbSkgPyBnZXRTZWxlY3Rpb24kMShmb2N1c2VkRWxlbSkgOiBudWxsXG4gIH07XG59XG5cbi8qKlxuICogQHJlc3RvcmVTZWxlY3Rpb246IElmIGFueSBzZWxlY3Rpb24gaW5mb3JtYXRpb24gd2FzIHBvdGVudGlhbGx5IGxvc3QsXG4gKiByZXN0b3JlIGl0LiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHBlcmZvcm1pbmcgb3BlcmF0aW9ucyB0aGF0IGNvdWxkIHJlbW92ZSBkb21cbiAqIG5vZGVzIGFuZCBwbGFjZSB0aGVtIGJhY2sgaW4sIHJlc3VsdGluZyBpbiBmb2N1cyBiZWluZyBsb3N0LlxuICovXG5mdW5jdGlvbiByZXN0b3JlU2VsZWN0aW9uKHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24pIHtcbiAgdmFyIGN1ckZvY3VzZWRFbGVtID0gZ2V0QWN0aXZlRWxlbWVudCgpO1xuICB2YXIgcHJpb3JGb2N1c2VkRWxlbSA9IHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24uZm9jdXNlZEVsZW07XG4gIHZhciBwcmlvclNlbGVjdGlvblJhbmdlID0gcHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbi5zZWxlY3Rpb25SYW5nZTtcbiAgaWYgKGN1ckZvY3VzZWRFbGVtICE9PSBwcmlvckZvY3VzZWRFbGVtICYmIGlzSW5Eb2N1bWVudChwcmlvckZvY3VzZWRFbGVtKSkge1xuICAgIGlmIChoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMocHJpb3JGb2N1c2VkRWxlbSkpIHtcbiAgICAgIHNldFNlbGVjdGlvbihwcmlvckZvY3VzZWRFbGVtLCBwcmlvclNlbGVjdGlvblJhbmdlKTtcbiAgICB9XG5cbiAgICAvLyBGb2N1c2luZyBhIG5vZGUgY2FuIGNoYW5nZSB0aGUgc2Nyb2xsIHBvc2l0aW9uLCB3aGljaCBpcyB1bmRlc2lyYWJsZVxuICAgIHZhciBhbmNlc3RvcnMgPSBbXTtcbiAgICB2YXIgYW5jZXN0b3IgPSBwcmlvckZvY3VzZWRFbGVtO1xuICAgIHdoaWxlIChhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudE5vZGUpIHtcbiAgICAgIGlmIChhbmNlc3Rvci5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgIGFuY2VzdG9ycy5wdXNoKHtcbiAgICAgICAgICBlbGVtZW50OiBhbmNlc3RvcixcbiAgICAgICAgICBsZWZ0OiBhbmNlc3Rvci5zY3JvbGxMZWZ0LFxuICAgICAgICAgIHRvcDogYW5jZXN0b3Iuc2Nyb2xsVG9wXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvY3VzTm9kZShwcmlvckZvY3VzZWRFbGVtKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5jZXN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaW5mbyA9IGFuY2VzdG9yc1tpXTtcbiAgICAgIGluZm8uZWxlbWVudC5zY3JvbGxMZWZ0ID0gaW5mby5sZWZ0O1xuICAgICAgaW5mby5lbGVtZW50LnNjcm9sbFRvcCA9IGluZm8udG9wO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBnZXRTZWxlY3Rpb246IEdldHMgdGhlIHNlbGVjdGlvbiBib3VuZHMgb2YgYSBmb2N1c2VkIHRleHRhcmVhLCBpbnB1dCBvclxuICogY29udGVudEVkaXRhYmxlIG5vZGUuXG4gKiAtQGlucHV0OiBMb29rIHVwIHNlbGVjdGlvbiBib3VuZHMgb2YgdGhpcyBpbnB1dFxuICogLUByZXR1cm4ge3N0YXJ0OiBzZWxlY3Rpb25TdGFydCwgZW5kOiBzZWxlY3Rpb25FbmR9XG4gKi9cbmZ1bmN0aW9uIGdldFNlbGVjdGlvbiQxKGlucHV0KSB7XG4gIHZhciBzZWxlY3Rpb24gPSB2b2lkIDA7XG5cbiAgaWYgKCdzZWxlY3Rpb25TdGFydCcgaW4gaW5wdXQpIHtcbiAgICAvLyBNb2Rlcm4gYnJvd3NlciB3aXRoIGlucHV0IG9yIHRleHRhcmVhLlxuICAgIHNlbGVjdGlvbiA9IHtcbiAgICAgIHN0YXJ0OiBpbnB1dC5zZWxlY3Rpb25TdGFydCxcbiAgICAgIGVuZDogaW5wdXQuc2VsZWN0aW9uRW5kXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBDb250ZW50IGVkaXRhYmxlIG9yIG9sZCBJRSB0ZXh0YXJlYS5cbiAgICBzZWxlY3Rpb24gPSBnZXRPZmZzZXRzKGlucHV0KTtcbiAgfVxuXG4gIHJldHVybiBzZWxlY3Rpb24gfHwgeyBzdGFydDogMCwgZW5kOiAwIH07XG59XG5cbi8qKlxuICogQHNldFNlbGVjdGlvbjogU2V0cyB0aGUgc2VsZWN0aW9uIGJvdW5kcyBvZiBhIHRleHRhcmVhIG9yIGlucHV0IGFuZCBmb2N1c2VzXG4gKiB0aGUgaW5wdXQuXG4gKiAtQGlucHV0ICAgICBTZXQgc2VsZWN0aW9uIGJvdW5kcyBvZiB0aGlzIGlucHV0IG9yIHRleHRhcmVhXG4gKiAtQG9mZnNldHMgICBPYmplY3Qgb2Ygc2FtZSBmb3JtIHRoYXQgaXMgcmV0dXJuZWQgZnJvbSBnZXQqXG4gKi9cbmZ1bmN0aW9uIHNldFNlbGVjdGlvbihpbnB1dCwgb2Zmc2V0cykge1xuICB2YXIgc3RhcnQgPSBvZmZzZXRzLnN0YXJ0LFxuICAgICAgZW5kID0gb2Zmc2V0cy5lbmQ7XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gc3RhcnQ7XG4gIH1cblxuICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBpbnB1dCkge1xuICAgIGlucHV0LnNlbGVjdGlvblN0YXJ0ID0gc3RhcnQ7XG4gICAgaW5wdXQuc2VsZWN0aW9uRW5kID0gTWF0aC5taW4oZW5kLCBpbnB1dC52YWx1ZS5sZW5ndGgpO1xuICB9IGVsc2Uge1xuICAgIHNldE9mZnNldHMoaW5wdXQsIG9mZnNldHMpO1xuICB9XG59XG5cbnZhciBza2lwU2VsZWN0aW9uQ2hhbmdlRXZlbnQgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRNb2RlIDw9IDExO1xuXG52YXIgZXZlbnRUeXBlcyQzID0ge1xuICBzZWxlY3Q6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogJ29uU2VsZWN0JyxcbiAgICAgIGNhcHR1cmVkOiAnb25TZWxlY3RDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcEJsdXInLCAndG9wQ29udGV4dE1lbnUnLCAndG9wRm9jdXMnLCAndG9wS2V5RG93bicsICd0b3BLZXlVcCcsICd0b3BNb3VzZURvd24nLCAndG9wTW91c2VVcCcsICd0b3BTZWxlY3Rpb25DaGFuZ2UnXVxuICB9XG59O1xuXG52YXIgYWN0aXZlRWxlbWVudCQxID0gbnVsbDtcbnZhciBhY3RpdmVFbGVtZW50SW5zdCQxID0gbnVsbDtcbnZhciBsYXN0U2VsZWN0aW9uID0gbnVsbDtcbnZhciBtb3VzZURvd24gPSBmYWxzZTtcblxuLyoqXG4gKiBHZXQgYW4gb2JqZWN0IHdoaWNoIGlzIGEgdW5pcXVlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAqXG4gKiBUaGUgcmV0dXJuIHZhbHVlIHdpbGwgbm90IGJlIGNvbnNpc3RlbnQgYWNyb3NzIG5vZGVzIG9yIGJyb3dzZXJzLCBidXRcbiAqIHR3byBpZGVudGljYWwgc2VsZWN0aW9ucyBvbiB0aGUgc2FtZSBub2RlIHdpbGwgcmV0dXJuIGlkZW50aWNhbCBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb24obm9kZSkge1xuICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBub2RlICYmIGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhub2RlKSkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydDogbm9kZS5zZWxlY3Rpb25TdGFydCxcbiAgICAgIGVuZDogbm9kZS5zZWxlY3Rpb25FbmRcbiAgICB9O1xuICB9IGVsc2UgaWYgKHdpbmRvdy5nZXRTZWxlY3Rpb24pIHtcbiAgICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgIHJldHVybiB7XG4gICAgICBhbmNob3JOb2RlOiBzZWxlY3Rpb24uYW5jaG9yTm9kZSxcbiAgICAgIGFuY2hvck9mZnNldDogc2VsZWN0aW9uLmFuY2hvck9mZnNldCxcbiAgICAgIGZvY3VzTm9kZTogc2VsZWN0aW9uLmZvY3VzTm9kZSxcbiAgICAgIGZvY3VzT2Zmc2V0OiBzZWxlY3Rpb24uZm9jdXNPZmZzZXRcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogUG9sbCBzZWxlY3Rpb24gdG8gc2VlIHdoZXRoZXIgaXQncyBjaGFuZ2VkLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7P1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBjb25zdHJ1Y3RTZWxlY3RFdmVudChuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgLy8gRW5zdXJlIHdlIGhhdmUgdGhlIHJpZ2h0IGVsZW1lbnQsIGFuZCB0aGF0IHRoZSB1c2VyIGlzIG5vdCBkcmFnZ2luZyBhXG4gIC8vIHNlbGVjdGlvbiAodGhpcyBtYXRjaGVzIG5hdGl2ZSBgc2VsZWN0YCBldmVudCBiZWhhdmlvcikuIEluIEhUTUw1LCBzZWxlY3RcbiAgLy8gZmlyZXMgb25seSBvbiBpbnB1dCBhbmQgdGV4dGFyZWEgdGh1cyBpZiB0aGVyZSdzIG5vIGZvY3VzZWQgZWxlbWVudCB3ZVxuICAvLyB3b24ndCBkaXNwYXRjaC5cbiAgaWYgKG1vdXNlRG93biB8fCBhY3RpdmVFbGVtZW50JDEgPT0gbnVsbCB8fCBhY3RpdmVFbGVtZW50JDEgIT09IGdldEFjdGl2ZUVsZW1lbnQoKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gT25seSBmaXJlIHdoZW4gc2VsZWN0aW9uIGhhcyBhY3R1YWxseSBjaGFuZ2VkLlxuICB2YXIgY3VycmVudFNlbGVjdGlvbiA9IGdldFNlbGVjdGlvbihhY3RpdmVFbGVtZW50JDEpO1xuICBpZiAoIWxhc3RTZWxlY3Rpb24gfHwgIXNoYWxsb3dFcXVhbChsYXN0U2VsZWN0aW9uLCBjdXJyZW50U2VsZWN0aW9uKSkge1xuICAgIGxhc3RTZWxlY3Rpb24gPSBjdXJyZW50U2VsZWN0aW9uO1xuXG4gICAgdmFyIHN5bnRoZXRpY0V2ZW50ID0gU3ludGhldGljRXZlbnQkMS5nZXRQb29sZWQoZXZlbnRUeXBlcyQzLnNlbGVjdCwgYWN0aXZlRWxlbWVudEluc3QkMSwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICAgIHN5bnRoZXRpY0V2ZW50LnR5cGUgPSAnc2VsZWN0JztcbiAgICBzeW50aGV0aWNFdmVudC50YXJnZXQgPSBhY3RpdmVFbGVtZW50JDE7XG5cbiAgICBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKHN5bnRoZXRpY0V2ZW50KTtcblxuICAgIHJldHVybiBzeW50aGV0aWNFdmVudDtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFRoaXMgcGx1Z2luIGNyZWF0ZXMgYW4gYG9uU2VsZWN0YCBldmVudCB0aGF0IG5vcm1hbGl6ZXMgc2VsZWN0IGV2ZW50c1xuICogYWNyb3NzIGZvcm0gZWxlbWVudHMuXG4gKlxuICogU3VwcG9ydGVkIGVsZW1lbnRzIGFyZTpcbiAqIC0gaW5wdXQgKHNlZSBgaXNUZXh0SW5wdXRFbGVtZW50YClcbiAqIC0gdGV4dGFyZWFcbiAqIC0gY29udGVudEVkaXRhYmxlXG4gKlxuICogVGhpcyBkaWZmZXJzIGZyb20gbmF0aXZlIGJyb3dzZXIgaW1wbGVtZW50YXRpb25zIGluIHRoZSBmb2xsb3dpbmcgd2F5czpcbiAqIC0gRmlyZXMgb24gY29udGVudEVkaXRhYmxlIGZpZWxkcyBhcyB3ZWxsIGFzIGlucHV0cy5cbiAqIC0gRmlyZXMgZm9yIGNvbGxhcHNlZCBzZWxlY3Rpb24uXG4gKiAtIEZpcmVzIGFmdGVyIHVzZXIgaW5wdXQuXG4gKi9cbnZhciBTZWxlY3RFdmVudFBsdWdpbiA9IHtcbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyQzLFxuXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHZhciBkb2MgPSBuYXRpdmVFdmVudFRhcmdldC53aW5kb3cgPT09IG5hdGl2ZUV2ZW50VGFyZ2V0ID8gbmF0aXZlRXZlbnRUYXJnZXQuZG9jdW1lbnQgOiBuYXRpdmVFdmVudFRhcmdldC5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSA/IG5hdGl2ZUV2ZW50VGFyZ2V0IDogbmF0aXZlRXZlbnRUYXJnZXQub3duZXJEb2N1bWVudDtcbiAgICAvLyBUcmFjayB3aGV0aGVyIGFsbCBsaXN0ZW5lcnMgZXhpc3RzIGZvciB0aGlzIHBsdWdpbi4gSWYgbm9uZSBleGlzdCwgd2UgZG9cbiAgICAvLyBub3QgZXh0cmFjdCBldmVudHMuIFNlZSAjMzYzOS5cbiAgICBpZiAoIWRvYyB8fCAhaXNMaXN0ZW5pbmdUb0FsbERlcGVuZGVuY2llcygnb25TZWxlY3QnLCBkb2MpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0Tm9kZSA9IHRhcmdldEluc3QgPyBnZXROb2RlRnJvbUluc3RhbmNlJDEodGFyZ2V0SW5zdCkgOiB3aW5kb3c7XG5cbiAgICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgICAgLy8gVHJhY2sgdGhlIGlucHV0IG5vZGUgdGhhdCBoYXMgZm9jdXMuXG4gICAgICBjYXNlICd0b3BGb2N1cyc6XG4gICAgICAgIGlmIChpc1RleHRJbnB1dEVsZW1lbnQodGFyZ2V0Tm9kZSkgfHwgdGFyZ2V0Tm9kZS5jb250ZW50RWRpdGFibGUgPT09ICd0cnVlJykge1xuICAgICAgICAgIGFjdGl2ZUVsZW1lbnQkMSA9IHRhcmdldE5vZGU7XG4gICAgICAgICAgYWN0aXZlRWxlbWVudEluc3QkMSA9IHRhcmdldEluc3Q7XG4gICAgICAgICAgbGFzdFNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BCbHVyJzpcbiAgICAgICAgYWN0aXZlRWxlbWVudCQxID0gbnVsbDtcbiAgICAgICAgYWN0aXZlRWxlbWVudEluc3QkMSA9IG51bGw7XG4gICAgICAgIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIERvbid0IGZpcmUgdGhlIGV2ZW50IHdoaWxlIHRoZSB1c2VyIGlzIGRyYWdnaW5nLiBUaGlzIG1hdGNoZXMgdGhlXG4gICAgICAvLyBzZW1hbnRpY3Mgb2YgdGhlIG5hdGl2ZSBzZWxlY3QgZXZlbnQuXG4gICAgICBjYXNlICd0b3BNb3VzZURvd24nOlxuICAgICAgICBtb3VzZURvd24gPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcENvbnRleHRNZW51JzpcbiAgICAgIGNhc2UgJ3RvcE1vdXNlVXAnOlxuICAgICAgICBtb3VzZURvd24gPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdFNlbGVjdEV2ZW50KG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgICAvLyBDaHJvbWUgYW5kIElFIGZpcmUgbm9uLXN0YW5kYXJkIGV2ZW50IHdoZW4gc2VsZWN0aW9uIGlzIGNoYW5nZWQgKGFuZFxuICAgICAgLy8gc29tZXRpbWVzIHdoZW4gaXQgaGFzbid0KS4gSUUncyBldmVudCBmaXJlcyBvdXQgb2Ygb3JkZXIgd2l0aCByZXNwZWN0XG4gICAgICAvLyB0byBrZXkgYW5kIGlucHV0IGV2ZW50cyBvbiBkZWxldGlvbiwgc28gd2UgZGlzY2FyZCBpdC5cbiAgICAgIC8vXG4gICAgICAvLyBGaXJlZm94IGRvZXNuJ3Qgc3VwcG9ydCBzZWxlY3Rpb25jaGFuZ2UsIHNvIGNoZWNrIHNlbGVjdGlvbiBzdGF0dXNcbiAgICAgIC8vIGFmdGVyIGVhY2gga2V5IGVudHJ5LiBUaGUgc2VsZWN0aW9uIGNoYW5nZXMgYWZ0ZXIga2V5ZG93biBhbmQgYmVmb3JlXG4gICAgICAvLyBrZXl1cCwgYnV0IHdlIGNoZWNrIG9uIGtleWRvd24gYXMgd2VsbCBpbiB0aGUgY2FzZSBvZiBob2xkaW5nIGRvd24gYVxuICAgICAgLy8ga2V5LCB3aGVuIG11bHRpcGxlIGtleWRvd24gZXZlbnRzIGFyZSBmaXJlZCBidXQgb25seSBvbmUga2V5dXAgaXMuXG4gICAgICAvLyBUaGlzIGlzIGFsc28gb3VyIGFwcHJvYWNoIGZvciBJRSBoYW5kbGluZywgZm9yIHRoZSByZWFzb24gYWJvdmUuXG4gICAgICBjYXNlICd0b3BTZWxlY3Rpb25DaGFuZ2UnOlxuICAgICAgICBpZiAoc2tpcFNlbGVjdGlvbkNoYW5nZUV2ZW50KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGNhc2UgJ3RvcEtleURvd24nOlxuICAgICAgY2FzZSAndG9wS2V5VXAnOlxuICAgICAgICByZXR1cm4gY29uc3RydWN0U2VsZWN0RXZlbnQobmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtYW5pbWF0aW9ucy8jQW5pbWF0aW9uRXZlbnQtaW50ZXJmYWNlXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BbmltYXRpb25FdmVudFxuICovXG52YXIgQW5pbWF0aW9uRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGFuaW1hdGlvbk5hbWU6IG51bGwsXG4gIGVsYXBzZWRUaW1lOiBudWxsLFxuICBwc2V1ZG9FbGVtZW50OiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljQW5pbWF0aW9uRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50JDEuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50JDEuYXVnbWVudENsYXNzKFN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50LCBBbmltYXRpb25FdmVudEludGVyZmFjZSk7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9jbGlwYm9hcmQtYXBpcy9cbiAqL1xudmFyIENsaXBib2FyZEV2ZW50SW50ZXJmYWNlID0ge1xuICBjbGlwYm9hcmREYXRhOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2NsaXBib2FyZERhdGEnIGluIGV2ZW50ID8gZXZlbnQuY2xpcGJvYXJkRGF0YSA6IHdpbmRvdy5jbGlwYm9hcmREYXRhO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljQ2xpcGJvYXJkRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50JDEuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50JDEuYXVnbWVudENsYXNzKFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50LCBDbGlwYm9hcmRFdmVudEludGVyZmFjZSk7XG5cbi8qKlxuICogQGludGVyZmFjZSBGb2N1c0V2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIEZvY3VzRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHJlbGF0ZWRUYXJnZXQ6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0ZvY3VzRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0ZvY3VzRXZlbnQsIEZvY3VzRXZlbnRJbnRlcmZhY2UpO1xuXG4vKipcbiAqIGBjaGFyQ29kZWAgcmVwcmVzZW50cyB0aGUgYWN0dWFsIFwiY2hhcmFjdGVyIGNvZGVcIiBhbmQgaXMgc2FmZSB0byB1c2Ugd2l0aFxuICogYFN0cmluZy5mcm9tQ2hhckNvZGVgLiBBcyBzdWNoLCBvbmx5IGtleXMgdGhhdCBjb3JyZXNwb25kIHRvIHByaW50YWJsZVxuICogY2hhcmFjdGVycyBwcm9kdWNlIGEgdmFsaWQgYGNoYXJDb2RlYCwgdGhlIG9ubHkgZXhjZXB0aW9uIHRvIHRoaXMgaXMgRW50ZXIuXG4gKiBUaGUgVGFiLWtleSBpcyBjb25zaWRlcmVkIG5vbi1wcmludGFibGUgYW5kIGRvZXMgbm90IGhhdmUgYSBgY2hhckNvZGVgLFxuICogcHJlc3VtYWJseSBiZWNhdXNlIGl0IGRvZXMgbm90IHByb2R1Y2UgYSB0YWItY2hhcmFjdGVyIGluIGJyb3dzZXJzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge251bWJlcn0gTm9ybWFsaXplZCBgY2hhckNvZGVgIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBjaGFyQ29kZTtcbiAgdmFyIGtleUNvZGUgPSBuYXRpdmVFdmVudC5rZXlDb2RlO1xuXG4gIGlmICgnY2hhckNvZGUnIGluIG5hdGl2ZUV2ZW50KSB7XG4gICAgY2hhckNvZGUgPSBuYXRpdmVFdmVudC5jaGFyQ29kZTtcblxuICAgIC8vIEZGIGRvZXMgbm90IHNldCBgY2hhckNvZGVgIGZvciB0aGUgRW50ZXIta2V5LCBjaGVjayBhZ2FpbnN0IGBrZXlDb2RlYC5cbiAgICBpZiAoY2hhckNvZGUgPT09IDAgJiYga2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgIGNoYXJDb2RlID0gMTM7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIElFOCBkb2VzIG5vdCBpbXBsZW1lbnQgYGNoYXJDb2RlYCwgYnV0IGBrZXlDb2RlYCBoYXMgdGhlIGNvcnJlY3QgdmFsdWUuXG4gICAgY2hhckNvZGUgPSBrZXlDb2RlO1xuICB9XG5cbiAgLy8gU29tZSBub24tcHJpbnRhYmxlIGtleXMgYXJlIHJlcG9ydGVkIGluIGBjaGFyQ29kZWAvYGtleUNvZGVgLCBkaXNjYXJkIHRoZW0uXG4gIC8vIE11c3Qgbm90IGRpc2NhcmQgdGhlIChub24tKXByaW50YWJsZSBFbnRlci1rZXkuXG4gIGlmIChjaGFyQ29kZSA+PSAzMiB8fCBjaGFyQ29kZSA9PT0gMTMpIHtcbiAgICByZXR1cm4gY2hhckNvZGU7XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuLyoqXG4gKiBOb3JtYWxpemF0aW9uIG9mIGRlcHJlY2F0ZWQgSFRNTDUgYGtleWAgdmFsdWVzXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50I0tleV9uYW1lc1xuICovXG52YXIgbm9ybWFsaXplS2V5ID0ge1xuICBFc2M6ICdFc2NhcGUnLFxuICBTcGFjZWJhcjogJyAnLFxuICBMZWZ0OiAnQXJyb3dMZWZ0JyxcbiAgVXA6ICdBcnJvd1VwJyxcbiAgUmlnaHQ6ICdBcnJvd1JpZ2h0JyxcbiAgRG93bjogJ0Fycm93RG93bicsXG4gIERlbDogJ0RlbGV0ZScsXG4gIFdpbjogJ09TJyxcbiAgTWVudTogJ0NvbnRleHRNZW51JyxcbiAgQXBwczogJ0NvbnRleHRNZW51JyxcbiAgU2Nyb2xsOiAnU2Nyb2xsTG9jaycsXG4gIE1velByaW50YWJsZUtleTogJ1VuaWRlbnRpZmllZCdcbn07XG5cbi8qKlxuICogVHJhbnNsYXRpb24gZnJvbSBsZWdhY3kgYGtleUNvZGVgIHRvIEhUTUw1IGBrZXlgXG4gKiBPbmx5IHNwZWNpYWwga2V5cyBzdXBwb3J0ZWQsIGFsbCBvdGhlcnMgZGVwZW5kIG9uIGtleWJvYXJkIGxheW91dCBvciBicm93c2VyXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50I0tleV9uYW1lc1xuICovXG52YXIgdHJhbnNsYXRlVG9LZXkgPSB7XG4gICc4JzogJ0JhY2tzcGFjZScsXG4gICc5JzogJ1RhYicsXG4gICcxMic6ICdDbGVhcicsXG4gICcxMyc6ICdFbnRlcicsXG4gICcxNic6ICdTaGlmdCcsXG4gICcxNyc6ICdDb250cm9sJyxcbiAgJzE4JzogJ0FsdCcsXG4gICcxOSc6ICdQYXVzZScsXG4gICcyMCc6ICdDYXBzTG9jaycsXG4gICcyNyc6ICdFc2NhcGUnLFxuICAnMzInOiAnICcsXG4gICczMyc6ICdQYWdlVXAnLFxuICAnMzQnOiAnUGFnZURvd24nLFxuICAnMzUnOiAnRW5kJyxcbiAgJzM2JzogJ0hvbWUnLFxuICAnMzcnOiAnQXJyb3dMZWZ0JyxcbiAgJzM4JzogJ0Fycm93VXAnLFxuICAnMzknOiAnQXJyb3dSaWdodCcsXG4gICc0MCc6ICdBcnJvd0Rvd24nLFxuICAnNDUnOiAnSW5zZXJ0JyxcbiAgJzQ2JzogJ0RlbGV0ZScsXG4gICcxMTInOiAnRjEnLFxuICAnMTEzJzogJ0YyJyxcbiAgJzExNCc6ICdGMycsXG4gICcxMTUnOiAnRjQnLFxuICAnMTE2JzogJ0Y1JyxcbiAgJzExNyc6ICdGNicsXG4gICcxMTgnOiAnRjcnLFxuICAnMTE5JzogJ0Y4JyxcbiAgJzEyMCc6ICdGOScsXG4gICcxMjEnOiAnRjEwJyxcbiAgJzEyMic6ICdGMTEnLFxuICAnMTIzJzogJ0YxMicsXG4gICcxNDQnOiAnTnVtTG9jaycsXG4gICcxNDUnOiAnU2Nyb2xsTG9jaycsXG4gICcyMjQnOiAnTWV0YSdcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7c3RyaW5nfSBOb3JtYWxpemVkIGBrZXlgIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBnZXRFdmVudEtleShuYXRpdmVFdmVudCkge1xuICBpZiAobmF0aXZlRXZlbnQua2V5KSB7XG4gICAgLy8gTm9ybWFsaXplIGluY29uc2lzdGVudCB2YWx1ZXMgcmVwb3J0ZWQgYnkgYnJvd3NlcnMgZHVlIHRvXG4gICAgLy8gaW1wbGVtZW50YXRpb25zIG9mIGEgd29ya2luZyBkcmFmdCBzcGVjaWZpY2F0aW9uLlxuXG4gICAgLy8gRmlyZUZveCBpbXBsZW1lbnRzIGBrZXlgIGJ1dCByZXR1cm5zIGBNb3pQcmludGFibGVLZXlgIGZvciBhbGxcbiAgICAvLyBwcmludGFibGUgY2hhcmFjdGVycyAobm9ybWFsaXplZCB0byBgVW5pZGVudGlmaWVkYCksIGlnbm9yZSBpdC5cbiAgICB2YXIga2V5ID0gbm9ybWFsaXplS2V5W25hdGl2ZUV2ZW50LmtleV0gfHwgbmF0aXZlRXZlbnQua2V5O1xuICAgIGlmIChrZXkgIT09ICdVbmlkZW50aWZpZWQnKSB7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgfVxuXG4gIC8vIEJyb3dzZXIgZG9lcyBub3QgaW1wbGVtZW50IGBrZXlgLCBwb2x5ZmlsbCBhcyBtdWNoIG9mIGl0IGFzIHdlIGNhbi5cbiAgaWYgKG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXlwcmVzcycpIHtcbiAgICB2YXIgY2hhckNvZGUgPSBnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KTtcblxuICAgIC8vIFRoZSBlbnRlci1rZXkgaXMgdGVjaG5pY2FsbHkgYm90aCBwcmludGFibGUgYW5kIG5vbi1wcmludGFibGUgYW5kIGNhblxuICAgIC8vIHRodXMgYmUgY2FwdHVyZWQgYnkgYGtleXByZXNzYCwgbm8gb3RoZXIgbm9uLXByaW50YWJsZSBrZXkgc2hvdWxkLlxuICAgIHJldHVybiBjaGFyQ29kZSA9PT0gMTMgPyAnRW50ZXInIDogU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7XG4gIH1cbiAgaWYgKG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBuYXRpdmVFdmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgLy8gV2hpbGUgdXNlciBrZXlib2FyZCBsYXlvdXQgZGV0ZXJtaW5lcyB0aGUgYWN0dWFsIG1lYW5pbmcgb2YgZWFjaFxuICAgIC8vIGBrZXlDb2RlYCB2YWx1ZSwgYWxtb3N0IGFsbCBmdW5jdGlvbiBrZXlzIGhhdmUgYSB1bml2ZXJzYWwgdmFsdWUuXG4gICAgcmV0dXJuIHRyYW5zbGF0ZVRvS2V5W25hdGl2ZUV2ZW50LmtleUNvZGVdIHx8ICdVbmlkZW50aWZpZWQnO1xuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBAaW50ZXJmYWNlIEtleWJvYXJkRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgS2V5Ym9hcmRFdmVudEludGVyZmFjZSA9IHtcbiAga2V5OiBnZXRFdmVudEtleSxcbiAgbG9jYXRpb246IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIHJlcGVhdDogbnVsbCxcbiAgbG9jYWxlOiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGUsXG4gIC8vIExlZ2FjeSBJbnRlcmZhY2VcbiAgY2hhckNvZGU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGBjaGFyQ29kZWAgaXMgdGhlIHJlc3VsdCBvZiBhIEtleVByZXNzIGV2ZW50IGFuZCByZXByZXNlbnRzIHRoZSB2YWx1ZSBvZlxuICAgIC8vIHRoZSBhY3R1YWwgcHJpbnRhYmxlIGNoYXJhY3Rlci5cblxuICAgIC8vIEtleVByZXNzIGlzIGRlcHJlY2F0ZWQsIGJ1dCBpdHMgcmVwbGFjZW1lbnQgaXMgbm90IHlldCBmaW5hbCBhbmQgbm90XG4gICAgLy8gaW1wbGVtZW50ZWQgaW4gYW55IG1ham9yIGJyb3dzZXIuIE9ubHkgS2V5UHJlc3MgaGFzIGNoYXJDb2RlLlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgICByZXR1cm4gZ2V0RXZlbnRDaGFyQ29kZShldmVudCk7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9LFxuICBrZXlDb2RlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBga2V5Q29kZWAgaXMgdGhlIHJlc3VsdCBvZiBhIEtleURvd24vVXAgZXZlbnQgYW5kIHJlcHJlc2VudHMgdGhlIHZhbHVlIG9mXG4gICAgLy8gcGh5c2ljYWwga2V5Ym9hcmQga2V5LlxuXG4gICAgLy8gVGhlIGFjdHVhbCBtZWFuaW5nIG9mIHRoZSB2YWx1ZSBkZXBlbmRzIG9uIHRoZSB1c2Vycycga2V5Ym9hcmQgbGF5b3V0XG4gICAgLy8gd2hpY2ggY2Fubm90IGJlIGRldGVjdGVkLiBBc3N1bWluZyB0aGF0IGl0IGlzIGEgVVMga2V5Ym9hcmQgbGF5b3V0XG4gICAgLy8gcHJvdmlkZXMgYSBzdXJwcmlzaW5nbHkgYWNjdXJhdGUgbWFwcGluZyBmb3IgVVMgYW5kIEV1cm9wZWFuIHVzZXJzLlxuICAgIC8vIER1ZSB0byB0aGlzLCBpdCBpcyBsZWZ0IHRvIHRoZSB1c2VyIHRvIGltcGxlbWVudCBhdCB0aGlzIHRpbWUuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBldmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgICByZXR1cm4gZXZlbnQua2V5Q29kZTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIHdoaWNoOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBgd2hpY2hgIGlzIGFuIGFsaWFzIGZvciBlaXRoZXIgYGtleUNvZGVgIG9yIGBjaGFyQ29kZWAgZGVwZW5kaW5nIG9uIHRoZVxuICAgIC8vIHR5cGUgb2YgdGhlIGV2ZW50LlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgICByZXR1cm4gZ2V0RXZlbnRDaGFyQ29kZShldmVudCk7XG4gICAgfVxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5ZG93bicgfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgICAgcmV0dXJuIGV2ZW50LmtleUNvZGU7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNLZXlib2FyZEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNLZXlib2FyZEV2ZW50LCBLZXlib2FyZEV2ZW50SW50ZXJmYWNlKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIERyYWdFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBEcmFnRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGRhdGFUcmFuc2ZlcjogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljTW91c2VFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljRHJhZ0V2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNNb3VzZUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNNb3VzZUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNEcmFnRXZlbnQsIERyYWdFdmVudEludGVyZmFjZSk7XG5cbi8qKlxuICogQGludGVyZmFjZSBUb3VjaEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL3RvdWNoLWV2ZW50cy9cbiAqL1xudmFyIFRvdWNoRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHRvdWNoZXM6IG51bGwsXG4gIHRhcmdldFRvdWNoZXM6IG51bGwsXG4gIGNoYW5nZWRUb3VjaGVzOiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGVcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY1RvdWNoRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY1RvdWNoRXZlbnQsIFRvdWNoRXZlbnRJbnRlcmZhY2UpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAwOS9XRC1jc3MzLXRyYW5zaXRpb25zLTIwMDkwMzIwLyN0cmFuc2l0aW9uLWV2ZW50cy1cbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1RyYW5zaXRpb25FdmVudFxuICovXG52YXIgVHJhbnNpdGlvbkV2ZW50SW50ZXJmYWNlID0ge1xuICBwcm9wZXJ0eU5hbWU6IG51bGwsXG4gIGVsYXBzZWRUaW1lOiBudWxsLFxuICBwc2V1ZG9FbGVtZW50OiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljVHJhbnNpdGlvbkV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudCQxLmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudCQxLmF1Z21lbnRDbGFzcyhTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQsIFRyYW5zaXRpb25FdmVudEludGVyZmFjZSk7XG5cbi8qKlxuICogQGludGVyZmFjZSBXaGVlbEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIFdoZWVsRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGRlbHRhWDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdkZWx0YVgnIGluIGV2ZW50ID8gZXZlbnQuZGVsdGFYIDogLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFYYCBmb3IgV2Via2l0IGFuZCBub3JtYWxpemUgKHJpZ2h0IGlzIHBvc2l0aXZlKS5cbiAgICAnd2hlZWxEZWx0YVgnIGluIGV2ZW50ID8gLWV2ZW50LndoZWVsRGVsdGFYIDogMDtcbiAgfSxcbiAgZGVsdGFZOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2RlbHRhWScgaW4gZXZlbnQgPyBldmVudC5kZWx0YVkgOiAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YVlgIGZvciBXZWJraXQgYW5kIG5vcm1hbGl6ZSAoZG93biBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGFZJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhWSA6IC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhYCBmb3IgSUU8OSBhbmQgbm9ybWFsaXplIChkb3duIGlzIHBvc2l0aXZlKS5cbiAgICAnd2hlZWxEZWx0YScgaW4gZXZlbnQgPyAtZXZlbnQud2hlZWxEZWx0YSA6IDA7XG4gIH0sXG4gIGRlbHRhWjogbnVsbCxcblxuICAvLyBCcm93c2VycyB3aXRob3V0IFwiZGVsdGFNb2RlXCIgaXMgcmVwb3J0aW5nIGluIHJhdyB3aGVlbCBkZWx0YSB3aGVyZSBvbmVcbiAgLy8gbm90Y2ggb24gdGhlIHNjcm9sbCBpcyBhbHdheXMgKy8tIDEyMCwgcm91Z2hseSBlcXVpdmFsZW50IHRvIHBpeGVscy5cbiAgLy8gQSBnb29kIGFwcHJveGltYXRpb24gb2YgRE9NX0RFTFRBX0xJTkUgKDEpIGlzIDUlIG9mIHZpZXdwb3J0IHNpemUgb3JcbiAgLy8gfjQwIHBpeGVscywgZm9yIERPTV9ERUxUQV9TQ1JFRU4gKDIpIGl0IGlzIDg3LjUlIG9mIHZpZXdwb3J0IHNpemUuXG4gIGRlbHRhTW9kZTogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljTW91c2VFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljV2hlZWxFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljTW91c2VFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljTW91c2VFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljV2hlZWxFdmVudCwgV2hlZWxFdmVudEludGVyZmFjZSk7XG5cbi8qKlxuICogVHVybnNcbiAqIFsnYWJvcnQnLCAuLi5dXG4gKiBpbnRvXG4gKiBldmVudFR5cGVzID0ge1xuICogICAnYWJvcnQnOiB7XG4gKiAgICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAqICAgICAgIGJ1YmJsZWQ6ICdvbkFib3J0JyxcbiAqICAgICAgIGNhcHR1cmVkOiAnb25BYm9ydENhcHR1cmUnLFxuICogICAgIH0sXG4gKiAgICAgZGVwZW5kZW5jaWVzOiBbJ3RvcEFib3J0J10sXG4gKiAgIH0sXG4gKiAgIC4uLlxuICogfTtcbiAqIHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZyA9IHtcbiAqICAgJ3RvcEFib3J0JzogeyBzYW1lQ29uZmlnIH1cbiAqIH07XG4gKi9cbnZhciBldmVudFR5cGVzJDQgPSB7fTtcbnZhciB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWcgPSB7fTtcblsnYWJvcnQnLCAnYW5pbWF0aW9uRW5kJywgJ2FuaW1hdGlvbkl0ZXJhdGlvbicsICdhbmltYXRpb25TdGFydCcsICdibHVyJywgJ2NhbmNlbCcsICdjYW5QbGF5JywgJ2NhblBsYXlUaHJvdWdoJywgJ2NsaWNrJywgJ2Nsb3NlJywgJ2NvbnRleHRNZW51JywgJ2NvcHknLCAnY3V0JywgJ2RvdWJsZUNsaWNrJywgJ2RyYWcnLCAnZHJhZ0VuZCcsICdkcmFnRW50ZXInLCAnZHJhZ0V4aXQnLCAnZHJhZ0xlYXZlJywgJ2RyYWdPdmVyJywgJ2RyYWdTdGFydCcsICdkcm9wJywgJ2R1cmF0aW9uQ2hhbmdlJywgJ2VtcHRpZWQnLCAnZW5jcnlwdGVkJywgJ2VuZGVkJywgJ2Vycm9yJywgJ2ZvY3VzJywgJ2lucHV0JywgJ2ludmFsaWQnLCAna2V5RG93bicsICdrZXlQcmVzcycsICdrZXlVcCcsICdsb2FkJywgJ2xvYWRlZERhdGEnLCAnbG9hZGVkTWV0YWRhdGEnLCAnbG9hZFN0YXJ0JywgJ21vdXNlRG93bicsICdtb3VzZU1vdmUnLCAnbW91c2VPdXQnLCAnbW91c2VPdmVyJywgJ21vdXNlVXAnLCAncGFzdGUnLCAncGF1c2UnLCAncGxheScsICdwbGF5aW5nJywgJ3Byb2dyZXNzJywgJ3JhdGVDaGFuZ2UnLCAncmVzZXQnLCAnc2Nyb2xsJywgJ3NlZWtlZCcsICdzZWVraW5nJywgJ3N0YWxsZWQnLCAnc3VibWl0JywgJ3N1c3BlbmQnLCAndGltZVVwZGF0ZScsICd0b2dnbGUnLCAndG91Y2hDYW5jZWwnLCAndG91Y2hFbmQnLCAndG91Y2hNb3ZlJywgJ3RvdWNoU3RhcnQnLCAndHJhbnNpdGlvbkVuZCcsICd2b2x1bWVDaGFuZ2UnLCAnd2FpdGluZycsICd3aGVlbCddLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHZhciBjYXBpdGFsaXplZEV2ZW50ID0gZXZlbnRbMF0udG9VcHBlckNhc2UoKSArIGV2ZW50LnNsaWNlKDEpO1xuICB2YXIgb25FdmVudCA9ICdvbicgKyBjYXBpdGFsaXplZEV2ZW50O1xuICB2YXIgdG9wRXZlbnQgPSAndG9wJyArIGNhcGl0YWxpemVkRXZlbnQ7XG5cbiAgdmFyIHR5cGUgPSB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IG9uRXZlbnQsXG4gICAgICBjYXB0dXJlZDogb25FdmVudCArICdDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbdG9wRXZlbnRdXG4gIH07XG4gIGV2ZW50VHlwZXMkNFtldmVudF0gPSB0eXBlO1xuICB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWdbdG9wRXZlbnRdID0gdHlwZTtcbn0pO1xuXG4vLyBPbmx5IHVzZWQgaW4gREVWIGZvciBleGhhdXN0aXZlbmVzcyB2YWxpZGF0aW9uLlxudmFyIGtub3duSFRNTFRvcExldmVsVHlwZXMgPSBbJ3RvcEFib3J0JywgJ3RvcENhbmNlbCcsICd0b3BDYW5QbGF5JywgJ3RvcENhblBsYXlUaHJvdWdoJywgJ3RvcENsb3NlJywgJ3RvcER1cmF0aW9uQ2hhbmdlJywgJ3RvcEVtcHRpZWQnLCAndG9wRW5jcnlwdGVkJywgJ3RvcEVuZGVkJywgJ3RvcEVycm9yJywgJ3RvcElucHV0JywgJ3RvcEludmFsaWQnLCAndG9wTG9hZCcsICd0b3BMb2FkZWREYXRhJywgJ3RvcExvYWRlZE1ldGFkYXRhJywgJ3RvcExvYWRTdGFydCcsICd0b3BQYXVzZScsICd0b3BQbGF5JywgJ3RvcFBsYXlpbmcnLCAndG9wUHJvZ3Jlc3MnLCAndG9wUmF0ZUNoYW5nZScsICd0b3BSZXNldCcsICd0b3BTZWVrZWQnLCAndG9wU2Vla2luZycsICd0b3BTdGFsbGVkJywgJ3RvcFN1Ym1pdCcsICd0b3BTdXNwZW5kJywgJ3RvcFRpbWVVcGRhdGUnLCAndG9wVG9nZ2xlJywgJ3RvcFZvbHVtZUNoYW5nZScsICd0b3BXYWl0aW5nJ107XG5cbnZhciBTaW1wbGVFdmVudFBsdWdpbiA9IHtcbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyQ0LFxuXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHZhciBkaXNwYXRjaENvbmZpZyA9IHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZ1t0b3BMZXZlbFR5cGVdO1xuICAgIGlmICghZGlzcGF0Y2hDb25maWcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgRXZlbnRDb25zdHJ1Y3RvcjtcbiAgICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgICAgY2FzZSAndG9wS2V5UHJlc3MnOlxuICAgICAgICAvLyBGaXJlZm94IGNyZWF0ZXMgYSBrZXlwcmVzcyBldmVudCBmb3IgZnVuY3Rpb24ga2V5cyB0b28uIFRoaXMgcmVtb3Zlc1xuICAgICAgICAvLyB0aGUgdW53YW50ZWQga2V5cHJlc3MgZXZlbnRzLiBFbnRlciBpcyBob3dldmVyIGJvdGggcHJpbnRhYmxlIGFuZFxuICAgICAgICAvLyBub24tcHJpbnRhYmxlLiBPbmUgd291bGQgZXhwZWN0IFRhYiB0byBiZSBhcyB3ZWxsIChidXQgaXQgaXNuJ3QpLlxuICAgICAgICBpZiAoZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCkgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSAndG9wS2V5RG93bic6XG4gICAgICBjYXNlICd0b3BLZXlVcCc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNLZXlib2FyZEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcEJsdXInOlxuICAgICAgY2FzZSAndG9wRm9jdXMnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljRm9jdXNFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BDbGljayc6XG4gICAgICAgIC8vIEZpcmVmb3ggY3JlYXRlcyBhIGNsaWNrIGV2ZW50IG9uIHJpZ2h0IG1vdXNlIGNsaWNrcy4gVGhpcyByZW1vdmVzIHRoZVxuICAgICAgICAvLyB1bndhbnRlZCBjbGljayBldmVudHMuXG4gICAgICAgIGlmIChuYXRpdmVFdmVudC5idXR0b24gPT09IDIpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSAndG9wRG91YmxlQ2xpY2snOlxuICAgICAgY2FzZSAndG9wTW91c2VEb3duJzpcbiAgICAgIGNhc2UgJ3RvcE1vdXNlTW92ZSc6XG4gICAgICBjYXNlICd0b3BNb3VzZVVwJzpcbiAgICAgIC8vIFRPRE86IERpc2FibGVkIGVsZW1lbnRzIHNob3VsZCBub3QgcmVzcG9uZCB0byBtb3VzZSBldmVudHNcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgJ3RvcE1vdXNlT3V0JzpcbiAgICAgIGNhc2UgJ3RvcE1vdXNlT3Zlcic6XG4gICAgICBjYXNlICd0b3BDb250ZXh0TWVudSc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNNb3VzZUV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcERyYWcnOlxuICAgICAgY2FzZSAndG9wRHJhZ0VuZCc6XG4gICAgICBjYXNlICd0b3BEcmFnRW50ZXInOlxuICAgICAgY2FzZSAndG9wRHJhZ0V4aXQnOlxuICAgICAgY2FzZSAndG9wRHJhZ0xlYXZlJzpcbiAgICAgIGNhc2UgJ3RvcERyYWdPdmVyJzpcbiAgICAgIGNhc2UgJ3RvcERyYWdTdGFydCc6XG4gICAgICBjYXNlICd0b3BEcm9wJzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0RyYWdFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BUb3VjaENhbmNlbCc6XG4gICAgICBjYXNlICd0b3BUb3VjaEVuZCc6XG4gICAgICBjYXNlICd0b3BUb3VjaE1vdmUnOlxuICAgICAgY2FzZSAndG9wVG91Y2hTdGFydCc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNUb3VjaEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcEFuaW1hdGlvbkVuZCc6XG4gICAgICBjYXNlICd0b3BBbmltYXRpb25JdGVyYXRpb24nOlxuICAgICAgY2FzZSAndG9wQW5pbWF0aW9uU3RhcnQnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljQW5pbWF0aW9uRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wVHJhbnNpdGlvbkVuZCc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wU2Nyb2xsJzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1VJRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wV2hlZWwnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljV2hlZWxFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BDb3B5JzpcbiAgICAgIGNhc2UgJ3RvcEN1dCc6XG4gICAgICBjYXNlICd0b3BQYXN0ZSc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNDbGlwYm9hcmRFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKGtub3duSFRNTFRvcExldmVsVHlwZXMuaW5kZXhPZih0b3BMZXZlbFR5cGUpID09PSAtMSkge1xuICAgICAgICAgICAgd2FybmluZyhmYWxzZSwgJ1NpbXBsZUV2ZW50UGx1Z2luOiBVbmhhbmRsZWQgZXZlbnQgdHlwZSwgYCVzYC4gVGhpcyB3YXJuaW5nICcgKyAnaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgdG9wTGV2ZWxUeXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSFRNTCBFdmVudHNcbiAgICAgICAgLy8gQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9pbmRleC5odG1sI2V2ZW50cy0wXG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNFdmVudCQxO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdmFyIGV2ZW50ID0gRXZlbnRDb25zdHJ1Y3Rvci5nZXRQb29sZWQoZGlzcGF0Y2hDb25maWcsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG59O1xuXG5zZXRIYW5kbGVUb3BMZXZlbChoYW5kbGVUb3BMZXZlbCk7XG5cbi8qKlxuICogSW5qZWN0IG1vZHVsZXMgZm9yIHJlc29sdmluZyBET00gaGllcmFyY2h5IGFuZCBwbHVnaW4gb3JkZXJpbmcuXG4gKi9cbmluamVjdGlvbiQxLmluamVjdEV2ZW50UGx1Z2luT3JkZXIoRE9NRXZlbnRQbHVnaW5PcmRlcik7XG5pbmplY3Rpb24kMi5pbmplY3RDb21wb25lbnRUcmVlKFJlYWN0RE9NQ29tcG9uZW50VHJlZSk7XG5cbi8qKlxuICogU29tZSBpbXBvcnRhbnQgZXZlbnQgcGx1Z2lucyBpbmNsdWRlZCBieSBkZWZhdWx0ICh3aXRob3V0IGhhdmluZyB0byByZXF1aXJlXG4gKiB0aGVtKS5cbiAqL1xuaW5qZWN0aW9uJDEuaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lKHtcbiAgU2ltcGxlRXZlbnRQbHVnaW46IFNpbXBsZUV2ZW50UGx1Z2luLFxuICBFbnRlckxlYXZlRXZlbnRQbHVnaW46IEVudGVyTGVhdmVFdmVudFBsdWdpbixcbiAgQ2hhbmdlRXZlbnRQbHVnaW46IENoYW5nZUV2ZW50UGx1Z2luLFxuICBTZWxlY3RFdmVudFBsdWdpbjogU2VsZWN0RXZlbnRQbHVnaW4sXG4gIEJlZm9yZUlucHV0RXZlbnRQbHVnaW46IEJlZm9yZUlucHV0RXZlbnRQbHVnaW5cbn0pO1xuXG52YXIgZW5hYmxlQXN5bmNTdWJ0cmVlQVBJID0gdHJ1ZTtcbnZhciBlbmFibGVBc3luY1NjaGVkdWxpbmdCeURlZmF1bHRJblJlYWN0RE9NID0gZmFsc2U7XG4vLyBFeHBvcnRzIFJlYWN0RE9NLmNyZWF0ZVJvb3RcbnZhciBlbmFibGVDcmVhdGVSb290ID0gZmFsc2U7XG52YXIgZW5hYmxlVXNlclRpbWluZ0FQSSA9IHRydWU7XG5cbi8vIE11dGF0aW5nIG1vZGUgKFJlYWN0IERPTSwgUmVhY3QgQVJULCBSZWFjdCBOYXRpdmUpOlxudmFyIGVuYWJsZU11dGF0aW5nUmVjb25jaWxlciA9IHRydWU7XG4vLyBFeHBlcmltZW50YWwgbm9vcCBtb2RlIChjdXJyZW50bHkgdW51c2VkKTpcbnZhciBlbmFibGVOb29wUmVjb25jaWxlciA9IGZhbHNlO1xuLy8gRXhwZXJpbWVudGFsIHBlcnNpc3RlbnQgbW9kZSAoQ1MpOlxudmFyIGVuYWJsZVBlcnNpc3RlbnRSZWNvbmNpbGVyID0gZmFsc2U7XG5cbi8vIEhlbHBzIGlkZW50aWZ5IHNpZGUgZWZmZWN0cyBpbiBiZWdpbi1waGFzZSBsaWZlY3ljbGUgaG9va3MgYW5kIHNldFN0YXRlIHJlZHVjZXJzOlxudmFyIGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0cyA9IGZhbHNlO1xuXG4vLyBPbmx5IHVzZWQgaW4gd3d3IGJ1aWxkcy5cblxudmFyIHZhbHVlU3RhY2sgPSBbXTtcblxue1xuICB2YXIgZmliZXJTdGFjayA9IFtdO1xufVxuXG52YXIgaW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY3JlYXRlQ3Vyc29yKGRlZmF1bHRWYWx1ZSkge1xuICByZXR1cm4ge1xuICAgIGN1cnJlbnQ6IGRlZmF1bHRWYWx1ZVxuICB9O1xufVxuXG5cblxuZnVuY3Rpb24gcG9wKGN1cnNvciwgZmliZXIpIHtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdVbmV4cGVjdGVkIHBvcC4nKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAge1xuICAgIGlmIChmaWJlciAhPT0gZmliZXJTdGFja1tpbmRleF0pIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdVbmV4cGVjdGVkIEZpYmVyIHBvcHBlZC4nKTtcbiAgICB9XG4gIH1cblxuICBjdXJzb3IuY3VycmVudCA9IHZhbHVlU3RhY2tbaW5kZXhdO1xuXG4gIHZhbHVlU3RhY2tbaW5kZXhdID0gbnVsbDtcblxuICB7XG4gICAgZmliZXJTdGFja1tpbmRleF0gPSBudWxsO1xuICB9XG5cbiAgaW5kZXgtLTtcbn1cblxuZnVuY3Rpb24gcHVzaChjdXJzb3IsIHZhbHVlLCBmaWJlcikge1xuICBpbmRleCsrO1xuXG4gIHZhbHVlU3RhY2tbaW5kZXhdID0gY3Vyc29yLmN1cnJlbnQ7XG5cbiAge1xuICAgIGZpYmVyU3RhY2tbaW5kZXhdID0gZmliZXI7XG4gIH1cblxuICBjdXJzb3IuY3VycmVudCA9IHZhbHVlO1xufVxuXG5mdW5jdGlvbiByZXNldCQxKCkge1xuICB3aGlsZSAoaW5kZXggPiAtMSkge1xuICAgIHZhbHVlU3RhY2tbaW5kZXhdID0gbnVsbDtcblxuICAgIHtcbiAgICAgIGZpYmVyU3RhY2tbaW5kZXhdID0gbnVsbDtcbiAgICB9XG5cbiAgICBpbmRleC0tO1xuICB9XG59XG5cbnZhciBkZXNjcmliZUNvbXBvbmVudEZyYW1lID0gZnVuY3Rpb24gKG5hbWUsIHNvdXJjZSwgb3duZXJOYW1lKSB7XG4gIHJldHVybiAnXFxuICAgIGluICcgKyAobmFtZSB8fCAnVW5rbm93bicpICsgKHNvdXJjZSA/ICcgKGF0ICcgKyBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpICsgJzonICsgc291cmNlLmxpbmVOdW1iZXIgKyAnKScgOiBvd25lck5hbWUgPyAnIChjcmVhdGVkIGJ5ICcgKyBvd25lck5hbWUgKyAnKScgOiAnJyk7XG59O1xuXG5mdW5jdGlvbiBkZXNjcmliZUZpYmVyKGZpYmVyKSB7XG4gIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgY2FzZSBJbmRldGVybWluYXRlQ29tcG9uZW50OlxuICAgIGNhc2UgRnVuY3Rpb25hbENvbXBvbmVudDpcbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHZhciBvd25lciA9IGZpYmVyLl9kZWJ1Z093bmVyO1xuICAgICAgdmFyIHNvdXJjZSA9IGZpYmVyLl9kZWJ1Z1NvdXJjZTtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlcik7XG4gICAgICB2YXIgb3duZXJOYW1lID0gbnVsbDtcbiAgICAgIGlmIChvd25lcikge1xuICAgICAgICBvd25lck5hbWUgPSBnZXRDb21wb25lbnROYW1lKG93bmVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZXNjcmliZUNvbXBvbmVudEZyYW1lKG5hbWUsIHNvdXJjZSwgb3duZXJOYW1lKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gY2FuIG9ubHkgYmUgY2FsbGVkIHdpdGggYSB3b3JrLWluLXByb2dyZXNzIGZpYmVyIGFuZFxuLy8gb25seSBkdXJpbmcgYmVnaW4gb3IgY29tcGxldGUgcGhhc2UuIERvIG5vdCBjYWxsIGl0IHVuZGVyIGFueSBvdGhlclxuLy8gY2lyY3Vtc3RhbmNlcy5cbmZ1bmN0aW9uIGdldFN0YWNrQWRkZW5kdW1CeVdvcmtJblByb2dyZXNzRmliZXIod29ya0luUHJvZ3Jlc3MpIHtcbiAgdmFyIGluZm8gPSAnJztcbiAgdmFyIG5vZGUgPSB3b3JrSW5Qcm9ncmVzcztcbiAgZG8ge1xuICAgIGluZm8gKz0gZGVzY3JpYmVGaWJlcihub2RlKTtcbiAgICAvLyBPdGhlcndpc2UgdGhpcyByZXR1cm4gcG9pbnRlciBtaWdodCBwb2ludCB0byB0aGUgd3JvbmcgdHJlZTpcbiAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gIH0gd2hpbGUgKG5vZGUpO1xuICByZXR1cm4gaW5mbztcbn1cblxuZnVuY3Rpb24gZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lKCkge1xuICB7XG4gICAgdmFyIGZpYmVyID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5jdXJyZW50O1xuICAgIGlmIChmaWJlciA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBvd25lciA9IGZpYmVyLl9kZWJ1Z093bmVyO1xuICAgIGlmIChvd25lciAhPT0gbnVsbCAmJiB0eXBlb2Ygb3duZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZShvd25lcik7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtKCkge1xuICB7XG4gICAgdmFyIGZpYmVyID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5jdXJyZW50O1xuICAgIGlmIChmaWJlciA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIFNhZmUgYmVjYXVzZSBpZiBjdXJyZW50IGZpYmVyIGV4aXN0cywgd2UgYXJlIHJlY29uY2lsaW5nLFxuICAgIC8vIGFuZCBpdCBpcyBndWFyYW50ZWVkIHRvIGJlIHRoZSB3b3JrLWluLXByb2dyZXNzIHZlcnNpb24uXG4gICAgcmV0dXJuIGdldFN0YWNrQWRkZW5kdW1CeVdvcmtJblByb2dyZXNzRmliZXIoZmliZXIpO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiByZXNldEN1cnJlbnRGaWJlcigpIHtcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2sgPSBudWxsO1xuICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmN1cnJlbnQgPSBudWxsO1xuICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnBoYXNlID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gc2V0Q3VycmVudEZpYmVyKGZpYmVyKSB7XG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrID0gZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bTtcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5jdXJyZW50ID0gZmliZXI7XG4gIFJlYWN0RGVidWdDdXJyZW50RmliZXIucGhhc2UgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBzZXRDdXJyZW50UGhhc2UocGhhc2UpIHtcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5waGFzZSA9IHBoYXNlO1xufVxuXG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlciA9IHtcbiAgY3VycmVudDogbnVsbCxcbiAgcGhhc2U6IG51bGwsXG4gIHJlc2V0Q3VycmVudEZpYmVyOiByZXNldEN1cnJlbnRGaWJlcixcbiAgc2V0Q3VycmVudEZpYmVyOiBzZXRDdXJyZW50RmliZXIsXG4gIHNldEN1cnJlbnRQaGFzZTogc2V0Q3VycmVudFBoYXNlLFxuICBnZXRDdXJyZW50RmliZXJPd25lck5hbWU6IGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSxcbiAgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bTogZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bVxufTtcblxuLy8gUHJlZml4IG1lYXN1cmVtZW50cyBzbyB0aGF0IGl0J3MgcG9zc2libGUgdG8gZmlsdGVyIHRoZW0uXG4vLyBMb25nZXIgcHJlZml4ZXMgYXJlIGhhcmQgdG8gcmVhZCBpbiBEZXZUb29scy5cbnZhciByZWFjdEVtb2ppID0gJ1xcdTI2OUInO1xudmFyIHdhcm5pbmdFbW9qaSA9ICdcXHUyNkQ0JztcbnZhciBzdXBwb3J0c1VzZXJUaW1pbmcgPSB0eXBlb2YgcGVyZm9ybWFuY2UgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5tYXJrID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5jbGVhck1hcmtzID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5tZWFzdXJlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5jbGVhck1lYXN1cmVzID09PSAnZnVuY3Rpb24nO1xuXG4vLyBLZWVwIHRyYWNrIG9mIGN1cnJlbnQgZmliZXIgc28gdGhhdCB3ZSBrbm93IHRoZSBwYXRoIHRvIHVud2luZCBvbiBwYXVzZS5cbi8vIFRPRE86IHRoaXMgbG9va3MgdGhlIHNhbWUgYXMgbmV4dFVuaXRPZldvcmsgaW4gc2NoZWR1bGVyLiBDYW4gd2UgdW5pZnkgdGhlbT9cbnZhciBjdXJyZW50RmliZXIgPSBudWxsO1xuLy8gSWYgd2UncmUgaW4gdGhlIG1pZGRsZSBvZiB1c2VyIGNvZGUsIHdoaWNoIGZpYmVyIGFuZCBtZXRob2QgaXMgaXQ/XG4vLyBSZXVzaW5nIGBjdXJyZW50RmliZXJgIHdvdWxkIGJlIGNvbmZ1c2luZyBmb3IgdGhpcyBiZWNhdXNlIHVzZXIgY29kZSBmaWJlclxuLy8gY2FuIGNoYW5nZSBkdXJpbmcgY29tbWl0IHBoYXNlIHRvbywgYnV0IHdlIGRvbid0IG5lZWQgdG8gdW53aW5kIGl0IChzaW5jZVxuLy8gbGlmZWN5Y2xlcyBpbiB0aGUgY29tbWl0IHBoYXNlIGRvbid0IHJlc2VtYmxlIGEgdHJlZSkuXG52YXIgY3VycmVudFBoYXNlID0gbnVsbDtcbnZhciBjdXJyZW50UGhhc2VGaWJlciA9IG51bGw7XG4vLyBEaWQgbGlmZWN5Y2xlIGhvb2sgc2NoZWR1bGUgYW4gdXBkYXRlPyBUaGlzIGlzIG9mdGVuIGEgcGVyZm9ybWFuY2UgcHJvYmxlbSxcbi8vIHNvIHdlIHdpbGwga2VlcCB0cmFjayBvZiBpdCwgYW5kIGluY2x1ZGUgaXQgaW4gdGhlIHJlcG9ydC5cbi8vIFRyYWNrIGNvbW1pdHMgY2F1c2VkIGJ5IGNhc2NhZGluZyB1cGRhdGVzLlxudmFyIGlzQ29tbWl0dGluZyA9IGZhbHNlO1xudmFyIGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudENvbW1pdCA9IGZhbHNlO1xudmFyIGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudFBoYXNlID0gZmFsc2U7XG52YXIgY29tbWl0Q291bnRJbkN1cnJlbnRXb3JrTG9vcCA9IDA7XG52YXIgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQgPSAwO1xudmFyIGlzV2FpdGluZ0ZvckNhbGxiYWNrID0gZmFsc2U7XG4vLyBEdXJpbmcgY29tbWl0cywgd2Ugb25seSBzaG93IGEgbWVhc3VyZW1lbnQgb25jZSBwZXIgbWV0aG9kIG5hbWVcbi8vIHRvIGF2b2lkIHN0cmV0Y2ggdGhlIGNvbW1pdCBwaGFzZSB3aXRoIG1lYXN1cmVtZW50IG92ZXJoZWFkLlxudmFyIGxhYmVsc0luQ3VycmVudENvbW1pdCA9IG5ldyBTZXQoKTtcblxudmFyIGZvcm1hdE1hcmtOYW1lID0gZnVuY3Rpb24gKG1hcmtOYW1lKSB7XG4gIHJldHVybiByZWFjdEVtb2ppICsgJyAnICsgbWFya05hbWU7XG59O1xuXG52YXIgZm9ybWF0TGFiZWwgPSBmdW5jdGlvbiAobGFiZWwsIHdhcm5pbmckJDEpIHtcbiAgdmFyIHByZWZpeCA9IHdhcm5pbmckJDEgPyB3YXJuaW5nRW1vamkgKyAnICcgOiByZWFjdEVtb2ppICsgJyAnO1xuICB2YXIgc3VmZml4ID0gd2FybmluZyQkMSA/ICcgV2FybmluZzogJyArIHdhcm5pbmckJDEgOiAnJztcbiAgcmV0dXJuICcnICsgcHJlZml4ICsgbGFiZWwgKyBzdWZmaXg7XG59O1xuXG52YXIgYmVnaW5NYXJrID0gZnVuY3Rpb24gKG1hcmtOYW1lKSB7XG4gIHBlcmZvcm1hbmNlLm1hcmsoZm9ybWF0TWFya05hbWUobWFya05hbWUpKTtcbn07XG5cbnZhciBjbGVhck1hcmsgPSBmdW5jdGlvbiAobWFya05hbWUpIHtcbiAgcGVyZm9ybWFuY2UuY2xlYXJNYXJrcyhmb3JtYXRNYXJrTmFtZShtYXJrTmFtZSkpO1xufTtcblxudmFyIGVuZE1hcmsgPSBmdW5jdGlvbiAobGFiZWwsIG1hcmtOYW1lLCB3YXJuaW5nJCQxKSB7XG4gIHZhciBmb3JtYXR0ZWRNYXJrTmFtZSA9IGZvcm1hdE1hcmtOYW1lKG1hcmtOYW1lKTtcbiAgdmFyIGZvcm1hdHRlZExhYmVsID0gZm9ybWF0TGFiZWwobGFiZWwsIHdhcm5pbmckJDEpO1xuICB0cnkge1xuICAgIHBlcmZvcm1hbmNlLm1lYXN1cmUoZm9ybWF0dGVkTGFiZWwsIGZvcm1hdHRlZE1hcmtOYW1lKTtcbiAgfSBjYXRjaCAoZXJyKSB7fVxuICAvLyBJZiBwcmV2aW91cyBtYXJrIHdhcyBtaXNzaW5nIGZvciBzb21lIHJlYXNvbiwgdGhpcyB3aWxsIHRocm93LlxuICAvLyBUaGlzIGNvdWxkIG9ubHkgaGFwcGVuIGlmIFJlYWN0IGNyYXNoZWQgaW4gYW4gdW5leHBlY3RlZCBwbGFjZSBlYXJsaWVyLlxuICAvLyBEb24ndCBwaWxlIG9uIHdpdGggbW9yZSBlcnJvcnMuXG5cbiAgLy8gQ2xlYXIgbWFya3MgaW1tZWRpYXRlbHkgdG8gYXZvaWQgZ3Jvd2luZyBidWZmZXIuXG4gIHBlcmZvcm1hbmNlLmNsZWFyTWFya3MoZm9ybWF0dGVkTWFya05hbWUpO1xuICBwZXJmb3JtYW5jZS5jbGVhck1lYXN1cmVzKGZvcm1hdHRlZExhYmVsKTtcbn07XG5cbnZhciBnZXRGaWJlck1hcmtOYW1lID0gZnVuY3Rpb24gKGxhYmVsLCBkZWJ1Z0lEKSB7XG4gIHJldHVybiBsYWJlbCArICcgKCMnICsgZGVidWdJRCArICcpJztcbn07XG5cbnZhciBnZXRGaWJlckxhYmVsID0gZnVuY3Rpb24gKGNvbXBvbmVudE5hbWUsIGlzTW91bnRlZCwgcGhhc2UpIHtcbiAgaWYgKHBoYXNlID09PSBudWxsKSB7XG4gICAgLy8gVGhlc2UgYXJlIGNvbXBvc2l0ZSBjb21wb25lbnQgdG90YWwgdGltZSBtZWFzdXJlbWVudHMuXG4gICAgcmV0dXJuIGNvbXBvbmVudE5hbWUgKyAnIFsnICsgKGlzTW91bnRlZCA/ICd1cGRhdGUnIDogJ21vdW50JykgKyAnXSc7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ29tcG9zaXRlIGNvbXBvbmVudCBtZXRob2RzLlxuICAgIHJldHVybiBjb21wb25lbnROYW1lICsgJy4nICsgcGhhc2U7XG4gIH1cbn07XG5cbnZhciBiZWdpbkZpYmVyTWFyayA9IGZ1bmN0aW9uIChmaWJlciwgcGhhc2UpIHtcbiAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyKSB8fCAnVW5rbm93bic7XG4gIHZhciBkZWJ1Z0lEID0gZmliZXIuX2RlYnVnSUQ7XG4gIHZhciBpc01vdW50ZWQgPSBmaWJlci5hbHRlcm5hdGUgIT09IG51bGw7XG4gIHZhciBsYWJlbCA9IGdldEZpYmVyTGFiZWwoY29tcG9uZW50TmFtZSwgaXNNb3VudGVkLCBwaGFzZSk7XG5cbiAgaWYgKGlzQ29tbWl0dGluZyAmJiBsYWJlbHNJbkN1cnJlbnRDb21taXQuaGFzKGxhYmVsKSkge1xuICAgIC8vIER1cmluZyB0aGUgY29tbWl0IHBoYXNlLCB3ZSBkb24ndCBzaG93IGR1cGxpY2F0ZSBsYWJlbHMgYmVjYXVzZVxuICAgIC8vIHRoZXJlIGlzIGEgZml4ZWQgb3ZlcmhlYWQgZm9yIGV2ZXJ5IG1lYXN1cmVtZW50LCBhbmQgd2UgZG9uJ3RcbiAgICAvLyB3YW50IHRvIHN0cmV0Y2ggdGhlIGNvbW1pdCBwaGFzZSBiZXlvbmQgbmVjZXNzYXJ5LlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsYWJlbHNJbkN1cnJlbnRDb21taXQuYWRkKGxhYmVsKTtcblxuICB2YXIgbWFya05hbWUgPSBnZXRGaWJlck1hcmtOYW1lKGxhYmVsLCBkZWJ1Z0lEKTtcbiAgYmVnaW5NYXJrKG1hcmtOYW1lKTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgY2xlYXJGaWJlck1hcmsgPSBmdW5jdGlvbiAoZmliZXIsIHBoYXNlKSB7XG4gIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlcikgfHwgJ1Vua25vd24nO1xuICB2YXIgZGVidWdJRCA9IGZpYmVyLl9kZWJ1Z0lEO1xuICB2YXIgaXNNb3VudGVkID0gZmliZXIuYWx0ZXJuYXRlICE9PSBudWxsO1xuICB2YXIgbGFiZWwgPSBnZXRGaWJlckxhYmVsKGNvbXBvbmVudE5hbWUsIGlzTW91bnRlZCwgcGhhc2UpO1xuICB2YXIgbWFya05hbWUgPSBnZXRGaWJlck1hcmtOYW1lKGxhYmVsLCBkZWJ1Z0lEKTtcbiAgY2xlYXJNYXJrKG1hcmtOYW1lKTtcbn07XG5cbnZhciBlbmRGaWJlck1hcmsgPSBmdW5jdGlvbiAoZmliZXIsIHBoYXNlLCB3YXJuaW5nJCQxKSB7XG4gIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlcikgfHwgJ1Vua25vd24nO1xuICB2YXIgZGVidWdJRCA9IGZpYmVyLl9kZWJ1Z0lEO1xuICB2YXIgaXNNb3VudGVkID0gZmliZXIuYWx0ZXJuYXRlICE9PSBudWxsO1xuICB2YXIgbGFiZWwgPSBnZXRGaWJlckxhYmVsKGNvbXBvbmVudE5hbWUsIGlzTW91bnRlZCwgcGhhc2UpO1xuICB2YXIgbWFya05hbWUgPSBnZXRGaWJlck1hcmtOYW1lKGxhYmVsLCBkZWJ1Z0lEKTtcbiAgZW5kTWFyayhsYWJlbCwgbWFya05hbWUsIHdhcm5pbmckJDEpO1xufTtcblxudmFyIHNob3VsZElnbm9yZUZpYmVyID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gIC8vIEhvc3QgY29tcG9uZW50cyBzaG91bGQgYmUgc2tpcHBlZCBpbiB0aGUgdGltZWxpbmUuXG4gIC8vIFdlIGNvdWxkIGNoZWNrIHR5cGVvZiBmaWJlci50eXBlLCBidXQgZG9lcyB0aGlzIHdvcmsgd2l0aCBSTj9cbiAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICBjYXNlIEhvc3RSb290OlxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICBjYXNlIFJldHVybkNvbXBvbmVudDpcbiAgICBjYXNlIEZyYWdtZW50OlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxudmFyIGNsZWFyUGVuZGluZ1BoYXNlTWVhc3VyZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChjdXJyZW50UGhhc2UgIT09IG51bGwgJiYgY3VycmVudFBoYXNlRmliZXIgIT09IG51bGwpIHtcbiAgICBjbGVhckZpYmVyTWFyayhjdXJyZW50UGhhc2VGaWJlciwgY3VycmVudFBoYXNlKTtcbiAgfVxuICBjdXJyZW50UGhhc2VGaWJlciA9IG51bGw7XG4gIGN1cnJlbnRQaGFzZSA9IG51bGw7XG4gIGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudFBoYXNlID0gZmFsc2U7XG59O1xuXG52YXIgcGF1c2VUaW1lcnMgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFN0b3BzIGFsbCBjdXJyZW50bHkgYWN0aXZlIG1lYXN1cmVtZW50cyBzbyB0aGF0IHRoZXkgY2FuIGJlIHJlc3VtZWRcbiAgLy8gaWYgd2UgY29udGludWUgaW4gYSBsYXRlciBkZWZlcnJlZCBsb29wIGZyb20gdGhlIHNhbWUgdW5pdCBvZiB3b3JrLlxuICB2YXIgZmliZXIgPSBjdXJyZW50RmliZXI7XG4gIHdoaWxlIChmaWJlcikge1xuICAgIGlmIChmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZykge1xuICAgICAgZW5kRmliZXJNYXJrKGZpYmVyLCBudWxsLCBudWxsKTtcbiAgICB9XG4gICAgZmliZXIgPSBmaWJlclsncmV0dXJuJ107XG4gIH1cbn07XG5cbnZhciByZXN1bWVUaW1lcnNSZWN1cnNpdmVseSA9IGZ1bmN0aW9uIChmaWJlcikge1xuICBpZiAoZmliZXJbJ3JldHVybiddICE9PSBudWxsKSB7XG4gICAgcmVzdW1lVGltZXJzUmVjdXJzaXZlbHkoZmliZXJbJ3JldHVybiddKTtcbiAgfVxuICBpZiAoZmliZXIuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcpIHtcbiAgICBiZWdpbkZpYmVyTWFyayhmaWJlciwgbnVsbCk7XG4gIH1cbn07XG5cbnZhciByZXN1bWVUaW1lcnMgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFJlc3VtZXMgYWxsIG1lYXN1cmVtZW50cyB0aGF0IHdlcmUgYWN0aXZlIGR1cmluZyB0aGUgbGFzdCBkZWZlcnJlZCBsb29wLlxuICBpZiAoY3VycmVudEZpYmVyICE9PSBudWxsKSB7XG4gICAgcmVzdW1lVGltZXJzUmVjdXJzaXZlbHkoY3VycmVudEZpYmVyKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gcmVjb3JkRWZmZWN0KCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0Kys7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjb3JkU2NoZWR1bGVVcGRhdGUoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKGlzQ29tbWl0dGluZykge1xuICAgICAgaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50Q29tbWl0ID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRQaGFzZSAhPT0gbnVsbCAmJiBjdXJyZW50UGhhc2UgIT09ICdjb21wb25lbnRXaWxsTW91bnQnICYmIGN1cnJlbnRQaGFzZSAhPT0gJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnKSB7XG4gICAgICBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRQaGFzZSA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0UmVxdWVzdENhbGxiYWNrVGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKHN1cHBvcnRzVXNlclRpbWluZyAmJiAhaXNXYWl0aW5nRm9yQ2FsbGJhY2spIHtcbiAgICAgIGlzV2FpdGluZ0ZvckNhbGxiYWNrID0gdHJ1ZTtcbiAgICAgIGJlZ2luTWFyaygnKFdhaXRpbmcgZm9yIGFzeW5jIGNhbGxiYWNrLi4uKScpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wUmVxdWVzdENhbGxiYWNrVGltZXIoZGlkRXhwaXJlKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKHN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgaXNXYWl0aW5nRm9yQ2FsbGJhY2sgPSBmYWxzZTtcbiAgICAgIHZhciB3YXJuaW5nJCQxID0gZGlkRXhwaXJlID8gJ1JlYWN0IHdhcyBibG9ja2VkIGJ5IG1haW4gdGhyZWFkJyA6IG51bGw7XG4gICAgICBlbmRNYXJrKCcoV2FpdGluZyBmb3IgYXN5bmMgY2FsbGJhY2suLi4pJywgJyhXYWl0aW5nIGZvciBhc3luYyBjYWxsYmFjay4uLiknLCB3YXJuaW5nJCQxKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRXb3JrVGltZXIoZmliZXIpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZyB8fCBzaG91bGRJZ25vcmVGaWJlcihmaWJlcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gSWYgd2UgcGF1c2UsIHRoaXMgaXMgdGhlIGZpYmVyIHRvIHVud2luZCBmcm9tLlxuICAgIGN1cnJlbnRGaWJlciA9IGZpYmVyO1xuICAgIGlmICghYmVnaW5GaWJlck1hcmsoZmliZXIsIG51bGwpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYW5jZWxXb3JrVGltZXIoZmliZXIpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZyB8fCBzaG91bGRJZ25vcmVGaWJlcihmaWJlcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gUmVtZW1iZXIgd2Ugc2hvdWxkbid0IGNvbXBsZXRlIG1lYXN1cmVtZW50IGZvciB0aGlzIGZpYmVyLlxuICAgIC8vIE90aGVyd2lzZSBmbGFtZWNoYXJ0IHdpbGwgYmUgZGVlcCBldmVuIGZvciBzbWFsbCB1cGRhdGVzLlxuICAgIGZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nID0gZmFsc2U7XG4gICAgY2xlYXJGaWJlck1hcmsoZmliZXIsIG51bGwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BXb3JrVGltZXIoZmliZXIpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZyB8fCBzaG91bGRJZ25vcmVGaWJlcihmaWJlcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gSWYgd2UgcGF1c2UsIGl0cyBwYXJlbnQgaXMgdGhlIGZpYmVyIHRvIHVud2luZCBmcm9tLlxuICAgIGN1cnJlbnRGaWJlciA9IGZpYmVyWydyZXR1cm4nXTtcbiAgICBpZiAoIWZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nID0gZmFsc2U7XG4gICAgZW5kRmliZXJNYXJrKGZpYmVyLCBudWxsLCBudWxsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wRmFpbGVkV29ya1RpbWVyKGZpYmVyKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcgfHwgc2hvdWxkSWdub3JlRmliZXIoZmliZXIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIElmIHdlIHBhdXNlLCBpdHMgcGFyZW50IGlzIHRoZSBmaWJlciB0byB1bndpbmQgZnJvbS5cbiAgICBjdXJyZW50RmliZXIgPSBmaWJlclsncmV0dXJuJ107XG4gICAgaWYgKCFmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZyA9IGZhbHNlO1xuICAgIHZhciB3YXJuaW5nJCQxID0gJ0FuIGVycm9yIHdhcyB0aHJvd24gaW5zaWRlIHRoaXMgZXJyb3IgYm91bmRhcnknO1xuICAgIGVuZEZpYmVyTWFyayhmaWJlciwgbnVsbCwgd2FybmluZyQkMSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRQaGFzZVRpbWVyKGZpYmVyLCBwaGFzZSkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNsZWFyUGVuZGluZ1BoYXNlTWVhc3VyZW1lbnQoKTtcbiAgICBpZiAoIWJlZ2luRmliZXJNYXJrKGZpYmVyLCBwaGFzZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY3VycmVudFBoYXNlRmliZXIgPSBmaWJlcjtcbiAgICBjdXJyZW50UGhhc2UgPSBwaGFzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wUGhhc2VUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY3VycmVudFBoYXNlICE9PSBudWxsICYmIGN1cnJlbnRQaGFzZUZpYmVyICE9PSBudWxsKSB7XG4gICAgICB2YXIgd2FybmluZyQkMSA9IGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudFBoYXNlID8gJ1NjaGVkdWxlZCBhIGNhc2NhZGluZyB1cGRhdGUnIDogbnVsbDtcbiAgICAgIGVuZEZpYmVyTWFyayhjdXJyZW50UGhhc2VGaWJlciwgY3VycmVudFBoYXNlLCB3YXJuaW5nJCQxKTtcbiAgICB9XG4gICAgY3VycmVudFBoYXNlID0gbnVsbDtcbiAgICBjdXJyZW50UGhhc2VGaWJlciA9IG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRXb3JrTG9vcFRpbWVyKG5leHRVbml0T2ZXb3JrKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgY3VycmVudEZpYmVyID0gbmV4dFVuaXRPZldvcms7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29tbWl0Q291bnRJbkN1cnJlbnRXb3JrTG9vcCA9IDA7XG4gICAgLy8gVGhpcyBpcyB0b3AgbGV2ZWwgY2FsbC5cbiAgICAvLyBBbnkgb3RoZXIgbWVhc3VyZW1lbnRzIGFyZSBwZXJmb3JtZWQgd2l0aGluLlxuICAgIGJlZ2luTWFyaygnKFJlYWN0IFRyZWUgUmVjb25jaWxpYXRpb24pJyk7XG4gICAgLy8gUmVzdW1lIGFueSBtZWFzdXJlbWVudHMgdGhhdCB3ZXJlIGluIHByb2dyZXNzIGR1cmluZyB0aGUgbGFzdCBsb29wLlxuICAgIHJlc3VtZVRpbWVycygpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BXb3JrTG9vcFRpbWVyKGludGVycnVwdGVkQnkpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgd2FybmluZyQkMSA9IG51bGw7XG4gICAgaWYgKGludGVycnVwdGVkQnkgIT09IG51bGwpIHtcbiAgICAgIGlmIChpbnRlcnJ1cHRlZEJ5LnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAgICAgd2FybmluZyQkMSA9ICdBIHRvcC1sZXZlbCB1cGRhdGUgaW50ZXJydXB0ZWQgdGhlIHByZXZpb3VzIHJlbmRlcic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoaW50ZXJydXB0ZWRCeSkgfHwgJ1Vua25vd24nO1xuICAgICAgICB3YXJuaW5nJCQxID0gJ0FuIHVwZGF0ZSB0byAnICsgY29tcG9uZW50TmFtZSArICcgaW50ZXJydXB0ZWQgdGhlIHByZXZpb3VzIHJlbmRlcic7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjb21taXRDb3VudEluQ3VycmVudFdvcmtMb29wID4gMSkge1xuICAgICAgd2FybmluZyQkMSA9ICdUaGVyZSB3ZXJlIGNhc2NhZGluZyB1cGRhdGVzJztcbiAgICB9XG4gICAgY29tbWl0Q291bnRJbkN1cnJlbnRXb3JrTG9vcCA9IDA7XG4gICAgLy8gUGF1c2UgYW55IG1lYXN1cmVtZW50cyB1bnRpbCB0aGUgbmV4dCBsb29wLlxuICAgIHBhdXNlVGltZXJzKCk7XG4gICAgZW5kTWFyaygnKFJlYWN0IFRyZWUgUmVjb25jaWxpYXRpb24pJywgJyhSZWFjdCBUcmVlIFJlY29uY2lsaWF0aW9uKScsIHdhcm5pbmckJDEpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0Q29tbWl0VGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaXNDb21taXR0aW5nID0gdHJ1ZTtcbiAgICBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRDb21taXQgPSBmYWxzZTtcbiAgICBsYWJlbHNJbkN1cnJlbnRDb21taXQuY2xlYXIoKTtcbiAgICBiZWdpbk1hcmsoJyhDb21taXR0aW5nIENoYW5nZXMpJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcENvbW1pdFRpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHdhcm5pbmckJDEgPSBudWxsO1xuICAgIGlmIChoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRDb21taXQpIHtcbiAgICAgIHdhcm5pbmckJDEgPSAnTGlmZWN5Y2xlIGhvb2sgc2NoZWR1bGVkIGEgY2FzY2FkaW5nIHVwZGF0ZSc7XG4gICAgfSBlbHNlIGlmIChjb21taXRDb3VudEluQ3VycmVudFdvcmtMb29wID4gMCkge1xuICAgICAgd2FybmluZyQkMSA9ICdDYXVzZWQgYnkgYSBjYXNjYWRpbmcgdXBkYXRlIGluIGVhcmxpZXIgY29tbWl0JztcbiAgICB9XG4gICAgaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50Q29tbWl0ID0gZmFsc2U7XG4gICAgY29tbWl0Q291bnRJbkN1cnJlbnRXb3JrTG9vcCsrO1xuICAgIGlzQ29tbWl0dGluZyA9IGZhbHNlO1xuICAgIGxhYmVsc0luQ3VycmVudENvbW1pdC5jbGVhcigpO1xuXG4gICAgZW5kTWFyaygnKENvbW1pdHRpbmcgQ2hhbmdlcyknLCAnKENvbW1pdHRpbmcgQ2hhbmdlcyknLCB3YXJuaW5nJCQxKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydENvbW1pdEhvc3RFZmZlY3RzVGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQgPSAwO1xuICAgIGJlZ2luTWFyaygnKENvbW1pdHRpbmcgSG9zdCBFZmZlY3RzKScpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BDb21taXRIb3N0RWZmZWN0c1RpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjb3VudCA9IGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0O1xuICAgIGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0ID0gMDtcbiAgICBlbmRNYXJrKCcoQ29tbWl0dGluZyBIb3N0IEVmZmVjdHM6ICcgKyBjb3VudCArICcgVG90YWwpJywgJyhDb21taXR0aW5nIEhvc3QgRWZmZWN0cyknLCBudWxsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydENvbW1pdExpZmVDeWNsZXNUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdCA9IDA7XG4gICAgYmVnaW5NYXJrKCcoQ2FsbGluZyBMaWZlY3ljbGUgTWV0aG9kcyknKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wQ29tbWl0TGlmZUN5Y2xlc1RpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjb3VudCA9IGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0O1xuICAgIGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0ID0gMDtcbiAgICBlbmRNYXJrKCcoQ2FsbGluZyBMaWZlY3ljbGUgTWV0aG9kczogJyArIGNvdW50ICsgJyBUb3RhbCknLCAnKENhbGxpbmcgTGlmZWN5Y2xlIE1ldGhvZHMpJywgbnVsbCk7XG4gIH1cbn1cblxue1xuICB2YXIgd2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0ID0ge307XG59XG5cbi8vIEEgY3Vyc29yIHRvIHRoZSBjdXJyZW50IG1lcmdlZCBjb250ZXh0IG9iamVjdCBvbiB0aGUgc3RhY2suXG52YXIgY29udGV4dFN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKGVtcHR5T2JqZWN0KTtcbi8vIEEgY3Vyc29yIHRvIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGNvbnRleHQgaGFzIGNoYW5nZWQuXG52YXIgZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihmYWxzZSk7XG4vLyBLZWVwIHRyYWNrIG9mIHRoZSBwcmV2aW91cyBjb250ZXh0IG9iamVjdCB0aGF0IHdhcyBvbiB0aGUgc3RhY2suXG4vLyBXZSB1c2UgdGhpcyB0byBnZXQgYWNjZXNzIHRvIHRoZSBwYXJlbnQgY29udGV4dCBhZnRlciB3ZSBoYXZlIGFscmVhZHlcbi8vIHB1c2hlZCB0aGUgbmV4dCBjb250ZXh0IHByb3ZpZGVyLCBhbmQgbm93IG5lZWQgdG8gbWVyZ2UgdGhlaXIgY29udGV4dHMuXG52YXIgcHJldmlvdXNDb250ZXh0ID0gZW1wdHlPYmplY3Q7XG5cbmZ1bmN0aW9uIGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcykge1xuICB2YXIgaGFzT3duQ29udGV4dCA9IGlzQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgaWYgKGhhc093bkNvbnRleHQpIHtcbiAgICAvLyBJZiB0aGUgZmliZXIgaXMgYSBjb250ZXh0IHByb3ZpZGVyIGl0c2VsZiwgd2hlbiB3ZSByZWFkIGl0cyBjb250ZXh0XG4gICAgLy8gd2UgaGF2ZSBhbHJlYWR5IHB1c2hlZCBpdHMgb3duIGNoaWxkIGNvbnRleHQgb24gdGhlIHN0YWNrLiBBIGNvbnRleHRcbiAgICAvLyBwcm92aWRlciBzaG91bGQgbm90IFwic2VlXCIgaXRzIG93biBjaGlsZCBjb250ZXh0LiBUaGVyZWZvcmUgd2UgcmVhZCB0aGVcbiAgICAvLyBwcmV2aW91cyAocGFyZW50KSBjb250ZXh0IGluc3RlYWQgZm9yIGEgY29udGV4dCBwcm92aWRlci5cbiAgICByZXR1cm4gcHJldmlvdXNDb250ZXh0O1xuICB9XG4gIHJldHVybiBjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudDtcbn1cblxuZnVuY3Rpb24gY2FjaGVDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQsIG1hc2tlZENvbnRleHQpIHtcbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0ID0gdW5tYXNrZWRDb250ZXh0O1xuICBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dCA9IG1hc2tlZENvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCkge1xuICB2YXIgdHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gIHZhciBjb250ZXh0VHlwZXMgPSB0eXBlLmNvbnRleHRUeXBlcztcbiAgaWYgKCFjb250ZXh0VHlwZXMpIHtcbiAgICByZXR1cm4gZW1wdHlPYmplY3Q7XG4gIH1cblxuICAvLyBBdm9pZCByZWNyZWF0aW5nIG1hc2tlZCBjb250ZXh0IHVubGVzcyB1bm1hc2tlZCBjb250ZXh0IGhhcyBjaGFuZ2VkLlxuICAvLyBGYWlsaW5nIHRvIGRvIHRoaXMgd2lsbCByZXN1bHQgaW4gdW5uZWNlc3NhcnkgY2FsbHMgdG8gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcy5cbiAgLy8gVGhpcyBtYXkgdHJpZ2dlciBpbmZpbml0ZSBsb29wcyBpZiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIGNhbGxzIHNldFN0YXRlLlxuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIGlmIChpbnN0YW5jZSAmJiBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0ID09PSB1bm1hc2tlZENvbnRleHQpIHtcbiAgICByZXR1cm4gaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNYXNrZWRDaGlsZENvbnRleHQ7XG4gIH1cblxuICB2YXIgY29udGV4dCA9IHt9O1xuICBmb3IgKHZhciBrZXkgaW4gY29udGV4dFR5cGVzKSB7XG4gICAgY29udGV4dFtrZXldID0gdW5tYXNrZWRDb250ZXh0W2tleV07XG4gIH1cblxuICB7XG4gICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKSB8fCAnVW5rbm93bic7XG4gICAgY2hlY2tQcm9wVHlwZXMoY29udGV4dFR5cGVzLCBjb250ZXh0LCAnY29udGV4dCcsIG5hbWUsIFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSk7XG4gIH1cblxuICAvLyBDYWNoZSB1bm1hc2tlZCBjb250ZXh0IHNvIHdlIGNhbiBhdm9pZCByZWNyZWF0aW5nIG1hc2tlZCBjb250ZXh0IHVubGVzcyBuZWNlc3NhcnkuXG4gIC8vIENvbnRleHQgaXMgY3JlYXRlZCBiZWZvcmUgdGhlIGNsYXNzIGNvbXBvbmVudCBpcyBpbnN0YW50aWF0ZWQgc28gY2hlY2sgZm9yIGluc3RhbmNlLlxuICBpZiAoaW5zdGFuY2UpIHtcbiAgICBjYWNoZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCwgY29udGV4dCk7XG4gIH1cblxuICByZXR1cm4gY29udGV4dDtcbn1cblxuZnVuY3Rpb24gaGFzQ29udGV4dENoYW5nZWQoKSB7XG4gIHJldHVybiBkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLmN1cnJlbnQ7XG59XG5cbmZ1bmN0aW9uIGlzQ29udGV4dENvbnN1bWVyKGZpYmVyKSB7XG4gIHJldHVybiBmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50ICYmIGZpYmVyLnR5cGUuY29udGV4dFR5cGVzICE9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzQ29udGV4dFByb3ZpZGVyKGZpYmVyKSB7XG4gIHJldHVybiBmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50ICYmIGZpYmVyLnR5cGUuY2hpbGRDb250ZXh0VHlwZXMgIT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gcG9wQ29udGV4dFByb3ZpZGVyKGZpYmVyKSB7XG4gIGlmICghaXNDb250ZXh0UHJvdmlkZXIoZmliZXIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcG9wKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xufVxuXG5mdW5jdGlvbiBwb3BUb3BMZXZlbENvbnRleHRPYmplY3QoZmliZXIpIHtcbiAgcG9wKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xufVxuXG5mdW5jdGlvbiBwdXNoVG9wTGV2ZWxDb250ZXh0T2JqZWN0KGZpYmVyLCBjb250ZXh0LCBkaWRDaGFuZ2UpIHtcbiAgIShjb250ZXh0U3RhY2tDdXJzb3IuY3Vyc29yID09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnVW5leHBlY3RlZCBjb250ZXh0IGZvdW5kIG9uIHN0YWNrLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBjb250ZXh0LCBmaWJlcik7XG4gIHB1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZGlkQ2hhbmdlLCBmaWJlcik7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NDaGlsZENvbnRleHQoZmliZXIsIHBhcmVudENvbnRleHQpIHtcbiAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuICB2YXIgY2hpbGRDb250ZXh0VHlwZXMgPSBmaWJlci50eXBlLmNoaWxkQ29udGV4dFR5cGVzO1xuXG4gIC8vIFRPRE8gKGJ2YXVnaG4pIFJlcGxhY2UgdGhpcyBiZWhhdmlvciB3aXRoIGFuIGludmFyaWFudCgpIGluIHRoZSBmdXR1cmUuXG4gIC8vIEl0IGhhcyBvbmx5IGJlZW4gYWRkZWQgaW4gRmliZXIgdG8gbWF0Y2ggdGhlICh1bmludGVudGlvbmFsKSBiZWhhdmlvciBpbiBTdGFjay5cbiAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQgIT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoZmliZXIpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKCF3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHRbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgd2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0W2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJyVzLmNoaWxkQ29udGV4dFR5cGVzIGlzIHNwZWNpZmllZCBidXQgdGhlcmUgaXMgbm8gZ2V0Q2hpbGRDb250ZXh0KCkgbWV0aG9kICcgKyAnb24gdGhlIGluc3RhbmNlLiBZb3UgY2FuIGVpdGhlciBkZWZpbmUgZ2V0Q2hpbGRDb250ZXh0KCkgb24gJXMgb3IgcmVtb3ZlICcgKyAnY2hpbGRDb250ZXh0VHlwZXMgZnJvbSBpdC4nLCBjb21wb25lbnROYW1lLCBjb21wb25lbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcmVudENvbnRleHQ7XG4gIH1cblxuICB2YXIgY2hpbGRDb250ZXh0ID0gdm9pZCAwO1xuICB7XG4gICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50UGhhc2UoJ2dldENoaWxkQ29udGV4dCcpO1xuICB9XG4gIHN0YXJ0UGhhc2VUaW1lcihmaWJlciwgJ2dldENoaWxkQ29udGV4dCcpO1xuICBjaGlsZENvbnRleHQgPSBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQoKTtcbiAgc3RvcFBoYXNlVGltZXIoKTtcbiAge1xuICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuc2V0Q3VycmVudFBoYXNlKG51bGwpO1xuICB9XG4gIGZvciAodmFyIGNvbnRleHRLZXkgaW4gY2hpbGRDb250ZXh0KSB7XG4gICAgIShjb250ZXh0S2V5IGluIGNoaWxkQ29udGV4dFR5cGVzKSA/IGludmFyaWFudChmYWxzZSwgJyVzLmdldENoaWxkQ29udGV4dCgpOiBrZXkgXCIlc1wiIGlzIG5vdCBkZWZpbmVkIGluIGNoaWxkQ29udGV4dFR5cGVzLicsIGdldENvbXBvbmVudE5hbWUoZmliZXIpIHx8ICdVbmtub3duJywgY29udGV4dEtleSkgOiB2b2lkIDA7XG4gIH1cbiAge1xuICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlcikgfHwgJ1Vua25vd24nO1xuICAgIGNoZWNrUHJvcFR5cGVzKGNoaWxkQ29udGV4dFR5cGVzLCBjaGlsZENvbnRleHQsICdjaGlsZCBjb250ZXh0JywgbmFtZSxcbiAgICAvLyBJbiBwcmFjdGljZSwgdGhlcmUgaXMgb25lIGNhc2UgaW4gd2hpY2ggd2Ugd29uJ3QgZ2V0IGEgc3RhY2suIEl0J3Mgd2hlblxuICAgIC8vIHNvbWVib2R5IGNhbGxzIHVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKCkgYW5kIHdlIHByb2Nlc3NcbiAgICAvLyBjb250ZXh0IGZyb20gdGhlIHBhcmVudCBjb21wb25lbnQgaW5zdGFuY2UuIFRoZSBzdGFjayB3aWxsIGJlIG1pc3NpbmdcbiAgICAvLyBiZWNhdXNlIGl0J3Mgb3V0c2lkZSBvZiB0aGUgcmVjb25jaWxpYXRpb24sIGFuZCBzbyB0aGUgcG9pbnRlciBoYXMgbm90XG4gICAgLy8gYmVlbiBzZXQuIFRoaXMgaXMgcmFyZSBhbmQgZG9lc24ndCBtYXR0ZXIuIFdlJ2xsIGFsc28gcmVtb3ZlIHRoYXQgQVBJLlxuICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSk7XG4gIH1cblxuICByZXR1cm4gX2Fzc2lnbih7fSwgcGFyZW50Q29udGV4dCwgY2hpbGRDb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcykge1xuICBpZiAoIWlzQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgLy8gV2UgcHVzaCB0aGUgY29udGV4dCBhcyBlYXJseSBhcyBwb3NzaWJsZSB0byBlbnN1cmUgc3RhY2sgaW50ZWdyaXR5LlxuICAvLyBJZiB0aGUgaW5zdGFuY2UgZG9lcyBub3QgZXhpc3QgeWV0LCB3ZSB3aWxsIHB1c2ggbnVsbCBhdCBmaXJzdCxcbiAgLy8gYW5kIHJlcGxhY2UgaXQgb24gdGhlIHN0YWNrIGxhdGVyIHdoZW4gaW52YWxpZGF0aW5nIHRoZSBjb250ZXh0LlxuICB2YXIgbWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQgPSBpbnN0YW5jZSAmJiBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCB8fCBlbXB0eU9iamVjdDtcblxuICAvLyBSZW1lbWJlciB0aGUgcGFyZW50IGNvbnRleHQgc28gd2UgY2FuIG1lcmdlIHdpdGggaXQgbGF0ZXIuXG4gIC8vIEluaGVyaXQgdGhlIHBhcmVudCdzIGRpZC1wZXJmb3JtLXdvcmsgdmFsdWUgdG8gYXZvaWQgaW5hZHZlcnRlbnRseSBibG9ja2luZyB1cGRhdGVzLlxuICBwcmV2aW91c0NvbnRleHQgPSBjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudDtcbiAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIG1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gIHB1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvci5jdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGludmFsaWRhdGVDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIGRpZENoYW5nZSkge1xuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICFpbnN0YW5jZSA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHRvIGhhdmUgYW4gaW5zdGFuY2UgYnkgdGhpcyBwb2ludC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcblxuICBpZiAoZGlkQ2hhbmdlKSB7XG4gICAgLy8gTWVyZ2UgcGFyZW50IGFuZCBvd24gY29udGV4dC5cbiAgICAvLyBTa2lwIHRoaXMgaWYgd2UncmUgbm90IHVwZGF0aW5nIGR1ZSB0byBzQ1UuXG4gICAgLy8gVGhpcyBhdm9pZHMgdW5uZWNlc3NhcmlseSByZWNvbXB1dGluZyBtZW1vaXplZCB2YWx1ZXMuXG4gICAgdmFyIG1lcmdlZENvbnRleHQgPSBwcm9jZXNzQ2hpbGRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBwcmV2aW91c0NvbnRleHQpO1xuICAgIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0ID0gbWVyZ2VkQ29udGV4dDtcblxuICAgIC8vIFJlcGxhY2UgdGhlIG9sZCAob3IgZW1wdHkpIGNvbnRleHQgd2l0aCB0aGUgbmV3IG9uZS5cbiAgICAvLyBJdCBpcyBpbXBvcnRhbnQgdG8gdW53aW5kIHRoZSBjb250ZXh0IGluIHRoZSByZXZlcnNlIG9yZGVyLlxuICAgIHBvcChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIC8vIE5vdyBwdXNoIHRoZSBuZXcgY29udGV4dCBhbmQgbWFyayB0aGF0IGl0IGhhcyBjaGFuZ2VkLlxuICAgIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBtZXJnZWRDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgcHVzaChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBkaWRDaGFuZ2UsIHdvcmtJblByb2dyZXNzKTtcbiAgfSBlbHNlIHtcbiAgICBwb3AoZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIHB1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZGlkQ2hhbmdlLCB3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzZXRDb250ZXh0KCkge1xuICBwcmV2aW91c0NvbnRleHQgPSBlbXB0eU9iamVjdDtcbiAgY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQgPSBlbXB0eU9iamVjdDtcbiAgZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvci5jdXJyZW50ID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGZpbmRDdXJyZW50VW5tYXNrZWRDb250ZXh0KGZpYmVyKSB7XG4gIC8vIEN1cnJlbnRseSB0aGlzIGlzIG9ubHkgdXNlZCB3aXRoIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOyBub3Qgc3VyZSBpZiBpdFxuICAvLyBtYWtlcyBzZW5zZSBlbHNld2hlcmVcbiAgIShpc0ZpYmVyTW91bnRlZChmaWJlcikgJiYgZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBzdWJ0cmVlIHBhcmVudCB0byBiZSBhIG1vdW50ZWQgY2xhc3MgY29tcG9uZW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gIHZhciBub2RlID0gZmliZXI7XG4gIHdoaWxlIChub2RlLnRhZyAhPT0gSG9zdFJvb3QpIHtcbiAgICBpZiAoaXNDb250ZXh0UHJvdmlkZXIobm9kZSkpIHtcbiAgICAgIHJldHVybiBub2RlLnN0YXRlTm9kZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dDtcbiAgICB9XG4gICAgdmFyIHBhcmVudCA9IG5vZGVbJ3JldHVybiddO1xuICAgICFwYXJlbnQgPyBpbnZhcmlhbnQoZmFsc2UsICdGb3VuZCB1bmV4cGVjdGVkIGRldGFjaGVkIHN1YnRyZWUgcGFyZW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgIG5vZGUgPSBwYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIG5vZGUuc3RhdGVOb2RlLmNvbnRleHQ7XG59XG5cbnZhciBOb1dvcmsgPSAwOyAvLyBUT0RPOiBVc2UgYW4gb3BhcXVlIHR5cGUgb25jZSBFU0xpbnQgZXQgYWwgc3VwcG9ydCB0aGUgc3ludGF4XG5cbnZhciBTeW5jID0gMTtcbnZhciBOZXZlciA9IDIxNDc0ODM2NDc7IC8vIE1heCBpbnQzMjogTWF0aC5wb3coMiwgMzEpIC0gMVxuXG52YXIgVU5JVF9TSVpFID0gMTA7XG52YXIgTUFHSUNfTlVNQkVSX09GRlNFVCA9IDI7XG5cbi8vIDEgdW5pdCBvZiBleHBpcmF0aW9uIHRpbWUgcmVwcmVzZW50cyAxMG1zLlxuZnVuY3Rpb24gbXNUb0V4cGlyYXRpb25UaW1lKG1zKSB7XG4gIC8vIEFsd2F5cyBhZGQgYW4gb2Zmc2V0IHNvIHRoYXQgd2UgZG9uJ3QgY2xhc2ggd2l0aCB0aGUgbWFnaWMgbnVtYmVyIGZvciBOb1dvcmsuXG4gIHJldHVybiAobXMgLyBVTklUX1NJWkUgfCAwKSArIE1BR0lDX05VTUJFUl9PRkZTRVQ7XG59XG5cbmZ1bmN0aW9uIGV4cGlyYXRpb25UaW1lVG9NcyhleHBpcmF0aW9uVGltZSkge1xuICByZXR1cm4gKGV4cGlyYXRpb25UaW1lIC0gTUFHSUNfTlVNQkVSX09GRlNFVCkgKiBVTklUX1NJWkU7XG59XG5cbmZ1bmN0aW9uIGNlaWxpbmcobnVtLCBwcmVjaXNpb24pIHtcbiAgcmV0dXJuICgobnVtIC8gcHJlY2lzaW9uIHwgMCkgKyAxKSAqIHByZWNpc2lvbjtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUV4cGlyYXRpb25CdWNrZXQoY3VycmVudFRpbWUsIGV4cGlyYXRpb25Jbk1zLCBidWNrZXRTaXplTXMpIHtcbiAgcmV0dXJuIGNlaWxpbmcoY3VycmVudFRpbWUgKyBleHBpcmF0aW9uSW5NcyAvIFVOSVRfU0laRSwgYnVja2V0U2l6ZU1zIC8gVU5JVF9TSVpFKTtcbn1cblxudmFyIE5vQ29udGV4dCA9IDA7XG52YXIgQXN5bmNVcGRhdGVzID0gMTtcblxue1xuICB2YXIgaGFzQmFkTWFwUG9seWZpbGwgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICB2YXIgbm9uRXh0ZW5zaWJsZU9iamVjdCA9IE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tbmV3ICovXG4gICAgXG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1uZXcgKi9cbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFRPRE86IENvbnNpZGVyIHdhcm5pbmcgYWJvdXQgYmFkIHBvbHlmaWxsc1xuICAgIGhhc0JhZE1hcFBvbHlmaWxsID0gdHJ1ZTtcbiAgfVxufVxuXG4vLyBBIEZpYmVyIGlzIHdvcmsgb24gYSBDb21wb25lbnQgdGhhdCBuZWVkcyB0byBiZSBkb25lIG9yIHdhcyBkb25lLiBUaGVyZSBjYW5cbi8vIGJlIG1vcmUgdGhhbiBvbmUgcGVyIGNvbXBvbmVudC5cblxuXG57XG4gIHZhciBkZWJ1Z0NvdW50ZXIgPSAxO1xufVxuXG5mdW5jdGlvbiBGaWJlck5vZGUodGFnLCBrZXksIGludGVybmFsQ29udGV4dFRhZykge1xuICAvLyBJbnN0YW5jZVxuICB0aGlzLnRhZyA9IHRhZztcbiAgdGhpcy5rZXkgPSBrZXk7XG4gIHRoaXMudHlwZSA9IG51bGw7XG4gIHRoaXMuc3RhdGVOb2RlID0gbnVsbDtcblxuICAvLyBGaWJlclxuICB0aGlzWydyZXR1cm4nXSA9IG51bGw7XG4gIHRoaXMuY2hpbGQgPSBudWxsO1xuICB0aGlzLnNpYmxpbmcgPSBudWxsO1xuICB0aGlzLmluZGV4ID0gMDtcblxuICB0aGlzLnJlZiA9IG51bGw7XG5cbiAgdGhpcy5wZW5kaW5nUHJvcHMgPSBudWxsO1xuICB0aGlzLm1lbW9pemVkUHJvcHMgPSBudWxsO1xuICB0aGlzLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgdGhpcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcblxuICB0aGlzLmludGVybmFsQ29udGV4dFRhZyA9IGludGVybmFsQ29udGV4dFRhZztcblxuICAvLyBFZmZlY3RzXG4gIHRoaXMuZWZmZWN0VGFnID0gTm9FZmZlY3Q7XG4gIHRoaXMubmV4dEVmZmVjdCA9IG51bGw7XG5cbiAgdGhpcy5maXJzdEVmZmVjdCA9IG51bGw7XG4gIHRoaXMubGFzdEVmZmVjdCA9IG51bGw7XG5cbiAgdGhpcy5leHBpcmF0aW9uVGltZSA9IE5vV29yaztcblxuICB0aGlzLmFsdGVybmF0ZSA9IG51bGw7XG5cbiAge1xuICAgIHRoaXMuX2RlYnVnSUQgPSBkZWJ1Z0NvdW50ZXIrKztcbiAgICB0aGlzLl9kZWJ1Z1NvdXJjZSA9IG51bGw7XG4gICAgdGhpcy5fZGVidWdPd25lciA9IG51bGw7XG4gICAgdGhpcy5fZGVidWdJc0N1cnJlbnRseVRpbWluZyA9IGZhbHNlO1xuICAgIGlmICghaGFzQmFkTWFwUG9seWZpbGwgJiYgdHlwZW9mIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHRoaXMpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBUaGlzIGlzIGEgY29uc3RydWN0b3IgZnVuY3Rpb24sIHJhdGhlciB0aGFuIGEgUE9KTyBjb25zdHJ1Y3Rvciwgc3RpbGxcbi8vIHBsZWFzZSBlbnN1cmUgd2UgZG8gdGhlIGZvbGxvd2luZzpcbi8vIDEpIE5vYm9keSBzaG91bGQgYWRkIGFueSBpbnN0YW5jZSBtZXRob2RzIG9uIHRoaXMuIEluc3RhbmNlIG1ldGhvZHMgY2FuIGJlXG4vLyAgICBtb3JlIGRpZmZpY3VsdCB0byBwcmVkaWN0IHdoZW4gdGhleSBnZXQgb3B0aW1pemVkIGFuZCB0aGV5IGFyZSBhbG1vc3Rcbi8vICAgIG5ldmVyIGlubGluZWQgcHJvcGVybHkgaW4gc3RhdGljIGNvbXBpbGVycy5cbi8vIDIpIE5vYm9keSBzaG91bGQgcmVseSBvbiBgaW5zdGFuY2VvZiBGaWJlcmAgZm9yIHR5cGUgdGVzdGluZy4gV2Ugc2hvdWxkXG4vLyAgICBhbHdheXMga25vdyB3aGVuIGl0IGlzIGEgZmliZXIuXG4vLyAzKSBXZSBtaWdodCB3YW50IHRvIGV4cGVyaW1lbnQgd2l0aCB1c2luZyBudW1lcmljIGtleXMgc2luY2UgdGhleSBhcmUgZWFzaWVyXG4vLyAgICB0byBvcHRpbWl6ZSBpbiBhIG5vbi1KSVQgZW52aXJvbm1lbnQuXG4vLyA0KSBXZSBjYW4gZWFzaWx5IGdvIGZyb20gYSBjb25zdHJ1Y3RvciB0byBhIGNyZWF0ZUZpYmVyIG9iamVjdCBsaXRlcmFsIGlmIHRoYXRcbi8vICAgIGlzIGZhc3Rlci5cbi8vIDUpIEl0IHNob3VsZCBiZSBlYXN5IHRvIHBvcnQgdGhpcyB0byBhIEMgc3RydWN0IGFuZCBrZWVwIGEgQyBpbXBsZW1lbnRhdGlvblxuLy8gICAgY29tcGF0aWJsZS5cbnZhciBjcmVhdGVGaWJlciA9IGZ1bmN0aW9uICh0YWcsIGtleSwgaW50ZXJuYWxDb250ZXh0VGFnKSB7XG4gIC8vICRGbG93Rml4TWU6IHRoZSBzaGFwZXMgYXJlIGV4YWN0IGhlcmUgYnV0IEZsb3cgZG9lc24ndCBsaWtlIGNvbnN0cnVjdG9yc1xuICByZXR1cm4gbmV3IEZpYmVyTm9kZSh0YWcsIGtleSwgaW50ZXJuYWxDb250ZXh0VGFnKTtcbn07XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgcmV0dXJuICEhKENvbXBvbmVudC5wcm90b3R5cGUgJiYgQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuLy8gVGhpcyBpcyB1c2VkIHRvIGNyZWF0ZSBhbiBhbHRlcm5hdGUgZmliZXIgdG8gZG8gd29yayBvbi5cbmZ1bmN0aW9uIGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnQsIHBlbmRpbmdQcm9wcywgZXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIHdvcmtJblByb2dyZXNzID0gY3VycmVudC5hbHRlcm5hdGU7XG4gIGlmICh3b3JrSW5Qcm9ncmVzcyA9PT0gbnVsbCkge1xuICAgIC8vIFdlIHVzZSBhIGRvdWJsZSBidWZmZXJpbmcgcG9vbGluZyB0ZWNobmlxdWUgYmVjYXVzZSB3ZSBrbm93IHRoYXQgd2UnbGxcbiAgICAvLyBvbmx5IGV2ZXIgbmVlZCBhdCBtb3N0IHR3byB2ZXJzaW9ucyBvZiBhIHRyZWUuIFdlIHBvb2wgdGhlIFwib3RoZXJcIiB1bnVzZWRcbiAgICAvLyBub2RlIHRoYXQgd2UncmUgZnJlZSB0byByZXVzZS4gVGhpcyBpcyBsYXppbHkgY3JlYXRlZCB0byBhdm9pZCBhbGxvY2F0aW5nXG4gICAgLy8gZXh0cmEgb2JqZWN0cyBmb3IgdGhpbmdzIHRoYXQgYXJlIG5ldmVyIHVwZGF0ZWQuIEl0IGFsc28gYWxsb3cgdXMgdG9cbiAgICAvLyByZWNsYWltIHRoZSBleHRyYSBtZW1vcnkgaWYgbmVlZGVkLlxuICAgIHdvcmtJblByb2dyZXNzID0gY3JlYXRlRmliZXIoY3VycmVudC50YWcsIGN1cnJlbnQua2V5LCBjdXJyZW50LmludGVybmFsQ29udGV4dFRhZyk7XG4gICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IGN1cnJlbnQudHlwZTtcbiAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjdXJyZW50LnN0YXRlTm9kZTtcblxuICAgIHtcbiAgICAgIC8vIERFVi1vbmx5IGZpZWxkc1xuICAgICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnSUQgPSBjdXJyZW50Ll9kZWJ1Z0lEO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnU291cmNlID0gY3VycmVudC5fZGVidWdTb3VyY2U7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdPd25lciA9IGN1cnJlbnQuX2RlYnVnT3duZXI7XG4gICAgfVxuXG4gICAgd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlID0gY3VycmVudDtcbiAgICBjdXJyZW50LmFsdGVybmF0ZSA9IHdvcmtJblByb2dyZXNzO1xuICB9IGVsc2Uge1xuICAgIC8vIFdlIGFscmVhZHkgaGF2ZSBhbiBhbHRlcm5hdGUuXG4gICAgLy8gUmVzZXQgdGhlIGVmZmVjdCB0YWcuXG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnID0gTm9FZmZlY3Q7XG5cbiAgICAvLyBUaGUgZWZmZWN0IGxpc3QgaXMgbm8gbG9uZ2VyIHZhbGlkLlxuICAgIHdvcmtJblByb2dyZXNzLm5leHRFZmZlY3QgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLmZpcnN0RWZmZWN0ID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5sYXN0RWZmZWN0ID0gbnVsbDtcbiAgfVxuXG4gIHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyA9IHBlbmRpbmdQcm9wcztcblxuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQuY2hpbGQ7XG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY3VycmVudC51cGRhdGVRdWV1ZTtcblxuICAvLyBUaGVzZSB3aWxsIGJlIG92ZXJyaWRkZW4gZHVyaW5nIHRoZSBwYXJlbnQncyByZWNvbmNpbGlhdGlvblxuICB3b3JrSW5Qcm9ncmVzcy5zaWJsaW5nID0gY3VycmVudC5zaWJsaW5nO1xuICB3b3JrSW5Qcm9ncmVzcy5pbmRleCA9IGN1cnJlbnQuaW5kZXg7XG4gIHdvcmtJblByb2dyZXNzLnJlZiA9IGN1cnJlbnQucmVmO1xuXG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbn1cblxuZnVuY3Rpb24gY3JlYXRlSG9zdFJvb3RGaWJlcigpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoSG9zdFJvb3QsIG51bGwsIE5vQ29udGV4dCk7XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tRWxlbWVudChlbGVtZW50LCBpbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciBvd25lciA9IG51bGw7XG4gIHtcbiAgICBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICB9XG5cbiAgdmFyIGZpYmVyID0gdm9pZCAwO1xuICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZSxcbiAgICAgIGtleSA9IGVsZW1lbnQua2V5O1xuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZpYmVyID0gc2hvdWxkQ29uc3RydWN0KHR5cGUpID8gY3JlYXRlRmliZXIoQ2xhc3NDb21wb25lbnQsIGtleSwgaW50ZXJuYWxDb250ZXh0VGFnKSA6IGNyZWF0ZUZpYmVyKEluZGV0ZXJtaW5hdGVDb21wb25lbnQsIGtleSwgaW50ZXJuYWxDb250ZXh0VGFnKTtcbiAgICBmaWJlci50eXBlID0gdHlwZTtcbiAgICBmaWJlci5wZW5kaW5nUHJvcHMgPSBlbGVtZW50LnByb3BzO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIGZpYmVyID0gY3JlYXRlRmliZXIoSG9zdENvbXBvbmVudCwga2V5LCBpbnRlcm5hbENvbnRleHRUYWcpO1xuICAgIGZpYmVyLnR5cGUgPSB0eXBlO1xuICAgIGZpYmVyLnBlbmRpbmdQcm9wcyA9IGVsZW1lbnQucHJvcHM7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgdHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgIC8vIEN1cnJlbnRseSBhc3N1bWVkIHRvIGJlIGEgY29udGludWF0aW9uIGFuZCB0aGVyZWZvcmUgaXMgYSBmaWJlciBhbHJlYWR5LlxuICAgIC8vIFRPRE86IFRoZSB5aWVsZCBzeXN0ZW0gaXMgY3VycmVudGx5IGJyb2tlbiBmb3IgdXBkYXRlcyBpbiBzb21lIGNhc2VzLlxuICAgIC8vIFRoZSByZWlmaWVkIHlpZWxkIHN0b3JlcyBhIGZpYmVyLCBidXQgd2UgZG9uJ3Qga25vdyB3aGljaCBmaWJlciB0aGF0IGlzO1xuICAgIC8vIHRoZSBjdXJyZW50IG9yIGEgd29ya0luUHJvZ3Jlc3M/IFdoZW4gdGhlIGNvbnRpbnVhdGlvbiBnZXRzIHJlbmRlcmVkIGhlcmVcbiAgICAvLyB3ZSBkb24ndCBrbm93IGlmIHdlIGNhbiByZXVzZSB0aGF0IGZpYmVyIG9yIGlmIHdlIG5lZWQgdG8gY2xvbmUgaXQuXG4gICAgLy8gVGhlcmUgaXMgcHJvYmFibHkgYSBjbGV2ZXIgd2F5IHRvIHJlc3RydWN0dXJlIHRoaXMuXG4gICAgZmliZXIgPSB0eXBlO1xuICAgIGZpYmVyLnBlbmRpbmdQcm9wcyA9IGVsZW1lbnQucHJvcHM7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGluZm8gPSAnJztcbiAgICB7XG4gICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgICAgfVxuICAgICAgdmFyIG93bmVyTmFtZSA9IG93bmVyID8gZ2V0Q29tcG9uZW50TmFtZShvd25lcikgOiBudWxsO1xuICAgICAgaWYgKG93bmVyTmFtZSkge1xuICAgICAgICBpbmZvICs9ICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG93bmVyTmFtZSArICdgLic7XG4gICAgICB9XG4gICAgfVxuICAgIGludmFyaWFudChmYWxzZSwgJ0VsZW1lbnQgdHlwZSBpcyBpbnZhbGlkOiBleHBlY3RlZCBhIHN0cmluZyAoZm9yIGJ1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCB0eXBlID09IG51bGwgPyB0eXBlIDogdHlwZW9mIHR5cGUsIGluZm8pO1xuICB9XG5cbiAge1xuICAgIGZpYmVyLl9kZWJ1Z1NvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcbiAgICBmaWJlci5fZGVidWdPd25lciA9IGVsZW1lbnQuX293bmVyO1xuICB9XG5cbiAgZmliZXIuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcblxuICByZXR1cm4gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KGVsZW1lbnRzLCBpbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lLCBrZXkpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoRnJhZ21lbnQsIGtleSwgaW50ZXJuYWxDb250ZXh0VGFnKTtcbiAgZmliZXIucGVuZGluZ1Byb3BzID0gZWxlbWVudHM7XG4gIGZpYmVyLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tVGV4dChjb250ZW50LCBpbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKEhvc3RUZXh0LCBudWxsLCBpbnRlcm5hbENvbnRleHRUYWcpO1xuICBmaWJlci5wZW5kaW5nUHJvcHMgPSBjb250ZW50O1xuICBmaWJlci5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICByZXR1cm4gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbUhvc3RJbnN0YW5jZUZvckRlbGV0aW9uKCkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihIb3N0Q29tcG9uZW50LCBudWxsLCBOb0NvbnRleHQpO1xuICBmaWJlci50eXBlID0gJ0RFTEVURUQnO1xuICByZXR1cm4gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbUNhbGwoY2FsbCwgaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihDYWxsQ29tcG9uZW50LCBjYWxsLmtleSwgaW50ZXJuYWxDb250ZXh0VGFnKTtcbiAgZmliZXIudHlwZSA9IGNhbGwuaGFuZGxlcjtcbiAgZmliZXIucGVuZGluZ1Byb3BzID0gY2FsbDtcbiAgZmliZXIuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgcmV0dXJuIGZpYmVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21SZXR1cm4ocmV0dXJuTm9kZSwgaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihSZXR1cm5Db21wb25lbnQsIG51bGwsIGludGVybmFsQ29udGV4dFRhZyk7XG4gIGZpYmVyLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tUG9ydGFsKHBvcnRhbCwgaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihIb3N0UG9ydGFsLCBwb3J0YWwua2V5LCBpbnRlcm5hbENvbnRleHRUYWcpO1xuICBmaWJlci5wZW5kaW5nUHJvcHMgPSBwb3J0YWwuY2hpbGRyZW4gfHwgW107XG4gIGZpYmVyLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIGZpYmVyLnN0YXRlTm9kZSA9IHtcbiAgICBjb250YWluZXJJbmZvOiBwb3J0YWwuY29udGFpbmVySW5mbyxcbiAgICBwZW5kaW5nQ2hpbGRyZW46IG51bGwsIC8vIFVzZWQgYnkgcGVyc2lzdGVudCB1cGRhdGVzXG4gICAgaW1wbGVtZW50YXRpb246IHBvcnRhbC5pbXBsZW1lbnRhdGlvblxuICB9O1xuICByZXR1cm4gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyUm9vdChjb250YWluZXJJbmZvLCBoeWRyYXRlKSB7XG4gIC8vIEN5Y2xpYyBjb25zdHJ1Y3Rpb24uIFRoaXMgY2hlYXRzIHRoZSB0eXBlIHN5c3RlbSByaWdodCBub3cgYmVjYXVzZVxuICAvLyBzdGF0ZU5vZGUgaXMgYW55LlxuICB2YXIgdW5pbml0aWFsaXplZEZpYmVyID0gY3JlYXRlSG9zdFJvb3RGaWJlcigpO1xuICB2YXIgcm9vdCA9IHtcbiAgICBjdXJyZW50OiB1bmluaXRpYWxpemVkRmliZXIsXG4gICAgY29udGFpbmVySW5mbzogY29udGFpbmVySW5mbyxcbiAgICBwZW5kaW5nQ2hpbGRyZW46IG51bGwsXG4gICAgcmVtYWluaW5nRXhwaXJhdGlvblRpbWU6IE5vV29yayxcbiAgICBpc1JlYWR5Rm9yQ29tbWl0OiBmYWxzZSxcbiAgICBmaW5pc2hlZFdvcms6IG51bGwsXG4gICAgY29udGV4dDogbnVsbCxcbiAgICBwZW5kaW5nQ29udGV4dDogbnVsbCxcbiAgICBoeWRyYXRlOiBoeWRyYXRlLFxuICAgIG5leHRTY2hlZHVsZWRSb290OiBudWxsXG4gIH07XG4gIHVuaW5pdGlhbGl6ZWRGaWJlci5zdGF0ZU5vZGUgPSByb290O1xuICByZXR1cm4gcm9vdDtcbn1cblxudmFyIG9uQ29tbWl0RmliZXJSb290ID0gbnVsbDtcbnZhciBvbkNvbW1pdEZpYmVyVW5tb3VudCA9IG51bGw7XG52YXIgaGFzTG9nZ2VkRXJyb3IgPSBmYWxzZTtcblxuZnVuY3Rpb24gY2F0Y2hFcnJvcnMoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZuKGFyZyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAodHJ1ZSAmJiAhaGFzTG9nZ2VkRXJyb3IpIHtcbiAgICAgICAgaGFzTG9nZ2VkRXJyb3IgPSB0cnVlO1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnUmVhY3QgRGV2VG9vbHMgZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzJywgZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluamVjdEludGVybmFscyhpbnRlcm5hbHMpIHtcbiAgaWYgKHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gTm8gRGV2VG9vbHNcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGhvb2sgPSBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG4gIGlmIChob29rLmlzRGlzYWJsZWQpIHtcbiAgICAvLyBUaGlzIGlzbid0IGEgcmVhbCBwcm9wZXJ0eSBvbiB0aGUgaG9vaywgYnV0IGl0IGNhbiBiZSBzZXQgdG8gb3B0IG91dFxuICAgIC8vIG9mIERldlRvb2xzIGludGVncmF0aW9uIGFuZCBhc3NvY2lhdGVkIHdhcm5pbmdzIGFuZCBsb2dzLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMzg3N1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICghaG9vay5zdXBwb3J0c0ZpYmVyKSB7XG4gICAge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1RoZSBpbnN0YWxsZWQgdmVyc2lvbiBvZiBSZWFjdCBEZXZUb29scyBpcyB0b28gb2xkIGFuZCB3aWxsIG5vdCB3b3JrICcgKyAnd2l0aCB0aGUgY3VycmVudCB2ZXJzaW9uIG9mIFJlYWN0LiBQbGVhc2UgdXBkYXRlIFJlYWN0IERldlRvb2xzLiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtZGV2dG9vbHMnKTtcbiAgICB9XG4gICAgLy8gRGV2VG9vbHMgZXhpc3RzLCBldmVuIHRob3VnaCBpdCBkb2Vzbid0IHN1cHBvcnQgRmliZXIuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdHJ5IHtcbiAgICB2YXIgcmVuZGVyZXJJRCA9IGhvb2suaW5qZWN0KGludGVybmFscyk7XG4gICAgLy8gV2UgaGF2ZSBzdWNjZXNzZnVsbHkgaW5qZWN0ZWQsIHNvIG5vdyBpdCBpcyBzYWZlIHRvIHNldCB1cCBob29rcy5cbiAgICBvbkNvbW1pdEZpYmVyUm9vdCA9IGNhdGNoRXJyb3JzKGZ1bmN0aW9uIChyb290KSB7XG4gICAgICByZXR1cm4gaG9vay5vbkNvbW1pdEZpYmVyUm9vdChyZW5kZXJlcklELCByb290KTtcbiAgICB9KTtcbiAgICBvbkNvbW1pdEZpYmVyVW5tb3VudCA9IGNhdGNoRXJyb3JzKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgcmV0dXJuIGhvb2sub25Db21taXRGaWJlclVubW91bnQocmVuZGVyZXJJRCwgZmliZXIpO1xuICAgIH0pO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBDYXRjaCBhbGwgZXJyb3JzIGJlY2F1c2UgaXQgaXMgdW5zYWZlIHRvIHRocm93IGR1cmluZyBpbml0aWFsaXphdGlvbi5cbiAgICB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnUmVhY3QgRGV2VG9vbHMgZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzLicsIGVycik7XG4gICAgfVxuICB9XG4gIC8vIERldlRvb2xzIGV4aXN0c1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gb25Db21taXRSb290KHJvb3QpIHtcbiAgaWYgKHR5cGVvZiBvbkNvbW1pdEZpYmVyUm9vdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9uQ29tbWl0RmliZXJSb290KHJvb3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9uQ29tbWl0VW5tb3VudChmaWJlcikge1xuICBpZiAodHlwZW9mIG9uQ29tbWl0RmliZXJVbm1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb25Db21taXRGaWJlclVubW91bnQoZmliZXIpO1xuICB9XG59XG5cbntcbiAgdmFyIGRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUgPSBmYWxzZTtcbn1cblxuLy8gQ2FsbGJhY2tzIGFyZSBub3QgdmFsaWRhdGVkIHVudGlsIGludm9jYXRpb25cblxuXG4vLyBTaW5nbHkgbGlua2VkLWxpc3Qgb2YgdXBkYXRlcy4gV2hlbiBhbiB1cGRhdGUgaXMgc2NoZWR1bGVkLCBpdCBpcyBhZGRlZCB0b1xuLy8gdGhlIHF1ZXVlIG9mIHRoZSBjdXJyZW50IGZpYmVyIGFuZCB0aGUgd29yay1pbi1wcm9ncmVzcyBmaWJlci4gVGhlIHR3byBxdWV1ZXNcbi8vIGFyZSBzZXBhcmF0ZSBidXQgdGhleSBzaGFyZSBhIHBlcnNpc3RlbnQgc3RydWN0dXJlLlxuLy9cbi8vIER1cmluZyByZWNvbmNpbGlhdGlvbiwgdXBkYXRlcyBhcmUgcmVtb3ZlZCBmcm9tIHRoZSB3b3JrLWluLXByb2dyZXNzIGZpYmVyLFxuLy8gYnV0IHRoZXkgcmVtYWluIG9uIHRoZSBjdXJyZW50IGZpYmVyLiBUaGF0IGVuc3VyZXMgdGhhdCBpZiBhIHdvcmstaW4tcHJvZ3Jlc3Ncbi8vIGlzIGFib3J0ZWQsIHRoZSBhYm9ydGVkIHVwZGF0ZXMgYXJlIHJlY292ZXJlZCBieSBjbG9uaW5nIGZyb20gY3VycmVudC5cbi8vXG4vLyBUaGUgd29yay1pbi1wcm9ncmVzcyBxdWV1ZSBpcyBhbHdheXMgYSBzdWJzZXQgb2YgdGhlIGN1cnJlbnQgcXVldWUuXG4vL1xuLy8gV2hlbiB0aGUgdHJlZSBpcyBjb21taXR0ZWQsIHRoZSB3b3JrLWluLXByb2dyZXNzIGJlY29tZXMgdGhlIGN1cnJlbnQuXG5cblxuZnVuY3Rpb24gY3JlYXRlVXBkYXRlUXVldWUoYmFzZVN0YXRlKSB7XG4gIHZhciBxdWV1ZSA9IHtcbiAgICBiYXNlU3RhdGU6IGJhc2VTdGF0ZSxcbiAgICBleHBpcmF0aW9uVGltZTogTm9Xb3JrLFxuICAgIGZpcnN0OiBudWxsLFxuICAgIGxhc3Q6IG51bGwsXG4gICAgY2FsbGJhY2tMaXN0OiBudWxsLFxuICAgIGhhc0ZvcmNlVXBkYXRlOiBmYWxzZSxcbiAgICBpc0luaXRpYWxpemVkOiBmYWxzZVxuICB9O1xuICB7XG4gICAgcXVldWUuaXNQcm9jZXNzaW5nID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHF1ZXVlO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRVcGRhdGVJbnRvUXVldWUocXVldWUsIHVwZGF0ZSkge1xuICAvLyBBcHBlbmQgdGhlIHVwZGF0ZSB0byB0aGUgZW5kIG9mIHRoZSBsaXN0LlxuICBpZiAocXVldWUubGFzdCA9PT0gbnVsbCkge1xuICAgIC8vIFF1ZXVlIGlzIGVtcHR5XG4gICAgcXVldWUuZmlyc3QgPSBxdWV1ZS5sYXN0ID0gdXBkYXRlO1xuICB9IGVsc2Uge1xuICAgIHF1ZXVlLmxhc3QubmV4dCA9IHVwZGF0ZTtcbiAgICBxdWV1ZS5sYXN0ID0gdXBkYXRlO1xuICB9XG4gIGlmIChxdWV1ZS5leHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IHF1ZXVlLmV4cGlyYXRpb25UaW1lID4gdXBkYXRlLmV4cGlyYXRpb25UaW1lKSB7XG4gICAgcXVldWUuZXhwaXJhdGlvblRpbWUgPSB1cGRhdGUuZXhwaXJhdGlvblRpbWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5zZXJ0VXBkYXRlSW50b0ZpYmVyKGZpYmVyLCB1cGRhdGUpIHtcbiAgLy8gV2UnbGwgaGF2ZSBhdCBsZWFzdCBvbmUgYW5kIGF0IG1vc3QgdHdvIGRpc3RpbmN0IHVwZGF0ZSBxdWV1ZXMuXG4gIHZhciBhbHRlcm5hdGVGaWJlciA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgdmFyIHF1ZXVlMSA9IGZpYmVyLnVwZGF0ZVF1ZXVlO1xuICBpZiAocXVldWUxID09PSBudWxsKSB7XG4gICAgLy8gVE9ETzogV2UgZG9uJ3Qga25vdyB3aGF0IHRoZSBiYXNlIHN0YXRlIHdpbGwgYmUgdW50aWwgd2UgYmVnaW4gd29yay5cbiAgICAvLyBJdCBkZXBlbmRzIG9uIHdoaWNoIGZpYmVyIGlzIHRoZSBuZXh0IGN1cnJlbnQuIEluaXRpYWxpemUgd2l0aCBhbiBlbXB0eVxuICAgIC8vIGJhc2Ugc3RhdGUsIHRoZW4gc2V0IHRvIHRoZSBtZW1vaXplZFN0YXRlIHdoZW4gcmVuZGVyaW5nLiBOb3Qgc3VwZXJcbiAgICAvLyBoYXBweSB3aXRoIHRoaXMgYXBwcm9hY2guXG4gICAgcXVldWUxID0gZmliZXIudXBkYXRlUXVldWUgPSBjcmVhdGVVcGRhdGVRdWV1ZShudWxsKTtcbiAgfVxuXG4gIHZhciBxdWV1ZTIgPSB2b2lkIDA7XG4gIGlmIChhbHRlcm5hdGVGaWJlciAhPT0gbnVsbCkge1xuICAgIHF1ZXVlMiA9IGFsdGVybmF0ZUZpYmVyLnVwZGF0ZVF1ZXVlO1xuICAgIGlmIChxdWV1ZTIgPT09IG51bGwpIHtcbiAgICAgIHF1ZXVlMiA9IGFsdGVybmF0ZUZpYmVyLnVwZGF0ZVF1ZXVlID0gY3JlYXRlVXBkYXRlUXVldWUobnVsbCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHF1ZXVlMiA9IG51bGw7XG4gIH1cbiAgcXVldWUyID0gcXVldWUyICE9PSBxdWV1ZTEgPyBxdWV1ZTIgOiBudWxsO1xuXG4gIC8vIFdhcm4gaWYgYW4gdXBkYXRlIGlzIHNjaGVkdWxlZCBmcm9tIGluc2lkZSBhbiB1cGRhdGVyIGZ1bmN0aW9uLlxuICB7XG4gICAgaWYgKChxdWV1ZTEuaXNQcm9jZXNzaW5nIHx8IHF1ZXVlMiAhPT0gbnVsbCAmJiBxdWV1ZTIuaXNQcm9jZXNzaW5nKSAmJiAhZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ0FuIHVwZGF0ZSAoc2V0U3RhdGUsIHJlcGxhY2VTdGF0ZSwgb3IgZm9yY2VVcGRhdGUpIHdhcyBzY2hlZHVsZWQgJyArICdmcm9tIGluc2lkZSBhbiB1cGRhdGUgZnVuY3Rpb24uIFVwZGF0ZSBmdW5jdGlvbnMgc2hvdWxkIGJlIHB1cmUsICcgKyAnd2l0aCB6ZXJvIHNpZGUtZWZmZWN0cy4gQ29uc2lkZXIgdXNpbmcgY29tcG9uZW50RGlkVXBkYXRlIG9yIGEgJyArICdjYWxsYmFjay4nKTtcbiAgICAgIGRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIElmIHRoZXJlJ3Mgb25seSBvbmUgcXVldWUsIGFkZCB0aGUgdXBkYXRlIHRvIHRoYXQgcXVldWUgYW5kIGV4aXQuXG4gIGlmIChxdWV1ZTIgPT09IG51bGwpIHtcbiAgICBpbnNlcnRVcGRhdGVJbnRvUXVldWUocXVldWUxLCB1cGRhdGUpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIElmIGVpdGhlciBxdWV1ZSBpcyBlbXB0eSwgd2UgbmVlZCB0byBhZGQgdG8gYm90aCBxdWV1ZXMuXG4gIGlmIChxdWV1ZTEubGFzdCA9PT0gbnVsbCB8fCBxdWV1ZTIubGFzdCA9PT0gbnVsbCkge1xuICAgIGluc2VydFVwZGF0ZUludG9RdWV1ZShxdWV1ZTEsIHVwZGF0ZSk7XG4gICAgaW5zZXJ0VXBkYXRlSW50b1F1ZXVlKHF1ZXVlMiwgdXBkYXRlKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBJZiBib3RoIGxpc3RzIGFyZSBub3QgZW1wdHksIHRoZSBsYXN0IHVwZGF0ZSBpcyB0aGUgc2FtZSBmb3IgYm90aCBsaXN0c1xuICAvLyBiZWNhdXNlIG9mIHN0cnVjdHVyYWwgc2hhcmluZy4gU28sIHdlIHNob3VsZCBvbmx5IGFwcGVuZCB0byBvbmUgb2ZcbiAgLy8gdGhlIGxpc3RzLlxuICBpbnNlcnRVcGRhdGVJbnRvUXVldWUocXVldWUxLCB1cGRhdGUpO1xuICAvLyBCdXQgd2Ugc3RpbGwgbmVlZCB0byB1cGRhdGUgdGhlIGBsYXN0YCBwb2ludGVyIG9mIHF1ZXVlMi5cbiAgcXVldWUyLmxhc3QgPSB1cGRhdGU7XG59XG5cbmZ1bmN0aW9uIGdldFVwZGF0ZUV4cGlyYXRpb25UaW1lKGZpYmVyKSB7XG4gIGlmIChmaWJlci50YWcgIT09IENsYXNzQ29tcG9uZW50ICYmIGZpYmVyLnRhZyAhPT0gSG9zdFJvb3QpIHtcbiAgICByZXR1cm4gTm9Xb3JrO1xuICB9XG4gIHZhciB1cGRhdGVRdWV1ZSA9IGZpYmVyLnVwZGF0ZVF1ZXVlO1xuICBpZiAodXBkYXRlUXVldWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gTm9Xb3JrO1xuICB9XG4gIHJldHVybiB1cGRhdGVRdWV1ZS5leHBpcmF0aW9uVGltZTtcbn1cblxuZnVuY3Rpb24gZ2V0U3RhdGVGcm9tVXBkYXRlKHVwZGF0ZSwgaW5zdGFuY2UsIHByZXZTdGF0ZSwgcHJvcHMpIHtcbiAgdmFyIHBhcnRpYWxTdGF0ZSA9IHVwZGF0ZS5wYXJ0aWFsU3RhdGU7XG4gIGlmICh0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHVwZGF0ZUZuID0gcGFydGlhbFN0YXRlO1xuXG4gICAgLy8gSW52b2tlIHNldFN0YXRlIGNhbGxiYWNrIGFuIGV4dHJhIHRpbWUgdG8gaGVscCBkZXRlY3Qgc2lkZS1lZmZlY3RzLlxuICAgIGlmIChkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHMpIHtcbiAgICAgIHVwZGF0ZUZuLmNhbGwoaW5zdGFuY2UsIHByZXZTdGF0ZSwgcHJvcHMpO1xuICAgIH1cblxuICAgIHJldHVybiB1cGRhdGVGbi5jYWxsKGluc3RhbmNlLCBwcmV2U3RhdGUsIHByb3BzKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcGFydGlhbFN0YXRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NVcGRhdGVRdWV1ZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcXVldWUsIGluc3RhbmNlLCBwcm9wcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC51cGRhdGVRdWV1ZSA9PT0gcXVldWUpIHtcbiAgICAvLyBXZSBuZWVkIHRvIGNyZWF0ZSBhIHdvcmstaW4tcHJvZ3Jlc3MgcXVldWUsIGJ5IGNsb25pbmcgdGhlIGN1cnJlbnQgcXVldWUuXG4gICAgdmFyIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgIHF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSB7XG4gICAgICBiYXNlU3RhdGU6IGN1cnJlbnRRdWV1ZS5iYXNlU3RhdGUsXG4gICAgICBleHBpcmF0aW9uVGltZTogY3VycmVudFF1ZXVlLmV4cGlyYXRpb25UaW1lLFxuICAgICAgZmlyc3Q6IGN1cnJlbnRRdWV1ZS5maXJzdCxcbiAgICAgIGxhc3Q6IGN1cnJlbnRRdWV1ZS5sYXN0LFxuICAgICAgaXNJbml0aWFsaXplZDogY3VycmVudFF1ZXVlLmlzSW5pdGlhbGl6ZWQsXG4gICAgICAvLyBUaGVzZSBmaWVsZHMgYXJlIG5vIGxvbmdlciB2YWxpZCBiZWNhdXNlIHRoZXkgd2VyZSBhbHJlYWR5IGNvbW1pdHRlZC5cbiAgICAgIC8vIFJlc2V0IHRoZW0uXG4gICAgICBjYWxsYmFja0xpc3Q6IG51bGwsXG4gICAgICBoYXNGb3JjZVVwZGF0ZTogZmFsc2VcbiAgICB9O1xuICB9XG5cbiAge1xuICAgIC8vIFNldCB0aGlzIGZsYWcgc28gd2UgY2FuIHdhcm4gaWYgc2V0U3RhdGUgaXMgY2FsbGVkIGluc2lkZSB0aGUgdXBkYXRlXG4gICAgLy8gZnVuY3Rpb24gb2YgYW5vdGhlciBzZXRTdGF0ZS5cbiAgICBxdWV1ZS5pc1Byb2Nlc3NpbmcgPSB0cnVlO1xuICB9XG5cbiAgLy8gUmVzZXQgdGhlIHJlbWFpbmluZyBleHBpcmF0aW9uIHRpbWUuIElmIHdlIHNraXAgb3ZlciBhbnkgdXBkYXRlcywgd2UnbGxcbiAgLy8gaW5jcmVhc2UgdGhpcyBhY2NvcmRpbmdseS5cbiAgcXVldWUuZXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG5cbiAgLy8gVE9ETzogV2UgZG9uJ3Qga25vdyB3aGF0IHRoZSBiYXNlIHN0YXRlIHdpbGwgYmUgdW50aWwgd2UgYmVnaW4gd29yay5cbiAgLy8gSXQgZGVwZW5kcyBvbiB3aGljaCBmaWJlciBpcyB0aGUgbmV4dCBjdXJyZW50LiBJbml0aWFsaXplIHdpdGggYW4gZW1wdHlcbiAgLy8gYmFzZSBzdGF0ZSwgdGhlbiBzZXQgdG8gdGhlIG1lbW9pemVkU3RhdGUgd2hlbiByZW5kZXJpbmcuIE5vdCBzdXBlclxuICAvLyBoYXBweSB3aXRoIHRoaXMgYXBwcm9hY2guXG4gIHZhciBzdGF0ZSA9IHZvaWQgMDtcbiAgaWYgKHF1ZXVlLmlzSW5pdGlhbGl6ZWQpIHtcbiAgICBzdGF0ZSA9IHF1ZXVlLmJhc2VTdGF0ZTtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZSA9IHF1ZXVlLmJhc2VTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgcXVldWUuaXNJbml0aWFsaXplZCA9IHRydWU7XG4gIH1cbiAgdmFyIGRvbnRNdXRhdGVQcmV2U3RhdGUgPSB0cnVlO1xuICB2YXIgdXBkYXRlID0gcXVldWUuZmlyc3Q7XG4gIHZhciBkaWRTa2lwID0gZmFsc2U7XG4gIHdoaWxlICh1cGRhdGUgIT09IG51bGwpIHtcbiAgICB2YXIgdXBkYXRlRXhwaXJhdGlvblRpbWUgPSB1cGRhdGUuZXhwaXJhdGlvblRpbWU7XG4gICAgaWYgKHVwZGF0ZUV4cGlyYXRpb25UaW1lID4gcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIC8vIFRoaXMgdXBkYXRlIGRvZXMgbm90IGhhdmUgc3VmZmljaWVudCBwcmlvcml0eS4gU2tpcCBpdC5cbiAgICAgIHZhciByZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IHF1ZXVlLmV4cGlyYXRpb25UaW1lO1xuICAgICAgaWYgKHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgcmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPiB1cGRhdGVFeHBpcmF0aW9uVGltZSkge1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHJlbWFpbmluZyBleHBpcmF0aW9uIHRpbWUuXG4gICAgICAgIHF1ZXVlLmV4cGlyYXRpb25UaW1lID0gdXBkYXRlRXhwaXJhdGlvblRpbWU7XG4gICAgICB9XG4gICAgICBpZiAoIWRpZFNraXApIHtcbiAgICAgICAgZGlkU2tpcCA9IHRydWU7XG4gICAgICAgIHF1ZXVlLmJhc2VTdGF0ZSA9IHN0YXRlO1xuICAgICAgfVxuICAgICAgLy8gQ29udGludWUgdG8gdGhlIG5leHQgdXBkYXRlLlxuICAgICAgdXBkYXRlID0gdXBkYXRlLm5leHQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIHVwZGF0ZSBkb2VzIGhhdmUgc3VmZmljaWVudCBwcmlvcml0eS5cblxuICAgIC8vIElmIG5vIHByZXZpb3VzIHVwZGF0ZXMgd2VyZSBza2lwcGVkLCBkcm9wIHRoaXMgdXBkYXRlIGZyb20gdGhlIHF1ZXVlIGJ5XG4gICAgLy8gYWR2YW5jaW5nIHRoZSBoZWFkIG9mIHRoZSBsaXN0LlxuICAgIGlmICghZGlkU2tpcCkge1xuICAgICAgcXVldWUuZmlyc3QgPSB1cGRhdGUubmV4dDtcbiAgICAgIGlmIChxdWV1ZS5maXJzdCA9PT0gbnVsbCkge1xuICAgICAgICBxdWV1ZS5sYXN0ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBQcm9jZXNzIHRoZSB1cGRhdGVcbiAgICB2YXIgX3BhcnRpYWxTdGF0ZSA9IHZvaWQgMDtcbiAgICBpZiAodXBkYXRlLmlzUmVwbGFjZSkge1xuICAgICAgc3RhdGUgPSBnZXRTdGF0ZUZyb21VcGRhdGUodXBkYXRlLCBpbnN0YW5jZSwgc3RhdGUsIHByb3BzKTtcbiAgICAgIGRvbnRNdXRhdGVQcmV2U3RhdGUgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBfcGFydGlhbFN0YXRlID0gZ2V0U3RhdGVGcm9tVXBkYXRlKHVwZGF0ZSwgaW5zdGFuY2UsIHN0YXRlLCBwcm9wcyk7XG4gICAgICBpZiAoX3BhcnRpYWxTdGF0ZSkge1xuICAgICAgICBpZiAoZG9udE11dGF0ZVByZXZTdGF0ZSkge1xuICAgICAgICAgIC8vICRGbG93Rml4TWU6IElkayBob3cgdG8gdHlwZSB0aGlzIHByb3Blcmx5LlxuICAgICAgICAgIHN0YXRlID0gX2Fzc2lnbih7fSwgc3RhdGUsIF9wYXJ0aWFsU3RhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlID0gX2Fzc2lnbihzdGF0ZSwgX3BhcnRpYWxTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZG9udE11dGF0ZVByZXZTdGF0ZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodXBkYXRlLmlzRm9yY2VkKSB7XG4gICAgICBxdWV1ZS5oYXNGb3JjZVVwZGF0ZSA9IHRydWU7XG4gICAgfVxuICAgIGlmICh1cGRhdGUuY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgIC8vIEFwcGVuZCB0byBsaXN0IG9mIGNhbGxiYWNrcy5cbiAgICAgIHZhciBfY2FsbGJhY2tMaXN0ID0gcXVldWUuY2FsbGJhY2tMaXN0O1xuICAgICAgaWYgKF9jYWxsYmFja0xpc3QgPT09IG51bGwpIHtcbiAgICAgICAgX2NhbGxiYWNrTGlzdCA9IHF1ZXVlLmNhbGxiYWNrTGlzdCA9IFtdO1xuICAgICAgfVxuICAgICAgX2NhbGxiYWNrTGlzdC5wdXNoKHVwZGF0ZSk7XG4gICAgfVxuICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuICB9XG5cbiAgaWYgKHF1ZXVlLmNhbGxiYWNrTGlzdCAhPT0gbnVsbCkge1xuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBDYWxsYmFjaztcbiAgfSBlbHNlIGlmIChxdWV1ZS5maXJzdCA9PT0gbnVsbCAmJiAhcXVldWUuaGFzRm9yY2VVcGRhdGUpIHtcbiAgICAvLyBUaGUgcXVldWUgaXMgZW1wdHkuIFdlIGNhbiByZXNldCBpdC5cbiAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IG51bGw7XG4gIH1cblxuICBpZiAoIWRpZFNraXApIHtcbiAgICBkaWRTa2lwID0gdHJ1ZTtcbiAgICBxdWV1ZS5iYXNlU3RhdGUgPSBzdGF0ZTtcbiAgfVxuXG4gIHtcbiAgICAvLyBObyBsb25nZXIgcHJvY2Vzc2luZy5cbiAgICBxdWV1ZS5pc1Byb2Nlc3NpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZTtcbn1cblxuZnVuY3Rpb24gY29tbWl0Q2FsbGJhY2tzKHF1ZXVlLCBjb250ZXh0KSB7XG4gIHZhciBjYWxsYmFja0xpc3QgPSBxdWV1ZS5jYWxsYmFja0xpc3Q7XG4gIGlmIChjYWxsYmFja0xpc3QgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gU2V0IHRoZSBsaXN0IHRvIG51bGwgdG8gbWFrZSBzdXJlIHRoZXkgZG9uJ3QgZ2V0IGNhbGxlZCBtb3JlIHRoYW4gb25jZS5cbiAgcXVldWUuY2FsbGJhY2tMaXN0ID0gbnVsbDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja0xpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdXBkYXRlID0gY2FsbGJhY2tMaXN0W2ldO1xuICAgIHZhciBfY2FsbGJhY2sgPSB1cGRhdGUuY2FsbGJhY2s7XG4gICAgLy8gVGhpcyB1cGRhdGUgbWlnaHQgYmUgcHJvY2Vzc2VkIGFnYWluLiBDbGVhciB0aGUgY2FsbGJhY2sgc28gaXQncyBvbmx5XG4gICAgLy8gY2FsbGVkIG9uY2UuXG4gICAgdXBkYXRlLmNhbGxiYWNrID0gbnVsbDtcbiAgICAhKHR5cGVvZiBfY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpID8gaW52YXJpYW50KGZhbHNlLCAnSW52YWxpZCBhcmd1bWVudCBwYXNzZWQgYXMgY2FsbGJhY2suIEV4cGVjdGVkIGEgZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzJywgX2NhbGxiYWNrKSA6IHZvaWQgMDtcbiAgICBfY2FsbGJhY2suY2FsbChjb250ZXh0KTtcbiAgfVxufVxuXG52YXIgZmFrZUludGVybmFsSW5zdGFuY2UgPSB7fTtcbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxue1xuICB2YXIgZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50ID0ge307XG5cbiAgdmFyIHdhcm5PbkludmFsaWRDYWxsYmFjayA9IGZ1bmN0aW9uIChjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5pbmcoY2FsbGJhY2sgPT09IG51bGwgfHwgdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nLCAnJXMoLi4uKTogRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhICcgKyAnZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsIGNhbGxlck5hbWUsIGNhbGxiYWNrKTtcbiAgfTtcblxuICAvLyBUaGlzIGlzIHNvIGdyb3NzIGJ1dCBpdCdzIGF0IGxlYXN0IG5vbi1jcml0aWNhbCBhbmQgY2FuIGJlIHJlbW92ZWQgaWZcbiAgLy8gaXQgY2F1c2VzIHByb2JsZW1zLiBUaGlzIGlzIG1lYW50IHRvIGdpdmUgYSBuaWNlciBlcnJvciBtZXNzYWdlIGZvclxuICAvLyBSZWFjdERPTTE1LnVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHJlYWN0RE9NMTZDb21wb25lbnQsXG4gIC8vIC4uLikpIHdoaWNoIG90aGVyd2lzZSB0aHJvd3MgYSBcIl9wcm9jZXNzQ2hpbGRDb250ZXh0IGlzIG5vdCBhIGZ1bmN0aW9uXCJcbiAgLy8gZXhjZXB0aW9uLlxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZmFrZUludGVybmFsSW5zdGFuY2UsICdfcHJvY2Vzc0NoaWxkQ29udGV4dCcsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnX3Byb2Nlc3NDaGlsZENvbnRleHQgaXMgbm90IGF2YWlsYWJsZSBpbiBSZWFjdCAxNisuIFRoaXMgbGlrZWx5IG1lYW5zIHlvdSBoYXZlIG11bHRpcGxlIGNvcGllcyBvZiBSZWFjdCBhbmQgYXJlIGF0dGVtcHRpbmcgdG8gbmVzdCBhIFJlYWN0IDE1IHRyZWUgaW5zaWRlIGEgUmVhY3QgMTYgdHJlZSB1c2luZyB1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciwgd2hpY2ggaXNuXFwndCBzdXBwb3J0ZWQuIFRyeSB0byBtYWtlIHN1cmUgeW91IGhhdmUgb25seSBvbmUgY29weSBvZiBSZWFjdCAoYW5kIGlkZWFsbHksIHN3aXRjaCB0byBSZWFjdERPTS5jcmVhdGVQb3J0YWwpLicpO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5mcmVlemUoZmFrZUludGVybmFsSW5zdGFuY2UpO1xufVxuXG52YXIgUmVhY3RGaWJlckNsYXNzQ29tcG9uZW50ID0gZnVuY3Rpb24gKHNjaGVkdWxlV29yaywgY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlciwgbWVtb2l6ZVByb3BzLCBtZW1vaXplU3RhdGUpIHtcbiAgLy8gQ2xhc3MgY29tcG9uZW50IHN0YXRlIHVwZGF0ZXJcbiAgdmFyIHVwZGF0ZXIgPSB7XG4gICAgaXNNb3VudGVkOiBpc01vdW50ZWQsXG4gICAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBmaWJlciA9IGdldChpbnN0YW5jZSk7XG4gICAgICBjYWxsYmFjayA9IGNhbGxiYWNrID09PSB1bmRlZmluZWQgPyBudWxsIDogY2FsbGJhY2s7XG4gICAgICB7XG4gICAgICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaywgJ3NldFN0YXRlJyk7XG4gICAgICB9XG4gICAgICB2YXIgZXhwaXJhdGlvblRpbWUgPSBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyKGZpYmVyKTtcbiAgICAgIHZhciB1cGRhdGUgPSB7XG4gICAgICAgIGV4cGlyYXRpb25UaW1lOiBleHBpcmF0aW9uVGltZSxcbiAgICAgICAgcGFydGlhbFN0YXRlOiBwYXJ0aWFsU3RhdGUsXG4gICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgaXNSZXBsYWNlOiBmYWxzZSxcbiAgICAgICAgaXNGb3JjZWQ6IGZhbHNlLFxuICAgICAgICBuZXh0Q2FsbGJhY2s6IG51bGwsXG4gICAgICAgIG5leHQ6IG51bGxcbiAgICAgIH07XG4gICAgICBpbnNlcnRVcGRhdGVJbnRvRmliZXIoZmliZXIsIHVwZGF0ZSk7XG4gICAgICBzY2hlZHVsZVdvcmsoZmliZXIsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9LFxuICAgIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChpbnN0YW5jZSwgc3RhdGUsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgZmliZXIgPSBnZXQoaW5zdGFuY2UpO1xuICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNhbGxiYWNrO1xuICAgICAge1xuICAgICAgICB3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2ssICdyZXBsYWNlU3RhdGUnKTtcbiAgICAgIH1cbiAgICAgIHZhciBleHBpcmF0aW9uVGltZSA9IGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIoZmliZXIpO1xuICAgICAgdmFyIHVwZGF0ZSA9IHtcbiAgICAgICAgZXhwaXJhdGlvblRpbWU6IGV4cGlyYXRpb25UaW1lLFxuICAgICAgICBwYXJ0aWFsU3RhdGU6IHN0YXRlLFxuICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICAgIGlzUmVwbGFjZTogdHJ1ZSxcbiAgICAgICAgaXNGb3JjZWQ6IGZhbHNlLFxuICAgICAgICBuZXh0Q2FsbGJhY2s6IG51bGwsXG4gICAgICAgIG5leHQ6IG51bGxcbiAgICAgIH07XG4gICAgICBpbnNlcnRVcGRhdGVJbnRvRmliZXIoZmliZXIsIHVwZGF0ZSk7XG4gICAgICBzY2hlZHVsZVdvcmsoZmliZXIsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9LFxuICAgIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKGluc3RhbmNlLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGZpYmVyID0gZ2V0KGluc3RhbmNlKTtcbiAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjYWxsYmFjaztcbiAgICAgIHtcbiAgICAgICAgd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrLCAnZm9yY2VVcGRhdGUnKTtcbiAgICAgIH1cbiAgICAgIHZhciBleHBpcmF0aW9uVGltZSA9IGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIoZmliZXIpO1xuICAgICAgdmFyIHVwZGF0ZSA9IHtcbiAgICAgICAgZXhwaXJhdGlvblRpbWU6IGV4cGlyYXRpb25UaW1lLFxuICAgICAgICBwYXJ0aWFsU3RhdGU6IG51bGwsXG4gICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgaXNSZXBsYWNlOiBmYWxzZSxcbiAgICAgICAgaXNGb3JjZWQ6IHRydWUsXG4gICAgICAgIG5leHRDYWxsYmFjazogbnVsbCxcbiAgICAgICAgbmV4dDogbnVsbFxuICAgICAgfTtcbiAgICAgIGluc2VydFVwZGF0ZUludG9GaWJlcihmaWJlciwgdXBkYXRlKTtcbiAgICAgIHNjaGVkdWxlV29yayhmaWJlciwgZXhwaXJhdGlvblRpbWUpO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgb2xkUHJvcHMsIG5ld1Byb3BzLCBvbGRTdGF0ZSwgbmV3U3RhdGUsIG5ld0NvbnRleHQpIHtcbiAgICBpZiAob2xkUHJvcHMgPT09IG51bGwgfHwgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgIT09IG51bGwgJiYgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUuaGFzRm9yY2VVcGRhdGUpIHtcbiAgICAgIC8vIElmIHRoZSB3b3JrSW5Qcm9ncmVzcyBhbHJlYWR5IGhhcyBhbiBVcGRhdGUgZWZmZWN0LCByZXR1cm4gdHJ1ZVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgc3RhcnRQaGFzZVRpbWVyKHdvcmtJblByb2dyZXNzLCAnc2hvdWxkQ29tcG9uZW50VXBkYXRlJyk7XG4gICAgICB2YXIgc2hvdWxkVXBkYXRlID0gaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5ld1Byb3BzLCBuZXdTdGF0ZSwgbmV3Q29udGV4dCk7XG4gICAgICBzdG9wUGhhc2VUaW1lcigpO1xuXG4gICAgICAvLyBTaW11bGF0ZSBhbiBhc3luYyBiYWlsb3V0L2ludGVycnVwdGlvbiBieSBpbnZva2luZyBsaWZlY3ljbGUgdHdpY2UuXG4gICAgICBpZiAoZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzKSB7XG4gICAgICAgIGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZShuZXdQcm9wcywgbmV3U3RhdGUsIG5ld0NvbnRleHQpO1xuICAgICAgfVxuXG4gICAgICB7XG4gICAgICAgIHdhcm5pbmcoc2hvdWxkVXBkYXRlICE9PSB1bmRlZmluZWQsICclcy5zaG91bGRDb21wb25lbnRVcGRhdGUoKTogUmV0dXJuZWQgdW5kZWZpbmVkIGluc3RlYWQgb2YgYSAnICsgJ2Jvb2xlYW4gdmFsdWUuIE1ha2Ugc3VyZSB0byByZXR1cm4gdHJ1ZSBvciBmYWxzZS4nLCBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKSB8fCAnVW5rbm93bicpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2hvdWxkVXBkYXRlO1xuICAgIH1cblxuICAgIGlmICh0eXBlLnByb3RvdHlwZSAmJiB0eXBlLnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCkge1xuICAgICAgcmV0dXJuICFzaGFsbG93RXF1YWwob2xkUHJvcHMsIG5ld1Byb3BzKSB8fCAhc2hhbGxvd0VxdWFsKG9sZFN0YXRlLCBuZXdTdGF0ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0NsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgdmFyIHR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB2YXIgcmVuZGVyUHJlc2VudCA9IGluc3RhbmNlLnJlbmRlcjtcblxuICAgICAgaWYgKCFyZW5kZXJQcmVzZW50KSB7XG4gICAgICAgIGlmICh0eXBlLnByb3RvdHlwZSAmJiB0eXBlb2YgdHlwZS5wcm90b3R5cGUucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgd2FybmluZyhmYWxzZSwgJyVzKC4uLik6IE5vIGByZW5kZXJgIG1ldGhvZCBmb3VuZCBvbiB0aGUgcmV0dXJuZWQgY29tcG9uZW50ICcgKyAnaW5zdGFuY2U6IGRpZCB5b3UgYWNjaWRlbnRhbGx5IHJldHVybiBhbiBvYmplY3QgZnJvbSB0aGUgY29uc3RydWN0b3I/JywgbmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FybmluZyhmYWxzZSwgJyVzKC4uLik6IE5vIGByZW5kZXJgIG1ldGhvZCBmb3VuZCBvbiB0aGUgcmV0dXJuZWQgY29tcG9uZW50ICcgKyAnaW5zdGFuY2U6IHlvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gZGVmaW5lIGByZW5kZXJgLicsIG5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBub0dldEluaXRpYWxTdGF0ZU9uRVM2ID0gIWluc3RhbmNlLmdldEluaXRpYWxTdGF0ZSB8fCBpbnN0YW5jZS5nZXRJbml0aWFsU3RhdGUuaXNSZWFjdENsYXNzQXBwcm92ZWQgfHwgaW5zdGFuY2Uuc3RhdGU7XG4gICAgICB3YXJuaW5nKG5vR2V0SW5pdGlhbFN0YXRlT25FUzYsICdnZXRJbml0aWFsU3RhdGUgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gJyArICdUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBjbGFzc2VzIGNyZWF0ZWQgdXNpbmcgUmVhY3QuY3JlYXRlQ2xhc3MuICcgKyAnRGlkIHlvdSBtZWFuIHRvIGRlZmluZSBhIHN0YXRlIHByb3BlcnR5IGluc3RlYWQ/JywgbmFtZSk7XG4gICAgICB2YXIgbm9HZXREZWZhdWx0UHJvcHNPbkVTNiA9ICFpbnN0YW5jZS5nZXREZWZhdWx0UHJvcHMgfHwgaW5zdGFuY2UuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkO1xuICAgICAgd2FybmluZyhub0dldERlZmF1bHRQcm9wc09uRVM2LCAnZ2V0RGVmYXVsdFByb3BzIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuICcgKyAnVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiAnICsgJ1VzZSBhIHN0YXRpYyBwcm9wZXJ0eSB0byBkZWZpbmUgZGVmYXVsdFByb3BzIGluc3RlYWQuJywgbmFtZSk7XG4gICAgICB2YXIgbm9JbnN0YW5jZVByb3BUeXBlcyA9ICFpbnN0YW5jZS5wcm9wVHlwZXM7XG4gICAgICB3YXJuaW5nKG5vSW5zdGFuY2VQcm9wVHlwZXMsICdwcm9wVHlwZXMgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhIHN0YXRpYyAnICsgJ3Byb3BlcnR5IHRvIGRlZmluZSBwcm9wVHlwZXMgaW5zdGVhZC4nLCBuYW1lKTtcbiAgICAgIHZhciBub0luc3RhbmNlQ29udGV4dFR5cGVzID0gIWluc3RhbmNlLmNvbnRleHRUeXBlcztcbiAgICAgIHdhcm5pbmcobm9JbnN0YW5jZUNvbnRleHRUeXBlcywgJ2NvbnRleHRUeXBlcyB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgc3RhdGljICcgKyAncHJvcGVydHkgdG8gZGVmaW5lIGNvbnRleHRUeXBlcyBpbnN0ZWFkLicsIG5hbWUpO1xuICAgICAgdmFyIG5vQ29tcG9uZW50U2hvdWxkVXBkYXRlID0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFNob3VsZFVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJztcbiAgICAgIHdhcm5pbmcobm9Db21wb25lbnRTaG91bGRVcGRhdGUsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50U2hvdWxkVXBkYXRlKCkuIERpZCB5b3UgbWVhbiBzaG91bGRDb21wb25lbnRVcGRhdGUoKT8gJyArICdUaGUgbmFtZSBpcyBwaHJhc2VkIGFzIGEgcXVlc3Rpb24gYmVjYXVzZSB0aGUgZnVuY3Rpb24gaXMgJyArICdleHBlY3RlZCB0byByZXR1cm4gYSB2YWx1ZS4nLCBuYW1lKTtcbiAgICAgIGlmICh0eXBlLnByb3RvdHlwZSAmJiB0eXBlLnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCAmJiB0eXBlb2YgaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCBzaG91bGRDb21wb25lbnRVcGRhdGUoKS4gJyArICdzaG91bGRDb21wb25lbnRVcGRhdGUgc2hvdWxkIG5vdCBiZSB1c2VkIHdoZW4gZXh0ZW5kaW5nIFJlYWN0LlB1cmVDb21wb25lbnQuICcgKyAnUGxlYXNlIGV4dGVuZCBSZWFjdC5Db21wb25lbnQgaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIGlzIHVzZWQuJywgZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcykgfHwgJ0EgcHVyZSBjb21wb25lbnQnKTtcbiAgICAgIH1cbiAgICAgIHZhciBub0NvbXBvbmVudERpZFVubW91bnQgPSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVW5tb3VudCAhPT0gJ2Z1bmN0aW9uJztcbiAgICAgIHdhcm5pbmcobm9Db21wb25lbnREaWRVbm1vdW50LCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudERpZFVubW91bnQoKS4gQnV0IHRoZXJlIGlzIG5vIHN1Y2ggbGlmZWN5Y2xlIG1ldGhvZC4gJyArICdEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFVubW91bnQoKT8nLCBuYW1lKTtcbiAgICAgIHZhciBub0NvbXBvbmVudERpZFJlY2VpdmVQcm9wcyA9IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRSZWNlaXZlUHJvcHMgIT09ICdmdW5jdGlvbic7XG4gICAgICB3YXJuaW5nKG5vQ29tcG9uZW50RGlkUmVjZWl2ZVByb3BzLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudERpZFJlY2VpdmVQcm9wcygpLiBCdXQgdGhlcmUgaXMgbm8gc3VjaCBsaWZlY3ljbGUgbWV0aG9kLiAnICsgJ0lmIHlvdSBtZWFudCB0byB1cGRhdGUgdGhlIHN0YXRlIGluIHJlc3BvbnNlIHRvIGNoYW5naW5nIHByb3BzLCAnICsgJ3VzZSBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCkuIElmIHlvdSBtZWFudCB0byBmZXRjaCBkYXRhIG9yICcgKyAncnVuIHNpZGUtZWZmZWN0cyBvciBtdXRhdGlvbnMgYWZ0ZXIgUmVhY3QgaGFzIHVwZGF0ZWQgdGhlIFVJLCB1c2UgY29tcG9uZW50RGlkVXBkYXRlKCkuJywgbmFtZSk7XG4gICAgICB2YXIgbm9Db21wb25lbnRXaWxsUmVjaWV2ZVByb3BzID0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgIT09ICdmdW5jdGlvbic7XG4gICAgICB3YXJuaW5nKG5vQ29tcG9uZW50V2lsbFJlY2lldmVQcm9wcywgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/JywgbmFtZSk7XG4gICAgICB2YXIgaGFzTXV0YXRlZFByb3BzID0gaW5zdGFuY2UucHJvcHMgIT09IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICAgIHdhcm5pbmcoaW5zdGFuY2UucHJvcHMgPT09IHVuZGVmaW5lZCB8fCAhaGFzTXV0YXRlZFByb3BzLCAnJXMoLi4uKTogV2hlbiBjYWxsaW5nIHN1cGVyKCkgaW4gYCVzYCwgbWFrZSBzdXJlIHRvIHBhc3MgJyArIFwidXAgdGhlIHNhbWUgcHJvcHMgdGhhdCB5b3VyIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yIHdhcyBwYXNzZWQuXCIsIG5hbWUsIG5hbWUpO1xuICAgICAgdmFyIG5vSW5zdGFuY2VEZWZhdWx0UHJvcHMgPSAhaW5zdGFuY2UuZGVmYXVsdFByb3BzO1xuICAgICAgd2FybmluZyhub0luc3RhbmNlRGVmYXVsdFByb3BzLCAnU2V0dGluZyBkZWZhdWx0UHJvcHMgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMgaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSBpZ25vcmVkLicgKyAnIEluc3RlYWQsIGRlZmluZSBkZWZhdWx0UHJvcHMgYXMgYSBzdGF0aWMgcHJvcGVydHkgb24gJXMuJywgbmFtZSwgbmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIHN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG4gICAgaWYgKHN0YXRlICYmICh0eXBlb2Ygc3RhdGUgIT09ICdvYmplY3QnIHx8IGlzQXJyYXkoc3RhdGUpKSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJyVzLnN0YXRlOiBtdXN0IGJlIHNldCB0byBhbiBvYmplY3Qgb3IgbnVsbCcsIGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MpKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdhcm5pbmcodHlwZW9mIHdvcmtJblByb2dyZXNzLnR5cGUuY2hpbGRDb250ZXh0VHlwZXMgPT09ICdvYmplY3QnLCAnJXMuZ2V0Q2hpbGRDb250ZXh0KCk6IGNoaWxkQ29udGV4dFR5cGVzIG11c3QgYmUgZGVmaW5lZCBpbiBvcmRlciB0byAnICsgJ3VzZSBnZXRDaGlsZENvbnRleHQoKS4nLCBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRJbnB1dFBvaW50ZXJzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSkge1xuICAgIGluc3RhbmNlLnByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICBpbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIH1cblxuICBmdW5jdGlvbiBhZG9wdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKSB7XG4gICAgaW5zdGFuY2UudXBkYXRlciA9IHVwZGF0ZXI7XG4gICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gaW5zdGFuY2U7XG4gICAgLy8gVGhlIGluc3RhbmNlIG5lZWRzIGFjY2VzcyB0byB0aGUgZmliZXIgc28gdGhhdCBpdCBjYW4gc2NoZWR1bGUgdXBkYXRlc1xuICAgIHNldChpbnN0YW5jZSwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIHtcbiAgICAgIGluc3RhbmNlLl9yZWFjdEludGVybmFsSW5zdGFuY2UgPSBmYWtlSW50ZXJuYWxJbnN0YW5jZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBwcm9wcykge1xuICAgIHZhciBjdG9yID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICB2YXIgdW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICB2YXIgbmVlZHNDb250ZXh0ID0gaXNDb250ZXh0Q29uc3VtZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgIHZhciBjb250ZXh0ID0gbmVlZHNDb250ZXh0ID8gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KSA6IGVtcHR5T2JqZWN0O1xuICAgIHZhciBpbnN0YW5jZSA9IG5ldyBjdG9yKHByb3BzLCBjb250ZXh0KTtcbiAgICBhZG9wdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcblxuICAgIC8vIENhY2hlIHVubWFza2VkIGNvbnRleHQgc28gd2UgY2FuIGF2b2lkIHJlY3JlYXRpbmcgbWFza2VkIGNvbnRleHQgdW5sZXNzIG5lY2Vzc2FyeS5cbiAgICAvLyBSZWFjdEZpYmVyQ29udGV4dCB1c3VhbGx5IHVwZGF0ZXMgdGhpcyBjYWNoZSBidXQgY2FuJ3QgZm9yIG5ld2x5LWNyZWF0ZWQgaW5zdGFuY2VzLlxuICAgIGlmIChuZWVkc0NvbnRleHQpIHtcbiAgICAgIGNhY2hlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0LCBjb250ZXh0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH1cblxuICBmdW5jdGlvbiBjYWxsQ29tcG9uZW50V2lsbE1vdW50KHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSkge1xuICAgIHN0YXJ0UGhhc2VUaW1lcih3b3JrSW5Qcm9ncmVzcywgJ2NvbXBvbmVudFdpbGxNb3VudCcpO1xuICAgIHZhciBvbGRTdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgIHN0b3BQaGFzZVRpbWVyKCk7XG5cbiAgICAvLyBTaW11bGF0ZSBhbiBhc3luYyBiYWlsb3V0L2ludGVycnVwdGlvbiBieSBpbnZva2luZyBsaWZlY3ljbGUgdHdpY2UuXG4gICAgaWYgKGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0cykge1xuICAgICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50KCk7XG4gICAgfVxuXG4gICAgaWYgKG9sZFN0YXRlICE9PSBpbnN0YW5jZS5zdGF0ZSkge1xuICAgICAge1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnJXMuY29tcG9uZW50V2lsbE1vdW50KCk6IEFzc2lnbmluZyBkaXJlY3RseSB0byB0aGlzLnN0YXRlIGlzICcgKyBcImRlcHJlY2F0ZWQgKGV4Y2VwdCBpbnNpZGUgYSBjb21wb25lbnQncyBcIiArICdjb25zdHJ1Y3RvcikuIFVzZSBzZXRTdGF0ZSBpbnN0ZWFkLicsIGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MpKTtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZXIuZW5xdWV1ZVJlcGxhY2VTdGF0ZShpbnN0YW5jZSwgaW5zdGFuY2Uuc3RhdGUsIG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSwgbmV3UHJvcHMsIG5ld0NvbnRleHQpIHtcbiAgICBzdGFydFBoYXNlVGltZXIod29ya0luUHJvZ3Jlc3MsICdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJyk7XG4gICAgdmFyIG9sZFN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG4gICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXdQcm9wcywgbmV3Q29udGV4dCk7XG4gICAgc3RvcFBoYXNlVGltZXIoKTtcblxuICAgIC8vIFNpbXVsYXRlIGFuIGFzeW5jIGJhaWxvdXQvaW50ZXJydXB0aW9uIGJ5IGludm9raW5nIGxpZmVjeWNsZSB0d2ljZS5cbiAgICBpZiAoZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzKSB7XG4gICAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5ld1Byb3BzLCBuZXdDb250ZXh0KTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2Uuc3RhdGUgIT09IG9sZFN0YXRlKSB7XG4gICAgICB7XG4gICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcykgfHwgJ0NvbXBvbmVudCc7XG4gICAgICAgIGlmICghZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50W2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgICAgd2FybmluZyhmYWxzZSwgJyVzLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKTogQXNzaWduaW5nIGRpcmVjdGx5IHRvICcgKyBcInRoaXMuc3RhdGUgaXMgZGVwcmVjYXRlZCAoZXhjZXB0IGluc2lkZSBhIGNvbXBvbmVudCdzIFwiICsgJ2NvbnN0cnVjdG9yKS4gVXNlIHNldFN0YXRlIGluc3RlYWQuJywgY29tcG9uZW50TmFtZSk7XG4gICAgICAgICAgZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50W2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKGluc3RhbmNlLCBpbnN0YW5jZS5zdGF0ZSwgbnVsbCk7XG4gICAgfVxuICB9XG5cbiAgLy8gSW52b2tlcyB0aGUgbW91bnQgbGlmZS1jeWNsZXMgb24gYSBwcmV2aW91c2x5IG5ldmVyIHJlbmRlcmVkIGluc3RhbmNlLlxuICBmdW5jdGlvbiBtb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgdmFyIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG5cbiAgICB7XG4gICAgICBjaGVja0NsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICB2YXIgc3RhdGUgPSBpbnN0YW5jZS5zdGF0ZSB8fCBudWxsO1xuXG4gICAgdmFyIHByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgICFwcm9wcyA/IGludmFyaWFudChmYWxzZSwgJ1RoZXJlIG11c3QgYmUgcGVuZGluZyBwcm9wcyBmb3IgYW4gaW5pdGlhbCBtb3VudC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcblxuICAgIHZhciB1bm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgaW5zdGFuY2UucHJvcHMgPSBwcm9wcztcbiAgICBpbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBzdGF0ZTtcbiAgICBpbnN0YW5jZS5yZWZzID0gZW1wdHlPYmplY3Q7XG4gICAgaW5zdGFuY2UuY29udGV4dCA9IGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCk7XG5cbiAgICBpZiAoZW5hYmxlQXN5bmNTdWJ0cmVlQVBJICYmIHdvcmtJblByb2dyZXNzLnR5cGUgIT0gbnVsbCAmJiB3b3JrSW5Qcm9ncmVzcy50eXBlLnByb3RvdHlwZSAhPSBudWxsICYmIHdvcmtJblByb2dyZXNzLnR5cGUucHJvdG90eXBlLnVuc3RhYmxlX2lzQXN5bmNSZWFjdENvbXBvbmVudCA9PT0gdHJ1ZSkge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuaW50ZXJuYWxDb250ZXh0VGFnIHw9IEFzeW5jVXBkYXRlcztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbENvbXBvbmVudFdpbGxNb3VudCh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpO1xuICAgICAgLy8gSWYgd2UgaGFkIGFkZGl0aW9uYWwgc3RhdGUgdXBkYXRlcyBkdXJpbmcgdGhpcyBsaWZlLWN5Y2xlLCBsZXQnc1xuICAgICAgLy8gcHJvY2VzcyB0aGVtIG5vdy5cbiAgICAgIHZhciB1cGRhdGVRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICAgICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgIGluc3RhbmNlLnN0YXRlID0gcHJvY2Vzc1VwZGF0ZVF1ZXVlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB1cGRhdGVRdWV1ZSwgaW5zdGFuY2UsIHByb3BzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2FsbGVkIG9uIGEgcHJlZXhpc3RpbmcgY2xhc3MgaW5zdGFuY2UuIFJldHVybnMgZmFsc2UgaWYgYSByZXN1bWVkIHJlbmRlclxuICAvLyBjb3VsZCBiZSByZXVzZWQuXG4gIC8vIGZ1bmN0aW9uIHJlc3VtZU1vdW50Q2xhc3NJbnN0YW5jZShcbiAgLy8gICB3b3JrSW5Qcm9ncmVzczogRmliZXIsXG4gIC8vICAgcHJpb3JpdHlMZXZlbDogUHJpb3JpdHlMZXZlbCxcbiAgLy8gKTogYm9vbGVhbiB7XG4gIC8vICAgY29uc3QgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIC8vICAgcmVzZXRJbnB1dFBvaW50ZXJzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7XG5cbiAgLy8gICBsZXQgbmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAvLyAgIGxldCBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgLy8gICBpZiAoIW5ld1Byb3BzKSB7XG4gIC8vICAgICAvLyBJZiB0aGVyZSBpc24ndCBhbnkgbmV3IHByb3BzLCB0aGVuIHdlJ2xsIHJldXNlIHRoZSBtZW1vaXplZCBwcm9wcy5cbiAgLy8gICAgIC8vIFRoaXMgY291bGQgYmUgZnJvbSBhbHJlYWR5IGNvbXBsZXRlZCB3b3JrLlxuICAvLyAgICAgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICAvLyAgICAgaW52YXJpYW50KFxuICAvLyAgICAgICBuZXdQcm9wcyAhPSBudWxsLFxuICAvLyAgICAgICAnVGhlcmUgc2hvdWxkIGFsd2F5cyBiZSBwZW5kaW5nIG9yIG1lbW9pemVkIHByb3BzLiBUaGlzIGVycm9yIGlzICcgK1xuICAvLyAgICAgICAgICdsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLFxuICAvLyAgICAgKTtcbiAgLy8gICB9XG4gIC8vICAgY29uc3QgbmV3VW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgLy8gICBjb25zdCBuZXdDb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgbmV3VW5tYXNrZWRDb250ZXh0KTtcblxuICAvLyAgIGNvbnN0IG9sZENvbnRleHQgPSBpbnN0YW5jZS5jb250ZXh0O1xuICAvLyAgIGNvbnN0IG9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcblxuICAvLyAgIGlmIChcbiAgLy8gICAgIHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nICYmXG4gIC8vICAgICAob2xkUHJvcHMgIT09IG5ld1Byb3BzIHx8IG9sZENvbnRleHQgIT09IG5ld0NvbnRleHQpXG4gIC8vICAgKSB7XG4gIC8vICAgICBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhcbiAgLy8gICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gIC8vICAgICAgIGluc3RhbmNlLFxuICAvLyAgICAgICBuZXdQcm9wcyxcbiAgLy8gICAgICAgbmV3Q29udGV4dCxcbiAgLy8gICAgICk7XG4gIC8vICAgfVxuXG4gIC8vICAgLy8gUHJvY2VzcyB0aGUgdXBkYXRlIHF1ZXVlIGJlZm9yZSBjYWxsaW5nIHNob3VsZENvbXBvbmVudFVwZGF0ZVxuICAvLyAgIGNvbnN0IHVwZGF0ZVF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gIC8vICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gIC8vICAgICBuZXdTdGF0ZSA9IHByb2Nlc3NVcGRhdGVRdWV1ZShcbiAgLy8gICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gIC8vICAgICAgIHVwZGF0ZVF1ZXVlLFxuICAvLyAgICAgICBpbnN0YW5jZSxcbiAgLy8gICAgICAgbmV3U3RhdGUsXG4gIC8vICAgICAgIG5ld1Byb3BzLFxuICAvLyAgICAgICBwcmlvcml0eUxldmVsLFxuICAvLyAgICAgKTtcbiAgLy8gICB9XG5cbiAgLy8gICAvLyBUT0RPOiBTaG91bGQgd2UgZGVhbCB3aXRoIGEgc2V0U3RhdGUgdGhhdCBoYXBwZW5lZCBhZnRlciB0aGUgbGFzdFxuICAvLyAgIC8vIGNvbXBvbmVudFdpbGxNb3VudCBhbmQgYmVmb3JlIHRoaXMgY29tcG9uZW50V2lsbE1vdW50PyBQcm9iYWJseVxuICAvLyAgIC8vIHVuc3VwcG9ydGVkIGFueXdheS5cblxuICAvLyAgIGlmIChcbiAgLy8gICAgICFjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZShcbiAgLy8gICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gIC8vICAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMsXG4gIC8vICAgICAgIG5ld1Byb3BzLFxuICAvLyAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlLFxuICAvLyAgICAgICBuZXdTdGF0ZSxcbiAgLy8gICAgICAgbmV3Q29udGV4dCxcbiAgLy8gICAgIClcbiAgLy8gICApIHtcbiAgLy8gICAgIC8vIFVwZGF0ZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UncyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHBvaW50ZXJzIGV2ZW5cbiAgLy8gICAgIC8vIHRob3VnaCB3ZSdyZSBiYWlsaW5nIG91dC5cbiAgLy8gICAgIGluc3RhbmNlLnByb3BzID0gbmV3UHJvcHM7XG4gIC8vICAgICBpbnN0YW5jZS5zdGF0ZSA9IG5ld1N0YXRlO1xuICAvLyAgICAgaW5zdGFuY2UuY29udGV4dCA9IG5ld0NvbnRleHQ7XG4gIC8vICAgICByZXR1cm4gZmFsc2U7XG4gIC8vICAgfVxuXG4gIC8vICAgLy8gVXBkYXRlIHRoZSBpbnB1dCBwb2ludGVycyBub3cgc28gdGhhdCB0aGV5IGFyZSBjb3JyZWN0IHdoZW4gd2UgY2FsbFxuICAvLyAgIC8vIGNvbXBvbmVudFdpbGxNb3VudFxuICAvLyAgIGluc3RhbmNlLnByb3BzID0gbmV3UHJvcHM7XG4gIC8vICAgaW5zdGFuY2Uuc3RhdGUgPSBuZXdTdGF0ZTtcbiAgLy8gICBpbnN0YW5jZS5jb250ZXh0ID0gbmV3Q29udGV4dDtcblxuICAvLyAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vICAgICBjYWxsQ29tcG9uZW50V2lsbE1vdW50KHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7XG4gIC8vICAgICAvLyBjb21wb25lbnRXaWxsTW91bnQgbWF5IGhhdmUgY2FsbGVkIHNldFN0YXRlLiBQcm9jZXNzIHRoZSB1cGRhdGUgcXVldWUuXG4gIC8vICAgICBjb25zdCBuZXdVcGRhdGVRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICAvLyAgICAgaWYgKG5ld1VwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gIC8vICAgICAgIG5ld1N0YXRlID0gcHJvY2Vzc1VwZGF0ZVF1ZXVlKFxuICAvLyAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAvLyAgICAgICAgIG5ld1VwZGF0ZVF1ZXVlLFxuICAvLyAgICAgICAgIGluc3RhbmNlLFxuICAvLyAgICAgICAgIG5ld1N0YXRlLFxuICAvLyAgICAgICAgIG5ld1Byb3BzLFxuICAvLyAgICAgICAgIHByaW9yaXR5TGV2ZWwsXG4gIC8vICAgICAgICk7XG4gIC8vICAgICB9XG4gIC8vICAgfVxuXG4gIC8vICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcbiAgLy8gICB9XG5cbiAgLy8gICBpbnN0YW5jZS5zdGF0ZSA9IG5ld1N0YXRlO1xuXG4gIC8vICAgcmV0dXJuIHRydWU7XG4gIC8vIH1cblxuICAvLyBJbnZva2VzIHRoZSB1cGRhdGUgbGlmZS1jeWNsZXMgYW5kIHJldHVybnMgZmFsc2UgaWYgaXQgc2hvdWxkbid0IHJlcmVuZGVyLlxuICBmdW5jdGlvbiB1cGRhdGVDbGFzc0luc3RhbmNlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICByZXNldElucHV0UG9pbnRlcnMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcblxuICAgIHZhciBvbGRQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgdmFyIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIGlmICghbmV3UHJvcHMpIHtcbiAgICAgIC8vIElmIHRoZXJlIGFyZW4ndCBhbnkgbmV3IHByb3BzLCB0aGVuIHdlJ2xsIHJldXNlIHRoZSBtZW1vaXplZCBwcm9wcy5cbiAgICAgIC8vIFRoaXMgY291bGQgYmUgZnJvbSBhbHJlYWR5IGNvbXBsZXRlZCB3b3JrLlxuICAgICAgbmV3UHJvcHMgPSBvbGRQcm9wcztcbiAgICAgICEobmV3UHJvcHMgIT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdUaGVyZSBzaG91bGQgYWx3YXlzIGJlIHBlbmRpbmcgb3IgbWVtb2l6ZWQgcHJvcHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgfVxuICAgIHZhciBvbGRDb250ZXh0ID0gaW5zdGFuY2UuY29udGV4dDtcbiAgICB2YXIgbmV3VW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICB2YXIgbmV3Q29udGV4dCA9IGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIG5ld1VubWFza2VkQ29udGV4dCk7XG5cbiAgICAvLyBOb3RlOiBEdXJpbmcgdGhlc2UgbGlmZS1jeWNsZXMsIGluc3RhbmNlLnByb3BzL2luc3RhbmNlLnN0YXRlIGFyZSB3aGF0XG4gICAgLy8gZXZlciB0aGUgcHJldmlvdXNseSBhdHRlbXB0ZWQgdG8gcmVuZGVyIC0gbm90IHRoZSBcImN1cnJlbnRcIi4gSG93ZXZlcixcbiAgICAvLyBkdXJpbmcgY29tcG9uZW50RGlkVXBkYXRlIHdlIHBhc3MgdGhlIFwiY3VycmVudFwiIHByb3BzLlxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nICYmIChvbGRQcm9wcyAhPT0gbmV3UHJvcHMgfHwgb2xkQ29udGV4dCAhPT0gbmV3Q29udGV4dCkpIHtcbiAgICAgIGNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSwgbmV3UHJvcHMsIG5ld0NvbnRleHQpO1xuICAgIH1cblxuICAgIC8vIENvbXB1dGUgdGhlIG5leHQgc3RhdGUgdXNpbmcgdGhlIG1lbW9pemVkIHN0YXRlIGFuZCB0aGUgdXBkYXRlIHF1ZXVlLlxuICAgIHZhciBvbGRTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgLy8gVE9ETzogUHJldmlvdXMgc3RhdGUgY2FuIGJlIG51bGwuXG4gICAgdmFyIG5ld1N0YXRlID0gdm9pZCAwO1xuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgbmV3U3RhdGUgPSBwcm9jZXNzVXBkYXRlUXVldWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlLCBpbnN0YW5jZSwgbmV3UHJvcHMsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3U3RhdGUgPSBvbGRTdGF0ZTtcbiAgICB9XG5cbiAgICBpZiAob2xkUHJvcHMgPT09IG5ld1Byb3BzICYmIG9sZFN0YXRlID09PSBuZXdTdGF0ZSAmJiAhaGFzQ29udGV4dENoYW5nZWQoKSAmJiAhKHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlICE9PSBudWxsICYmIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlLmhhc0ZvcmNlVXBkYXRlKSkge1xuICAgICAgLy8gSWYgYW4gdXBkYXRlIHdhcyBhbHJlYWR5IGluIHByb2dyZXNzLCB3ZSBzaG91bGQgc2NoZWR1bGUgYW4gVXBkYXRlXG4gICAgICAvLyBlZmZlY3QgZXZlbiB0aG91Z2ggd2UncmUgYmFpbGluZyBvdXQsIHNvIHRoYXQgY1dVL2NEVSBhcmUgY2FsbGVkLlxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKG9sZFByb3BzICE9PSBjdXJyZW50Lm1lbW9pemVkUHJvcHMgfHwgb2xkU3RhdGUgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSkge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgc2hvdWxkVXBkYXRlID0gY2hlY2tTaG91bGRDb21wb25lbnRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIG9sZFByb3BzLCBuZXdQcm9wcywgb2xkU3RhdGUsIG5ld1N0YXRlLCBuZXdDb250ZXh0KTtcblxuICAgIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBzdGFydFBoYXNlVGltZXIod29ya0luUHJvZ3Jlc3MsICdjb21wb25lbnRXaWxsVXBkYXRlJyk7XG4gICAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXdDb250ZXh0KTtcbiAgICAgICAgc3RvcFBoYXNlVGltZXIoKTtcblxuICAgICAgICAvLyBTaW11bGF0ZSBhbiBhc3luYyBiYWlsb3V0L2ludGVycnVwdGlvbiBieSBpbnZva2luZyBsaWZlY3ljbGUgdHdpY2UuXG4gICAgICAgIGlmIChkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlKG5ld1Byb3BzLCBuZXdTdGF0ZSwgbmV3Q29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIGFuIHVwZGF0ZSB3YXMgYWxyZWFkeSBpbiBwcm9ncmVzcywgd2Ugc2hvdWxkIHNjaGVkdWxlIGFuIFVwZGF0ZVxuICAgICAgLy8gZWZmZWN0IGV2ZW4gdGhvdWdoIHdlJ3JlIGJhaWxpbmcgb3V0LCBzbyB0aGF0IGNXVS9jRFUgYXJlIGNhbGxlZC5cbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmIChvbGRQcm9wcyAhPT0gY3VycmVudC5tZW1vaXplZFByb3BzIHx8IG9sZFN0YXRlICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gVXBkYXRlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHNob3VsZENvbXBvbmVudFVwZGF0ZSByZXR1cm5lZCBmYWxzZSwgd2Ugc2hvdWxkIHN0aWxsIHVwZGF0ZSB0aGVcbiAgICAgIC8vIG1lbW9pemVkIHByb3BzL3N0YXRlIHRvIGluZGljYXRlIHRoYXQgdGhpcyB3b3JrIGNhbiBiZSByZXVzZWQuXG4gICAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5ld1Byb3BzKTtcbiAgICAgIG1lbW9pemVTdGF0ZSh3b3JrSW5Qcm9ncmVzcywgbmV3U3RhdGUpO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UncyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHBvaW50ZXJzIGV2ZW5cbiAgICAvLyBpZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJucyBmYWxzZS5cbiAgICBpbnN0YW5jZS5wcm9wcyA9IG5ld1Byb3BzO1xuICAgIGluc3RhbmNlLnN0YXRlID0gbmV3U3RhdGU7XG4gICAgaW5zdGFuY2UuY29udGV4dCA9IG5ld0NvbnRleHQ7XG5cbiAgICByZXR1cm4gc2hvdWxkVXBkYXRlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBhZG9wdENsYXNzSW5zdGFuY2U6IGFkb3B0Q2xhc3NJbnN0YW5jZSxcbiAgICBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlOiBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlLFxuICAgIG1vdW50Q2xhc3NJbnN0YW5jZTogbW91bnRDbGFzc0luc3RhbmNlLFxuICAgIC8vIHJlc3VtZU1vdW50Q2xhc3NJbnN0YW5jZSxcbiAgICB1cGRhdGVDbGFzc0luc3RhbmNlOiB1cGRhdGVDbGFzc0luc3RhbmNlXG4gIH07XG59O1xuXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIGhhc1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sWydmb3InXTtcblxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbFsnZm9yJ10oJ3JlYWN0LmVsZW1lbnQnKSA6IDB4ZWFjNztcbnZhciBSRUFDVF9DQUxMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5jYWxsJykgOiAweGVhYzg7XG52YXIgUkVBQ1RfUkVUVVJOX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5yZXR1cm4nKSA6IDB4ZWFjOTtcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbFsnZm9yJ10oJ3JlYWN0LnBvcnRhbCcpIDogMHhlYWNhO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5mcmFnbWVudCcpIDogMHhlYWNiO1xuXG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5cbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQxID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtO1xuXG5cbntcbiAgdmFyIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcbiAgLyoqXG4gICAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAgICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gICAqIHVwZGF0ZXMuXG4gICAqL1xuICB2YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG4gIHZhciBvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmcgPSB7fTtcblxuICB2YXIgd2FybkZvck1pc3NpbmdLZXkgPSBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQgPT09IG51bGwgfHwgdHlwZW9mIGNoaWxkICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWNoaWxkLl9zdG9yZSB8fCBjaGlsZC5fc3RvcmUudmFsaWRhdGVkIHx8IGNoaWxkLmtleSAhPSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgICEodHlwZW9mIGNoaWxkLl9zdG9yZSA9PT0gJ29iamVjdCcpID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3QgQ29tcG9uZW50IGluIHdhcm5Gb3JNaXNzaW5nS2V5IHNob3VsZCBoYXZlIGEgX3N0b3JlLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgIGNoaWxkLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuXG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSAnRWFjaCBjaGlsZCBpbiBhbiBhcnJheSBvciBpdGVyYXRvciBzaG91bGQgaGF2ZSBhIHVuaXF1ZSAnICsgJ1wia2V5XCIgcHJvcC4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1rZXlzIGZvciAnICsgJ21vcmUgaW5mb3JtYXRpb24uJyArIChnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDEoKSB8fCAnJyk7XG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlO1xuXG4gICAgd2FybmluZyhmYWxzZSwgJ0VhY2ggY2hpbGQgaW4gYW4gYXJyYXkgb3IgaXRlcmF0b3Igc2hvdWxkIGhhdmUgYSB1bmlxdWUgJyArICdcImtleVwiIHByb3AuIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmcta2V5cyBmb3IgJyArICdtb3JlIGluZm9ybWF0aW9uLiVzJywgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQxKCkpO1xuICB9O1xufVxuXG52YXIgaXNBcnJheSQxID0gQXJyYXkuaXNBcnJheTtcblxuZnVuY3Rpb24gY29lcmNlUmVmKGN1cnJlbnQsIGVsZW1lbnQpIHtcbiAgdmFyIG1peGVkUmVmID0gZWxlbWVudC5yZWY7XG4gIGlmIChtaXhlZFJlZiAhPT0gbnVsbCAmJiB0eXBlb2YgbWl4ZWRSZWYgIT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoZWxlbWVudC5fb3duZXIpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIGluc3QgPSB2b2lkIDA7XG4gICAgICBpZiAob3duZXIpIHtcbiAgICAgICAgdmFyIG93bmVyRmliZXIgPSBvd25lcjtcbiAgICAgICAgIShvd25lckZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpID8gaW52YXJpYW50KGZhbHNlLCAnU3RhdGVsZXNzIGZ1bmN0aW9uIGNvbXBvbmVudHMgY2Fubm90IGhhdmUgcmVmcy4nKSA6IHZvaWQgMDtcbiAgICAgICAgaW5zdCA9IG93bmVyRmliZXIuc3RhdGVOb2RlO1xuICAgICAgfVxuICAgICAgIWluc3QgPyBpbnZhcmlhbnQoZmFsc2UsICdNaXNzaW5nIG93bmVyIGZvciBzdHJpbmcgcmVmICVzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicsIG1peGVkUmVmKSA6IHZvaWQgMDtcbiAgICAgIHZhciBzdHJpbmdSZWYgPSAnJyArIG1peGVkUmVmO1xuICAgICAgLy8gQ2hlY2sgaWYgcHJldmlvdXMgc3RyaW5nIHJlZiBtYXRjaGVzIG5ldyBzdHJpbmcgcmVmXG4gICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50LnJlZiAhPT0gbnVsbCAmJiBjdXJyZW50LnJlZi5fc3RyaW5nUmVmID09PSBzdHJpbmdSZWYpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQucmVmO1xuICAgICAgfVxuICAgICAgdmFyIHJlZiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcmVmcyA9IGluc3QucmVmcyA9PT0gZW1wdHlPYmplY3QgPyBpbnN0LnJlZnMgPSB7fSA6IGluc3QucmVmcztcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgZGVsZXRlIHJlZnNbc3RyaW5nUmVmXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWZzW3N0cmluZ1JlZl0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJlZi5fc3RyaW5nUmVmID0gc3RyaW5nUmVmO1xuICAgICAgcmV0dXJuIHJlZjtcbiAgICB9IGVsc2Uge1xuICAgICAgISh0eXBlb2YgbWl4ZWRSZWYgPT09ICdzdHJpbmcnKSA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHJlZiB0byBiZSBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nLicpIDogdm9pZCAwO1xuICAgICAgIWVsZW1lbnQuX293bmVyID8gaW52YXJpYW50KGZhbHNlLCAnRWxlbWVudCByZWYgd2FzIHNwZWNpZmllZCBhcyBhIHN0cmluZyAoJXMpIGJ1dCBubyBvd25lciB3YXMgc2V0LiBZb3UgbWF5IGhhdmUgbXVsdGlwbGUgY29waWVzIG9mIFJlYWN0IGxvYWRlZC4gKGRldGFpbHM6IGh0dHBzOi8vZmIubWUvcmVhY3QtcmVmcy1tdXN0LWhhdmUtb3duZXIpLicsIG1peGVkUmVmKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1peGVkUmVmO1xufVxuXG5mdW5jdGlvbiB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKSB7XG4gIGlmIChyZXR1cm5GaWJlci50eXBlICE9PSAndGV4dGFyZWEnKSB7XG4gICAgdmFyIGFkZGVuZHVtID0gJyc7XG4gICAge1xuICAgICAgYWRkZW5kdW0gPSAnIElmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgJyArICdpbnN0ZWFkLicgKyAoZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQxKCkgfHwgJycpO1xuICAgIH1cbiAgICBpbnZhcmlhbnQoZmFsc2UsICdPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6ICVzKS4lcycsIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuZXdDaGlsZCkgPT09ICdbb2JqZWN0IE9iamVjdF0nID8gJ29iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhuZXdDaGlsZCkuam9pbignLCAnKSArICd9JyA6IG5ld0NoaWxkLCBhZGRlbmR1bSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2Fybk9uRnVuY3Rpb25UeXBlKCkge1xuICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9ICdGdW5jdGlvbnMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkLiBUaGlzIG1heSBoYXBwZW4gaWYgJyArICd5b3UgcmV0dXJuIGEgQ29tcG9uZW50IGluc3RlYWQgb2YgPENvbXBvbmVudCAvPiBmcm9tIHJlbmRlci4gJyArICdPciBtYXliZSB5b3UgbWVhbnQgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uIHJhdGhlciB0aGFuIHJldHVybiBpdC4nICsgKGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMSgpIHx8ICcnKTtcblxuICBpZiAob3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIG93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7XG5cbiAgd2FybmluZyhmYWxzZSwgJ0Z1bmN0aW9ucyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQuIFRoaXMgbWF5IGhhcHBlbiBpZiAnICsgJ3lvdSByZXR1cm4gYSBDb21wb25lbnQgaW5zdGVhZCBvZiA8Q29tcG9uZW50IC8+IGZyb20gcmVuZGVyLiAnICsgJ09yIG1heWJlIHlvdSBtZWFudCB0byBjYWxsIHRoaXMgZnVuY3Rpb24gcmF0aGVyIHRoYW4gcmV0dXJuIGl0LiVzJywgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQxKCkgfHwgJycpO1xufVxuXG4vLyBUaGlzIHdyYXBwZXIgZnVuY3Rpb24gZXhpc3RzIGJlY2F1c2UgSSBleHBlY3QgdG8gY2xvbmUgdGhlIGNvZGUgaW4gZWFjaCBwYXRoXG4vLyB0byBiZSBhYmxlIHRvIG9wdGltaXplIGVhY2ggcGF0aCBpbmRpdmlkdWFsbHkgYnkgYnJhbmNoaW5nIGVhcmx5LiBUaGlzIG5lZWRzXG4vLyBhIGNvbXBpbGVyIG9yIHdlIGNhbiBkbyBpdCBtYW51YWxseS4gSGVscGVycyB0aGF0IGRvbid0IG5lZWQgdGhpcyBicmFuY2hpbmdcbi8vIGxpdmUgb3V0c2lkZSBvZiB0aGlzIGZ1bmN0aW9uLlxuZnVuY3Rpb24gQ2hpbGRSZWNvbmNpbGVyKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgZnVuY3Rpb24gZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkVG9EZWxldGUpIHtcbiAgICBpZiAoIXNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIE5vb3AuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIERlbGV0aW9ucyBhcmUgYWRkZWQgaW4gcmV2ZXJzZWQgb3JkZXIgc28gd2UgYWRkIGl0IHRvIHRoZSBmcm9udC5cbiAgICAvLyBBdCB0aGlzIHBvaW50LCB0aGUgcmV0dXJuIGZpYmVyJ3MgZWZmZWN0IGxpc3QgaXMgZW1wdHkgZXhjZXB0IGZvclxuICAgIC8vIGRlbGV0aW9ucywgc28gd2UgY2FuIGp1c3QgYXBwZW5kIHRoZSBkZWxldGlvbiB0byB0aGUgbGlzdC4gVGhlIHJlbWFpbmluZ1xuICAgIC8vIGVmZmVjdHMgYXJlbid0IGFkZGVkIHVudGlsIHRoZSBjb21wbGV0ZSBwaGFzZS4gT25jZSB3ZSBpbXBsZW1lbnRcbiAgICAvLyByZXN1bWluZywgdGhpcyBtYXkgbm90IGJlIHRydWUuXG4gICAgdmFyIGxhc3QgPSByZXR1cm5GaWJlci5sYXN0RWZmZWN0O1xuICAgIGlmIChsYXN0ICE9PSBudWxsKSB7XG4gICAgICBsYXN0Lm5leHRFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgfVxuICAgIGNoaWxkVG9EZWxldGUubmV4dEVmZmVjdCA9IG51bGw7XG4gICAgY2hpbGRUb0RlbGV0ZS5lZmZlY3RUYWcgPSBEZWxldGlvbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCkge1xuICAgIGlmICghc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gTm9vcC5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIFRPRE86IEZvciB0aGUgc2hvdWxkQ2xvbmUgY2FzZSwgdGhpcyBjb3VsZCBiZSBtaWNyby1vcHRpbWl6ZWQgYSBiaXQgYnlcbiAgICAvLyBhc3N1bWluZyB0aGF0IGFmdGVyIHRoZSBmaXJzdCBjaGlsZCB3ZSd2ZSBhbHJlYWR5IGFkZGVkIGV2ZXJ5dGhpbmcuXG4gICAgdmFyIGNoaWxkVG9EZWxldGUgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoY2hpbGRUb0RlbGV0ZSAhPT0gbnVsbCkge1xuICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkVG9EZWxldGUpO1xuICAgICAgY2hpbGRUb0RlbGV0ZSA9IGNoaWxkVG9EZWxldGUuc2libGluZztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBtYXBSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpIHtcbiAgICAvLyBBZGQgdGhlIHJlbWFpbmluZyBjaGlsZHJlbiB0byBhIHRlbXBvcmFyeSBtYXAgc28gdGhhdCB3ZSBjYW4gZmluZCB0aGVtIGJ5XG4gICAgLy8ga2V5cyBxdWlja2x5LiBJbXBsaWNpdCAobnVsbCkga2V5cyBnZXQgYWRkZWQgdG8gdGhpcyBzZXQgd2l0aCB0aGVpciBpbmRleFxuICAgIHZhciBleGlzdGluZ0NoaWxkcmVuID0gbmV3IE1hcCgpO1xuXG4gICAgdmFyIGV4aXN0aW5nQ2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoZXhpc3RpbmdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGV4aXN0aW5nQ2hpbGQua2V5ICE9PSBudWxsKSB7XG4gICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uc2V0KGV4aXN0aW5nQ2hpbGQua2V5LCBleGlzdGluZ0NoaWxkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uc2V0KGV4aXN0aW5nQ2hpbGQuaW5kZXgsIGV4aXN0aW5nQ2hpbGQpO1xuICAgICAgfVxuICAgICAgZXhpc3RpbmdDaGlsZCA9IGV4aXN0aW5nQ2hpbGQuc2libGluZztcbiAgICB9XG4gICAgcmV0dXJuIGV4aXN0aW5nQ2hpbGRyZW47XG4gIH1cblxuICBmdW5jdGlvbiB1c2VGaWJlcihmaWJlciwgcGVuZGluZ1Byb3BzLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFdlIGN1cnJlbnRseSBzZXQgc2libGluZyB0byBudWxsIGFuZCBpbmRleCB0byAwIGhlcmUgYmVjYXVzZSBpdCBpcyBlYXN5XG4gICAgLy8gdG8gZm9yZ2V0IHRvIGRvIGJlZm9yZSByZXR1cm5pbmcgaXQuIEUuZy4gZm9yIHRoZSBzaW5nbGUgY2hpbGQgY2FzZS5cbiAgICB2YXIgY2xvbmUgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhmaWJlciwgcGVuZGluZ1Byb3BzLCBleHBpcmF0aW9uVGltZSk7XG4gICAgY2xvbmUuaW5kZXggPSAwO1xuICAgIGNsb25lLnNpYmxpbmcgPSBudWxsO1xuICAgIHJldHVybiBjbG9uZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBsYWNlQ2hpbGQobmV3RmliZXIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SW5kZXgpIHtcbiAgICBuZXdGaWJlci5pbmRleCA9IG5ld0luZGV4O1xuICAgIGlmICghc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gTm9vcC5cbiAgICAgIHJldHVybiBsYXN0UGxhY2VkSW5kZXg7XG4gICAgfVxuICAgIHZhciBjdXJyZW50ID0gbmV3RmliZXIuYWx0ZXJuYXRlO1xuICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICB2YXIgb2xkSW5kZXggPSBjdXJyZW50LmluZGV4O1xuICAgICAgaWYgKG9sZEluZGV4IDwgbGFzdFBsYWNlZEluZGV4KSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBtb3ZlLlxuICAgICAgICBuZXdGaWJlci5lZmZlY3RUYWcgPSBQbGFjZW1lbnQ7XG4gICAgICAgIHJldHVybiBsYXN0UGxhY2VkSW5kZXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGl0ZW0gY2FuIHN0YXkgaW4gcGxhY2UuXG4gICAgICAgIHJldHVybiBvbGRJbmRleDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyBpcyBhbiBpbnNlcnRpb24uXG4gICAgICBuZXdGaWJlci5lZmZlY3RUYWcgPSBQbGFjZW1lbnQ7XG4gICAgICByZXR1cm4gbGFzdFBsYWNlZEluZGV4O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBsYWNlU2luZ2xlQ2hpbGQobmV3RmliZXIpIHtcbiAgICAvLyBUaGlzIGlzIHNpbXBsZXIgZm9yIHRoZSBzaW5nbGUgY2hpbGQgY2FzZS4gV2Ugb25seSBuZWVkIHRvIGRvIGFcbiAgICAvLyBwbGFjZW1lbnQgZm9yIGluc2VydGluZyBuZXcgY2hpbGRyZW4uXG4gICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMgJiYgbmV3RmliZXIuYWx0ZXJuYXRlID09PSBudWxsKSB7XG4gICAgICBuZXdGaWJlci5lZmZlY3RUYWcgPSBQbGFjZW1lbnQ7XG4gICAgfVxuICAgIHJldHVybiBuZXdGaWJlcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBjdXJyZW50LCB0ZXh0Q29udGVudCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50LnRhZyAhPT0gSG9zdFRleHQpIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21UZXh0KHRleHRDb250ZW50LCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXBkYXRlXG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCB0ZXh0Q29udGVudCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlciwgY3VycmVudCwgZWxlbWVudCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50LnR5cGUgPT09IGVsZW1lbnQudHlwZSkge1xuICAgICAgLy8gTW92ZSBiYXNlZCBvbiBpbmRleFxuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCwgZWxlbWVudC5wcm9wcywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgZXhpc3RpbmcucmVmID0gY29lcmNlUmVmKGN1cnJlbnQsIGVsZW1lbnQpO1xuICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICB7XG4gICAgICAgIGV4aXN0aW5nLl9kZWJ1Z1NvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcbiAgICAgICAgZXhpc3RpbmcuX2RlYnVnT3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSW5zZXJ0XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoZWxlbWVudCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBjcmVhdGVkLnJlZiA9IGNvZXJjZVJlZihjdXJyZW50LCBlbGVtZW50KTtcbiAgICAgIGNyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDYWxsKHJldHVybkZpYmVyLCBjdXJyZW50LCBjYWxsLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFRPRE86IFNob3VsZCB0aGlzIGFsc28gY29tcGFyZSBoYW5kbGVyIHRvIGRldGVybWluZSB3aGV0aGVyIHRvIHJldXNlP1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQudGFnICE9PSBDYWxsQ29tcG9uZW50KSB7XG4gICAgICAvLyBJbnNlcnRcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tQ2FsbChjYWxsLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTW92ZSBiYXNlZCBvbiBpbmRleFxuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCwgY2FsbCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlUmV0dXJuKHJldHVybkZpYmVyLCBjdXJyZW50LCByZXR1cm5Ob2RlLCBleHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQudGFnICE9PSBSZXR1cm5Db21wb25lbnQpIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21SZXR1cm4ocmV0dXJuTm9kZSwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBjcmVhdGVkLnR5cGUgPSByZXR1cm5Ob2RlLnZhbHVlO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBNb3ZlIGJhc2VkIG9uIGluZGV4XG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCBudWxsLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBleGlzdGluZy50eXBlID0gcmV0dXJuTm9kZS52YWx1ZTtcbiAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVBvcnRhbChyZXR1cm5GaWJlciwgY3VycmVudCwgcG9ydGFsLCBleHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQudGFnICE9PSBIb3N0UG9ydGFsIHx8IGN1cnJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8gIT09IHBvcnRhbC5jb250YWluZXJJbmZvIHx8IGN1cnJlbnQuc3RhdGVOb2RlLmltcGxlbWVudGF0aW9uICE9PSBwb3J0YWwuaW1wbGVtZW50YXRpb24pIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXBkYXRlXG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCBwb3J0YWwuY2hpbGRyZW4gfHwgW10sIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBjdXJyZW50LCBmcmFnbWVudCwgZXhwaXJhdGlvblRpbWUsIGtleSkge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQudGFnICE9PSBGcmFnbWVudCkge1xuICAgICAgLy8gSW5zZXJ0XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KGZyYWdtZW50LCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lLCBrZXkpO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVcGRhdGVcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnQsIGZyYWdtZW50LCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBleGlzdGluZ1sncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgLy8gVGV4dCBub2RlcyBkb24ndCBoYXZlIGtleXMuIElmIHRoZSBwcmV2aW91cyBub2RlIGlzIGltcGxpY2l0bHkga2V5ZWRcbiAgICAgIC8vIHdlIGNhbiBjb250aW51ZSB0byByZXBsYWNlIGl0IHdpdGhvdXQgYWJvcnRpbmcgZXZlbiBpZiBpdCBpcyBub3QgYSB0ZXh0XG4gICAgICAvLyBub2RlLlxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21UZXh0KCcnICsgbmV3Q2hpbGQsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICAgICAgICAgIHZhciBfY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KG5ld0NoaWxkLnByb3BzLmNoaWxkcmVuLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lLCBuZXdDaGlsZC5rZXkpO1xuICAgICAgICAgICAgICBfY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jcmVhdGVkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIF9jcmVhdGVkMiA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQobmV3Q2hpbGQsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgICAgICBfY3JlYXRlZDIucmVmID0gY29lcmNlUmVmKG51bGwsIG5ld0NoaWxkKTtcbiAgICAgICAgICAgICAgX2NyZWF0ZWQyWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICAgICAgICByZXR1cm4gX2NyZWF0ZWQyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX0NBTExfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX2NyZWF0ZWQzID0gY3JlYXRlRmliZXJGcm9tQ2FsbChuZXdDaGlsZCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgICBfY3JlYXRlZDNbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICByZXR1cm4gX2NyZWF0ZWQzO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1JFVFVSTl9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfY3JlYXRlZDQgPSBjcmVhdGVGaWJlckZyb21SZXR1cm4obmV3Q2hpbGQsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgICAgX2NyZWF0ZWQ0LnR5cGUgPSBuZXdDaGlsZC52YWx1ZTtcbiAgICAgICAgICAgIF9jcmVhdGVkNFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgIHJldHVybiBfY3JlYXRlZDQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9jcmVhdGVkNSA9IGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChuZXdDaGlsZCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgICBfY3JlYXRlZDVbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICByZXR1cm4gX2NyZWF0ZWQ1O1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzQXJyYXkkMShuZXdDaGlsZCkgfHwgZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgICAgdmFyIF9jcmVhdGVkNiA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KG5ld0NoaWxkLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lLCBudWxsKTtcbiAgICAgICAgX2NyZWF0ZWQ2WydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICByZXR1cm4gX2NyZWF0ZWQ2O1xuICAgICAgfVxuXG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlU2xvdChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFVwZGF0ZSB0aGUgZmliZXIgaWYgdGhlIGtleXMgbWF0Y2gsIG90aGVyd2lzZSByZXR1cm4gbnVsbC5cblxuICAgIHZhciBrZXkgPSBvbGRGaWJlciAhPT0gbnVsbCA/IG9sZEZpYmVyLmtleSA6IG51bGw7XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBUZXh0IG5vZGVzIGRvbid0IGhhdmUga2V5cy4gSWYgdGhlIHByZXZpb3VzIG5vZGUgaXMgaW1wbGljaXRseSBrZXllZFxuICAgICAgLy8gd2UgY2FuIGNvbnRpbnVlIHRvIHJlcGxhY2UgaXQgd2l0aG91dCBhYm9ydGluZyBldmVuIGlmIGl0IGlzIG5vdCBhIHRleHRcbiAgICAgIC8vIG5vZGUuXG4gICAgICBpZiAoa2V5ICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBvbGRGaWJlciwgJycgKyBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgICBpZiAobmV3Q2hpbGQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLnByb3BzLmNoaWxkcmVuLCBleHBpcmF0aW9uVGltZSwga2V5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9DQUxMX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKG5ld0NoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgIHJldHVybiB1cGRhdGVDYWxsKHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1JFVFVSTl9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIFJldHVybnMgZG9uJ3QgaGF2ZSBrZXlzLiBJZiB0aGUgcHJldmlvdXMgbm9kZSBpcyBpbXBsaWNpdGx5IGtleWVkXG4gICAgICAgICAgICAvLyB3ZSBjYW4gY29udGludWUgdG8gcmVwbGFjZSBpdCB3aXRob3V0IGFib3J0aW5nIGV2ZW4gaWYgaXQgaXMgbm90IGFcbiAgICAgICAgICAgIC8vIHlpZWxkLlxuICAgICAgICAgICAgaWYgKGtleSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlUmV0dXJuKHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlUG9ydGFsKHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzQXJyYXkkMShuZXdDaGlsZCkgfHwgZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgICAgaWYgKGtleSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lLCBudWxsKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuT25GdW5jdGlvblR5cGUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUZyb21NYXAoZXhpc3RpbmdDaGlsZHJlbiwgcmV0dXJuRmliZXIsIG5ld0lkeCwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgLy8gVGV4dCBub2RlcyBkb24ndCBoYXZlIGtleXMsIHNvIHdlIG5laXRoZXIgaGF2ZSB0byBjaGVjayB0aGUgb2xkIG5vclxuICAgICAgLy8gbmV3IG5vZGUgZm9yIHRoZSBrZXkuIElmIGJvdGggYXJlIHRleHQgbm9kZXMsIHRoZXkgbWF0Y2guXG4gICAgICB2YXIgbWF0Y2hlZEZpYmVyID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3SWR4KSB8fCBudWxsO1xuICAgICAgcmV0dXJuIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBtYXRjaGVkRmliZXIsICcnICsgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX21hdGNoZWRGaWJlciA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0NoaWxkLmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IG5ld0NoaWxkLmtleSkgfHwgbnVsbDtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICAgICAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgX21hdGNoZWRGaWJlciwgbmV3Q2hpbGQucHJvcHMuY2hpbGRyZW4sIGV4cGlyYXRpb25UaW1lLCBuZXdDaGlsZC5rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUVsZW1lbnQocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXIsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfQ0FMTF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfbWF0Y2hlZEZpYmVyMiA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0NoaWxkLmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IG5ld0NoaWxkLmtleSkgfHwgbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVDYWxsKHJldHVybkZpYmVyLCBfbWF0Y2hlZEZpYmVyMiwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9SRVRVUk5fVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICAvLyBSZXR1cm5zIGRvbid0IGhhdmUga2V5cywgc28gd2UgbmVpdGhlciBoYXZlIHRvIGNoZWNrIHRoZSBvbGQgbm9yXG4gICAgICAgICAgICAvLyBuZXcgbm9kZSBmb3IgdGhlIGtleS4gSWYgYm90aCBhcmUgcmV0dXJucywgdGhleSBtYXRjaC5cbiAgICAgICAgICAgIHZhciBfbWF0Y2hlZEZpYmVyMyA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0lkeCkgfHwgbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVSZXR1cm4ocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXIzLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfbWF0Y2hlZEZpYmVyNCA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0NoaWxkLmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IG5ld0NoaWxkLmtleSkgfHwgbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVQb3J0YWwocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXI0LCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzQXJyYXkkMShuZXdDaGlsZCkgfHwgZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgICAgdmFyIF9tYXRjaGVkRmliZXI1ID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3SWR4KSB8fCBudWxsO1xuICAgICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXI1LCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUsIG51bGwpO1xuICAgICAgfVxuXG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFdhcm5zIGlmIHRoZXJlIGlzIGEgZHVwbGljYXRlIG9yIG1pc3Npbmcga2V5XG4gICAqL1xuICBmdW5jdGlvbiB3YXJuT25JbnZhbGlkS2V5KGNoaWxkLCBrbm93bktleXMpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIGNoaWxkICE9PSAnb2JqZWN0JyB8fCBjaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4ga25vd25LZXlzO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChjaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgY2FzZSBSRUFDVF9DQUxMX1RZUEU6XG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgd2FybkZvck1pc3NpbmdLZXkoY2hpbGQpO1xuICAgICAgICAgIHZhciBrZXkgPSBjaGlsZC5rZXk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGtub3duS2V5cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAga25vd25LZXlzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAga25vd25LZXlzLmFkZChrZXkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgha25vd25LZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICBrbm93bktleXMuYWRkKGtleSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgd2FybmluZyhmYWxzZSwgJ0VuY291bnRlcmVkIHR3byBjaGlsZHJlbiB3aXRoIHRoZSBzYW1lIGtleSwgYCVzYC4gJyArICdLZXlzIHNob3VsZCBiZSB1bmlxdWUgc28gdGhhdCBjb21wb25lbnRzIG1haW50YWluIHRoZWlyIGlkZW50aXR5ICcgKyAnYWNyb3NzIHVwZGF0ZXMuIE5vbi11bmlxdWUga2V5cyBtYXkgY2F1c2UgY2hpbGRyZW4gdG8gYmUgJyArICdkdXBsaWNhdGVkIGFuZC9vciBvbWl0dGVkIOKAlCB0aGUgYmVoYXZpb3IgaXMgdW5zdXBwb3J0ZWQgYW5kICcgKyAnY291bGQgY2hhbmdlIGluIGEgZnV0dXJlIHZlcnNpb24uJXMnLCBrZXksIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMSgpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGtub3duS2V5cztcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuQXJyYXkocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZHJlbiwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBUaGlzIGFsZ29yaXRobSBjYW4ndCBvcHRpbWl6ZSBieSBzZWFyY2hpbmcgZnJvbSBib3RocyBlbmRzIHNpbmNlIHdlXG4gICAgLy8gZG9uJ3QgaGF2ZSBiYWNrcG9pbnRlcnMgb24gZmliZXJzLiBJJ20gdHJ5aW5nIHRvIHNlZSBob3cgZmFyIHdlIGNhbiBnZXRcbiAgICAvLyB3aXRoIHRoYXQgbW9kZWwuIElmIGl0IGVuZHMgdXAgbm90IGJlaW5nIHdvcnRoIHRoZSB0cmFkZW9mZnMsIHdlIGNhblxuICAgIC8vIGFkZCBpdCBsYXRlci5cblxuICAgIC8vIEV2ZW4gd2l0aCBhIHR3byBlbmRlZCBvcHRpbWl6YXRpb24sIHdlJ2Qgd2FudCB0byBvcHRpbWl6ZSBmb3IgdGhlIGNhc2VcbiAgICAvLyB3aGVyZSB0aGVyZSBhcmUgZmV3IGNoYW5nZXMgYW5kIGJydXRlIGZvcmNlIHRoZSBjb21wYXJpc29uIGluc3RlYWQgb2ZcbiAgICAvLyBnb2luZyBmb3IgdGhlIE1hcC4gSXQnZCBsaWtlIHRvIGV4cGxvcmUgaGl0dGluZyB0aGF0IHBhdGggZmlyc3QgaW5cbiAgICAvLyBmb3J3YXJkLW9ubHkgbW9kZSBhbmQgb25seSBnbyBmb3IgdGhlIE1hcCBvbmNlIHdlIG5vdGljZSB0aGF0IHdlIG5lZWRcbiAgICAvLyBsb3RzIG9mIGxvb2sgYWhlYWQuIFRoaXMgZG9lc24ndCBoYW5kbGUgcmV2ZXJzYWwgYXMgd2VsbCBhcyB0d28gZW5kZWRcbiAgICAvLyBzZWFyY2ggYnV0IHRoYXQncyB1bnVzdWFsLiBCZXNpZGVzLCBmb3IgdGhlIHR3byBlbmRlZCBvcHRpbWl6YXRpb24gdG9cbiAgICAvLyB3b3JrIG9uIEl0ZXJhYmxlcywgd2UnZCBuZWVkIHRvIGNvcHkgdGhlIHdob2xlIHNldC5cblxuICAgIC8vIEluIHRoaXMgZmlyc3QgaXRlcmF0aW9uLCB3ZSdsbCBqdXN0IGxpdmUgd2l0aCBoaXR0aW5nIHRoZSBiYWQgY2FzZVxuICAgIC8vIChhZGRpbmcgZXZlcnl0aGluZyB0byBhIE1hcCkgaW4gZm9yIGV2ZXJ5IGluc2VydC9tb3ZlLlxuXG4gICAgLy8gSWYgeW91IGNoYW5nZSB0aGlzIGNvZGUsIGFsc28gdXBkYXRlIHJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IoKSB3aGljaFxuICAgIC8vIHVzZXMgdGhlIHNhbWUgYWxnb3JpdGhtLlxuXG4gICAge1xuICAgICAgLy8gRmlyc3QsIHZhbGlkYXRlIGtleXMuXG4gICAgICB2YXIga25vd25LZXlzID0gbnVsbDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gbmV3Q2hpbGRyZW5baV07XG4gICAgICAgIGtub3duS2V5cyA9IHdhcm5PbkludmFsaWRLZXkoY2hpbGQsIGtub3duS2V5cyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBudWxsO1xuICAgIHZhciBwcmV2aW91c05ld0ZpYmVyID0gbnVsbDtcblxuICAgIHZhciBvbGRGaWJlciA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIHZhciBsYXN0UGxhY2VkSW5kZXggPSAwO1xuICAgIHZhciBuZXdJZHggPSAwO1xuICAgIHZhciBuZXh0T2xkRmliZXIgPSBudWxsO1xuICAgIGZvciAoOyBvbGRGaWJlciAhPT0gbnVsbCAmJiBuZXdJZHggPCBuZXdDaGlsZHJlbi5sZW5ndGg7IG5ld0lkeCsrKSB7XG4gICAgICBpZiAob2xkRmliZXIuaW5kZXggPiBuZXdJZHgpIHtcbiAgICAgICAgbmV4dE9sZEZpYmVyID0gb2xkRmliZXI7XG4gICAgICAgIG9sZEZpYmVyID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRPbGRGaWJlciA9IG9sZEZpYmVyLnNpYmxpbmc7XG4gICAgICB9XG4gICAgICB2YXIgbmV3RmliZXIgPSB1cGRhdGVTbG90KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGRyZW5bbmV3SWR4XSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgaWYgKG5ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgYnJlYWtzIG9uIGVtcHR5IHNsb3RzIGxpa2UgbnVsbCBjaGlsZHJlbi4gVGhhdCdzXG4gICAgICAgIC8vIHVuZm9ydHVuYXRlIGJlY2F1c2UgaXQgdHJpZ2dlcnMgdGhlIHNsb3cgcGF0aCBhbGwgdGhlIHRpbWUuIFdlIG5lZWRcbiAgICAgICAgLy8gYSBiZXR0ZXIgd2F5IHRvIGNvbW11bmljYXRlIHdoZXRoZXIgdGhpcyB3YXMgYSBtaXNzIG9yIG51bGwsXG4gICAgICAgIC8vIGJvb2xlYW4sIHVuZGVmaW5lZCwgZXRjLlxuICAgICAgICBpZiAob2xkRmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgIGlmIChvbGRGaWJlciAmJiBuZXdGaWJlci5hbHRlcm5hdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSBtYXRjaGVkIHRoZSBzbG90LCBidXQgd2UgZGlkbid0IHJldXNlIHRoZSBleGlzdGluZyBmaWJlciwgc28gd2VcbiAgICAgICAgICAvLyBuZWVkIHRvIGRlbGV0ZSB0aGUgZXhpc3RpbmcgY2hpbGQuXG4gICAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChuZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxuICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gbmV3RmliZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUT0RPOiBEZWZlciBzaWJsaW5ncyBpZiB3ZSdyZSBub3QgYXQgdGhlIHJpZ2h0IGluZGV4IGZvciB0aGlzIHNsb3QuXG4gICAgICAgIC8vIEkuZS4gaWYgd2UgaGFkIG51bGwgdmFsdWVzIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIGRlZmVyIHRoaXNcbiAgICAgICAgLy8gZm9yIGVhY2ggbnVsbCB2YWx1ZS4gSG93ZXZlciwgd2UgYWxzbyBkb24ndCB3YW50IHRvIGNhbGwgdXBkYXRlU2xvdFxuICAgICAgICAvLyB3aXRoIHRoZSBwcmV2aW91cyBvbmUuXG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IG5ld0ZpYmVyO1xuICAgICAgfVxuICAgICAgcHJldmlvdXNOZXdGaWJlciA9IG5ld0ZpYmVyO1xuICAgICAgb2xkRmliZXIgPSBuZXh0T2xkRmliZXI7XG4gICAgfVxuXG4gICAgaWYgKG5ld0lkeCA9PT0gbmV3Q2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAvLyBXZSd2ZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIG5ldyBjaGlsZHJlbi4gV2UgY2FuIGRlbGV0ZSB0aGUgcmVzdC5cbiAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG4gICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICB9XG5cbiAgICBpZiAob2xkRmliZXIgPT09IG51bGwpIHtcbiAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYW55IG1vcmUgZXhpc3RpbmcgY2hpbGRyZW4gd2UgY2FuIGNob29zZSBhIGZhc3QgcGF0aFxuICAgICAgLy8gc2luY2UgdGhlIHJlc3Qgd2lsbCBhbGwgYmUgaW5zZXJ0aW9ucy5cbiAgICAgIGZvciAoOyBuZXdJZHggPCBuZXdDaGlsZHJlbi5sZW5ndGg7IG5ld0lkeCsrKSB7XG4gICAgICAgIHZhciBfbmV3RmliZXIgPSBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgbmV3Q2hpbGRyZW5bbmV3SWR4XSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICBpZiAoIV9uZXdGaWJlcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQoX25ld0ZpYmVyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG4gICAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxuICAgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBfbmV3RmliZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gX25ld0ZpYmVyO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICB9XG5cbiAgICAvLyBBZGQgYWxsIGNoaWxkcmVuIHRvIGEga2V5IG1hcCBmb3IgcXVpY2sgbG9va3Vwcy5cbiAgICB2YXIgZXhpc3RpbmdDaGlsZHJlbiA9IG1hcFJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG5cbiAgICAvLyBLZWVwIHNjYW5uaW5nIGFuZCB1c2UgdGhlIG1hcCB0byByZXN0b3JlIGRlbGV0ZWQgaXRlbXMgYXMgbW92ZXMuXG4gICAgZm9yICg7IG5ld0lkeCA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgbmV3SWR4KyspIHtcbiAgICAgIHZhciBfbmV3RmliZXIyID0gdXBkYXRlRnJvbU1hcChleGlzdGluZ0NoaWxkcmVuLCByZXR1cm5GaWJlciwgbmV3SWR4LCBuZXdDaGlsZHJlbltuZXdJZHhdLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBpZiAoX25ld0ZpYmVyMikge1xuICAgICAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgICAgIGlmIChfbmV3RmliZXIyLmFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gVGhlIG5ldyBmaWJlciBpcyBhIHdvcmsgaW4gcHJvZ3Jlc3MsIGJ1dCBpZiB0aGVyZSBleGlzdHMgYVxuICAgICAgICAgICAgLy8gY3VycmVudCwgdGhhdCBtZWFucyB0aGF0IHdlIHJldXNlZCB0aGUgZmliZXIuIFdlIG5lZWQgdG8gZGVsZXRlXG4gICAgICAgICAgICAvLyBpdCBmcm9tIHRoZSBjaGlsZCBsaXN0IHNvIHRoYXQgd2UgZG9uJ3QgYWRkIGl0IHRvIHRoZSBkZWxldGlvblxuICAgICAgICAgICAgLy8gbGlzdC5cbiAgICAgICAgICAgIGV4aXN0aW5nQ2hpbGRyZW5bJ2RlbGV0ZSddKF9uZXdGaWJlcjIua2V5ID09PSBudWxsID8gbmV3SWR4IDogX25ld0ZpYmVyMi5rZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKF9uZXdGaWJlcjIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcbiAgICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gX25ld0ZpYmVyMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBfbmV3RmliZXIyO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXIyO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBBbnkgZXhpc3RpbmcgY2hpbGRyZW4gdGhhdCB3ZXJlbid0IGNvbnN1bWVkIGFib3ZlIHdlcmUgZGVsZXRlZC4gV2UgbmVlZFxuICAgICAgLy8gdG8gYWRkIHRoZW0gdG8gdGhlIGRlbGV0aW9uIGxpc3QuXG4gICAgICBleGlzdGluZ0NoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZHJlbkl0ZXJhdG9yKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGRyZW5JdGVyYWJsZSwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBzYW1lIGltcGxlbWVudGF0aW9uIGFzIHJlY29uY2lsZUNoaWxkcmVuQXJyYXkoKSxcbiAgICAvLyBidXQgdXNpbmcgdGhlIGl0ZXJhdG9yIGluc3RlYWQuXG5cbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGRyZW5JdGVyYWJsZSk7XG4gICAgISh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykgPyBpbnZhcmlhbnQoZmFsc2UsICdBbiBvYmplY3QgaXMgbm90IGFuIGl0ZXJhYmxlLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gICAge1xuICAgICAgLy8gV2FybiBhYm91dCB1c2luZyBNYXBzIGFzIGNoaWxkcmVuXG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkcmVuSXRlcmFibGUuZW50cmllcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgcG9zc2libGVNYXAgPSBuZXdDaGlsZHJlbkl0ZXJhYmxlO1xuICAgICAgICBpZiAocG9zc2libGVNYXAuZW50cmllcyA9PT0gaXRlcmF0b3JGbikge1xuICAgICAgICAgIHdhcm5pbmcoZGlkV2FybkFib3V0TWFwcywgJ1VzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgdW5zdXBwb3J0ZWQgYW5kIHdpbGwgbGlrZWx5IHlpZWxkICcgKyAndW5leHBlY3RlZCByZXN1bHRzLiBDb252ZXJ0IGl0IHRvIGEgc2VxdWVuY2UvaXRlcmFibGUgb2Yga2V5ZWQgJyArICdSZWFjdEVsZW1lbnRzIGluc3RlYWQuJXMnLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDEoKSk7XG4gICAgICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gRmlyc3QsIHZhbGlkYXRlIGtleXMuXG4gICAgICAvLyBXZSdsbCBnZXQgYSBkaWZmZXJlbnQgaXRlcmF0b3IgbGF0ZXIgZm9yIHRoZSBtYWluIHBhc3MuXG4gICAgICB2YXIgX25ld0NoaWxkcmVuID0gaXRlcmF0b3JGbi5jYWxsKG5ld0NoaWxkcmVuSXRlcmFibGUpO1xuICAgICAgaWYgKF9uZXdDaGlsZHJlbikge1xuICAgICAgICB2YXIga25vd25LZXlzID0gbnVsbDtcbiAgICAgICAgdmFyIF9zdGVwID0gX25ld0NoaWxkcmVuLm5leHQoKTtcbiAgICAgICAgZm9yICg7ICFfc3RlcC5kb25lOyBfc3RlcCA9IF9uZXdDaGlsZHJlbi5uZXh0KCkpIHtcbiAgICAgICAgICB2YXIgY2hpbGQgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICBrbm93bktleXMgPSB3YXJuT25JbnZhbGlkS2V5KGNoaWxkLCBrbm93bktleXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG5ld0NoaWxkcmVuID0gaXRlcmF0b3JGbi5jYWxsKG5ld0NoaWxkcmVuSXRlcmFibGUpO1xuICAgICEobmV3Q2hpbGRyZW4gIT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdBbiBpdGVyYWJsZSBvYmplY3QgcHJvdmlkZWQgbm8gaXRlcmF0b3IuJykgOiB2b2lkIDA7XG5cbiAgICB2YXIgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IG51bGw7XG4gICAgdmFyIHByZXZpb3VzTmV3RmliZXIgPSBudWxsO1xuXG4gICAgdmFyIG9sZEZpYmVyID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgdmFyIGxhc3RQbGFjZWRJbmRleCA9IDA7XG4gICAgdmFyIG5ld0lkeCA9IDA7XG4gICAgdmFyIG5leHRPbGRGaWJlciA9IG51bGw7XG5cbiAgICB2YXIgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKTtcbiAgICBmb3IgKDsgb2xkRmliZXIgIT09IG51bGwgJiYgIXN0ZXAuZG9uZTsgbmV3SWR4KyssIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCkpIHtcbiAgICAgIGlmIChvbGRGaWJlci5pbmRleCA+IG5ld0lkeCkge1xuICAgICAgICBuZXh0T2xkRmliZXIgPSBvbGRGaWJlcjtcbiAgICAgICAgb2xkRmliZXIgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dE9sZEZpYmVyID0gb2xkRmliZXIuc2libGluZztcbiAgICAgIH1cbiAgICAgIHZhciBuZXdGaWJlciA9IHVwZGF0ZVNsb3QocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBzdGVwLnZhbHVlLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBpZiAobmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBicmVha3Mgb24gZW1wdHkgc2xvdHMgbGlrZSBudWxsIGNoaWxkcmVuLiBUaGF0J3NcbiAgICAgICAgLy8gdW5mb3J0dW5hdGUgYmVjYXVzZSBpdCB0cmlnZ2VycyB0aGUgc2xvdyBwYXRoIGFsbCB0aGUgdGltZS4gV2UgbmVlZFxuICAgICAgICAvLyBhIGJldHRlciB3YXkgdG8gY29tbXVuaWNhdGUgd2hldGhlciB0aGlzIHdhcyBhIG1pc3Mgb3IgbnVsbCxcbiAgICAgICAgLy8gYm9vbGVhbiwgdW5kZWZpbmVkLCBldGMuXG4gICAgICAgIGlmICghb2xkRmliZXIpIHtcbiAgICAgICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgIGlmIChvbGRGaWJlciAmJiBuZXdGaWJlci5hbHRlcm5hdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSBtYXRjaGVkIHRoZSBzbG90LCBidXQgd2UgZGlkbid0IHJldXNlIHRoZSBleGlzdGluZyBmaWJlciwgc28gd2VcbiAgICAgICAgICAvLyBuZWVkIHRvIGRlbGV0ZSB0aGUgZXhpc3RpbmcgY2hpbGQuXG4gICAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChuZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxuICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gbmV3RmliZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUT0RPOiBEZWZlciBzaWJsaW5ncyBpZiB3ZSdyZSBub3QgYXQgdGhlIHJpZ2h0IGluZGV4IGZvciB0aGlzIHNsb3QuXG4gICAgICAgIC8vIEkuZS4gaWYgd2UgaGFkIG51bGwgdmFsdWVzIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIGRlZmVyIHRoaXNcbiAgICAgICAgLy8gZm9yIGVhY2ggbnVsbCB2YWx1ZS4gSG93ZXZlciwgd2UgYWxzbyBkb24ndCB3YW50IHRvIGNhbGwgdXBkYXRlU2xvdFxuICAgICAgICAvLyB3aXRoIHRoZSBwcmV2aW91cyBvbmUuXG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IG5ld0ZpYmVyO1xuICAgICAgfVxuICAgICAgcHJldmlvdXNOZXdGaWJlciA9IG5ld0ZpYmVyO1xuICAgICAgb2xkRmliZXIgPSBuZXh0T2xkRmliZXI7XG4gICAgfVxuXG4gICAgaWYgKHN0ZXAuZG9uZSkge1xuICAgICAgLy8gV2UndmUgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBuZXcgY2hpbGRyZW4uIFdlIGNhbiBkZWxldGUgdGhlIHJlc3QuXG4gICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuICAgICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gICAgfVxuXG4gICAgaWYgKG9sZEZpYmVyID09PSBudWxsKSB7XG4gICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGFueSBtb3JlIGV4aXN0aW5nIGNoaWxkcmVuIHdlIGNhbiBjaG9vc2UgYSBmYXN0IHBhdGhcbiAgICAgIC8vIHNpbmNlIHRoZSByZXN0IHdpbGwgYWxsIGJlIGluc2VydGlvbnMuXG4gICAgICBmb3IgKDsgIXN0ZXAuZG9uZTsgbmV3SWR4KyssIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCkpIHtcbiAgICAgICAgdmFyIF9uZXdGaWJlcjMgPSBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgc3RlcC52YWx1ZSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICBpZiAoX25ld0ZpYmVyMyA9PT0gbnVsbCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQoX25ld0ZpYmVyMywgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuICAgICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFRPRE86IE1vdmUgb3V0IG9mIHRoZSBsb29wLiBUaGlzIG9ubHkgaGFwcGVucyBmb3IgdGhlIGZpcnN0IHJ1bi5cbiAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gX25ld0ZpYmVyMztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBfbmV3RmliZXIzO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXIzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gICAgfVxuXG4gICAgLy8gQWRkIGFsbCBjaGlsZHJlbiB0byBhIGtleSBtYXAgZm9yIHF1aWNrIGxvb2t1cHMuXG4gICAgdmFyIGV4aXN0aW5nQ2hpbGRyZW4gPSBtYXBSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuXG4gICAgLy8gS2VlcCBzY2FubmluZyBhbmQgdXNlIHRoZSBtYXAgdG8gcmVzdG9yZSBkZWxldGVkIGl0ZW1zIGFzIG1vdmVzLlxuICAgIGZvciAoOyAhc3RlcC5kb25lOyBuZXdJZHgrKywgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKSkge1xuICAgICAgdmFyIF9uZXdGaWJlcjQgPSB1cGRhdGVGcm9tTWFwKGV4aXN0aW5nQ2hpbGRyZW4sIHJldHVybkZpYmVyLCBuZXdJZHgsIHN0ZXAudmFsdWUsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGlmIChfbmV3RmliZXI0ICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgICAgaWYgKF9uZXdGaWJlcjQuYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBUaGUgbmV3IGZpYmVyIGlzIGEgd29yayBpbiBwcm9ncmVzcywgYnV0IGlmIHRoZXJlIGV4aXN0cyBhXG4gICAgICAgICAgICAvLyBjdXJyZW50LCB0aGF0IG1lYW5zIHRoYXQgd2UgcmV1c2VkIHRoZSBmaWJlci4gV2UgbmVlZCB0byBkZWxldGVcbiAgICAgICAgICAgIC8vIGl0IGZyb20gdGhlIGNoaWxkIGxpc3Qgc28gdGhhdCB3ZSBkb24ndCBhZGQgaXQgdG8gdGhlIGRlbGV0aW9uXG4gICAgICAgICAgICAvLyBsaXN0LlxuICAgICAgICAgICAgZXhpc3RpbmdDaGlsZHJlblsnZGVsZXRlJ10oX25ld0ZpYmVyNC5rZXkgPT09IG51bGwgPyBuZXdJZHggOiBfbmV3RmliZXI0LmtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQoX25ld0ZpYmVyNCwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuICAgICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBfbmV3RmliZXI0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IF9uZXdGaWJlcjQ7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IF9uZXdGaWJlcjQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIEFueSBleGlzdGluZyBjaGlsZHJlbiB0aGF0IHdlcmVuJ3QgY29uc3VtZWQgYWJvdmUgd2VyZSBkZWxldGVkLiBXZSBuZWVkXG4gICAgICAvLyB0byBhZGQgdGhlbSB0byB0aGUgZGVsZXRpb24gbGlzdC5cbiAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZVNpbmdsZVRleHROb2RlKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgdGV4dENvbnRlbnQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gVGhlcmUncyBubyBuZWVkIHRvIGNoZWNrIGZvciBrZXlzIG9uIHRleHQgbm9kZXMgc2luY2Ugd2UgZG9uJ3QgaGF2ZSBhXG4gICAgLy8gd2F5IHRvIGRlZmluZSB0aGVtLlxuICAgIGlmIChjdXJyZW50Rmlyc3RDaGlsZCAhPT0gbnVsbCAmJiBjdXJyZW50Rmlyc3RDaGlsZC50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAvLyBXZSBhbHJlYWR5IGhhdmUgYW4gZXhpc3Rpbmcgbm9kZSBzbyBsZXQncyBqdXN0IHVwZGF0ZSBpdCBhbmQgZGVsZXRlXG4gICAgICAvLyB0aGUgcmVzdC5cbiAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZC5zaWJsaW5nKTtcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnRGaXJzdENoaWxkLCB0ZXh0Q29udGVudCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICAgIC8vIFRoZSBleGlzdGluZyBmaXJzdCBjaGlsZCBpcyBub3QgYSB0ZXh0IG5vZGUgc28gd2UgbmVlZCB0byBjcmVhdGUgb25lXG4gICAgLy8gYW5kIGRlbGV0ZSB0aGUgZXhpc3Rpbmcgb25lcy5cbiAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpO1xuICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tVGV4dCh0ZXh0Q29udGVudCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICByZXR1cm4gY3JlYXRlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZVNpbmdsZUVsZW1lbnQocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBlbGVtZW50LCBleHBpcmF0aW9uVGltZSkge1xuICAgIHZhciBrZXkgPSBlbGVtZW50LmtleTtcbiAgICB2YXIgY2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRPRE86IElmIGtleSA9PT0gbnVsbCBhbmQgY2hpbGQua2V5ID09PSBudWxsLCB0aGVuIHRoaXMgb25seSBhcHBsaWVzIHRvXG4gICAgICAvLyB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgbGlzdC5cbiAgICAgIGlmIChjaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICBpZiAoY2hpbGQudGFnID09PSBGcmFnbWVudCA/IGVsZW1lbnQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSA6IGNoaWxkLnR5cGUgPT09IGVsZW1lbnQudHlwZSkge1xuICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZC5zaWJsaW5nKTtcbiAgICAgICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjaGlsZCwgZWxlbWVudC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFID8gZWxlbWVudC5wcm9wcy5jaGlsZHJlbiA6IGVsZW1lbnQucHJvcHMsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICBleGlzdGluZy5yZWYgPSBjb2VyY2VSZWYoY2hpbGQsIGVsZW1lbnQpO1xuICAgICAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGV4aXN0aW5nLl9kZWJ1Z1NvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcbiAgICAgICAgICAgIGV4aXN0aW5nLl9kZWJ1Z093bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfVxuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cblxuICAgIGlmIChlbGVtZW50LnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZWxlbWVudC5wcm9wcy5jaGlsZHJlbiwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSwgZWxlbWVudC5rZXkpO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX2NyZWF0ZWQ3ID0gY3JlYXRlRmliZXJGcm9tRWxlbWVudChlbGVtZW50LCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIF9jcmVhdGVkNy5yZWYgPSBjb2VyY2VSZWYoY3VycmVudEZpcnN0Q2hpbGQsIGVsZW1lbnQpO1xuICAgICAgX2NyZWF0ZWQ3WydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIF9jcmVhdGVkNztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVTaW5nbGVDYWxsKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgY2FsbCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICB2YXIga2V5ID0gY2FsbC5rZXk7XG4gICAgdmFyIGNoaWxkID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAvLyBUT0RPOiBJZiBrZXkgPT09IG51bGwgYW5kIGNoaWxkLmtleSA9PT0gbnVsbCwgdGhlbiB0aGlzIG9ubHkgYXBwbGllcyB0b1xuICAgICAgLy8gdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGxpc3QuXG4gICAgICBpZiAoY2hpbGQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gQ2FsbENvbXBvbmVudCkge1xuICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZC5zaWJsaW5nKTtcbiAgICAgICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjaGlsZCwgY2FsbCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfVxuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cblxuICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tQ2FsbChjYWxsLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICBjcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgIHJldHVybiBjcmVhdGVkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlU2luZ2xlUmV0dXJuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgcmV0dXJuTm9kZSwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBUaGVyZSdzIG5vIG5lZWQgdG8gY2hlY2sgZm9yIGtleXMgb24geWllbGRzIHNpbmNlIHRoZXkncmUgc3RhdGVsZXNzLlxuICAgIHZhciBjaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIGlmIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gUmV0dXJuQ29tcG9uZW50KSB7XG4gICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZC5zaWJsaW5nKTtcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY2hpbGQsIG51bGwsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgZXhpc3RpbmcudHlwZSA9IHJldHVybk5vZGUudmFsdWU7XG4gICAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tUmV0dXJuKHJldHVybk5vZGUsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgIGNyZWF0ZWQudHlwZSA9IHJldHVybk5vZGUudmFsdWU7XG4gICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICByZXR1cm4gY3JlYXRlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZVNpbmdsZVBvcnRhbChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIHBvcnRhbCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICB2YXIga2V5ID0gcG9ydGFsLmtleTtcbiAgICB2YXIgY2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRPRE86IElmIGtleSA9PT0gbnVsbCBhbmQgY2hpbGQua2V5ID09PSBudWxsLCB0aGVuIHRoaXMgb25seSBhcHBsaWVzIHRvXG4gICAgICAvLyB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgbGlzdC5cbiAgICAgIGlmIChjaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICBpZiAoY2hpbGQudGFnID09PSBIb3N0UG9ydGFsICYmIGNoaWxkLnN0YXRlTm9kZS5jb250YWluZXJJbmZvID09PSBwb3J0YWwuY29udGFpbmVySW5mbyAmJiBjaGlsZC5zdGF0ZU5vZGUuaW1wbGVtZW50YXRpb24gPT09IHBvcnRhbC5pbXBsZW1lbnRhdGlvbikge1xuICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZC5zaWJsaW5nKTtcbiAgICAgICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjaGlsZCwgcG9ydGFsLmNoaWxkcmVuIHx8IFtdLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9XG4gICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgfVxuXG4gICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICBjcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgIHJldHVybiBjcmVhdGVkO1xuICB9XG5cbiAgLy8gVGhpcyBBUEkgd2lsbCB0YWcgdGhlIGNoaWxkcmVuIHdpdGggdGhlIHNpZGUtZWZmZWN0IG9mIHRoZSByZWNvbmNpbGlhdGlvblxuICAvLyBpdHNlbGYuIFRoZXkgd2lsbCBiZSBhZGRlZCB0byB0aGUgc2lkZS1lZmZlY3QgbGlzdCBhcyB3ZSBwYXNzIHRocm91Z2ggdGhlXG4gIC8vIGNoaWxkcmVuIGFuZCB0aGUgcGFyZW50LlxuICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZEZpYmVycyhyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgbm90IHJlY3Vyc2l2ZS5cbiAgICAvLyBJZiB0aGUgdG9wIGxldmVsIGl0ZW0gaXMgYW4gYXJyYXksIHdlIHRyZWF0IGl0IGFzIGEgc2V0IG9mIGNoaWxkcmVuLFxuICAgIC8vIG5vdCBhcyBhIGZyYWdtZW50LiBOZXN0ZWQgYXJyYXlzIG9uIHRoZSBvdGhlciBoYW5kIHdpbGwgYmUgdHJlYXRlZCBhc1xuICAgIC8vIGZyYWdtZW50IG5vZGVzLiBSZWN1cnNpb24gaGFwcGVucyBhdCB0aGUgbm9ybWFsIGZsb3cuXG5cbiAgICAvLyBIYW5kbGUgdG9wIGxldmVsIHVua2V5ZWQgZnJhZ21lbnRzIGFzIGlmIHRoZXkgd2VyZSBhcnJheXMuXG4gICAgLy8gVGhpcyBsZWFkcyB0byBhbiBhbWJpZ3VpdHkgYmV0d2VlbiA8PntbLi4uXX08Lz4gYW5kIDw+Li4uPC8+LlxuICAgIC8vIFdlIHRyZWF0IHRoZSBhbWJpZ3VvdXMgY2FzZXMgYWJvdmUgdGhlIHNhbWUuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGwgJiYgbmV3Q2hpbGQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSAmJiBuZXdDaGlsZC5rZXkgPT09IG51bGwpIHtcbiAgICAgIG5ld0NoaWxkID0gbmV3Q2hpbGQucHJvcHMuY2hpbGRyZW47XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIG9iamVjdCB0eXBlc1xuICAgIHZhciBpc09iamVjdCA9IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGw7XG5cbiAgICBpZiAoaXNPYmplY3QpIHtcbiAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQocmVjb25jaWxlU2luZ2xlRWxlbWVudChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSkpO1xuXG4gICAgICAgIGNhc2UgUkVBQ1RfQ0FMTF9UWVBFOlxuICAgICAgICAgIHJldHVybiBwbGFjZVNpbmdsZUNoaWxkKHJlY29uY2lsZVNpbmdsZUNhbGwocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpKTtcbiAgICAgICAgY2FzZSBSRUFDVF9SRVRVUk5fVFlQRTpcbiAgICAgICAgICByZXR1cm4gcGxhY2VTaW5nbGVDaGlsZChyZWNvbmNpbGVTaW5nbGVSZXR1cm4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpKTtcbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICByZXR1cm4gcGxhY2VTaW5nbGVDaGlsZChyZWNvbmNpbGVTaW5nbGVQb3J0YWwocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gcGxhY2VTaW5nbGVDaGlsZChyZWNvbmNpbGVTaW5nbGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsICcnICsgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSk7XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkkMShuZXdDaGlsZCkpIHtcbiAgICAgIHJldHVybiByZWNvbmNpbGVDaGlsZHJlbkFycmF5KHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG5cbiAgICBpZiAoZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgIHJldHVybiByZWNvbmNpbGVDaGlsZHJlbkl0ZXJhdG9yKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG5cbiAgICBpZiAoaXNPYmplY3QpIHtcbiAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBJZiB0aGUgbmV3IGNoaWxkIGlzIHVuZGVmaW5lZCwgYW5kIHRoZSByZXR1cm4gZmliZXIgaXMgYSBjb21wb3NpdGVcbiAgICAgIC8vIGNvbXBvbmVudCwgdGhyb3cgYW4gZXJyb3IuIElmIEZpYmVyIHJldHVybiB0eXBlcyBhcmUgZGlzYWJsZWQsXG4gICAgICAvLyB3ZSBhbHJlYWR5IHRocmV3IGFib3ZlLlxuICAgICAgc3dpdGNoIChyZXR1cm5GaWJlci50YWcpIHtcbiAgICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IHJldHVybkZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnJlbmRlci5faXNNb2NrRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBhbGxvdyBhdXRvLW1vY2tzIHRvIHByb2NlZWQgYXMgaWYgdGhleSdyZSByZXR1cm5pbmcgbnVsbC5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgLy8gSW50ZW50aW9uYWxseSBmYWxsIHRocm91Z2ggdG8gdGhlIG5leHQgY2FzZSwgd2hpY2ggaGFuZGxlcyBib3RoXG4gICAgICAgIC8vIGZ1bmN0aW9ucyBhbmQgY2xhc3Nlc1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVkIG5vLWZhbGx0aHJvdWdoXG4gICAgICAgIGNhc2UgRnVuY3Rpb25hbENvbXBvbmVudDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgQ29tcG9uZW50ID0gcmV0dXJuRmliZXIudHlwZTtcbiAgICAgICAgICAgIGludmFyaWFudChmYWxzZSwgJyVzKC4uLik6IE5vdGhpbmcgd2FzIHJldHVybmVkIGZyb20gcmVuZGVyLiBUaGlzIHVzdWFsbHkgbWVhbnMgYSByZXR1cm4gc3RhdGVtZW50IGlzIG1pc3NpbmcuIE9yLCB0byByZW5kZXIgbm90aGluZywgcmV0dXJuIG51bGwuJywgQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVtYWluaW5nIGNhc2VzIGFyZSBhbGwgdHJlYXRlZCBhcyBlbXB0eS5cbiAgICByZXR1cm4gZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKTtcbiAgfVxuXG4gIHJldHVybiByZWNvbmNpbGVDaGlsZEZpYmVycztcbn1cblxudmFyIHJlY29uY2lsZUNoaWxkRmliZXJzID0gQ2hpbGRSZWNvbmNpbGVyKHRydWUpO1xudmFyIG1vdW50Q2hpbGRGaWJlcnMgPSBDaGlsZFJlY29uY2lsZXIoZmFsc2UpO1xuXG5mdW5jdGlvbiBjbG9uZUNoaWxkRmliZXJzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICEoY3VycmVudCA9PT0gbnVsbCB8fCB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9PT0gY3VycmVudC5jaGlsZCkgPyBpbnZhcmlhbnQoZmFsc2UsICdSZXN1bWluZyB3b3JrIG5vdCB5ZXQgaW1wbGVtZW50ZWQuJykgOiB2b2lkIDA7XG5cbiAgaWYgKHdvcmtJblByb2dyZXNzLmNoaWxkID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGN1cnJlbnRDaGlsZCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB2YXIgbmV3Q2hpbGQgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50Q2hpbGQsIGN1cnJlbnRDaGlsZC5wZW5kaW5nUHJvcHMsIGN1cnJlbnRDaGlsZC5leHBpcmF0aW9uVGltZSk7XG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbmV3Q2hpbGQ7XG5cbiAgbmV3Q2hpbGRbJ3JldHVybiddID0gd29ya0luUHJvZ3Jlc3M7XG4gIHdoaWxlIChjdXJyZW50Q2hpbGQuc2libGluZyAhPT0gbnVsbCkge1xuICAgIGN1cnJlbnRDaGlsZCA9IGN1cnJlbnRDaGlsZC5zaWJsaW5nO1xuICAgIG5ld0NoaWxkID0gbmV3Q2hpbGQuc2libGluZyA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnRDaGlsZCwgY3VycmVudENoaWxkLnBlbmRpbmdQcm9wcywgY3VycmVudENoaWxkLmV4cGlyYXRpb25UaW1lKTtcbiAgICBuZXdDaGlsZFsncmV0dXJuJ10gPSB3b3JrSW5Qcm9ncmVzcztcbiAgfVxuICBuZXdDaGlsZC5zaWJsaW5nID0gbnVsbDtcbn1cblxue1xuICB2YXIgd2FybmVkQWJvdXRTdGF0ZWxlc3NSZWZzID0ge307XG59XG5cbnZhciBSZWFjdEZpYmVyQmVnaW5Xb3JrID0gZnVuY3Rpb24gKGNvbmZpZywgaG9zdENvbnRleHQsIGh5ZHJhdGlvbkNvbnRleHQsIHNjaGVkdWxlV29yaywgY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcikge1xuICB2YXIgc2hvdWxkU2V0VGV4dENvbnRlbnQgPSBjb25maWcuc2hvdWxkU2V0VGV4dENvbnRlbnQsXG4gICAgICB1c2VTeW5jU2NoZWR1bGluZyA9IGNvbmZpZy51c2VTeW5jU2NoZWR1bGluZyxcbiAgICAgIHNob3VsZERlcHJpb3JpdGl6ZVN1YnRyZWUgPSBjb25maWcuc2hvdWxkRGVwcmlvcml0aXplU3VidHJlZTtcbiAgdmFyIHB1c2hIb3N0Q29udGV4dCA9IGhvc3RDb250ZXh0LnB1c2hIb3N0Q29udGV4dCxcbiAgICAgIHB1c2hIb3N0Q29udGFpbmVyID0gaG9zdENvbnRleHQucHVzaEhvc3RDb250YWluZXI7XG4gIHZhciBlbnRlckh5ZHJhdGlvblN0YXRlID0gaHlkcmF0aW9uQ29udGV4dC5lbnRlckh5ZHJhdGlvblN0YXRlLFxuICAgICAgcmVzZXRIeWRyYXRpb25TdGF0ZSA9IGh5ZHJhdGlvbkNvbnRleHQucmVzZXRIeWRyYXRpb25TdGF0ZSxcbiAgICAgIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gaHlkcmF0aW9uQ29udGV4dC50cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZTtcblxuICB2YXIgX1JlYWN0RmliZXJDbGFzc0NvbXBvID0gUmVhY3RGaWJlckNsYXNzQ29tcG9uZW50KHNjaGVkdWxlV29yaywgY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlciwgbWVtb2l6ZVByb3BzLCBtZW1vaXplU3RhdGUpLFxuICAgICAgYWRvcHRDbGFzc0luc3RhbmNlID0gX1JlYWN0RmliZXJDbGFzc0NvbXBvLmFkb3B0Q2xhc3NJbnN0YW5jZSxcbiAgICAgIGNvbnN0cnVjdENsYXNzSW5zdGFuY2UgPSBfUmVhY3RGaWJlckNsYXNzQ29tcG8uY29uc3RydWN0Q2xhc3NJbnN0YW5jZSxcbiAgICAgIG1vdW50Q2xhc3NJbnN0YW5jZSA9IF9SZWFjdEZpYmVyQ2xhc3NDb21wby5tb3VudENsYXNzSW5zdGFuY2UsXG4gICAgICB1cGRhdGVDbGFzc0luc3RhbmNlID0gX1JlYWN0RmliZXJDbGFzc0NvbXBvLnVwZGF0ZUNsYXNzSW5zdGFuY2U7XG5cbiAgLy8gVE9ETzogUmVtb3ZlIHRoaXMgYW5kIHVzZSByZWNvbmNpbGVDaGlsZHJlbkF0RXhwaXJhdGlvblRpbWUgZGlyZWN0bHkuXG5cblxuICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKSB7XG4gICAgcmVjb25jaWxlQ2hpbGRyZW5BdEV4cGlyYXRpb25UaW1lKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuQXRFeHBpcmF0aW9uVGltZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAvLyBJZiB0aGlzIGlzIGEgZnJlc2ggbmV3IGNvbXBvbmVudCB0aGF0IGhhc24ndCBiZWVuIHJlbmRlcmVkIHlldCwgd2VcbiAgICAgIC8vIHdvbid0IHVwZGF0ZSBpdHMgY2hpbGQgc2V0IGJ5IGFwcGx5aW5nIG1pbmltYWwgc2lkZS1lZmZlY3RzLiBJbnN0ZWFkLFxuICAgICAgLy8gd2Ugd2lsbCBhZGQgdGhlbSBhbGwgdG8gdGhlIGNoaWxkIGJlZm9yZSBpdCBnZXRzIHJlbmRlcmVkLiBUaGF0IG1lYW5zXG4gICAgICAvLyB3ZSBjYW4gb3B0aW1pemUgdGhpcyByZWNvbmNpbGlhdGlvbiBwYXNzIGJ5IG5vdCB0cmFja2luZyBzaWRlLWVmZmVjdHMuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG1vdW50Q2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIG51bGwsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB0aGUgY3VycmVudCBjaGlsZCBpcyB0aGUgc2FtZSBhcyB0aGUgd29yayBpbiBwcm9ncmVzcywgaXQgbWVhbnMgdGhhdFxuICAgICAgLy8gd2UgaGF2ZW4ndCB5ZXQgc3RhcnRlZCBhbnkgd29yayBvbiB0aGVzZSBjaGlsZHJlbi4gVGhlcmVmb3JlLCB3ZSB1c2VcbiAgICAgIC8vIHRoZSBjbG9uZSBhbGdvcml0aG0gdG8gY3JlYXRlIGEgY29weSBvZiBhbGwgdGhlIGN1cnJlbnQgY2hpbGRyZW4uXG5cbiAgICAgIC8vIElmIHdlIGhhZCBhbnkgcHJvZ3Jlc3NlZCB3b3JrIGFscmVhZHksIHRoYXQgaXMgaW52YWxpZCBhdCB0aGlzIHBvaW50IHNvXG4gICAgICAvLyBsZXQncyB0aHJvdyBpdCBvdXQuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBjdXJyZW50LmNoaWxkLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVGcmFnbWVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIHZhciBuZXh0Q2hpbGRyZW4gPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgaWYgKGhhc0NvbnRleHRDaGFuZ2VkKCkpIHtcbiAgICAgIC8vIE5vcm1hbGx5IHdlIGNhbiBiYWlsIG91dCBvbiBwcm9wcyBlcXVhbGl0eSBidXQgaWYgY29udGV4dCBoYXMgY2hhbmdlZFxuICAgICAgLy8gd2UgZG9uJ3QgZG8gdGhlIGJhaWxvdXQgYW5kIHdlIGhhdmUgdG8gcmV1c2UgZXhpc3RpbmcgcHJvcHMgaW5zdGVhZC5cbiAgICAgIGlmIChuZXh0Q2hpbGRyZW4gPT09IG51bGwpIHtcbiAgICAgICAgbmV4dENoaWxkcmVuID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5leHRDaGlsZHJlbiA9PT0gbnVsbCB8fCB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID09PSBuZXh0Q2hpbGRyZW4pIHtcbiAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbik7XG4gICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICB2YXIgcmVmID0gd29ya0luUHJvZ3Jlc3MucmVmO1xuICAgIGlmIChyZWYgIT09IG51bGwgJiYgKCFjdXJyZW50IHx8IGN1cnJlbnQucmVmICE9PSByZWYpKSB7XG4gICAgICAvLyBTY2hlZHVsZSBhIFJlZiBlZmZlY3RcbiAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBSZWY7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRnVuY3Rpb25hbENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIHZhciBmbiA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcblxuICAgIHZhciBtZW1vaXplZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICBpZiAoaGFzQ29udGV4dENoYW5nZWQoKSkge1xuICAgICAgLy8gTm9ybWFsbHkgd2UgY2FuIGJhaWwgb3V0IG9uIHByb3BzIGVxdWFsaXR5IGJ1dCBpZiBjb250ZXh0IGhhcyBjaGFuZ2VkXG4gICAgICAvLyB3ZSBkb24ndCBkbyB0aGUgYmFpbG91dCBhbmQgd2UgaGF2ZSB0byByZXVzZSBleGlzdGluZyBwcm9wcyBpbnN0ZWFkLlxuICAgICAgaWYgKG5leHRQcm9wcyA9PT0gbnVsbCkge1xuICAgICAgICBuZXh0UHJvcHMgPSBtZW1vaXplZFByb3BzO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobmV4dFByb3BzID09PSBudWxsIHx8IG1lbW9pemVkUHJvcHMgPT09IG5leHRQcm9wcykge1xuICAgICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB9XG4gICAgICAvLyBUT0RPOiBjb25zaWRlciBicmluZ2luZyBmbi5zaG91bGRDb21wb25lbnRVcGRhdGUoKSBiYWNrLlxuICAgICAgLy8gSXQgdXNlZCB0byBiZSBoZXJlLlxuICAgIH1cblxuICAgIHZhciB1bm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgIHZhciBjb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KTtcblxuICAgIHZhciBuZXh0Q2hpbGRyZW47XG5cbiAgICB7XG4gICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnNldEN1cnJlbnRQaGFzZSgncmVuZGVyJyk7XG4gICAgICBuZXh0Q2hpbGRyZW4gPSBmbihuZXh0UHJvcHMsIGNvbnRleHQpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50UGhhc2UobnVsbCk7XG4gICAgfVxuICAgIC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cbiAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gUGVyZm9ybWVkV29yaztcbiAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcyk7XG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlQ2xhc3NDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gUHVzaCBjb250ZXh0IHByb3ZpZGVycyBlYXJseSB0byBwcmV2ZW50IGNvbnRleHQgc3RhY2sgbWlzbWF0Y2hlcy5cbiAgICAvLyBEdXJpbmcgbW91bnRpbmcgd2UgZG9uJ3Qga25vdyB0aGUgY2hpbGQgY29udGV4dCB5ZXQgYXMgdGhlIGluc3RhbmNlIGRvZXNuJ3QgZXhpc3QuXG4gICAgLy8gV2Ugd2lsbCBpbnZhbGlkYXRlIHRoZSBjaGlsZCBjb250ZXh0IGluIGZpbmlzaENsYXNzQ29tcG9uZW50KCkgcmlnaHQgYWZ0ZXIgcmVuZGVyaW5nLlxuICAgIHZhciBoYXNDb250ZXh0ID0gcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICB2YXIgc2hvdWxkVXBkYXRlID0gdm9pZCAwO1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICBpZiAoIXdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSkge1xuICAgICAgICAvLyBJbiB0aGUgaW5pdGlhbCBwYXNzIHdlIG1pZ2h0IG5lZWQgdG8gY29uc3RydWN0IHRoZSBpbnN0YW5jZS5cbiAgICAgICAgY29uc3RydWN0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzKTtcbiAgICAgICAgbW91bnRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICAgIHNob3VsZFVwZGF0ZSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdSZXN1bWluZyB3b3JrIG5vdCB5ZXQgaW1wbGVtZW50ZWQuJyk7XG4gICAgICAgIC8vIEluIGEgcmVzdW1lLCB3ZSdsbCBhbHJlYWR5IGhhdmUgYW4gaW5zdGFuY2Ugd2UgY2FuIHJldXNlLlxuICAgICAgICAvLyBzaG91bGRVcGRhdGUgPSByZXN1bWVNb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2hvdWxkVXBkYXRlID0gdXBkYXRlQ2xhc3NJbnN0YW5jZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIH1cbiAgICByZXR1cm4gZmluaXNoQ2xhc3NDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHNob3VsZFVwZGF0ZSwgaGFzQ29udGV4dCk7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5pc2hDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgc2hvdWxkVXBkYXRlLCBoYXNDb250ZXh0KSB7XG4gICAgLy8gUmVmcyBzaG91bGQgdXBkYXRlIGV2ZW4gaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybnMgZmFsc2VcbiAgICBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcblxuICAgIGlmICghc2hvdWxkVXBkYXRlKSB7XG4gICAgICAvLyBDb250ZXh0IHByb3ZpZGVycyBzaG91bGQgZGVmZXIgdG8gc0NVIGZvciByZW5kZXJpbmdcbiAgICAgIGlmIChoYXNDb250ZXh0KSB7XG4gICAgICAgIGludmFsaWRhdGVDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcblxuICAgIC8vIFJlcmVuZGVyXG4gICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuICAgIHZhciBuZXh0Q2hpbGRyZW4gPSB2b2lkIDA7XG4gICAge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50UGhhc2UoJ3JlbmRlcicpO1xuICAgICAgbmV4dENoaWxkcmVuID0gaW5zdGFuY2UucmVuZGVyKCk7XG4gICAgICBpZiAoZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzKSB7XG4gICAgICAgIGluc3RhbmNlLnJlbmRlcigpO1xuICAgICAgfVxuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50UGhhc2UobnVsbCk7XG4gICAgfVxuICAgIC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cbiAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gUGVyZm9ybWVkV29yaztcbiAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgICAvLyBNZW1vaXplIHByb3BzIGFuZCBzdGF0ZSB1c2luZyB0aGUgdmFsdWVzIHdlIGp1c3QgdXNlZCB0byByZW5kZXIuXG4gICAgLy8gVE9ETzogUmVzdHJ1Y3R1cmUgc28gd2UgbmV2ZXIgcmVhZCB2YWx1ZXMgZnJvbSB0aGUgaW5zdGFuY2UuXG4gICAgbWVtb2l6ZVN0YXRlKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZS5zdGF0ZSk7XG4gICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZS5wcm9wcyk7XG5cbiAgICAvLyBUaGUgY29udGV4dCBtaWdodCBoYXZlIGNoYW5nZWQgc28gd2UgbmVlZCB0byByZWNhbGN1bGF0ZSBpdC5cbiAgICBpZiAoaGFzQ29udGV4dCkge1xuICAgICAgaW52YWxpZGF0ZUNvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaEhvc3RSb290Q29udGV4dCh3b3JrSW5Qcm9ncmVzcykge1xuICAgIHZhciByb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgIGlmIChyb290LnBlbmRpbmdDb250ZXh0KSB7XG4gICAgICBwdXNoVG9wTGV2ZWxDb250ZXh0T2JqZWN0KHdvcmtJblByb2dyZXNzLCByb290LnBlbmRpbmdDb250ZXh0LCByb290LnBlbmRpbmdDb250ZXh0ICE9PSByb290LmNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAocm9vdC5jb250ZXh0KSB7XG4gICAgICAvLyBTaG91bGQgYWx3YXlzIGJlIHNldFxuICAgICAgcHVzaFRvcExldmVsQ29udGV4dE9iamVjdCh3b3JrSW5Qcm9ncmVzcywgcm9vdC5jb250ZXh0LCBmYWxzZSk7XG4gICAgfVxuICAgIHB1c2hIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzLCByb290LmNvbnRhaW5lckluZm8pO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlSG9zdFJvb3QoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgcHVzaEhvc3RSb290Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgdmFyIHVwZGF0ZVF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICB2YXIgcHJldlN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIHZhciBzdGF0ZSA9IHByb2Nlc3NVcGRhdGVRdWV1ZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUXVldWUsIG51bGwsIG51bGwsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGlmIChwcmV2U3RhdGUgPT09IHN0YXRlKSB7XG4gICAgICAgIC8vIElmIHRoZSBzdGF0ZSBpcyB0aGUgc2FtZSBhcyBiZWZvcmUsIHRoYXQncyBhIGJhaWxvdXQgYmVjYXVzZSB3ZSBoYWRcbiAgICAgICAgLy8gbm8gd29yayB0aGF0IGV4cGlyZXMgYXQgdGhpcyB0aW1lLlxuICAgICAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gICAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIH1cbiAgICAgIHZhciBlbGVtZW50ID0gc3RhdGUuZWxlbWVudDtcbiAgICAgIHZhciByb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgaWYgKChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQuY2hpbGQgPT09IG51bGwpICYmIHJvb3QuaHlkcmF0ZSAmJiBlbnRlckh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKSkge1xuICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGFueSBjdXJyZW50IGNoaWxkcmVuIHRoaXMgbWlnaHQgYmUgdGhlIGZpcnN0IHBhc3MuXG4gICAgICAgIC8vIFdlIGFsd2F5cyB0cnkgdG8gaHlkcmF0ZS4gSWYgdGhpcyBpc24ndCBhIGh5ZHJhdGlvbiBwYXNzIHRoZXJlIHdvbid0XG4gICAgICAgIC8vIGJlIGFueSBjaGlsZHJlbiB0byBoeWRyYXRlIHdoaWNoIGlzIGVmZmVjdGl2ZWx5IHRoZSBzYW1lIHRoaW5nIGFzXG4gICAgICAgIC8vIG5vdCBoeWRyYXRpbmcuXG5cbiAgICAgICAgLy8gVGhpcyBpcyBhIGJpdCBvZiBhIGhhY2suIFdlIHRyYWNrIHRoZSBob3N0IHJvb3QgYXMgYSBwbGFjZW1lbnQgdG9cbiAgICAgICAgLy8ga25vdyB0aGF0IHdlJ3JlIGN1cnJlbnRseSBpbiBhIG1vdW50aW5nIHN0YXRlLiBUaGF0IHdheSBpc01vdW50ZWRcbiAgICAgICAgLy8gd29ya3MgYXMgZXhwZWN0ZWQuIFdlIG11c3QgcmVzZXQgdGhpcyBiZWZvcmUgY29tbWl0dGluZy5cbiAgICAgICAgLy8gVE9ETzogRGVsZXRlIHRoaXMgd2hlbiB3ZSBkZWxldGUgaXNNb3VudGVkIGFuZCBmaW5kRE9NTm9kZS5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFBsYWNlbWVudDtcblxuICAgICAgICAvLyBFbnN1cmUgdGhhdCBjaGlsZHJlbiBtb3VudCBpbnRvIHRoaXMgcm9vdCB3aXRob3V0IHRyYWNraW5nXG4gICAgICAgIC8vIHNpZGUtZWZmZWN0cy4gVGhpcyBlbnN1cmVzIHRoYXQgd2UgZG9uJ3Qgc3RvcmUgUGxhY2VtZW50IGVmZmVjdHMgb25cbiAgICAgICAgLy8gbm9kZXMgdGhhdCB3aWxsIGJlIGh5ZHJhdGVkLlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG1vdW50Q2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIG51bGwsIGVsZW1lbnQsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSByZXNldCBoeWRyYXRpb24gc3RhdGUgaW4gY2FzZSB3ZSBhYm9ydGVkIGFuZCByZXN1bWVkIGFub3RoZXJcbiAgICAgICAgLy8gcm9vdC5cbiAgICAgICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAgICAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgZWxlbWVudCk7XG4gICAgICB9XG4gICAgICBtZW1vaXplU3RhdGUod29ya0luUHJvZ3Jlc3MsIHN0YXRlKTtcbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICB9XG4gICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAgIC8vIElmIHRoZXJlIGlzIG5vIHVwZGF0ZSBxdWV1ZSwgdGhhdCdzIGEgYmFpbG91dCBiZWNhdXNlIHRoZSByb290IGhhcyBubyBwcm9wcy5cbiAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVIb3N0Q29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIHB1c2hIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICB2YXIgbWVtb2l6ZWRQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICBpZiAobmV4dFByb3BzID09PSBudWxsKSB7XG4gICAgICBuZXh0UHJvcHMgPSBtZW1vaXplZFByb3BzO1xuICAgICAgIShuZXh0UHJvcHMgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnV2Ugc2hvdWxkIGFsd2F5cyBoYXZlIHBlbmRpbmcgb3IgY3VycmVudCBwcm9wcy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICB9XG4gICAgdmFyIHByZXZQcm9wcyA9IGN1cnJlbnQgIT09IG51bGwgPyBjdXJyZW50Lm1lbW9pemVkUHJvcHMgOiBudWxsO1xuXG4gICAgaWYgKGhhc0NvbnRleHRDaGFuZ2VkKCkpIHtcbiAgICAgIC8vIE5vcm1hbGx5IHdlIGNhbiBiYWlsIG91dCBvbiBwcm9wcyBlcXVhbGl0eSBidXQgaWYgY29udGV4dCBoYXMgY2hhbmdlZFxuICAgICAgLy8gd2UgZG9uJ3QgZG8gdGhlIGJhaWxvdXQgYW5kIHdlIGhhdmUgdG8gcmV1c2UgZXhpc3RpbmcgcHJvcHMgaW5zdGVhZC5cbiAgICB9IGVsc2UgaWYgKG5leHRQcm9wcyA9PT0gbnVsbCB8fCBtZW1vaXplZFByb3BzID09PSBuZXh0UHJvcHMpIHtcbiAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuICAgIHZhciBpc0RpcmVjdFRleHRDaGlsZCA9IHNob3VsZFNldFRleHRDb250ZW50KHR5cGUsIG5leHRQcm9wcyk7XG5cbiAgICBpZiAoaXNEaXJlY3RUZXh0Q2hpbGQpIHtcbiAgICAgIC8vIFdlIHNwZWNpYWwgY2FzZSBhIGRpcmVjdCB0ZXh0IGNoaWxkIG9mIGEgaG9zdCBub2RlLiBUaGlzIGlzIGEgY29tbW9uXG4gICAgICAvLyBjYXNlLiBXZSB3b24ndCBoYW5kbGUgaXQgYXMgYSByZWlmaWVkIGNoaWxkLiBXZSB3aWxsIGluc3RlYWQgaGFuZGxlXG4gICAgICAvLyB0aGlzIGluIHRoZSBob3N0IGVudmlyb25tZW50IHRoYXQgYWxzbyBoYXZlIGFjY2VzcyB0byB0aGlzIHByb3AuIFRoYXRcbiAgICAgIC8vIGF2b2lkcyBhbGxvY2F0aW5nIGFub3RoZXIgSG9zdFRleHQgZmliZXIgYW5kIHRyYXZlcnNpbmcgaXQuXG4gICAgICBuZXh0Q2hpbGRyZW4gPSBudWxsO1xuICAgIH0gZWxzZSBpZiAocHJldlByb3BzICYmIHNob3VsZFNldFRleHRDb250ZW50KHR5cGUsIHByZXZQcm9wcykpIHtcbiAgICAgIC8vIElmIHdlJ3JlIHN3aXRjaGluZyBmcm9tIGEgZGlyZWN0IHRleHQgY2hpbGQgdG8gYSBub3JtYWwgY2hpbGQsIG9yIHRvXG4gICAgICAvLyBlbXB0eSwgd2UgbmVlZCB0byBzY2hlZHVsZSB0aGUgdGV4dCBjb250ZW50IHRvIGJlIHJlc2V0LlxuICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IENvbnRlbnRSZXNldDtcbiAgICB9XG5cbiAgICBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcblxuICAgIC8vIENoZWNrIHRoZSBob3N0IGNvbmZpZyB0byBzZWUgaWYgdGhlIGNoaWxkcmVuIGFyZSBvZmZzY3JlZW4vaGlkZGVuLlxuICAgIGlmIChyZW5kZXJFeHBpcmF0aW9uVGltZSAhPT0gTmV2ZXIgJiYgIXVzZVN5bmNTY2hlZHVsaW5nICYmIHNob3VsZERlcHJpb3JpdGl6ZVN1YnRyZWUodHlwZSwgbmV4dFByb3BzKSkge1xuICAgICAgLy8gRG93bi1wcmlvcml0aXplIHRoZSBjaGlsZHJlbi5cbiAgICAgIHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID0gTmV2ZXI7XG4gICAgICAvLyBCYWlsb3V0IGFuZCBjb21lIGJhY2sgdG8gdGhpcyBmaWJlciBsYXRlci5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzKTtcbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVIb3N0VGV4dChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuICAgIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgaWYgKG5leHRQcm9wcyA9PT0gbnVsbCkge1xuICAgICAgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICB9XG4gICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMpO1xuICAgIC8vIE5vdGhpbmcgdG8gZG8gaGVyZS4gVGhpcyBpcyB0ZXJtaW5hbC4gV2UnbGwgZG8gdGhlIGNvbXBsZXRpb24gc3RlcFxuICAgIC8vIGltbWVkaWF0ZWx5IGFmdGVyLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gbW91bnRJbmRldGVybWluYXRlQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgICEoY3VycmVudCA9PT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdBbiBpbmRldGVybWluYXRlIGNvbXBvbmVudCBzaG91bGQgbmV2ZXIgaGF2ZSBtb3VudGVkLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgIHZhciBmbiA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgdmFyIHByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIHZhciB1bm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgIHZhciBjb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KTtcblxuICAgIHZhciB2YWx1ZTtcblxuICAgIHtcbiAgICAgIGlmIChmbi5wcm90b3R5cGUgJiYgdHlwZW9mIGZuLnByb3RvdHlwZS5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgXCJUaGUgPCVzIC8+IGNvbXBvbmVudCBhcHBlYXJzIHRvIGhhdmUgYSByZW5kZXIgbWV0aG9kLCBidXQgZG9lc24ndCBleHRlbmQgUmVhY3QuQ29tcG9uZW50LiBcIiArICdUaGlzIGlzIGxpa2VseSB0byBjYXVzZSBlcnJvcnMuIENoYW5nZSAlcyB0byBleHRlbmQgUmVhY3QuQ29tcG9uZW50IGluc3RlYWQuJywgY29tcG9uZW50TmFtZSwgY29tcG9uZW50TmFtZSk7XG4gICAgICB9XG4gICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICB2YWx1ZSA9IGZuKHByb3BzLCBjb250ZXh0KTtcbiAgICB9XG4gICAgLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBQZXJmb3JtZWRXb3JrO1xuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gUHJvY2VlZCB1bmRlciB0aGUgYXNzdW1wdGlvbiB0aGF0IHRoaXMgaXMgYSBjbGFzcyBpbnN0YW5jZVxuICAgICAgd29ya0luUHJvZ3Jlc3MudGFnID0gQ2xhc3NDb21wb25lbnQ7XG5cbiAgICAgIC8vIFB1c2ggY29udGV4dCBwcm92aWRlcnMgZWFybHkgdG8gcHJldmVudCBjb250ZXh0IHN0YWNrIG1pc21hdGNoZXMuXG4gICAgICAvLyBEdXJpbmcgbW91bnRpbmcgd2UgZG9uJ3Qga25vdyB0aGUgY2hpbGQgY29udGV4dCB5ZXQgYXMgdGhlIGluc3RhbmNlIGRvZXNuJ3QgZXhpc3QuXG4gICAgICAvLyBXZSB3aWxsIGludmFsaWRhdGUgdGhlIGNoaWxkIGNvbnRleHQgaW4gZmluaXNoQ2xhc3NDb21wb25lbnQoKSByaWdodCBhZnRlciByZW5kZXJpbmcuXG4gICAgICB2YXIgaGFzQ29udGV4dCA9IHB1c2hDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgYWRvcHRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCB2YWx1ZSk7XG4gICAgICBtb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIHJldHVybiBmaW5pc2hDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdHJ1ZSwgaGFzQ29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFByb2NlZWQgdW5kZXIgdGhlIGFzc3VtcHRpb24gdGhhdCB0aGlzIGlzIGEgZnVuY3Rpb25hbCBjb21wb25lbnRcbiAgICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IEZ1bmN0aW9uYWxDb21wb25lbnQ7XG4gICAgICB7XG4gICAgICAgIHZhciBDb21wb25lbnQgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuXG4gICAgICAgIGlmIChDb21wb25lbnQpIHtcbiAgICAgICAgICB3YXJuaW5nKCFDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXMsICclcyguLi4pOiBjaGlsZENvbnRleHRUeXBlcyBjYW5ub3QgYmUgZGVmaW5lZCBvbiBhIGZ1bmN0aW9uYWwgY29tcG9uZW50LicsIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLnJlZiAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBpbmZvID0gJyc7XG4gICAgICAgICAgdmFyIG93bmVyTmFtZSA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lKCk7XG4gICAgICAgICAgaWYgKG93bmVyTmFtZSkge1xuICAgICAgICAgICAgaW5mbyArPSAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBvd25lck5hbWUgKyAnYC4nO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciB3YXJuaW5nS2V5ID0gb3duZXJOYW1lIHx8IHdvcmtJblByb2dyZXNzLl9kZWJ1Z0lEIHx8ICcnO1xuICAgICAgICAgIHZhciBkZWJ1Z1NvdXJjZSA9IHdvcmtJblByb2dyZXNzLl9kZWJ1Z1NvdXJjZTtcbiAgICAgICAgICBpZiAoZGVidWdTb3VyY2UpIHtcbiAgICAgICAgICAgIHdhcm5pbmdLZXkgPSBkZWJ1Z1NvdXJjZS5maWxlTmFtZSArICc6JyArIGRlYnVnU291cmNlLmxpbmVOdW1iZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghd2FybmVkQWJvdXRTdGF0ZWxlc3NSZWZzW3dhcm5pbmdLZXldKSB7XG4gICAgICAgICAgICB3YXJuZWRBYm91dFN0YXRlbGVzc1JlZnNbd2FybmluZ0tleV0gPSB0cnVlO1xuICAgICAgICAgICAgd2FybmluZyhmYWxzZSwgJ1N0YXRlbGVzcyBmdW5jdGlvbiBjb21wb25lbnRzIGNhbm5vdCBiZSBnaXZlbiByZWZzLiAnICsgJ0F0dGVtcHRzIHRvIGFjY2VzcyB0aGlzIHJlZiB3aWxsIGZhaWwuJXMlcycsIGluZm8sIFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB2YWx1ZSk7XG4gICAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIHByb3BzKTtcbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDYWxsQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIHZhciBuZXh0Q2FsbCA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICBpZiAoaGFzQ29udGV4dENoYW5nZWQoKSkge1xuICAgICAgLy8gTm9ybWFsbHkgd2UgY2FuIGJhaWwgb3V0IG9uIHByb3BzIGVxdWFsaXR5IGJ1dCBpZiBjb250ZXh0IGhhcyBjaGFuZ2VkXG4gICAgICAvLyB3ZSBkb24ndCBkbyB0aGUgYmFpbG91dCBhbmQgd2UgaGF2ZSB0byByZXVzZSBleGlzdGluZyBwcm9wcyBpbnN0ZWFkLlxuICAgICAgaWYgKG5leHRDYWxsID09PSBudWxsKSB7XG4gICAgICAgIG5leHRDYWxsID0gY3VycmVudCAmJiBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgICAgICEobmV4dENhbGwgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnV2Ugc2hvdWxkIGFsd2F5cyBoYXZlIHBlbmRpbmcgb3IgY3VycmVudCBwcm9wcy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5leHRDYWxsID09PSBudWxsIHx8IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPT09IG5leHRDYWxsKSB7XG4gICAgICBuZXh0Q2FsbCA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgICAvLyBUT0RPOiBXaGVuIGJhaWxpbmcgb3V0LCB3ZSBtaWdodCBuZWVkIHRvIHJldHVybiB0aGUgc3RhdGVOb2RlIGluc3RlYWRcbiAgICAgIC8vIG9mIHRoZSBjaGlsZC4gVG8gY2hlY2sgaXQgZm9yIHdvcmsuXG4gICAgICAvLyByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IG5leHRDYWxsLmNoaWxkcmVuO1xuXG4gICAgLy8gVGhlIGZvbGxvd2luZyBpcyBhIGZvcmsgb2YgcmVjb25jaWxlQ2hpbGRyZW5BdEV4cGlyYXRpb25UaW1lIGJ1dCB1c2luZ1xuICAgIC8vIHN0YXRlTm9kZSB0byBzdG9yZSB0aGUgY2hpbGQuXG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IG1vdW50Q2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSwgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIH1cblxuICAgIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dENhbGwpO1xuICAgIC8vIFRoaXMgZG9lc24ndCB0YWtlIGFyYml0cmFyeSB0aW1lIHNvIHdlIGNvdWxkIHN5bmNocm9ub3VzbHkganVzdCBiZWdpblxuICAgIC8vIGVhZ2VybHkgZG8gdGhlIHdvcmsgb2Ygd29ya0luUHJvZ3Jlc3MuY2hpbGQgYXMgYW4gb3B0aW1pemF0aW9uLlxuICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVQb3J0YWxDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgcHVzaEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtcbiAgICB2YXIgbmV4dENoaWxkcmVuID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIGlmIChoYXNDb250ZXh0Q2hhbmdlZCgpKSB7XG4gICAgICAvLyBOb3JtYWxseSB3ZSBjYW4gYmFpbCBvdXQgb24gcHJvcHMgZXF1YWxpdHkgYnV0IGlmIGNvbnRleHQgaGFzIGNoYW5nZWRcbiAgICAgIC8vIHdlIGRvbid0IGRvIHRoZSBiYWlsb3V0IGFuZCB3ZSBoYXZlIHRvIHJldXNlIGV4aXN0aW5nIHByb3BzIGluc3RlYWQuXG4gICAgICBpZiAobmV4dENoaWxkcmVuID09PSBudWxsKSB7XG4gICAgICAgIG5leHRDaGlsZHJlbiA9IGN1cnJlbnQgJiYgY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgICAgICAhKG5leHRDaGlsZHJlbiAhPSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1dlIHNob3VsZCBhbHdheXMgaGF2ZSBwZW5kaW5nIG9yIGN1cnJlbnQgcHJvcHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuZXh0Q2hpbGRyZW4gPT09IG51bGwgfHwgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9PT0gbmV4dENoaWxkcmVuKSB7XG4gICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIFBvcnRhbHMgYXJlIHNwZWNpYWwgYmVjYXVzZSB3ZSBkb24ndCBhcHBlbmQgdGhlIGNoaWxkcmVuIGR1cmluZyBtb3VudFxuICAgICAgLy8gYnV0IGF0IGNvbW1pdC4gVGhlcmVmb3JlIHdlIG5lZWQgdG8gdHJhY2sgaW5zZXJ0aW9ucyB3aGljaCB0aGUgbm9ybWFsXG4gICAgICAvLyBmbG93IGRvZXNuJ3QgZG8gZHVyaW5nIG1vdW50LiBUaGlzIGRvZXNuJ3QgaGFwcGVuIGF0IHRoZSByb290IGJlY2F1c2VcbiAgICAgIC8vIHRoZSByb290IGFsd2F5cyBzdGFydHMgd2l0aCBhIFwiY3VycmVudFwiIHdpdGggYSBudWxsIGNoaWxkLlxuICAgICAgLy8gVE9ETzogQ29uc2lkZXIgdW5pZnlpbmcgdGhpcyB3aXRoIGhvdyB0aGUgcm9vdCB3b3Jrcy5cbiAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVjb25jaWxlQ2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIG51bGwsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgICAgIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgICB9XG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG5cbiAgLypcbiAgZnVuY3Rpb24gcmV1c2VDaGlsZHJlbkVmZmVjdHMocmV0dXJuRmliZXIgOiBGaWJlciwgZmlyc3RDaGlsZCA6IEZpYmVyKSB7XG4gICAgbGV0IGNoaWxkID0gZmlyc3RDaGlsZDtcbiAgICBkbyB7XG4gICAgICAvLyBFbnN1cmUgdGhhdCB0aGUgZmlyc3QgYW5kIGxhc3QgZWZmZWN0IG9mIHRoZSBwYXJlbnQgY29ycmVzcG9uZHNcbiAgICAgIC8vIHRvIHRoZSBjaGlsZHJlbidzIGZpcnN0IGFuZCBsYXN0IGVmZmVjdC5cbiAgICAgIGlmICghcmV0dXJuRmliZXIuZmlyc3RFZmZlY3QpIHtcbiAgICAgICAgcmV0dXJuRmliZXIuZmlyc3RFZmZlY3QgPSBjaGlsZC5maXJzdEVmZmVjdDtcbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZC5sYXN0RWZmZWN0KSB7XG4gICAgICAgIGlmIChyZXR1cm5GaWJlci5sYXN0RWZmZWN0KSB7XG4gICAgICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdC5uZXh0RWZmZWN0ID0gY2hpbGQuZmlyc3RFZmZlY3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNoaWxkLmxhc3RFZmZlY3Q7XG4gICAgICB9XG4gICAgfSB3aGlsZSAoY2hpbGQgPSBjaGlsZC5zaWJsaW5nKTtcbiAgfVxuICAqL1xuXG4gIGZ1bmN0aW9uIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICBjYW5jZWxXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgLy8gVE9ETzogV2Ugc2hvdWxkIGlkZWFsbHkgYmUgYWJsZSB0byBiYWlsIG91dCBlYXJseSBpZiB0aGUgY2hpbGRyZW4gaGF2ZSBub1xuICAgIC8vIG1vcmUgd29yayB0byBkby4gSG93ZXZlciwgc2luY2Ugd2UgZG9uJ3QgaGF2ZSBhIHNlcGFyYXRpb24gb2YgdGhpc1xuICAgIC8vIEZpYmVyJ3MgcHJpb3JpdHkgYW5kIGl0cyBjaGlsZHJlbiB5ZXQgLSB3ZSBkb24ndCBrbm93IHdpdGhvdXQgZG9pbmcgbG90c1xuICAgIC8vIG9mIHRoZSBzYW1lIHdvcmsgd2UgZG8gYW55d2F5LiBPbmNlIHdlIGhhdmUgdGhhdCBzZXBhcmF0aW9uIHdlIGNhbiBqdXN0XG4gICAgLy8gYmFpbCBvdXQgaGVyZSBpZiB0aGUgY2hpbGRyZW4gaGFzIG5vIG1vcmUgd29yayBhdCB0aGlzIHByaW9yaXR5IGxldmVsLlxuICAgIC8vIGlmICh3b3JrSW5Qcm9ncmVzcy5wcmlvcml0eU9mQ2hpbGRyZW4gPD0gcHJpb3JpdHlMZXZlbCkge1xuICAgIC8vICAgLy8gSWYgdGhlcmUgYXJlIHNpZGUtZWZmZWN0cyBpbiB0aGVzZSBjaGlsZHJlbiB0aGF0IGhhdmUgbm90IHlldCBiZWVuXG4gICAgLy8gICAvLyBjb21taXR0ZWQgd2UgbmVlZCB0byBlbnN1cmUgdGhhdCB0aGV5IGdldCBwcm9wZXJseSB0cmFuc2ZlcnJlZCB1cC5cbiAgICAvLyAgIGlmIChjdXJyZW50ICYmIGN1cnJlbnQuY2hpbGQgIT09IHdvcmtJblByb2dyZXNzLmNoaWxkKSB7XG4gICAgLy8gICAgIHJldXNlQ2hpbGRyZW5FZmZlY3RzKHdvcmtJblByb2dyZXNzLCBjaGlsZCk7XG4gICAgLy8gICB9XG4gICAgLy8gICByZXR1cm4gbnVsbDtcbiAgICAvLyB9XG5cbiAgICBjbG9uZUNoaWxkRmliZXJzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiBiYWlsb3V0T25Mb3dQcmlvcml0eShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIGNhbmNlbFdvcmtUaW1lcih3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAvLyBUT0RPOiBIYW5kbGUgSG9zdENvbXBvbmVudCB0YWdzIGhlcmUgYXMgd2VsbCBhbmQgY2FsbCBwdXNoSG9zdENvbnRleHQoKT9cbiAgICAvLyBTZWUgUFIgODU5MCBkaXNjdXNzaW9uIGZvciBjb250ZXh0XG4gICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHB1c2hIb3N0Um9vdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHB1c2hDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgcHVzaEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIFRPRE86IFdoYXQgaWYgdGhpcyBpcyBjdXJyZW50bHkgaW4gcHJvZ3Jlc3M/XG4gICAgLy8gSG93IGNhbiB0aGF0IGhhcHBlbj8gSG93IGlzIHRoaXMgbm90IGJlaW5nIGNsb25lZD9cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIFRPRE86IERlbGV0ZSBtZW1vaXplUHJvcHMvU3RhdGUgYW5kIG1vdmUgdG8gcmVjb25jaWxlL2JhaWxvdXQgaW5zdGVhZFxuICBmdW5jdGlvbiBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcykge1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBuZXh0UHJvcHM7XG4gIH1cblxuICBmdW5jdGlvbiBtZW1vaXplU3RhdGUod29ya0luUHJvZ3Jlc3MsIG5leHRTdGF0ZSkge1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgLy8gRG9uJ3QgcmVzZXQgdGhlIHVwZGF0ZVF1ZXVlLCBpbiBjYXNlIHRoZXJlIGFyZSBwZW5kaW5nIHVwZGF0ZXMuIFJlc2V0dGluZ1xuICAgIC8vIGlzIGhhbmRsZWQgYnkgcHJvY2Vzc1VwZGF0ZVF1ZXVlLlxuICB9XG5cbiAgZnVuY3Rpb24gYmVnaW5Xb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID4gcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIHJldHVybiBiYWlsb3V0T25Mb3dQcmlvcml0eShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgIGNhc2UgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuIG1vdW50SW5kZXRlcm1pbmF0ZUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgY2FzZSBGdW5jdGlvbmFsQ29tcG9uZW50OlxuICAgICAgICByZXR1cm4gdXBkYXRlRnVuY3Rpb25hbENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICByZXR1cm4gdXBkYXRlQ2xhc3NDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHJldHVybiB1cGRhdGVIb3N0Um9vdChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICByZXR1cm4gdXBkYXRlSG9zdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUhvc3RUZXh0KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGNhc2UgQ2FsbEhhbmRsZXJQaGFzZTpcbiAgICAgICAgLy8gVGhpcyBpcyBhIHJlc3RhcnQuIFJlc2V0IHRoZSB0YWcgdG8gdGhlIGluaXRpYWwgcGhhc2UuXG4gICAgICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IENhbGxDb21wb25lbnQ7XG4gICAgICAvLyBJbnRlbnRpb25hbGx5IGZhbGwgdGhyb3VnaCBzaW5jZSB0aGlzIGlzIG5vdyB0aGUgc2FtZS5cbiAgICAgIGNhc2UgQ2FsbENvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUNhbGxDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNhc2UgUmV0dXJuQ29tcG9uZW50OlxuICAgICAgICAvLyBBIHJldHVybiBjb21wb25lbnQgaXMganVzdCBhIHBsYWNlaG9sZGVyLCB3ZSBjYW4ganVzdCBydW4gdGhyb3VnaCB0aGVcbiAgICAgICAgLy8gbmV4dCBvbmUgaW1tZWRpYXRlbHkuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICByZXR1cm4gdXBkYXRlUG9ydGFsQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICBjYXNlIEZyYWdtZW50OlxuICAgICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnVW5rbm93biB1bml0IG9mIHdvcmsgdGFnLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGJlZ2luRmFpbGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBQdXNoIGNvbnRleHQgcHJvdmlkZXJzIGhlcmUgdG8gYXZvaWQgYSBwdXNoL3BvcCBjb250ZXh0IG1pc21hdGNoLlxuICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICBwdXNoQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICBwdXNoSG9zdFJvb3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdJbnZhbGlkIHR5cGUgb2Ygd29yay4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgYW4gZXJyb3IgZWZmZWN0IHNvIHdlIGNhbiBoYW5kbGUgdGhlIGVycm9yIGR1cmluZyB0aGUgY29tbWl0IHBoYXNlXG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IEVycjtcblxuICAgIC8vIFRoaXMgaXMgYSB3ZWlyZCBjYXNlIHdoZXJlIHdlIGRvIFwicmVzdW1lXCIgd29yayDigJQgd29yayB0aGF0IGZhaWxlZCBvblxuICAgIC8vIG91ciBmaXJzdCBhdHRlbXB0LiBCZWNhdXNlIHdlIG5vIGxvbmdlciBoYXZlIGEgbm90aW9uIG9mIFwicHJvZ3Jlc3NlZFxuICAgIC8vIGRlbGV0aW9ucyxcIiByZXNldCB0aGUgY2hpbGQgdG8gdGhlIGN1cnJlbnQgY2hpbGQgdG8gbWFrZSBzdXJlIHdlIGRlbGV0ZVxuICAgIC8vIGl0IGFnYWluLiBUT0RPOiBGaW5kIGEgYmV0dGVyIHdheSB0byBoYW5kbGUgdGhpcywgcGVyaGFwcyBkdXJpbmcgYSBtb3JlXG4gICAgLy8gZ2VuZXJhbCBvdmVyaGF1bCBvZiBlcnJvciBoYW5kbGluZy5cbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAod29ya0luUHJvZ3Jlc3MuY2hpbGQgIT09IGN1cnJlbnQuY2hpbGQpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudC5jaGlsZDtcbiAgICB9XG5cbiAgICBpZiAod29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCB3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA+IHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgICByZXR1cm4gYmFpbG91dE9uTG93UHJpb3JpdHkoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGRvbid0IGJhaWwgb3V0LCB3ZSdyZSBnb2luZyBiZSByZWNvbXB1dGluZyBvdXIgY2hpbGRyZW4gc28gd2UgbmVlZFxuICAgIC8vIHRvIGRyb3Agb3VyIGVmZmVjdCBsaXN0LlxuICAgIHdvcmtJblByb2dyZXNzLmZpcnN0RWZmZWN0ID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5sYXN0RWZmZWN0ID0gbnVsbDtcblxuICAgIC8vIFVubW91bnQgdGhlIGN1cnJlbnQgY2hpbGRyZW4gYXMgaWYgdGhlIGNvbXBvbmVudCByZW5kZXJlZCBudWxsXG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IG51bGw7XG4gICAgcmVjb25jaWxlQ2hpbGRyZW5BdEV4cGlyYXRpb25UaW1lKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcblxuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gaW5zdGFuY2UucHJvcHM7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBiZWdpbldvcms6IGJlZ2luV29yayxcbiAgICBiZWdpbkZhaWxlZFdvcms6IGJlZ2luRmFpbGVkV29ya1xuICB9O1xufTtcblxudmFyIFJlYWN0RmliZXJDb21wbGV0ZVdvcmsgPSBmdW5jdGlvbiAoY29uZmlnLCBob3N0Q29udGV4dCwgaHlkcmF0aW9uQ29udGV4dCkge1xuICB2YXIgY3JlYXRlSW5zdGFuY2UgPSBjb25maWcuY3JlYXRlSW5zdGFuY2UsXG4gICAgICBjcmVhdGVUZXh0SW5zdGFuY2UgPSBjb25maWcuY3JlYXRlVGV4dEluc3RhbmNlLFxuICAgICAgYXBwZW5kSW5pdGlhbENoaWxkID0gY29uZmlnLmFwcGVuZEluaXRpYWxDaGlsZCxcbiAgICAgIGZpbmFsaXplSW5pdGlhbENoaWxkcmVuID0gY29uZmlnLmZpbmFsaXplSW5pdGlhbENoaWxkcmVuLFxuICAgICAgcHJlcGFyZVVwZGF0ZSA9IGNvbmZpZy5wcmVwYXJlVXBkYXRlLFxuICAgICAgbXV0YXRpb24gPSBjb25maWcubXV0YXRpb24sXG4gICAgICBwZXJzaXN0ZW5jZSA9IGNvbmZpZy5wZXJzaXN0ZW5jZTtcbiAgdmFyIGdldFJvb3RIb3N0Q29udGFpbmVyID0gaG9zdENvbnRleHQuZ2V0Um9vdEhvc3RDb250YWluZXIsXG4gICAgICBwb3BIb3N0Q29udGV4dCA9IGhvc3RDb250ZXh0LnBvcEhvc3RDb250ZXh0LFxuICAgICAgZ2V0SG9zdENvbnRleHQgPSBob3N0Q29udGV4dC5nZXRIb3N0Q29udGV4dCxcbiAgICAgIHBvcEhvc3RDb250YWluZXIgPSBob3N0Q29udGV4dC5wb3BIb3N0Q29udGFpbmVyO1xuICB2YXIgcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSA9IGh5ZHJhdGlvbkNvbnRleHQucHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSxcbiAgICAgIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlID0gaHlkcmF0aW9uQ29udGV4dC5wcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSxcbiAgICAgIHBvcEh5ZHJhdGlvblN0YXRlID0gaHlkcmF0aW9uQ29udGV4dC5wb3BIeWRyYXRpb25TdGF0ZTtcblxuXG4gIGZ1bmN0aW9uIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpIHtcbiAgICAvLyBUYWcgdGhlIGZpYmVyIHdpdGggYW4gdXBkYXRlIGVmZmVjdC4gVGhpcyB0dXJucyBhIFBsYWNlbWVudCBpbnRvXG4gICAgLy8gYW4gVXBkYXRlQW5kUGxhY2VtZW50LlxuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gIH1cblxuICBmdW5jdGlvbiBtYXJrUmVmKHdvcmtJblByb2dyZXNzKSB7XG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFJlZjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFwcGVuZEFsbFJldHVybnMocmV0dXJucywgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICBpZiAobm9kZSkge1xuICAgICAgbm9kZVsncmV0dXJuJ10gPSB3b3JrSW5Qcm9ncmVzcztcbiAgICB9XG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQgfHwgbm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnQSBjYWxsIGNhbm5vdCBoYXZlIGhvc3QgY29tcG9uZW50IGNoaWxkcmVuLicpO1xuICAgICAgfSBlbHNlIGlmIChub2RlLnRhZyA9PT0gUmV0dXJuQ29tcG9uZW50KSB7XG4gICAgICAgIHJldHVybnMucHVzaChub2RlLnR5cGUpO1xuICAgICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuY2hpbGRbJ3JldHVybiddID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZVsncmV0dXJuJ10gPT09IG51bGwgfHwgbm9kZVsncmV0dXJuJ10gPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgIH1cbiAgICAgIG5vZGUuc2libGluZ1sncmV0dXJuJ10gPSBub2RlWydyZXR1cm4nXTtcbiAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbW92ZUNhbGxUb0hhbmRsZXJQaGFzZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICB2YXIgY2FsbCA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgIWNhbGwgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgYmUgcmVzb2x2ZWQgYnkgbm93LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gICAgLy8gRmlyc3Qgc3RlcCBvZiB0aGUgY2FsbCBoYXMgY29tcGxldGVkLiBOb3cgd2UgbmVlZCB0byBkbyB0aGUgc2Vjb25kLlxuICAgIC8vIFRPRE86IEl0IHdvdWxkIGJlIG5pY2UgdG8gaGF2ZSBhIG11bHRpIHN0YWdlIGNhbGwgcmVwcmVzZW50ZWQgYnkgYVxuICAgIC8vIHNpbmdsZSBjb21wb25lbnQsIG9yIGF0IGxlYXN0IHRhaWwgY2FsbCBvcHRpbWl6ZSBuZXN0ZWQgb25lcy4gQ3VycmVudGx5XG4gICAgLy8gdGhhdCByZXF1aXJlcyBhZGRpdGlvbmFsIGZpZWxkcyB0aGF0IHdlIGRvbid0IHdhbnQgdG8gYWRkIHRvIHRoZSBmaWJlci5cbiAgICAvLyBTbyB0aGlzIHJlcXVpcmVzIG5lc3RlZCBoYW5kbGVycy5cbiAgICAvLyBOb3RlOiBUaGlzIGRvZXNuJ3QgbXV0YXRlIHRoZSBhbHRlcm5hdGUgbm9kZS4gSSBkb24ndCB0aGluayBpdCBuZWVkcyB0b1xuICAgIC8vIHNpbmNlIHRoaXMgc3RhZ2UgaXMgcmVzZXQgZm9yIGV2ZXJ5IHBhc3MuXG4gICAgd29ya0luUHJvZ3Jlc3MudGFnID0gQ2FsbEhhbmRsZXJQaGFzZTtcblxuICAgIC8vIEJ1aWxkIHVwIHRoZSByZXR1cm5zLlxuICAgIC8vIFRPRE86IENvbXBhcmUgdGhpcyB0byBhIGdlbmVyYXRvciBvciBvcGFxdWUgaGVscGVycyBsaWtlIENoaWxkcmVuLlxuICAgIHZhciByZXR1cm5zID0gW107XG4gICAgYXBwZW5kQWxsUmV0dXJucyhyZXR1cm5zLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgdmFyIGZuID0gY2FsbC5oYW5kbGVyO1xuICAgIHZhciBwcm9wcyA9IGNhbGwucHJvcHM7XG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IGZuKHByb3BzLCByZXR1cm5zKTtcblxuICAgIHZhciBjdXJyZW50Rmlyc3RDaGlsZCA9IGN1cnJlbnQgIT09IG51bGwgPyBjdXJyZW50LmNoaWxkIDogbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gYXBwZW5kQWxsQ2hpbGRyZW4ocGFyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGNyZWF0ZWQgYnV0IHdlIG5lZWQgcmVjdXJzZSBkb3duIGl0c1xuICAgIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbiAgICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAgIGFwcGVuZEluaXRpYWxDaGlsZChwYXJlbnQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIHBvcnRhbCBjaGlsZCwgdGhlbiB3ZSBkb24ndCB3YW50IHRvIHRyYXZlcnNlXG4gICAgICAgIC8vIGRvd24gaXRzIGNoaWxkcmVuLiBJbnN0ZWFkLCB3ZSdsbCBnZXQgaW5zZXJ0aW9ucyBmcm9tIGVhY2ggY2hpbGQgaW5cbiAgICAgICAgLy8gdGhlIHBvcnRhbCBkaXJlY3RseS5cbiAgICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlWydyZXR1cm4nXSA9PT0gbnVsbCB8fCBub2RlWydyZXR1cm4nXSA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgfVxuICAgICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH1cblxuICB2YXIgdXBkYXRlSG9zdENvbnRhaW5lciA9IHZvaWQgMDtcbiAgdmFyIHVwZGF0ZUhvc3RDb21wb25lbnQgPSB2b2lkIDA7XG4gIHZhciB1cGRhdGVIb3N0VGV4dCA9IHZvaWQgMDtcbiAgaWYgKG11dGF0aW9uKSB7XG4gICAgaWYgKGVuYWJsZU11dGF0aW5nUmVjb25jaWxlcikge1xuICAgICAgLy8gTXV0YXRpb24gbW9kZVxuICAgICAgdXBkYXRlSG9zdENvbnRhaW5lciA9IGZ1bmN0aW9uICh3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAvLyBOb29wXG4gICAgICB9O1xuICAgICAgdXBkYXRlSG9zdENvbXBvbmVudCA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpIHtcbiAgICAgICAgLy8gVE9ETzogVHlwZSB0aGlzIHNwZWNpZmljIHRvIHRoaXMgdHlwZSBvZiBjb21wb25lbnQuXG4gICAgICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gdXBkYXRlUGF5bG9hZDtcbiAgICAgICAgLy8gSWYgdGhlIHVwZGF0ZSBwYXlsb2FkIGluZGljYXRlcyB0aGF0IHRoZXJlIGlzIGEgY2hhbmdlIG9yIGlmIHRoZXJlXG4gICAgICAgIC8vIGlzIGEgbmV3IHJlZiB3ZSBtYXJrIHRoaXMgYXMgYW4gdXBkYXRlLiBBbGwgdGhlIHdvcmsgaXMgZG9uZSBpbiBjb21taXRXb3JrLlxuICAgICAgICBpZiAodXBkYXRlUGF5bG9hZCkge1xuICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdXBkYXRlSG9zdFRleHQgPSBmdW5jdGlvbiAoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG9sZFRleHQsIG5ld1RleHQpIHtcbiAgICAgICAgLy8gSWYgdGhlIHRleHQgZGlmZmVycywgbWFyayBpdCBhcyBhbiB1cGRhdGUuIEFsbCB0aGUgd29yayBpbiBkb25lIGluIGNvbW1pdFdvcmsuXG4gICAgICAgIGlmIChvbGRUZXh0ICE9PSBuZXdUZXh0KSB7XG4gICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ011dGF0aW5nIHJlY29uY2lsZXIgaXMgZGlzYWJsZWQuJyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHBlcnNpc3RlbmNlKSB7XG4gICAgaWYgKGVuYWJsZVBlcnNpc3RlbnRSZWNvbmNpbGVyKSB7XG4gICAgICAvLyBQZXJzaXN0ZW50IGhvc3QgdHJlZSBtb2RlXG4gICAgICB2YXIgY2xvbmVJbnN0YW5jZSA9IHBlcnNpc3RlbmNlLmNsb25lSW5zdGFuY2UsXG4gICAgICAgICAgY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQgPSBwZXJzaXN0ZW5jZS5jcmVhdGVDb250YWluZXJDaGlsZFNldCxcbiAgICAgICAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyQ2hpbGRTZXQgPSBwZXJzaXN0ZW5jZS5hcHBlbmRDaGlsZFRvQ29udGFpbmVyQ2hpbGRTZXQsXG4gICAgICAgICAgZmluYWxpemVDb250YWluZXJDaGlsZHJlbiA9IHBlcnNpc3RlbmNlLmZpbmFsaXplQ29udGFpbmVyQ2hpbGRyZW47XG5cbiAgICAgIC8vIEFuIHVuZm9ydHVuYXRlIGZvcmsgb2YgYXBwZW5kQWxsQ2hpbGRyZW4gYmVjYXVzZSB3ZSBoYXZlIHR3byBkaWZmZXJlbnQgcGFyZW50IHR5cGVzLlxuXG4gICAgICB2YXIgYXBwZW5kQWxsQ2hpbGRyZW5Ub0NvbnRhaW5lciA9IGZ1bmN0aW9uIChjb250YWluZXJDaGlsZFNldCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgY3JlYXRlZCBidXQgd2UgbmVlZCByZWN1cnNlIGRvd24gaXRzXG4gICAgICAgIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbiAgICAgICAgdmFyIG5vZGUgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAgICAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyQ2hpbGRTZXQoY29udGFpbmVyQ2hpbGRTZXQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgcG9ydGFsIGNoaWxkLCB0aGVuIHdlIGRvbid0IHdhbnQgdG8gdHJhdmVyc2VcbiAgICAgICAgICAgIC8vIGRvd24gaXRzIGNoaWxkcmVuLiBJbnN0ZWFkLCB3ZSdsbCBnZXQgaW5zZXJ0aW9ucyBmcm9tIGVhY2ggY2hpbGQgaW5cbiAgICAgICAgICAgIC8vIHRoZSBwb3J0YWwgZGlyZWN0bHkuXG4gICAgICAgICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobm9kZSA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKG5vZGVbJ3JldHVybiddID09PSBudWxsIHx8IG5vZGVbJ3JldHVybiddID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUuc2libGluZ1sncmV0dXJuJ10gPSBub2RlWydyZXR1cm4nXTtcbiAgICAgICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdXBkYXRlSG9zdENvbnRhaW5lciA9IGZ1bmN0aW9uICh3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICB2YXIgcG9ydGFsT3JSb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICB2YXIgY2hpbGRyZW5VbmNoYW5nZWQgPSB3b3JrSW5Qcm9ncmVzcy5maXJzdEVmZmVjdCA9PT0gbnVsbDtcbiAgICAgICAgaWYgKGNoaWxkcmVuVW5jaGFuZ2VkKSB7XG4gICAgICAgICAgLy8gTm8gY2hhbmdlcywganVzdCByZXVzZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGNvbnRhaW5lciA9IHBvcnRhbE9yUm9vdC5jb250YWluZXJJbmZvO1xuICAgICAgICAgIHZhciBuZXdDaGlsZFNldCA9IGNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0KGNvbnRhaW5lcik7XG4gICAgICAgICAgaWYgKGZpbmFsaXplQ29udGFpbmVyQ2hpbGRyZW4oY29udGFpbmVyLCBuZXdDaGlsZFNldCkpIHtcbiAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwb3J0YWxPclJvb3QucGVuZGluZ0NoaWxkcmVuID0gbmV3Q2hpbGRTZXQ7XG4gICAgICAgICAgLy8gSWYgY2hpbGRyZW4gbWlnaHQgaGF2ZSBjaGFuZ2VkLCB3ZSBoYXZlIHRvIGFkZCB0aGVtIGFsbCB0byB0aGUgc2V0LlxuICAgICAgICAgIGFwcGVuZEFsbENoaWxkcmVuVG9Db250YWluZXIobmV3Q2hpbGRTZXQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAvLyBTY2hlZHVsZSBhbiB1cGRhdGUgb24gdGhlIGNvbnRhaW5lciB0byBzd2FwIG91dCB0aGUgY29udGFpbmVyLlxuICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdXBkYXRlSG9zdENvbXBvbmVudCA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIGVmZmVjdHMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbm9kZSwgdGhlbiBub25lIG9mIG91ciBjaGlsZHJlbiBoYWQgYW55IHVwZGF0ZXMuXG4gICAgICAgIC8vIFRoaXMgZ3VhcmFudGVlcyB0aGF0IHdlIGNhbiByZXVzZSBhbGwgb2YgdGhlbS5cbiAgICAgICAgdmFyIGNoaWxkcmVuVW5jaGFuZ2VkID0gd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3QgPT09IG51bGw7XG4gICAgICAgIHZhciBjdXJyZW50SW5zdGFuY2UgPSBjdXJyZW50LnN0YXRlTm9kZTtcbiAgICAgICAgaWYgKGNoaWxkcmVuVW5jaGFuZ2VkICYmIHVwZGF0ZVBheWxvYWQgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBObyBjaGFuZ2VzLCBqdXN0IHJldXNlIHRoZSBleGlzdGluZyBpbnN0YW5jZS5cbiAgICAgICAgICAvLyBOb3RlIHRoYXQgdGhpcyBtaWdodCByZWxlYXNlIGEgcHJldmlvdXMgY2xvbmUuXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3VycmVudEluc3RhbmNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciByZWN5Y2xhYmxlSW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgICAgdmFyIG5ld0luc3RhbmNlID0gY2xvbmVJbnN0YW5jZShjdXJyZW50SW5zdGFuY2UsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgd29ya0luUHJvZ3Jlc3MsIGNoaWxkcmVuVW5jaGFuZ2VkLCByZWN5Y2xhYmxlSW5zdGFuY2UpO1xuICAgICAgICAgIGlmIChmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbihuZXdJbnN0YW5jZSwgdHlwZSwgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSkpIHtcbiAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBuZXdJbnN0YW5jZTtcbiAgICAgICAgICBpZiAoY2hpbGRyZW5VbmNoYW5nZWQpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBvdGhlciBlZmZlY3RzIGluIHRoaXMgdHJlZSwgd2UgbmVlZCB0byBmbGFnIHRoaXMgbm9kZSBhcyBoYXZpbmcgb25lLlxuICAgICAgICAgICAgLy8gRXZlbiB0aG91Z2ggd2UncmUgbm90IGdvaW5nIHRvIHVzZSBpdCBmb3IgYW55dGhpbmcuXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UgcGFyZW50cyB3b24ndCBrbm93IHRoYXQgdGhlcmUgYXJlIG5ldyBjaGlsZHJlbiB0byBwcm9wYWdhdGUgdXB3YXJkcy5cbiAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBjaGlsZHJlbiBtaWdodCBoYXZlIGNoYW5nZWQsIHdlIGhhdmUgdG8gYWRkIHRoZW0gYWxsIHRvIHRoZSBzZXQuXG4gICAgICAgICAgICBhcHBlbmRBbGxDaGlsZHJlbihuZXdJbnN0YW5jZSwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHVwZGF0ZUhvc3RUZXh0ID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBvbGRUZXh0LCBuZXdUZXh0KSB7XG4gICAgICAgIGlmIChvbGRUZXh0ICE9PSBuZXdUZXh0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIHRleHQgY29udGVudCBkaWZmZXJzLCB3ZSdsbCBjcmVhdGUgYSBuZXcgdGV4dCBpbnN0YW5jZSBmb3IgaXQuXG4gICAgICAgICAgdmFyIHJvb3RDb250YWluZXJJbnN0YW5jZSA9IGdldFJvb3RIb3N0Q29udGFpbmVyKCk7XG4gICAgICAgICAgdmFyIGN1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3JlYXRlVGV4dEluc3RhbmNlKG5ld1RleHQsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgLy8gV2UnbGwgaGF2ZSB0byBtYXJrIGl0IGFzIGhhdmluZyBhbiBlZmZlY3QsIGV2ZW4gdGhvdWdoIHdlIHdvbid0IHVzZSB0aGUgZWZmZWN0IGZvciBhbnl0aGluZy5cbiAgICAgICAgICAvLyBUaGlzIGxldHMgdGhlIHBhcmVudHMga25vdyB0aGF0IGF0IGxlYXN0IG9uZSBvZiB0aGVpciBjaGlsZHJlbiBoYXMgY2hhbmdlZC5cbiAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnUGVyc2lzdGVudCByZWNvbmNpbGVyIGlzIGRpc2FibGVkLicpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZW5hYmxlTm9vcFJlY29uY2lsZXIpIHtcbiAgICAgIC8vIE5vIGhvc3Qgb3BlcmF0aW9uc1xuICAgICAgdXBkYXRlSG9zdENvbnRhaW5lciA9IGZ1bmN0aW9uICh3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAvLyBOb29wXG4gICAgICB9O1xuICAgICAgdXBkYXRlSG9zdENvbXBvbmVudCA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpIHtcbiAgICAgICAgLy8gTm9vcFxuICAgICAgfTtcbiAgICAgIHVwZGF0ZUhvc3RUZXh0ID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBvbGRUZXh0LCBuZXdUZXh0KSB7XG4gICAgICAgIC8vIE5vb3BcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ05vb3AgcmVjb25jaWxlciBpcyBkaXNhYmxlZC4nKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21wbGV0ZVdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gR2V0IHRoZSBsYXRlc3QgcHJvcHMuXG4gICAgdmFyIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIGlmIChuZXdQcm9wcyA9PT0gbnVsbCkge1xuICAgICAgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICAgIH0gZWxzZSBpZiAod29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgIT09IE5ldmVyIHx8IHJlbmRlckV4cGlyYXRpb25UaW1lID09PSBOZXZlcikge1xuICAgICAgLy8gUmVzZXQgdGhlIHBlbmRpbmcgcHJvcHMsIHVubGVzcyB0aGlzIHdhcyBhIGRvd24tcHJpb3JpdGl6YXRpb24uXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMgPSBudWxsO1xuICAgIH1cblxuICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICBjYXNlIEZ1bmN0aW9uYWxDb21wb25lbnQ6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFdlIGFyZSBsZWF2aW5nIHRoaXMgc3VidHJlZSwgc28gcG9wIGNvbnRleHQgaWYgYW55LlxuICAgICAgICAgIHBvcENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHtcbiAgICAgICAgICBwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICBwb3BUb3BMZXZlbENvbnRleHRPYmplY3Qod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHZhciBmaWJlclJvb3QgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgICAgaWYgKGZpYmVyUm9vdC5wZW5kaW5nQ29udGV4dCkge1xuICAgICAgICAgICAgZmliZXJSb290LmNvbnRleHQgPSBmaWJlclJvb3QucGVuZGluZ0NvbnRleHQ7XG4gICAgICAgICAgICBmaWJlclJvb3QucGVuZGluZ0NvbnRleHQgPSBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQuY2hpbGQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGh5ZHJhdGVkLCBwb3Agc28gdGhhdCB3ZSBjYW4gZGVsZXRlIGFueSByZW1haW5pbmcgY2hpbGRyZW5cbiAgICAgICAgICAgIC8vIHRoYXQgd2VyZW4ndCBoeWRyYXRlZC5cbiAgICAgICAgICAgIHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIC8vIFRoaXMgcmVzZXRzIHRoZSBoYWNreSBzdGF0ZSB0byBmaXggaXNNb3VudGVkIGJlZm9yZSBjb21taXR0aW5nLlxuICAgICAgICAgICAgLy8gVE9ETzogRGVsZXRlIHRoaXMgd2hlbiB3ZSBkZWxldGUgaXNNb3VudGVkIGFuZCBmaW5kRE9NTm9kZS5cbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyAmPSB+UGxhY2VtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICB1cGRhdGVIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgcG9wSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHZhciByb290Q29udGFpbmVySW5zdGFuY2UgPSBnZXRSb290SG9zdENvbnRhaW5lcigpO1xuICAgICAgICAgIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhbiBhbHRlcm5hdGUsIHRoYXQgbWVhbnMgdGhpcyBpcyBhbiB1cGRhdGUgYW5kIHdlIG5lZWQgdG9cbiAgICAgICAgICAgIC8vIHNjaGVkdWxlIGEgc2lkZS1lZmZlY3QgdG8gZG8gdGhlIHVwZGF0ZXMuXG4gICAgICAgICAgICB2YXIgb2xkUHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAvLyBJZiB3ZSBnZXQgdXBkYXRlZCBiZWNhdXNlIG9uZSBvZiBvdXIgY2hpbGRyZW4gdXBkYXRlZCwgd2UgZG9uJ3RcbiAgICAgICAgICAgIC8vIGhhdmUgbmV3UHJvcHMgc28gd2UnbGwgaGF2ZSB0byByZXVzZSB0aGVtLlxuICAgICAgICAgICAgLy8gVE9ETzogU3BsaXQgdGhlIHVwZGF0ZSBBUEkgYXMgc2VwYXJhdGUgZm9yIHRoZSBwcm9wcyB2cy4gY2hpbGRyZW4uXG4gICAgICAgICAgICAvLyBFdmVuIGJldHRlciB3b3VsZCBiZSBpZiBjaGlsZHJlbiB3ZXJlbid0IHNwZWNpYWwgY2FzZWQgYXQgYWxsIHRoby5cbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIHZhciBjdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpO1xuICAgICAgICAgICAgdmFyIHVwZGF0ZVBheWxvYWQgPSBwcmVwYXJlVXBkYXRlKGluc3RhbmNlLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0KTtcblxuICAgICAgICAgICAgdXBkYXRlSG9zdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpO1xuXG4gICAgICAgICAgICBpZiAoY3VycmVudC5yZWYgIT09IHdvcmtJblByb2dyZXNzLnJlZikge1xuICAgICAgICAgICAgICBtYXJrUmVmKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFuZXdQcm9wcykge1xuICAgICAgICAgICAgICAhKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdXZSBtdXN0IGhhdmUgbmV3IHByb3BzIGZvciBuZXcgbW91bnRzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiB3ZSBhYm9ydCB3b3JrLlxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIF9jdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpO1xuICAgICAgICAgICAgLy8gVE9ETzogTW92ZSBjcmVhdGVJbnN0YW5jZSB0byBiZWdpbldvcmsgYW5kIGtlZXAgaXQgb24gYSBjb250ZXh0XG4gICAgICAgICAgICAvLyBcInN0YWNrXCIgYXMgdGhlIHBhcmVudC4gVGhlbiBhcHBlbmQgY2hpbGRyZW4gYXMgd2UgZ28gaW4gYmVnaW5Xb3JrXG4gICAgICAgICAgICAvLyBvciBjb21wbGV0ZVdvcmsgZGVwZW5kaW5nIG9uIHdlIHdhbnQgdG8gYWRkIHRoZW4gdG9wLT5kb3duIG9yXG4gICAgICAgICAgICAvLyBib3R0b20tPnVwLiBUb3AtPmRvd24gaXMgZmFzdGVyIGluIElFMTEuXG4gICAgICAgICAgICB2YXIgd2FzSHlkcmF0ZWQgPSBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICBpZiAod2FzSHlkcmF0ZWQpIHtcbiAgICAgICAgICAgICAgLy8gVE9ETzogTW92ZSB0aGlzIGFuZCBjcmVhdGVJbnN0YW5jZSBzdGVwIGludG8gdGhlIGJlZ2luUGhhc2VcbiAgICAgICAgICAgICAgLy8gdG8gY29uc29saWRhdGUuXG4gICAgICAgICAgICAgIGlmIChwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKHdvcmtJblByb2dyZXNzLCByb290Q29udGFpbmVySW5zdGFuY2UsIF9jdXJyZW50SG9zdENvbnRleHQpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgY2hhbmdlcyB0byB0aGUgaHlkcmF0ZWQgbm9kZSBuZWVkcyB0byBiZSBhcHBsaWVkIGF0IHRoZVxuICAgICAgICAgICAgICAgIC8vIGNvbW1pdC1waGFzZSB3ZSBtYXJrIHRoaXMgYXMgc3VjaC5cbiAgICAgICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIF9pbnN0YW5jZSA9IGNyZWF0ZUluc3RhbmNlKHR5cGUsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIF9jdXJyZW50SG9zdENvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcblxuICAgICAgICAgICAgICBhcHBlbmRBbGxDaGlsZHJlbihfaW5zdGFuY2UsIHdvcmtJblByb2dyZXNzKTtcblxuICAgICAgICAgICAgICAvLyBDZXJ0YWluIHJlbmRlcmVycyByZXF1aXJlIGNvbW1pdC10aW1lIGVmZmVjdHMgZm9yIGluaXRpYWwgbW91bnQuXG4gICAgICAgICAgICAgIC8vIChlZyBET00gcmVuZGVyZXIgc3VwcG9ydHMgYXV0by1mb2N1cyBmb3IgY2VydGFpbiBlbGVtZW50cykuXG4gICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBzdWNoIHJlbmRlcmVycyBnZXQgc2NoZWR1bGVkIGZvciBsYXRlciB3b3JrLlxuICAgICAgICAgICAgICBpZiAoZmluYWxpemVJbml0aWFsQ2hpbGRyZW4oX2luc3RhbmNlLCB0eXBlLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKSkge1xuICAgICAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IF9pbnN0YW5jZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLnJlZiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIHJlZiBvbiBhIGhvc3Qgbm9kZSB3ZSBuZWVkIHRvIHNjaGVkdWxlIGEgY2FsbGJhY2tcbiAgICAgICAgICAgICAgbWFya1JlZih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIG5ld1RleHQgPSBuZXdQcm9wcztcbiAgICAgICAgICBpZiAoY3VycmVudCAmJiB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIG9sZFRleHQgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGFuIGFsdGVybmF0ZSwgdGhhdCBtZWFucyB0aGlzIGlzIGFuIHVwZGF0ZSBhbmQgd2UgbmVlZFxuICAgICAgICAgICAgLy8gdG8gc2NoZWR1bGUgYSBzaWRlLWVmZmVjdCB0byBkbyB0aGUgdXBkYXRlcy5cbiAgICAgICAgICAgIHVwZGF0ZUhvc3RUZXh0KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBvbGRUZXh0LCBuZXdUZXh0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBuZXdUZXh0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAhKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdXZSBtdXN0IGhhdmUgbmV3IHByb3BzIGZvciBuZXcgbW91bnRzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiB3ZSBhYm9ydCB3b3JrLlxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfcm9vdENvbnRhaW5lckluc3RhbmNlID0gZ2V0Um9vdEhvc3RDb250YWluZXIoKTtcbiAgICAgICAgICAgIHZhciBfY3VycmVudEhvc3RDb250ZXh0MiA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgICAgICAgICB2YXIgX3dhc0h5ZHJhdGVkID0gcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgaWYgKF93YXNIeWRyYXRlZCkge1xuICAgICAgICAgICAgICBpZiAocHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpKSB7XG4gICAgICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGNyZWF0ZVRleHRJbnN0YW5jZShuZXdUZXh0LCBfcm9vdENvbnRhaW5lckluc3RhbmNlLCBfY3VycmVudEhvc3RDb250ZXh0Miwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgY2FzZSBDYWxsQ29tcG9uZW50OlxuICAgICAgICByZXR1cm4gbW92ZUNhbGxUb0hhbmRsZXJQaGFzZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgY2FzZSBDYWxsSGFuZGxlclBoYXNlOlxuICAgICAgICAvLyBSZXNldCB0aGUgdGFnIHRvIG5vdyBiZSBhIGZpcnN0IHBoYXNlIGNhbGwuXG4gICAgICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IENhbGxDb21wb25lbnQ7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY2FzZSBSZXR1cm5Db21wb25lbnQ6XG4gICAgICAgIC8vIERvZXMgbm90aGluZy5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBjYXNlIEZyYWdtZW50OlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgcG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHVwZGF0ZUhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIC8vIEVycm9yIGNhc2VzXG4gICAgICBjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ0FuIGluZGV0ZXJtaW5hdGUgY29tcG9uZW50IHNob3VsZCBoYXZlIGJlY29tZSBkZXRlcm1pbmF0ZSBiZWZvcmUgY29tcGxldGluZy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnVW5rbm93biB1bml0IG9mIHdvcmsgdGFnLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY29tcGxldGVXb3JrOiBjb21wbGV0ZVdvcmtcbiAgfTtcbn07XG5cbnZhciBpbnZva2VHdWFyZGVkQ2FsbGJhY2skMiA9IFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2s7XG52YXIgaGFzQ2F1Z2h0RXJyb3IkMSA9IFJlYWN0RXJyb3JVdGlscy5oYXNDYXVnaHRFcnJvcjtcbnZhciBjbGVhckNhdWdodEVycm9yJDEgPSBSZWFjdEVycm9yVXRpbHMuY2xlYXJDYXVnaHRFcnJvcjtcblxuXG52YXIgUmVhY3RGaWJlckNvbW1pdFdvcmsgPSBmdW5jdGlvbiAoY29uZmlnLCBjYXB0dXJlRXJyb3IpIHtcbiAgdmFyIGdldFB1YmxpY0luc3RhbmNlID0gY29uZmlnLmdldFB1YmxpY0luc3RhbmNlLFxuICAgICAgbXV0YXRpb24gPSBjb25maWcubXV0YXRpb24sXG4gICAgICBwZXJzaXN0ZW5jZSA9IGNvbmZpZy5wZXJzaXN0ZW5jZTtcblxuXG4gIHZhciBjYWxsQ29tcG9uZW50V2lsbFVubW91bnRXaXRoVGltZXIgPSBmdW5jdGlvbiAoY3VycmVudCwgaW5zdGFuY2UpIHtcbiAgICBzdGFydFBoYXNlVGltZXIoY3VycmVudCwgJ2NvbXBvbmVudFdpbGxVbm1vdW50Jyk7XG4gICAgaW5zdGFuY2UucHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgaW5zdGFuY2Uuc3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVubW91bnQoKTtcbiAgICBzdG9wUGhhc2VUaW1lcigpO1xuICB9O1xuXG4gIC8vIENhcHR1cmUgZXJyb3JzIHNvIHRoZXkgZG9uJ3QgaW50ZXJydXB0IHVubW91bnRpbmcuXG4gIGZ1bmN0aW9uIHNhZmVseUNhbGxDb21wb25lbnRXaWxsVW5tb3VudChjdXJyZW50LCBpbnN0YW5jZSkge1xuICAgIHtcbiAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayQyKG51bGwsIGNhbGxDb21wb25lbnRXaWxsVW5tb3VudFdpdGhUaW1lciwgbnVsbCwgY3VycmVudCwgaW5zdGFuY2UpO1xuICAgICAgaWYgKGhhc0NhdWdodEVycm9yJDEoKSkge1xuICAgICAgICB2YXIgdW5tb3VudEVycm9yID0gY2xlYXJDYXVnaHRFcnJvciQxKCk7XG4gICAgICAgIGNhcHR1cmVFcnJvcihjdXJyZW50LCB1bm1vdW50RXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNhZmVseURldGFjaFJlZihjdXJyZW50KSB7XG4gICAgdmFyIHJlZiA9IGN1cnJlbnQucmVmO1xuICAgIGlmIChyZWYgIT09IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrJDIobnVsbCwgcmVmLCBudWxsLCBudWxsKTtcbiAgICAgICAgaWYgKGhhc0NhdWdodEVycm9yJDEoKSkge1xuICAgICAgICAgIHZhciByZWZFcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IkMSgpO1xuICAgICAgICAgIGNhcHR1cmVFcnJvcihjdXJyZW50LCByZWZFcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXRMaWZlQ3ljbGVzKGN1cnJlbnQsIGZpbmlzaGVkV29yaykge1xuICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgaWYgKGZpbmlzaGVkV29yay5lZmZlY3RUYWcgJiBVcGRhdGUpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHN0YXJ0UGhhc2VUaW1lcihmaW5pc2hlZFdvcmssICdjb21wb25lbnREaWRNb3VudCcpO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5wcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5zdGF0ZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCgpO1xuICAgICAgICAgICAgICBzdG9wUGhhc2VUaW1lcigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHByZXZQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgICAgdmFyIHByZXZTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICAgICAgc3RhcnRQaGFzZVRpbWVyKGZpbmlzaGVkV29yaywgJ2NvbXBvbmVudERpZFVwZGF0ZScpO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5wcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5zdGF0ZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUpO1xuICAgICAgICAgICAgICBzdG9wUGhhc2VUaW1lcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdXBkYXRlUXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG4gICAgICAgICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb21taXRDYWxsYmFja3ModXBkYXRlUXVldWUsIGluc3RhbmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF91cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgICAgICAgICBpZiAoX3VwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgX2luc3RhbmNlID0gZmluaXNoZWRXb3JrLmNoaWxkICE9PSBudWxsID8gZmluaXNoZWRXb3JrLmNoaWxkLnN0YXRlTm9kZSA6IG51bGw7XG4gICAgICAgICAgICBjb21taXRDYWxsYmFja3MoX3VwZGF0ZVF1ZXVlLCBfaW5zdGFuY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfaW5zdGFuY2UyID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcblxuICAgICAgICAgIC8vIFJlbmRlcmVycyBtYXkgc2NoZWR1bGUgd29yayB0byBiZSBkb25lIGFmdGVyIGhvc3QgY29tcG9uZW50cyBhcmUgbW91bnRlZFxuICAgICAgICAgIC8vIChlZyBET00gcmVuZGVyZXIgbWF5IHNjaGVkdWxlIGF1dG8tZm9jdXMgZm9yIGlucHV0cyBhbmQgZm9ybSBjb250cm9scykuXG4gICAgICAgICAgLy8gVGhlc2UgZWZmZWN0cyBzaG91bGQgb25seSBiZSBjb21taXR0ZWQgd2hlbiBjb21wb25lbnRzIGFyZSBmaXJzdCBtb3VudGVkLFxuICAgICAgICAgIC8vIGFrYSB3aGVuIHRoZXJlIGlzIG5vIGN1cnJlbnQvYWx0ZXJuYXRlLlxuICAgICAgICAgIGlmIChjdXJyZW50ID09PSBudWxsICYmIGZpbmlzaGVkV29yay5lZmZlY3RUYWcgJiBVcGRhdGUpIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gZmluaXNoZWRXb3JrLnR5cGU7XG4gICAgICAgICAgICB2YXIgcHJvcHMgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgIGNvbW1pdE1vdW50KF9pbnN0YW5jZTIsIHR5cGUsIHByb3BzLCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFdlIGhhdmUgbm8gbGlmZS1jeWNsZXMgYXNzb2NpYXRlZCB3aXRoIHRleHQuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBXZSBoYXZlIG5vIGxpZmUtY3ljbGVzIGFzc29jaWF0ZWQgd2l0aCBwb3J0YWxzLlxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIGludmFyaWFudChmYWxzZSwgJ1RoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0QXR0YWNoUmVmKGZpbmlzaGVkV29yaykge1xuICAgIHZhciByZWYgPSBmaW5pc2hlZFdvcmsucmVmO1xuICAgIGlmIChyZWYgIT09IG51bGwpIHtcbiAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgIHJlZihnZXRQdWJsaWNJbnN0YW5jZShpbnN0YW5jZSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlZihpbnN0YW5jZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0RGV0YWNoUmVmKGN1cnJlbnQpIHtcbiAgICB2YXIgY3VycmVudFJlZiA9IGN1cnJlbnQucmVmO1xuICAgIGlmIChjdXJyZW50UmVmICE9PSBudWxsKSB7XG4gICAgICBjdXJyZW50UmVmKG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFVzZXItb3JpZ2luYXRpbmcgZXJyb3JzIChsaWZlY3ljbGVzIGFuZCByZWZzKSBzaG91bGQgbm90IGludGVycnVwdFxuICAvLyBkZWxldGlvbiwgc28gZG9uJ3QgbGV0IHRoZW0gdGhyb3cuIEhvc3Qtb3JpZ2luYXRpbmcgZXJyb3JzIHNob3VsZFxuICAvLyBpbnRlcnJ1cHQgZGVsZXRpb24sIHNvIGl0J3Mgb2theVxuICBmdW5jdGlvbiBjb21taXRVbm1vdW50KGN1cnJlbnQpIHtcbiAgICBpZiAodHlwZW9mIG9uQ29tbWl0VW5tb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb25Db21taXRVbm1vdW50KGN1cnJlbnQpO1xuICAgIH1cblxuICAgIHN3aXRjaCAoY3VycmVudC50YWcpIHtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCk7XG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gY3VycmVudC5zdGF0ZU5vZGU7XG4gICAgICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVW5tb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50KGN1cnJlbnQsIGluc3RhbmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIENhbGxDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBjb21taXROZXN0ZWRVbm1vdW50cyhjdXJyZW50LnN0YXRlTm9kZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBUT0RPOiB0aGlzIGlzIHJlY3Vyc2l2ZS5cbiAgICAgICAgICAvLyBXZSBhcmUgYWxzbyBub3QgdXNpbmcgdGhpcyBwYXJlbnQgYmVjYXVzZVxuICAgICAgICAgIC8vIHRoZSBwb3J0YWwgd2lsbCBnZXQgcHVzaGVkIGltbWVkaWF0ZWx5LlxuICAgICAgICAgIGlmIChlbmFibGVNdXRhdGluZ1JlY29uY2lsZXIgJiYgbXV0YXRpb24pIHtcbiAgICAgICAgICAgIHVubW91bnRIb3N0Q29tcG9uZW50cyhjdXJyZW50KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGVuYWJsZVBlcnNpc3RlbnRSZWNvbmNpbGVyICYmIHBlcnNpc3RlbmNlKSB7XG4gICAgICAgICAgICBlbXB0eVBvcnRhbENvbnRhaW5lcihjdXJyZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0TmVzdGVkVW5tb3VudHMocm9vdCkge1xuICAgIC8vIFdoaWxlIHdlJ3JlIGluc2lkZSBhIHJlbW92ZWQgaG9zdCBub2RlIHdlIGRvbid0IHdhbnQgdG8gY2FsbFxuICAgIC8vIHJlbW92ZUNoaWxkIG9uIHRoZSBpbm5lciBub2RlcyBiZWNhdXNlIHRoZXkncmUgcmVtb3ZlZCBieSB0aGUgdG9wXG4gICAgLy8gY2FsbCBhbnl3YXkuIFdlIGFsc28gd2FudCB0byBjYWxsIGNvbXBvbmVudFdpbGxVbm1vdW50IG9uIGFsbFxuICAgIC8vIGNvbXBvc2l0ZXMgYmVmb3JlIHRoaXMgaG9zdCBub2RlIGlzIHJlbW92ZWQgZnJvbSB0aGUgdHJlZS4gVGhlcmVmb3JlXG4gICAgdmFyIG5vZGUgPSByb290O1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb21taXRVbm1vdW50KG5vZGUpO1xuICAgICAgLy8gVmlzaXQgY2hpbGRyZW4gYmVjYXVzZSB0aGV5IG1heSBjb250YWluIG1vcmUgY29tcG9zaXRlIG9yIGhvc3Qgbm9kZXMuXG4gICAgICAvLyBTa2lwIHBvcnRhbHMgYmVjYXVzZSBjb21taXRVbm1vdW50KCkgY3VycmVudGx5IHZpc2l0cyB0aGVtIHJlY3Vyc2l2ZWx5LlxuICAgICAgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwgJiYgKFxuICAgICAgLy8gSWYgd2UgdXNlIG11dGF0aW9uIHdlIGRyaWxsIGRvd24gaW50byBwb3J0YWxzIHVzaW5nIGNvbW1pdFVubW91bnQgYWJvdmUuXG4gICAgICAvLyBJZiB3ZSBkb24ndCB1c2UgbXV0YXRpb24gd2UgZHJpbGwgZG93biBpbnRvIHBvcnRhbHMgaGVyZSBpbnN0ZWFkLlxuICAgICAgIW11dGF0aW9uIHx8IG5vZGUudGFnICE9PSBIb3N0UG9ydGFsKSkge1xuICAgICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlID09PSByb290KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGVbJ3JldHVybiddID09PSBudWxsIHx8IG5vZGVbJ3JldHVybiddID09PSByb290KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgIH1cbiAgICAgIG5vZGUuc2libGluZ1sncmV0dXJuJ10gPSBub2RlWydyZXR1cm4nXTtcbiAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGV0YWNoRmliZXIoY3VycmVudCkge1xuICAgIC8vIEN1dCBvZmYgdGhlIHJldHVybiBwb2ludGVycyB0byBkaXNjb25uZWN0IGl0IGZyb20gdGhlIHRyZWUuIElkZWFsbHksIHdlXG4gICAgLy8gc2hvdWxkIGNsZWFyIHRoZSBjaGlsZCBwb2ludGVyIG9mIHRoZSBwYXJlbnQgYWx0ZXJuYXRlIHRvIGxldCB0aGlzXG4gICAgLy8gZ2V0IEdDOmVkIGJ1dCB3ZSBkb24ndCBrbm93IHdoaWNoIGZvciBzdXJlIHdoaWNoIHBhcmVudCBpcyB0aGUgY3VycmVudFxuICAgIC8vIG9uZSBzbyB3ZSdsbCBzZXR0bGUgZm9yIEdDOmluZyB0aGUgc3VidHJlZSBvZiB0aGlzIGNoaWxkLiBUaGlzIGNoaWxkXG4gICAgLy8gaXRzZWxmIHdpbGwgYmUgR0M6ZWQgd2hlbiB0aGUgcGFyZW50IHVwZGF0ZXMgdGhlIG5leHQgdGltZS5cbiAgICBjdXJyZW50WydyZXR1cm4nXSA9IG51bGw7XG4gICAgY3VycmVudC5jaGlsZCA9IG51bGw7XG4gICAgaWYgKGN1cnJlbnQuYWx0ZXJuYXRlKSB7XG4gICAgICBjdXJyZW50LmFsdGVybmF0ZS5jaGlsZCA9IG51bGw7XG4gICAgICBjdXJyZW50LmFsdGVybmF0ZVsncmV0dXJuJ10gPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGlmICghbXV0YXRpb24pIHtcbiAgICB2YXIgY29tbWl0Q29udGFpbmVyID0gdm9pZCAwO1xuICAgIGlmIChwZXJzaXN0ZW5jZSkge1xuICAgICAgdmFyIHJlcGxhY2VDb250YWluZXJDaGlsZHJlbiA9IHBlcnNpc3RlbmNlLnJlcGxhY2VDb250YWluZXJDaGlsZHJlbixcbiAgICAgICAgICBjcmVhdGVDb250YWluZXJDaGlsZFNldCA9IHBlcnNpc3RlbmNlLmNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0O1xuXG4gICAgICB2YXIgZW1wdHlQb3J0YWxDb250YWluZXIgPSBmdW5jdGlvbiAoY3VycmVudCkge1xuICAgICAgICB2YXIgcG9ydGFsID0gY3VycmVudC5zdGF0ZU5vZGU7XG4gICAgICAgIHZhciBjb250YWluZXJJbmZvID0gcG9ydGFsLmNvbnRhaW5lckluZm87XG5cbiAgICAgICAgdmFyIGVtcHR5Q2hpbGRTZXQgPSBjcmVhdGVDb250YWluZXJDaGlsZFNldChjb250YWluZXJJbmZvKTtcbiAgICAgICAgcmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuKGNvbnRhaW5lckluZm8sIGVtcHR5Q2hpbGRTZXQpO1xuICAgICAgfTtcbiAgICAgIGNvbW1pdENvbnRhaW5lciA9IGZ1bmN0aW9uIChmaW5pc2hlZFdvcmspIHtcbiAgICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIHBvcnRhbE9yUm9vdCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgIHZhciBjb250YWluZXJJbmZvID0gcG9ydGFsT3JSb290LmNvbnRhaW5lckluZm8sXG4gICAgICAgICAgICAgICAgICBfcGVuZGluZ0NoaWxkcmVuID0gcG9ydGFsT3JSb290LnBlbmRpbmdDaGlsZHJlbjtcblxuICAgICAgICAgICAgICByZXBsYWNlQ29udGFpbmVyQ2hpbGRyZW4oY29udGFpbmVySW5mbywgX3BlbmRpbmdDaGlsZHJlbik7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdUaGlzIHVuaXQgb2Ygd29yayB0YWcgc2hvdWxkIG5vdCBoYXZlIHNpZGUtZWZmZWN0cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29tbWl0Q29udGFpbmVyID0gZnVuY3Rpb24gKGZpbmlzaGVkV29yaykge1xuICAgICAgICAvLyBOb29wXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoZW5hYmxlUGVyc2lzdGVudFJlY29uY2lsZXIgfHwgZW5hYmxlTm9vcFJlY29uY2lsZXIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbW1pdFJlc2V0VGV4dENvbnRlbnQ6IGZ1bmN0aW9uIChmaW5pc2hlZFdvcmspIHt9LFxuICAgICAgICBjb21taXRQbGFjZW1lbnQ6IGZ1bmN0aW9uIChmaW5pc2hlZFdvcmspIHt9LFxuICAgICAgICBjb21taXREZWxldGlvbjogZnVuY3Rpb24gKGN1cnJlbnQpIHtcbiAgICAgICAgICAvLyBEZXRhY2ggcmVmcyBhbmQgY2FsbCBjb21wb25lbnRXaWxsVW5tb3VudCgpIG9uIHRoZSB3aG9sZSBzdWJ0cmVlLlxuICAgICAgICAgIGNvbW1pdE5lc3RlZFVubW91bnRzKGN1cnJlbnQpO1xuICAgICAgICAgIGRldGFjaEZpYmVyKGN1cnJlbnQpO1xuICAgICAgICB9LFxuICAgICAgICBjb21taXRXb3JrOiBmdW5jdGlvbiAoY3VycmVudCwgZmluaXNoZWRXb3JrKSB7XG4gICAgICAgICAgY29tbWl0Q29udGFpbmVyKGZpbmlzaGVkV29yayk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29tbWl0TGlmZUN5Y2xlczogY29tbWl0TGlmZUN5Y2xlcyxcbiAgICAgICAgY29tbWl0QXR0YWNoUmVmOiBjb21taXRBdHRhY2hSZWYsXG4gICAgICAgIGNvbW1pdERldGFjaFJlZjogY29tbWl0RGV0YWNoUmVmXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAocGVyc2lzdGVuY2UpIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ1BlcnNpc3RlbnQgcmVjb25jaWxlciBpcyBkaXNhYmxlZC4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnTm9vcCByZWNvbmNpbGVyIGlzIGRpc2FibGVkLicpO1xuICAgIH1cbiAgfVxuICB2YXIgY29tbWl0TW91bnQgPSBtdXRhdGlvbi5jb21taXRNb3VudCxcbiAgICAgIGNvbW1pdFVwZGF0ZSA9IG11dGF0aW9uLmNvbW1pdFVwZGF0ZSxcbiAgICAgIHJlc2V0VGV4dENvbnRlbnQgPSBtdXRhdGlvbi5yZXNldFRleHRDb250ZW50LFxuICAgICAgY29tbWl0VGV4dFVwZGF0ZSA9IG11dGF0aW9uLmNvbW1pdFRleHRVcGRhdGUsXG4gICAgICBhcHBlbmRDaGlsZCA9IG11dGF0aW9uLmFwcGVuZENoaWxkLFxuICAgICAgYXBwZW5kQ2hpbGRUb0NvbnRhaW5lciA9IG11dGF0aW9uLmFwcGVuZENoaWxkVG9Db250YWluZXIsXG4gICAgICBpbnNlcnRCZWZvcmUgPSBtdXRhdGlvbi5pbnNlcnRCZWZvcmUsXG4gICAgICBpbnNlcnRJbkNvbnRhaW5lckJlZm9yZSA9IG11dGF0aW9uLmluc2VydEluQ29udGFpbmVyQmVmb3JlLFxuICAgICAgcmVtb3ZlQ2hpbGQgPSBtdXRhdGlvbi5yZW1vdmVDaGlsZCxcbiAgICAgIHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lciA9IG11dGF0aW9uLnJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcjtcblxuXG4gIGZ1bmN0aW9uIGdldEhvc3RQYXJlbnRGaWJlcihmaWJlcikge1xuICAgIHZhciBwYXJlbnQgPSBmaWJlclsncmV0dXJuJ107XG4gICAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGlzSG9zdFBhcmVudChwYXJlbnQpKSB7XG4gICAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnRbJ3JldHVybiddO1xuICAgIH1cbiAgICBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCB0byBmaW5kIGEgaG9zdCBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0hvc3RQYXJlbnQoZmliZXIpIHtcbiAgICByZXR1cm4gZmliZXIudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IGZpYmVyLnRhZyA9PT0gSG9zdFJvb3QgfHwgZmliZXIudGFnID09PSBIb3N0UG9ydGFsO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SG9zdFNpYmxpbmcoZmliZXIpIHtcbiAgICAvLyBXZSdyZSBnb2luZyB0byBzZWFyY2ggZm9yd2FyZCBpbnRvIHRoZSB0cmVlIHVudGlsIHdlIGZpbmQgYSBzaWJsaW5nIGhvc3RcbiAgICAvLyBub2RlLiBVbmZvcnR1bmF0ZWx5LCBpZiBtdWx0aXBsZSBpbnNlcnRpb25zIGFyZSBkb25lIGluIGEgcm93IHdlIGhhdmUgdG9cbiAgICAvLyBzZWFyY2ggcGFzdCB0aGVtLiBUaGlzIGxlYWRzIHRvIGV4cG9uZW50aWFsIHNlYXJjaCBmb3IgdGhlIG5leHQgc2libGluZy5cbiAgICB2YXIgbm9kZSA9IGZpYmVyO1xuICAgIHNpYmxpbmdzOiB3aGlsZSAodHJ1ZSkge1xuICAgICAgLy8gSWYgd2UgZGlkbid0IGZpbmQgYW55dGhpbmcsIGxldCdzIHRyeSB0aGUgbmV4dCBzaWJsaW5nLlxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZVsncmV0dXJuJ10gPT09IG51bGwgfHwgaXNIb3N0UGFyZW50KG5vZGVbJ3JldHVybiddKSkge1xuICAgICAgICAgIC8vIElmIHdlIHBvcCBvdXQgb2YgdGhlIHJvb3Qgb3IgaGl0IHRoZSBwYXJlbnQgdGhlIGZpYmVyIHdlIGFyZSB0aGVcbiAgICAgICAgICAvLyBsYXN0IHNpYmxpbmcuXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgfVxuICAgICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICAgIHdoaWxlIChub2RlLnRhZyAhPT0gSG9zdENvbXBvbmVudCAmJiBub2RlLnRhZyAhPT0gSG9zdFRleHQpIHtcbiAgICAgICAgLy8gSWYgaXQgaXMgbm90IGhvc3Qgbm9kZSBhbmQsIHdlIG1pZ2h0IGhhdmUgYSBob3N0IG5vZGUgaW5zaWRlIGl0LlxuICAgICAgICAvLyBUcnkgdG8gc2VhcmNoIGRvd24gdW50aWwgd2UgZmluZCBvbmUuXG4gICAgICAgIGlmIChub2RlLmVmZmVjdFRhZyAmIFBsYWNlbWVudCkge1xuICAgICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBjaGlsZCwgdHJ5IHRoZSBzaWJsaW5ncyBpbnN0ZWFkLlxuICAgICAgICAgIGNvbnRpbnVlIHNpYmxpbmdzO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBjaGlsZCwgdHJ5IHRoZSBzaWJsaW5ncyBpbnN0ZWFkLlxuICAgICAgICAvLyBXZSBhbHNvIHNraXAgcG9ydGFscyBiZWNhdXNlIHRoZXkgYXJlIG5vdCBwYXJ0IG9mIHRoaXMgaG9zdCB0cmVlLlxuICAgICAgICBpZiAobm9kZS5jaGlsZCA9PT0gbnVsbCB8fCBub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgICAgIGNvbnRpbnVlIHNpYmxpbmdzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUuY2hpbGRbJ3JldHVybiddID0gbm9kZTtcbiAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBob3N0IG5vZGUgaXMgc3RhYmxlIG9yIGFib3V0IHRvIGJlIHBsYWNlZC5cbiAgICAgIGlmICghKG5vZGUuZWZmZWN0VGFnICYgUGxhY2VtZW50KSkge1xuICAgICAgICAvLyBGb3VuZCBpdCFcbiAgICAgICAgcmV0dXJuIG5vZGUuc3RhdGVOb2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdFBsYWNlbWVudChmaW5pc2hlZFdvcmspIHtcbiAgICAvLyBSZWN1cnNpdmVseSBpbnNlcnQgYWxsIGhvc3Qgbm9kZXMgaW50byB0aGUgcGFyZW50LlxuICAgIHZhciBwYXJlbnRGaWJlciA9IGdldEhvc3RQYXJlbnRGaWJlcihmaW5pc2hlZFdvcmspO1xuICAgIHZhciBwYXJlbnQgPSB2b2lkIDA7XG4gICAgdmFyIGlzQ29udGFpbmVyID0gdm9pZCAwO1xuICAgIHN3aXRjaCAocGFyZW50RmliZXIudGFnKSB7XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHBhcmVudCA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgaXNDb250YWluZXIgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICBwYXJlbnQgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgaXNDb250YWluZXIgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgcGFyZW50ID0gcGFyZW50RmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgIGlzQ29udGFpbmVyID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdJbnZhbGlkIGhvc3QgcGFyZW50IGZpYmVyLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgICBpZiAocGFyZW50RmliZXIuZWZmZWN0VGFnICYgQ29udGVudFJlc2V0KSB7XG4gICAgICAvLyBSZXNldCB0aGUgdGV4dCBjb250ZW50IG9mIHRoZSBwYXJlbnQgYmVmb3JlIGRvaW5nIGFueSBpbnNlcnRpb25zXG4gICAgICByZXNldFRleHRDb250ZW50KHBhcmVudCk7XG4gICAgICAvLyBDbGVhciBDb250ZW50UmVzZXQgZnJvbSB0aGUgZWZmZWN0IHRhZ1xuICAgICAgcGFyZW50RmliZXIuZWZmZWN0VGFnICY9IH5Db250ZW50UmVzZXQ7XG4gICAgfVxuXG4gICAgdmFyIGJlZm9yZSA9IGdldEhvc3RTaWJsaW5nKGZpbmlzaGVkV29yayk7XG4gICAgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgaW5zZXJ0ZWQgYnV0IHdlIG5lZWQgcmVjdXJzZSBkb3duIGl0c1xuICAgIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbiAgICB2YXIgbm9kZSA9IGZpbmlzaGVkV29yaztcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgICAgaWYgKGlzQ29udGFpbmVyKSB7XG4gICAgICAgICAgICBpbnNlcnRJbkNvbnRhaW5lckJlZm9yZShwYXJlbnQsIG5vZGUuc3RhdGVOb2RlLCBiZWZvcmUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnNlcnRCZWZvcmUocGFyZW50LCBub2RlLnN0YXRlTm9kZSwgYmVmb3JlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGlzQ29udGFpbmVyKSB7XG4gICAgICAgICAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyKHBhcmVudCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcHBlbmRDaGlsZChwYXJlbnQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgLy8gSWYgdGhlIGluc2VydGlvbiBpdHNlbGYgaXMgYSBwb3J0YWwsIHRoZW4gd2UgZG9uJ3Qgd2FudCB0byB0cmF2ZXJzZVxuICAgICAgICAvLyBkb3duIGl0cyBjaGlsZHJlbi4gSW5zdGVhZCwgd2UnbGwgZ2V0IGluc2VydGlvbnMgZnJvbSBlYWNoIGNoaWxkIGluXG4gICAgICAgIC8vIHRoZSBwb3J0YWwgZGlyZWN0bHkuXG4gICAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZS5jaGlsZFsncmV0dXJuJ10gPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAobm9kZSA9PT0gZmluaXNoZWRXb3JrKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGVbJ3JldHVybiddID09PSBudWxsIHx8IG5vZGVbJ3JldHVybiddID09PSBmaW5pc2hlZFdvcmspIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgfVxuICAgICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1bm1vdW50SG9zdENvbXBvbmVudHMoY3VycmVudCkge1xuICAgIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGluc2VydGVkIGJ1dCB3ZSBuZWVkIHJlY3Vyc2UgZG93biBpdHNcbiAgICB2YXIgbm9kZSA9IGN1cnJlbnQ7XG5cbiAgICAvLyBFYWNoIGl0ZXJhdGlvbiwgY3VycmVudFBhcmVudCBpcyBwb3B1bGF0ZWQgd2l0aCBub2RlJ3MgaG9zdCBwYXJlbnQgaWYgbm90XG4gICAgLy8gY3VycmVudFBhcmVudElzVmFsaWQuXG4gICAgdmFyIGN1cnJlbnRQYXJlbnRJc1ZhbGlkID0gZmFsc2U7XG4gICAgdmFyIGN1cnJlbnRQYXJlbnQgPSB2b2lkIDA7XG4gICAgdmFyIGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciA9IHZvaWQgMDtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAoIWN1cnJlbnRQYXJlbnRJc1ZhbGlkKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgICAgZmluZFBhcmVudDogd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAhKHBhcmVudCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCB0byBmaW5kIGEgaG9zdCBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICAgICAgc3dpdGNoIChwYXJlbnQudGFnKSB7XG4gICAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICBjdXJyZW50UGFyZW50SXNDb250YWluZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWsgZmluZFBhcmVudDtcbiAgICAgICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrIGZpbmRQYXJlbnQ7XG4gICAgICAgICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrIGZpbmRQYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcmVudCA9IHBhcmVudFsncmV0dXJuJ107XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFBhcmVudElzVmFsaWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAgIGNvbW1pdE5lc3RlZFVubW91bnRzKG5vZGUpO1xuICAgICAgICAvLyBBZnRlciBhbGwgdGhlIGNoaWxkcmVuIGhhdmUgdW5tb3VudGVkLCBpdCBpcyBub3cgc2FmZSB0byByZW1vdmUgdGhlXG4gICAgICAgIC8vIG5vZGUgZnJvbSB0aGUgdHJlZS5cbiAgICAgICAgaWYgKGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lcikge1xuICAgICAgICAgIHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcihjdXJyZW50UGFyZW50LCBub2RlLnN0YXRlTm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVtb3ZlQ2hpbGQoY3VycmVudFBhcmVudCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvbid0IHZpc2l0IGNoaWxkcmVuIGJlY2F1c2Ugd2UgYWxyZWFkeSB2aXNpdGVkIHRoZW0uXG4gICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgIC8vIFdoZW4gd2UgZ28gaW50byBhIHBvcnRhbCwgaXQgYmVjb21lcyB0aGUgcGFyZW50IHRvIHJlbW92ZSBmcm9tLlxuICAgICAgICAvLyBXZSB3aWxsIHJlYXNzaWduIGl0IGJhY2sgd2hlbiB3ZSBwb3AgdGhlIHBvcnRhbCBvbiB0aGUgd2F5IHVwLlxuICAgICAgICBjdXJyZW50UGFyZW50ID0gbm9kZS5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgLy8gVmlzaXQgY2hpbGRyZW4gYmVjYXVzZSBwb3J0YWxzIG1pZ2h0IGNvbnRhaW4gaG9zdCBjb21wb25lbnRzLlxuICAgICAgICBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgIG5vZGUuY2hpbGRbJ3JldHVybiddID0gbm9kZTtcbiAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tbWl0VW5tb3VudChub2RlKTtcbiAgICAgICAgLy8gVmlzaXQgY2hpbGRyZW4gYmVjYXVzZSB3ZSBtYXkgZmluZCBtb3JlIGhvc3QgY29tcG9uZW50cyBiZWxvdy5cbiAgICAgICAgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChub2RlID09PSBjdXJyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGVbJ3JldHVybiddID09PSBudWxsIHx8IG5vZGVbJ3JldHVybiddID09PSBjdXJyZW50KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgICAgLy8gV2hlbiB3ZSBnbyBvdXQgb2YgdGhlIHBvcnRhbCwgd2UgbmVlZCB0byByZXN0b3JlIHRoZSBwYXJlbnQuXG4gICAgICAgICAgLy8gU2luY2Ugd2UgZG9uJ3Qga2VlcCBhIHN0YWNrIG9mIHRoZW0sIHdlIHdpbGwgc2VhcmNoIGZvciBpdC5cbiAgICAgICAgICBjdXJyZW50UGFyZW50SXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBub2RlLnNpYmxpbmdbJ3JldHVybiddID0gbm9kZVsncmV0dXJuJ107XG4gICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdERlbGV0aW9uKGN1cnJlbnQpIHtcbiAgICAvLyBSZWN1cnNpdmVseSBkZWxldGUgYWxsIGhvc3Qgbm9kZXMgZnJvbSB0aGUgcGFyZW50LlxuICAgIC8vIERldGFjaCByZWZzIGFuZCBjYWxsIGNvbXBvbmVudFdpbGxVbm1vdW50KCkgb24gdGhlIHdob2xlIHN1YnRyZWUuXG4gICAgdW5tb3VudEhvc3RDb21wb25lbnRzKGN1cnJlbnQpO1xuICAgIGRldGFjaEZpYmVyKGN1cnJlbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0V29yayhjdXJyZW50LCBmaW5pc2hlZFdvcmspIHtcbiAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgaWYgKGluc3RhbmNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIENvbW1pdCB0aGUgd29yayBwcmVwYXJlZCBlYXJsaWVyLlxuICAgICAgICAgICAgdmFyIG5ld1Byb3BzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAvLyBGb3IgaHlkcmF0aW9uIHdlIHJldXNlIHRoZSB1cGRhdGUgcGF0aCBidXQgd2UgdHJlYXQgdGhlIG9sZFByb3BzXG4gICAgICAgICAgICAvLyBhcyB0aGUgbmV3UHJvcHMuIFRoZSB1cGRhdGVQYXlsb2FkIHdpbGwgY29udGFpbiB0aGUgcmVhbCBjaGFuZ2UgaW5cbiAgICAgICAgICAgIC8vIHRoaXMgY2FzZS5cbiAgICAgICAgICAgIHZhciBvbGRQcm9wcyA9IGN1cnJlbnQgIT09IG51bGwgPyBjdXJyZW50Lm1lbW9pemVkUHJvcHMgOiBuZXdQcm9wcztcbiAgICAgICAgICAgIHZhciB0eXBlID0gZmluaXNoZWRXb3JrLnR5cGU7XG4gICAgICAgICAgICAvLyBUT0RPOiBUeXBlIHRoZSB1cGRhdGVRdWV1ZSB0byBiZSBzcGVjaWZpYyB0byBob3N0IGNvbXBvbmVudHMuXG4gICAgICAgICAgICB2YXIgdXBkYXRlUGF5bG9hZCA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgICAgICAgICAgIGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSA9IG51bGw7XG4gICAgICAgICAgICBpZiAodXBkYXRlUGF5bG9hZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBjb21taXRVcGRhdGUoaW5zdGFuY2UsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICB7XG4gICAgICAgICAgIShmaW5pc2hlZFdvcmsuc3RhdGVOb2RlICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1RoaXMgc2hvdWxkIGhhdmUgYSB0ZXh0IG5vZGUgaW5pdGlhbGl6ZWQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICAgICAgdmFyIHRleHRJbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgdmFyIG5ld1RleHQgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAvLyBGb3IgaHlkcmF0aW9uIHdlIHJldXNlIHRoZSB1cGRhdGUgcGF0aCBidXQgd2UgdHJlYXQgdGhlIG9sZFByb3BzXG4gICAgICAgICAgLy8gYXMgdGhlIG5ld1Byb3BzLiBUaGUgdXBkYXRlUGF5bG9hZCB3aWxsIGNvbnRhaW4gdGhlIHJlYWwgY2hhbmdlIGluXG4gICAgICAgICAgLy8gdGhpcyBjYXNlLlxuICAgICAgICAgIHZhciBvbGRUZXh0ID0gY3VycmVudCAhPT0gbnVsbCA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyA6IG5ld1RleHQ7XG4gICAgICAgICAgY29tbWl0VGV4dFVwZGF0ZSh0ZXh0SW5zdGFuY2UsIG9sZFRleHQsIG5ld1RleHQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIGludmFyaWFudChmYWxzZSwgJ1RoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0UmVzZXRUZXh0Q29udGVudChjdXJyZW50KSB7XG4gICAgcmVzZXRUZXh0Q29udGVudChjdXJyZW50LnN0YXRlTm9kZSk7XG4gIH1cblxuICBpZiAoZW5hYmxlTXV0YXRpbmdSZWNvbmNpbGVyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbW1pdFJlc2V0VGV4dENvbnRlbnQ6IGNvbW1pdFJlc2V0VGV4dENvbnRlbnQsXG4gICAgICBjb21taXRQbGFjZW1lbnQ6IGNvbW1pdFBsYWNlbWVudCxcbiAgICAgIGNvbW1pdERlbGV0aW9uOiBjb21taXREZWxldGlvbixcbiAgICAgIGNvbW1pdFdvcms6IGNvbW1pdFdvcmssXG4gICAgICBjb21taXRMaWZlQ3ljbGVzOiBjb21taXRMaWZlQ3ljbGVzLFxuICAgICAgY29tbWl0QXR0YWNoUmVmOiBjb21taXRBdHRhY2hSZWYsXG4gICAgICBjb21taXREZXRhY2hSZWY6IGNvbW1pdERldGFjaFJlZlxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgaW52YXJpYW50KGZhbHNlLCAnTXV0YXRpbmcgcmVjb25jaWxlciBpcyBkaXNhYmxlZC4nKTtcbiAgfVxufTtcblxudmFyIE5PX0NPTlRFWFQgPSB7fTtcblxudmFyIFJlYWN0RmliZXJIb3N0Q29udGV4dCA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgdmFyIGdldENoaWxkSG9zdENvbnRleHQgPSBjb25maWcuZ2V0Q2hpbGRIb3N0Q29udGV4dCxcbiAgICAgIGdldFJvb3RIb3N0Q29udGV4dCA9IGNvbmZpZy5nZXRSb290SG9zdENvbnRleHQ7XG5cblxuICB2YXIgY29udGV4dFN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKE5PX0NPTlRFWFQpO1xuICB2YXIgY29udGV4dEZpYmVyU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoTk9fQ09OVEVYVCk7XG4gIHZhciByb290SW5zdGFuY2VTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihOT19DT05URVhUKTtcblxuICBmdW5jdGlvbiByZXF1aXJlZENvbnRleHQoYykge1xuICAgICEoYyAhPT0gTk9fQ09OVEVYVCkgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBob3N0IGNvbnRleHQgdG8gZXhpc3QuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGM7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRSb290SG9zdENvbnRhaW5lcigpIHtcbiAgICB2YXIgcm9vdEluc3RhbmNlID0gcmVxdWlyZWRDb250ZXh0KHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLmN1cnJlbnQpO1xuICAgIHJldHVybiByb290SW5zdGFuY2U7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoSG9zdENvbnRhaW5lcihmaWJlciwgbmV4dFJvb3RJbnN0YW5jZSkge1xuICAgIC8vIFB1c2ggY3VycmVudCByb290IGluc3RhbmNlIG9udG8gdGhlIHN0YWNrO1xuICAgIC8vIFRoaXMgYWxsb3dzIHVzIHRvIHJlc2V0IHJvb3Qgd2hlbiBwb3J0YWxzIGFyZSBwb3BwZWQuXG4gICAgcHVzaChyb290SW5zdGFuY2VTdGFja0N1cnNvciwgbmV4dFJvb3RJbnN0YW5jZSwgZmliZXIpO1xuXG4gICAgdmFyIG5leHRSb290Q29udGV4dCA9IGdldFJvb3RIb3N0Q29udGV4dChuZXh0Um9vdEluc3RhbmNlKTtcblxuICAgIC8vIFRyYWNrIHRoZSBjb250ZXh0IGFuZCB0aGUgRmliZXIgdGhhdCBwcm92aWRlZCBpdC5cbiAgICAvLyBUaGlzIGVuYWJsZXMgdXMgdG8gcG9wIG9ubHkgRmliZXJzIHRoYXQgcHJvdmlkZSB1bmlxdWUgY29udGV4dHMuXG4gICAgcHVzaChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIsIGZpYmVyKTtcbiAgICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciwgbmV4dFJvb3RDb250ZXh0LCBmaWJlcik7XG4gIH1cblxuICBmdW5jdGlvbiBwb3BIb3N0Q29udGFpbmVyKGZpYmVyKSB7XG4gICAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xuICAgIHBvcChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIpO1xuICAgIHBvcChyb290SW5zdGFuY2VTdGFja0N1cnNvciwgZmliZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SG9zdENvbnRleHQoKSB7XG4gICAgdmFyIGNvbnRleHQgPSByZXF1aXJlZENvbnRleHQoY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQpO1xuICAgIHJldHVybiBjb250ZXh0O1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaEhvc3RDb250ZXh0KGZpYmVyKSB7XG4gICAgdmFyIHJvb3RJbnN0YW5jZSA9IHJlcXVpcmVkQ29udGV4dChyb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50KTtcbiAgICB2YXIgY29udGV4dCA9IHJlcXVpcmVkQ29udGV4dChjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudCk7XG4gICAgdmFyIG5leHRDb250ZXh0ID0gZ2V0Q2hpbGRIb3N0Q29udGV4dChjb250ZXh0LCBmaWJlci50eXBlLCByb290SW5zdGFuY2UpO1xuXG4gICAgLy8gRG9uJ3QgcHVzaCB0aGlzIEZpYmVyJ3MgY29udGV4dCB1bmxlc3MgaXQncyB1bmlxdWUuXG4gICAgaWYgKGNvbnRleHQgPT09IG5leHRDb250ZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVHJhY2sgdGhlIGNvbnRleHQgYW5kIHRoZSBGaWJlciB0aGF0IHByb3ZpZGVkIGl0LlxuICAgIC8vIFRoaXMgZW5hYmxlcyB1cyB0byBwb3Agb25seSBGaWJlcnMgdGhhdCBwcm92aWRlIHVuaXF1ZSBjb250ZXh0cy5cbiAgICBwdXNoKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLCBmaWJlciwgZmliZXIpO1xuICAgIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBuZXh0Q29udGV4dCwgZmliZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcG9wSG9zdENvbnRleHQoZmliZXIpIHtcbiAgICAvLyBEbyBub3QgcG9wIHVubGVzcyB0aGlzIEZpYmVyIHByb3ZpZGVkIHRoZSBjdXJyZW50IGNvbnRleHQuXG4gICAgLy8gcHVzaEhvc3RDb250ZXh0KCkgb25seSBwdXNoZXMgRmliZXJzIHRoYXQgcHJvdmlkZSB1bmlxdWUgY29udGV4dHMuXG4gICAgaWYgKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLmN1cnJlbnQgIT09IGZpYmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xuICAgIHBvcChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRIb3N0Q29udGFpbmVyKCkge1xuICAgIGNvbnRleHRTdGFja0N1cnNvci5jdXJyZW50ID0gTk9fQ09OVEVYVDtcbiAgICByb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50ID0gTk9fQ09OVEVYVDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZ2V0SG9zdENvbnRleHQ6IGdldEhvc3RDb250ZXh0LFxuICAgIGdldFJvb3RIb3N0Q29udGFpbmVyOiBnZXRSb290SG9zdENvbnRhaW5lcixcbiAgICBwb3BIb3N0Q29udGFpbmVyOiBwb3BIb3N0Q29udGFpbmVyLFxuICAgIHBvcEhvc3RDb250ZXh0OiBwb3BIb3N0Q29udGV4dCxcbiAgICBwdXNoSG9zdENvbnRhaW5lcjogcHVzaEhvc3RDb250YWluZXIsXG4gICAgcHVzaEhvc3RDb250ZXh0OiBwdXNoSG9zdENvbnRleHQsXG4gICAgcmVzZXRIb3N0Q29udGFpbmVyOiByZXNldEhvc3RDb250YWluZXJcbiAgfTtcbn07XG5cbnZhciBSZWFjdEZpYmVySHlkcmF0aW9uQ29udGV4dCA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgdmFyIHNob3VsZFNldFRleHRDb250ZW50ID0gY29uZmlnLnNob3VsZFNldFRleHRDb250ZW50LFxuICAgICAgaHlkcmF0aW9uID0gY29uZmlnLmh5ZHJhdGlvbjtcblxuICAvLyBJZiB0aGlzIGRvZXNuJ3QgaGF2ZSBoeWRyYXRpb24gbW9kZS5cblxuICBpZiAoIWh5ZHJhdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICBlbnRlckh5ZHJhdGlvblN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sXG4gICAgICByZXNldEh5ZHJhdGlvblN0YXRlOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgIHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSgpIHRvIG5ldmVyIGJlIGNhbGxlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgIH0sXG4gICAgICBwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSgpIHRvIG5ldmVyIGJlIGNhbGxlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgIH0sXG4gICAgICBwb3BIeWRyYXRpb25TdGF0ZTogZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgdmFyIGNhbkh5ZHJhdGVJbnN0YW5jZSA9IGh5ZHJhdGlvbi5jYW5IeWRyYXRlSW5zdGFuY2UsXG4gICAgICBjYW5IeWRyYXRlVGV4dEluc3RhbmNlID0gaHlkcmF0aW9uLmNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UsXG4gICAgICBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcgPSBoeWRyYXRpb24uZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nLFxuICAgICAgZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQgPSBoeWRyYXRpb24uZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQsXG4gICAgICBoeWRyYXRlSW5zdGFuY2UgPSBoeWRyYXRpb24uaHlkcmF0ZUluc3RhbmNlLFxuICAgICAgaHlkcmF0ZVRleHRJbnN0YW5jZSA9IGh5ZHJhdGlvbi5oeWRyYXRlVGV4dEluc3RhbmNlLFxuICAgICAgZGlkTm90TWF0Y2hIeWRyYXRlZENvbnRhaW5lclRleHRJbnN0YW5jZSA9IGh5ZHJhdGlvbi5kaWROb3RNYXRjaEh5ZHJhdGVkQ29udGFpbmVyVGV4dEluc3RhbmNlLFxuICAgICAgZGlkTm90TWF0Y2hIeWRyYXRlZFRleHRJbnN0YW5jZSA9IGh5ZHJhdGlvbi5kaWROb3RNYXRjaEh5ZHJhdGVkVGV4dEluc3RhbmNlLFxuICAgICAgZGlkTm90SHlkcmF0ZUNvbnRhaW5lckluc3RhbmNlID0gaHlkcmF0aW9uLmRpZE5vdEh5ZHJhdGVDb250YWluZXJJbnN0YW5jZSxcbiAgICAgIGRpZE5vdEh5ZHJhdGVJbnN0YW5jZSA9IGh5ZHJhdGlvbi5kaWROb3RIeWRyYXRlSW5zdGFuY2UsXG4gICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lckluc3RhbmNlID0gaHlkcmF0aW9uLmRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVySW5zdGFuY2UsXG4gICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lclRleHRJbnN0YW5jZSA9IGh5ZHJhdGlvbi5kaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lclRleHRJbnN0YW5jZSxcbiAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlSW5zdGFuY2UgPSBoeWRyYXRpb24uZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZSxcbiAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlID0gaHlkcmF0aW9uLmRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlO1xuXG4gIC8vIFRoZSBkZWVwZXN0IEZpYmVyIG9uIHRoZSBzdGFjayBpbnZvbHZlZCBpbiBhIGh5ZHJhdGlvbiBjb250ZXh0LlxuICAvLyBUaGlzIG1heSBoYXZlIGJlZW4gYW4gaW5zZXJ0aW9uIG9yIGEgaHlkcmF0aW9uLlxuXG4gIHZhciBoeWRyYXRpb25QYXJlbnRGaWJlciA9IG51bGw7XG4gIHZhciBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gbnVsbDtcbiAgdmFyIGlzSHlkcmF0aW5nID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZW50ZXJIeWRyYXRpb25TdGF0ZShmaWJlcikge1xuICAgIHZhciBwYXJlbnRJbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZChwYXJlbnRJbnN0YW5jZSk7XG4gICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjtcbiAgICBpc0h5ZHJhdGluZyA9IHRydWU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBkZWxldGVIeWRyYXRhYmxlSW5zdGFuY2UocmV0dXJuRmliZXIsIGluc3RhbmNlKSB7XG4gICAge1xuICAgICAgc3dpdGNoIChyZXR1cm5GaWJlci50YWcpIHtcbiAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICBkaWROb3RIeWRyYXRlQ29udGFpbmVySW5zdGFuY2UocmV0dXJuRmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8sIGluc3RhbmNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgIGRpZE5vdEh5ZHJhdGVJbnN0YW5jZShyZXR1cm5GaWJlci50eXBlLCByZXR1cm5GaWJlci5tZW1vaXplZFByb3BzLCByZXR1cm5GaWJlci5zdGF0ZU5vZGUsIGluc3RhbmNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2hpbGRUb0RlbGV0ZSA9IGNyZWF0ZUZpYmVyRnJvbUhvc3RJbnN0YW5jZUZvckRlbGV0aW9uKCk7XG4gICAgY2hpbGRUb0RlbGV0ZS5zdGF0ZU5vZGUgPSBpbnN0YW5jZTtcbiAgICBjaGlsZFRvRGVsZXRlWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgIGNoaWxkVG9EZWxldGUuZWZmZWN0VGFnID0gRGVsZXRpb247XG5cbiAgICAvLyBUaGlzIG1pZ2h0IHNlZW0gbGlrZSBpdCBiZWxvbmdzIG9uIHByb2dyZXNzZWRGaXJzdERlbGV0aW9uLiBIb3dldmVyLFxuICAgIC8vIHRoZXNlIGNoaWxkcmVuIGFyZSBub3QgcGFydCBvZiB0aGUgcmVjb25jaWxpYXRpb24gbGlzdCBvZiBjaGlsZHJlbi5cbiAgICAvLyBFdmVuIGlmIHdlIGFib3J0IGFuZCByZXJlY29uY2lsZSB0aGUgY2hpbGRyZW4sIHRoYXQgd2lsbCB0cnkgdG8gaHlkcmF0ZVxuICAgIC8vIGFnYWluIGFuZCB0aGUgbm9kZXMgYXJlIHN0aWxsIGluIHRoZSBob3N0IHRyZWUgc28gdGhlc2Ugd2lsbCBiZVxuICAgIC8vIHJlY3JlYXRlZC5cbiAgICBpZiAocmV0dXJuRmliZXIubGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdC5uZXh0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluc2VydE5vbkh5ZHJhdGVkSW5zdGFuY2UocmV0dXJuRmliZXIsIGZpYmVyKSB7XG4gICAgZmliZXIuZWZmZWN0VGFnIHw9IFBsYWNlbWVudDtcbiAgICB7XG4gICAgICBzd2l0Y2ggKHJldHVybkZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnRDb250YWluZXIgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7XG4gICAgICAgICAgICAgICAgdmFyIHByb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVySW5zdGFuY2UocGFyZW50Q29udGFpbmVyLCB0eXBlLCBwcm9wcyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICAgICAgICAgICAgdmFyIHRleHQgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJUZXh0SW5zdGFuY2UocGFyZW50Q29udGFpbmVyLCB0ZXh0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnRUeXBlID0gcmV0dXJuRmliZXIudHlwZTtcbiAgICAgICAgICAgIHZhciBwYXJlbnRQcm9wcyA9IHJldHVybkZpYmVyLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICB2YXIgcGFyZW50SW5zdGFuY2UgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICAgICAgdmFyIF90eXBlID0gZmliZXIudHlwZTtcbiAgICAgICAgICAgICAgICB2YXIgX3Byb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlSW5zdGFuY2UocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCBfdHlwZSwgX3Byb3BzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAgICAgICAgICB2YXIgX3RleHQgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2UocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCBfdGV4dCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRyeUh5ZHJhdGUoZmliZXIsIG5leHRJbnN0YW5jZSkge1xuICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7XG4gICAgICAgICAgdmFyIHByb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGNhbkh5ZHJhdGVJbnN0YW5jZShuZXh0SW5zdGFuY2UsIHR5cGUsIHByb3BzKTtcbiAgICAgICAgICBpZiAoaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZpYmVyLnN0YXRlTm9kZSA9IGluc3RhbmNlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB0ZXh0ID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgIHZhciB0ZXh0SW5zdGFuY2UgPSBjYW5IeWRyYXRlVGV4dEluc3RhbmNlKG5leHRJbnN0YW5jZSwgdGV4dCk7XG4gICAgICAgICAgaWYgKHRleHRJbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZmliZXIuc3RhdGVOb2RlID0gdGV4dEluc3RhbmNlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlKGZpYmVyKSB7XG4gICAgaWYgKCFpc0h5ZHJhdGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbmV4dEluc3RhbmNlID0gbmV4dEh5ZHJhdGFibGVJbnN0YW5jZTtcbiAgICBpZiAoIW5leHRJbnN0YW5jZSkge1xuICAgICAgLy8gTm90aGluZyB0byBoeWRyYXRlLiBNYWtlIGl0IGFuIGluc2VydGlvbi5cbiAgICAgIGluc2VydE5vbkh5ZHJhdGVkSW5zdGFuY2UoaHlkcmF0aW9uUGFyZW50RmliZXIsIGZpYmVyKTtcbiAgICAgIGlzSHlkcmF0aW5nID0gZmFsc2U7XG4gICAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRyeUh5ZHJhdGUoZmliZXIsIG5leHRJbnN0YW5jZSkpIHtcbiAgICAgIC8vIElmIHdlIGNhbid0IGh5ZHJhdGUgdGhpcyBpbnN0YW5jZSBsZXQncyB0cnkgdGhlIG5leHQgb25lLlxuICAgICAgLy8gV2UgdXNlIHRoaXMgYXMgYSBoZXVyaXN0aWMuIEl0J3MgYmFzZWQgb24gaW50dWl0aW9uIGFuZCBub3QgZGF0YSBzbyBpdFxuICAgICAgLy8gbWlnaHQgYmUgZmxhd2VkIG9yIHVubmVjZXNzYXJ5LlxuICAgICAgbmV4dEluc3RhbmNlID0gZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nKG5leHRJbnN0YW5jZSk7XG4gICAgICBpZiAoIW5leHRJbnN0YW5jZSB8fCAhdHJ5SHlkcmF0ZShmaWJlciwgbmV4dEluc3RhbmNlKSkge1xuICAgICAgICAvLyBOb3RoaW5nIHRvIGh5ZHJhdGUuIE1ha2UgaXQgYW4gaW5zZXJ0aW9uLlxuICAgICAgICBpbnNlcnROb25IeWRyYXRlZEluc3RhbmNlKGh5ZHJhdGlvblBhcmVudEZpYmVyLCBmaWJlcik7XG4gICAgICAgIGlzSHlkcmF0aW5nID0gZmFsc2U7XG4gICAgICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIFdlIG1hdGNoZWQgdGhlIG5leHQgb25lLCB3ZSdsbCBub3cgYXNzdW1lIHRoYXQgdGhlIGZpcnN0IG9uZSB3YXNcbiAgICAgIC8vIHN1cGVyZmx1b3VzIGFuZCB3ZSdsbCBkZWxldGUgaXQuIFNpbmNlIHdlIGNhbid0IGVhZ2VybHkgZGVsZXRlIGl0XG4gICAgICAvLyB3ZSdsbCBoYXZlIHRvIHNjaGVkdWxlIGEgZGVsZXRpb24uIFRvIGRvIHRoYXQsIHRoaXMgbm9kZSBuZWVkcyBhIGR1bW15XG4gICAgICAvLyBmaWJlciBhc3NvY2lhdGVkIHdpdGggaXQuXG4gICAgICBkZWxldGVIeWRyYXRhYmxlSW5zdGFuY2UoaHlkcmF0aW9uUGFyZW50RmliZXIsIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UpO1xuICAgIH1cbiAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyO1xuICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZChuZXh0SW5zdGFuY2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZShmaWJlciwgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCkge1xuICAgIHZhciBpbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgICB2YXIgdXBkYXRlUGF5bG9hZCA9IGh5ZHJhdGVJbnN0YW5jZShpbnN0YW5jZSwgZmliZXIudHlwZSwgZmliZXIubWVtb2l6ZWRQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCwgZmliZXIpO1xuICAgIC8vIFRPRE86IFR5cGUgdGhpcyBzcGVjaWZpYyB0byB0aGlzIHR5cGUgb2YgY29tcG9uZW50LlxuICAgIGZpYmVyLnVwZGF0ZVF1ZXVlID0gdXBkYXRlUGF5bG9hZDtcbiAgICAvLyBJZiB0aGUgdXBkYXRlIHBheWxvYWQgaW5kaWNhdGVzIHRoYXQgdGhlcmUgaXMgYSBjaGFuZ2Ugb3IgaWYgdGhlcmVcbiAgICAvLyBpcyBhIG5ldyByZWYgd2UgbWFyayB0aGlzIGFzIGFuIHVwZGF0ZS5cbiAgICBpZiAodXBkYXRlUGF5bG9hZCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlKGZpYmVyKSB7XG4gICAgdmFyIHRleHRJbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgICB2YXIgdGV4dENvbnRlbnQgPSBmaWJlci5tZW1vaXplZFByb3BzO1xuICAgIHZhciBzaG91bGRVcGRhdGUgPSBoeWRyYXRlVGV4dEluc3RhbmNlKHRleHRJbnN0YW5jZSwgdGV4dENvbnRlbnQsIGZpYmVyKTtcbiAgICB7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgICAgIC8vIFdlIGFzc3VtZSB0aGF0IHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlIGlzIGNhbGxlZCBpbiBhIGNvbnRleHQgd2hlcmUgdGhlXG4gICAgICAgIC8vIGh5ZHJhdGlvbiBwYXJlbnQgaXMgdGhlIHBhcmVudCBob3N0IGNvbXBvbmVudCBvZiB0aGlzIGhvc3QgdGV4dC5cbiAgICAgICAgdmFyIHJldHVybkZpYmVyID0gaHlkcmF0aW9uUGFyZW50RmliZXI7XG4gICAgICAgIGlmIChyZXR1cm5GaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAgIHN3aXRjaCAocmV0dXJuRmliZXIudGFnKSB7XG4gICAgICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudENvbnRhaW5lciA9IHJldHVybkZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICAgICAgICAgIGRpZE5vdE1hdGNoSHlkcmF0ZWRDb250YWluZXJUZXh0SW5zdGFuY2UocGFyZW50Q29udGFpbmVyLCB0ZXh0SW5zdGFuY2UsIHRleHRDb250ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudFR5cGUgPSByZXR1cm5GaWJlci50eXBlO1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRQcm9wcyA9IHJldHVybkZpYmVyLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudEluc3RhbmNlID0gcmV0dXJuRmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICAgIGRpZE5vdE1hdGNoSHlkcmF0ZWRUZXh0SW5zdGFuY2UocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCB0ZXh0SW5zdGFuY2UsIHRleHRDb250ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2hvdWxkVXBkYXRlO1xuICB9XG5cbiAgZnVuY3Rpb24gcG9wVG9OZXh0SG9zdFBhcmVudChmaWJlcikge1xuICAgIHZhciBwYXJlbnQgPSBmaWJlclsncmV0dXJuJ107XG4gICAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCAmJiBwYXJlbnQudGFnICE9PSBIb3N0Q29tcG9uZW50ICYmIHBhcmVudC50YWcgIT09IEhvc3RSb290KSB7XG4gICAgICBwYXJlbnQgPSBwYXJlbnRbJ3JldHVybiddO1xuICAgIH1cbiAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IHBhcmVudDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvcEh5ZHJhdGlvblN0YXRlKGZpYmVyKSB7XG4gICAgaWYgKGZpYmVyICE9PSBoeWRyYXRpb25QYXJlbnRGaWJlcikge1xuICAgICAgLy8gV2UncmUgZGVlcGVyIHRoYW4gdGhlIGN1cnJlbnQgaHlkcmF0aW9uIGNvbnRleHQsIGluc2lkZSBhbiBpbnNlcnRlZFxuICAgICAgLy8gdHJlZS5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFpc0h5ZHJhdGluZykge1xuICAgICAgLy8gSWYgd2UncmUgbm90IGN1cnJlbnRseSBoeWRyYXRpbmcgYnV0IHdlJ3JlIGluIGEgaHlkcmF0aW9uIGNvbnRleHQsIHRoZW5cbiAgICAgIC8vIHdlIHdlcmUgYW4gaW5zZXJ0aW9uIGFuZCBub3cgbmVlZCB0byBwb3AgdXAgcmVlbnRlciBoeWRyYXRpb24gb2Ygb3VyXG4gICAgICAvLyBzaWJsaW5ncy5cbiAgICAgIHBvcFRvTmV4dEhvc3RQYXJlbnQoZmliZXIpO1xuICAgICAgaXNIeWRyYXRpbmcgPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciB0eXBlID0gZmliZXIudHlwZTtcblxuICAgIC8vIElmIHdlIGhhdmUgYW55IHJlbWFpbmluZyBoeWRyYXRhYmxlIG5vZGVzLCB3ZSBuZWVkIHRvIGRlbGV0ZSB0aGVtIG5vdy5cbiAgICAvLyBXZSBvbmx5IGRvIHRoaXMgZGVlcGVyIHRoYW4gaGVhZCBhbmQgYm9keSBzaW5jZSB0aGV5IHRlbmQgdG8gaGF2ZSByYW5kb21cbiAgICAvLyBvdGhlciBub2RlcyBpbiB0aGVtLiBXZSBhbHNvIGlnbm9yZSBjb21wb25lbnRzIHdpdGggcHVyZSB0ZXh0IGNvbnRlbnQgaW5cbiAgICAvLyBzaWRlIG9mIHRoZW0uXG4gICAgLy8gVE9ETzogQmV0dGVyIGhldXJpc3RpYy5cbiAgICBpZiAoZmliZXIudGFnICE9PSBIb3N0Q29tcG9uZW50IHx8IHR5cGUgIT09ICdoZWFkJyAmJiB0eXBlICE9PSAnYm9keScgJiYgIXNob3VsZFNldFRleHRDb250ZW50KHR5cGUsIGZpYmVyLm1lbW9pemVkUHJvcHMpKSB7XG4gICAgICB2YXIgbmV4dEluc3RhbmNlID0gbmV4dEh5ZHJhdGFibGVJbnN0YW5jZTtcbiAgICAgIHdoaWxlIChuZXh0SW5zdGFuY2UpIHtcbiAgICAgICAgZGVsZXRlSHlkcmF0YWJsZUluc3RhbmNlKGZpYmVyLCBuZXh0SW5zdGFuY2UpO1xuICAgICAgICBuZXh0SW5zdGFuY2UgPSBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcobmV4dEluc3RhbmNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwb3BUb05leHRIb3N0UGFyZW50KGZpYmVyKTtcbiAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gaHlkcmF0aW9uUGFyZW50RmliZXIgPyBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcoZmliZXIuc3RhdGVOb2RlKSA6IG51bGw7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldEh5ZHJhdGlvblN0YXRlKCkge1xuICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gbnVsbDtcbiAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gbnVsbDtcbiAgICBpc0h5ZHJhdGluZyA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBlbnRlckh5ZHJhdGlvblN0YXRlOiBlbnRlckh5ZHJhdGlvblN0YXRlLFxuICAgIHJlc2V0SHlkcmF0aW9uU3RhdGU6IHJlc2V0SHlkcmF0aW9uU3RhdGUsXG4gICAgdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2U6IHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlLFxuICAgIHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2U6IHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2UsXG4gICAgcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2U6IHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlLFxuICAgIHBvcEh5ZHJhdGlvblN0YXRlOiBwb3BIeWRyYXRpb25TdGF0ZVxuICB9O1xufTtcblxuLy8gVGhpcyBsZXRzIHVzIGhvb2sgaW50byBGaWJlciB0byBkZWJ1ZyB3aGF0IGl0J3MgZG9pbmcuXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvODAzMy5cbi8vIFRoaXMgaXMgbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBBUEksIG5vdCBldmVuIGZvciBSZWFjdCBEZXZUb29scy5cbi8vIFlvdSBtYXkgb25seSBpbmplY3QgYSBkZWJ1Z1Rvb2wgaWYgeW91IHdvcmsgb24gUmVhY3QgRmliZXIgaXRzZWxmLlxudmFyIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb24gPSB7XG4gIGRlYnVnVG9vbDogbnVsbFxufTtcblxudmFyIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMSA9IFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb247XG5cbnZhciBkZWZhdWx0U2hvd0RpYWxvZyA9IGZ1bmN0aW9uIChjYXB0dXJlZEVycm9yKSB7XG4gIHJldHVybiB0cnVlO1xufTtcblxudmFyIHNob3dEaWFsb2cgPSBkZWZhdWx0U2hvd0RpYWxvZztcblxuZnVuY3Rpb24gbG9nQ2FwdHVyZWRFcnJvcihjYXB0dXJlZEVycm9yKSB7XG4gIHZhciBsb2dFcnJvciA9IHNob3dEaWFsb2coY2FwdHVyZWRFcnJvcik7XG5cbiAgLy8gQWxsb3cgaW5qZWN0ZWQgc2hvd0RpYWxvZygpIHRvIHByZXZlbnQgZGVmYXVsdCBjb25zb2xlLmVycm9yIGxvZ2dpbmcuXG4gIC8vIFRoaXMgZW5hYmxlcyByZW5kZXJlcnMgbGlrZSBSZWFjdE5hdGl2ZSB0byBiZXR0ZXIgbWFuYWdlIHJlZGJveCBiZWhhdmlvci5cbiAgaWYgKGxvZ0Vycm9yID09PSBmYWxzZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBlcnJvciA9IGNhcHR1cmVkRXJyb3IuZXJyb3I7XG4gIHZhciBzdXBwcmVzc0xvZ2dpbmcgPSBlcnJvciAmJiBlcnJvci5zdXBwcmVzc1JlYWN0RXJyb3JMb2dnaW5nO1xuICBpZiAoc3VwcHJlc3NMb2dnaW5nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAge1xuICAgIHZhciBjb21wb25lbnROYW1lID0gY2FwdHVyZWRFcnJvci5jb21wb25lbnROYW1lLFxuICAgICAgICBjb21wb25lbnRTdGFjayA9IGNhcHR1cmVkRXJyb3IuY29tcG9uZW50U3RhY2ssXG4gICAgICAgIGVycm9yQm91bmRhcnlOYW1lID0gY2FwdHVyZWRFcnJvci5lcnJvckJvdW5kYXJ5TmFtZSxcbiAgICAgICAgZXJyb3JCb3VuZGFyeUZvdW5kID0gY2FwdHVyZWRFcnJvci5lcnJvckJvdW5kYXJ5Rm91bmQsXG4gICAgICAgIHdpbGxSZXRyeSA9IGNhcHR1cmVkRXJyb3Iud2lsbFJldHJ5O1xuXG5cbiAgICB2YXIgY29tcG9uZW50TmFtZU1lc3NhZ2UgPSBjb21wb25lbnROYW1lID8gJ1RoZSBhYm92ZSBlcnJvciBvY2N1cnJlZCBpbiB0aGUgPCcgKyBjb21wb25lbnROYW1lICsgJz4gY29tcG9uZW50OicgOiAnVGhlIGFib3ZlIGVycm9yIG9jY3VycmVkIGluIG9uZSBvZiB5b3VyIFJlYWN0IGNvbXBvbmVudHM6JztcblxuICAgIHZhciBlcnJvckJvdW5kYXJ5TWVzc2FnZSA9IHZvaWQgMDtcbiAgICAvLyBlcnJvckJvdW5kYXJ5Rm91bmQgY2hlY2sgaXMgc3VmZmljaWVudDsgZXJyb3JCb3VuZGFyeU5hbWUgY2hlY2sgaXMgdG8gc2F0aXNmeSBGbG93LlxuICAgIGlmIChlcnJvckJvdW5kYXJ5Rm91bmQgJiYgZXJyb3JCb3VuZGFyeU5hbWUpIHtcbiAgICAgIGlmICh3aWxsUmV0cnkpIHtcbiAgICAgICAgZXJyb3JCb3VuZGFyeU1lc3NhZ2UgPSAnUmVhY3Qgd2lsbCB0cnkgdG8gcmVjcmVhdGUgdGhpcyBjb21wb25lbnQgdHJlZSBmcm9tIHNjcmF0Y2ggJyArICgndXNpbmcgdGhlIGVycm9yIGJvdW5kYXJ5IHlvdSBwcm92aWRlZCwgJyArIGVycm9yQm91bmRhcnlOYW1lICsgJy4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yQm91bmRhcnlNZXNzYWdlID0gJ1RoaXMgZXJyb3Igd2FzIGluaXRpYWxseSBoYW5kbGVkIGJ5IHRoZSBlcnJvciBib3VuZGFyeSAnICsgZXJyb3JCb3VuZGFyeU5hbWUgKyAnLlxcbicgKyAnUmVjcmVhdGluZyB0aGUgdHJlZSBmcm9tIHNjcmF0Y2ggZmFpbGVkIHNvIFJlYWN0IHdpbGwgdW5tb3VudCB0aGUgdHJlZS4nO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvckJvdW5kYXJ5TWVzc2FnZSA9ICdDb25zaWRlciBhZGRpbmcgYW4gZXJyb3IgYm91bmRhcnkgdG8geW91ciB0cmVlIHRvIGN1c3RvbWl6ZSBlcnJvciBoYW5kbGluZyBiZWhhdmlvci5cXG4nICsgJ1Zpc2l0IGh0dHBzOi8vZmIubWUvcmVhY3QtZXJyb3ItYm91bmRhcmllcyB0byBsZWFybiBtb3JlIGFib3V0IGVycm9yIGJvdW5kYXJpZXMuJztcbiAgICB9XG4gICAgdmFyIGNvbWJpbmVkTWVzc2FnZSA9ICcnICsgY29tcG9uZW50TmFtZU1lc3NhZ2UgKyBjb21wb25lbnRTdGFjayArICdcXG5cXG4nICsgKCcnICsgZXJyb3JCb3VuZGFyeU1lc3NhZ2UpO1xuXG4gICAgLy8gSW4gZGV2ZWxvcG1lbnQsIHdlIHByb3ZpZGUgb3VyIG93biBtZXNzYWdlIHdpdGgganVzdCB0aGUgY29tcG9uZW50IHN0YWNrLlxuICAgIC8vIFdlIGRvbid0IGluY2x1ZGUgdGhlIG9yaWdpbmFsIGVycm9yIG1lc3NhZ2UgYW5kIEpTIHN0YWNrIGJlY2F1c2UgdGhlIGJyb3dzZXJcbiAgICAvLyBoYXMgYWxyZWFkeSBwcmludGVkIGl0LiBFdmVuIGlmIHRoZSBhcHBsaWNhdGlvbiBzd2FsbG93cyB0aGUgZXJyb3IsIGl0IGlzIHN0aWxsXG4gICAgLy8gZGlzcGxheWVkIGJ5IHRoZSBicm93c2VyIHRoYW5rcyB0byB0aGUgREVWLW9ubHkgZmFrZSBldmVudCB0cmljayBpbiBSZWFjdEVycm9yVXRpbHMuXG4gICAgY29uc29sZS5lcnJvcihjb21iaW5lZE1lc3NhZ2UpO1xuICB9XG59XG5cbnZhciBpbnZva2VHdWFyZGVkQ2FsbGJhY2skMSA9IFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2s7XG52YXIgaGFzQ2F1Z2h0RXJyb3IgPSBSZWFjdEVycm9yVXRpbHMuaGFzQ2F1Z2h0RXJyb3I7XG52YXIgY2xlYXJDYXVnaHRFcnJvciA9IFJlYWN0RXJyb3JVdGlscy5jbGVhckNhdWdodEVycm9yO1xuXG5cbntcbiAgdmFyIGRpZFdhcm5BYm91dFN0YXRlVHJhbnNpdGlvbiA9IGZhbHNlO1xuICB2YXIgZGlkV2FyblNldFN0YXRlQ2hpbGRDb250ZXh0ID0gZmFsc2U7XG4gIHZhciBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQgPSB7fTtcblxuICB2YXIgd2FybkFib3V0VXBkYXRlT25Vbm1vdW50ZWQgPSBmdW5jdGlvbiAoZmliZXIpIHtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoZmliZXIpIHx8ICdSZWFjdENsYXNzJztcbiAgICBpZiAoZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHdhcm5pbmcoZmFsc2UsICdDYW4gb25seSB1cGRhdGUgYSBtb3VudGVkIG9yIG1vdW50aW5nICcgKyAnY29tcG9uZW50LiBUaGlzIHVzdWFsbHkgbWVhbnMgeW91IGNhbGxlZCBzZXRTdGF0ZSwgcmVwbGFjZVN0YXRlLCAnICsgJ29yIGZvcmNlVXBkYXRlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuIFRoaXMgaXMgYSBuby1vcC5cXG5cXG5QbGVhc2UgJyArICdjaGVjayB0aGUgY29kZSBmb3IgdGhlICVzIGNvbXBvbmVudC4nLCBjb21wb25lbnROYW1lKTtcbiAgICBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICB9O1xuXG4gIHZhciB3YXJuQWJvdXRJbnZhbGlkVXBkYXRlcyA9IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgIHN3aXRjaCAoUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5waGFzZSkge1xuICAgICAgY2FzZSAnZ2V0Q2hpbGRDb250ZXh0JzpcbiAgICAgICAgaWYgKGRpZFdhcm5TZXRTdGF0ZUNoaWxkQ29udGV4dCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnc2V0U3RhdGUoLi4uKTogQ2Fubm90IGNhbGwgc2V0U3RhdGUoKSBpbnNpZGUgZ2V0Q2hpbGRDb250ZXh0KCknKTtcbiAgICAgICAgZGlkV2FyblNldFN0YXRlQ2hpbGRDb250ZXh0ID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyZW5kZXInOlxuICAgICAgICBpZiAoZGlkV2FybkFib3V0U3RhdGVUcmFuc2l0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdDYW5ub3QgdXBkYXRlIGR1cmluZyBhbiBleGlzdGluZyBzdGF0ZSB0cmFuc2l0aW9uIChzdWNoIGFzIHdpdGhpbiAnICsgXCJgcmVuZGVyYCBvciBhbm90aGVyIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yKS4gUmVuZGVyIG1ldGhvZHMgc2hvdWxkIFwiICsgJ2JlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGU7IGNvbnN0cnVjdG9yIHNpZGUtZWZmZWN0cyBhcmUgJyArICdhbiBhbnRpLXBhdHRlcm4sIGJ1dCBjYW4gYmUgbW92ZWQgdG8gYGNvbXBvbmVudFdpbGxNb3VudGAuJyk7XG4gICAgICAgIGRpZFdhcm5BYm91dFN0YXRlVHJhbnNpdGlvbiA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIFJlYWN0RmliZXJTY2hlZHVsZXIgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gIHZhciBob3N0Q29udGV4dCA9IFJlYWN0RmliZXJIb3N0Q29udGV4dChjb25maWcpO1xuICB2YXIgaHlkcmF0aW9uQ29udGV4dCA9IFJlYWN0RmliZXJIeWRyYXRpb25Db250ZXh0KGNvbmZpZyk7XG4gIHZhciBwb3BIb3N0Q29udGFpbmVyID0gaG9zdENvbnRleHQucG9wSG9zdENvbnRhaW5lcixcbiAgICAgIHBvcEhvc3RDb250ZXh0ID0gaG9zdENvbnRleHQucG9wSG9zdENvbnRleHQsXG4gICAgICByZXNldEhvc3RDb250YWluZXIgPSBob3N0Q29udGV4dC5yZXNldEhvc3RDb250YWluZXI7XG5cbiAgdmFyIF9SZWFjdEZpYmVyQmVnaW5Xb3JrID0gUmVhY3RGaWJlckJlZ2luV29yayhjb25maWcsIGhvc3RDb250ZXh0LCBoeWRyYXRpb25Db250ZXh0LCBzY2hlZHVsZVdvcmssIGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIpLFxuICAgICAgYmVnaW5Xb3JrID0gX1JlYWN0RmliZXJCZWdpbldvcmsuYmVnaW5Xb3JrLFxuICAgICAgYmVnaW5GYWlsZWRXb3JrID0gX1JlYWN0RmliZXJCZWdpbldvcmsuYmVnaW5GYWlsZWRXb3JrO1xuXG4gIHZhciBfUmVhY3RGaWJlckNvbXBsZXRlV28gPSBSZWFjdEZpYmVyQ29tcGxldGVXb3JrKGNvbmZpZywgaG9zdENvbnRleHQsIGh5ZHJhdGlvbkNvbnRleHQpLFxuICAgICAgY29tcGxldGVXb3JrID0gX1JlYWN0RmliZXJDb21wbGV0ZVdvLmNvbXBsZXRlV29yaztcblxuICB2YXIgX1JlYWN0RmliZXJDb21taXRXb3JrID0gUmVhY3RGaWJlckNvbW1pdFdvcmsoY29uZmlnLCBjYXB0dXJlRXJyb3IpLFxuICAgICAgY29tbWl0UmVzZXRUZXh0Q29udGVudCA9IF9SZWFjdEZpYmVyQ29tbWl0V29yay5jb21taXRSZXNldFRleHRDb250ZW50LFxuICAgICAgY29tbWl0UGxhY2VtZW50ID0gX1JlYWN0RmliZXJDb21taXRXb3JrLmNvbW1pdFBsYWNlbWVudCxcbiAgICAgIGNvbW1pdERlbGV0aW9uID0gX1JlYWN0RmliZXJDb21taXRXb3JrLmNvbW1pdERlbGV0aW9uLFxuICAgICAgY29tbWl0V29yayA9IF9SZWFjdEZpYmVyQ29tbWl0V29yay5jb21taXRXb3JrLFxuICAgICAgY29tbWl0TGlmZUN5Y2xlcyA9IF9SZWFjdEZpYmVyQ29tbWl0V29yay5jb21taXRMaWZlQ3ljbGVzLFxuICAgICAgY29tbWl0QXR0YWNoUmVmID0gX1JlYWN0RmliZXJDb21taXRXb3JrLmNvbW1pdEF0dGFjaFJlZixcbiAgICAgIGNvbW1pdERldGFjaFJlZiA9IF9SZWFjdEZpYmVyQ29tbWl0V29yay5jb21taXREZXRhY2hSZWY7XG5cbiAgdmFyIG5vdyA9IGNvbmZpZy5ub3csXG4gICAgICBzY2hlZHVsZURlZmVycmVkQ2FsbGJhY2sgPSBjb25maWcuc2NoZWR1bGVEZWZlcnJlZENhbGxiYWNrLFxuICAgICAgY2FuY2VsRGVmZXJyZWRDYWxsYmFjayA9IGNvbmZpZy5jYW5jZWxEZWZlcnJlZENhbGxiYWNrLFxuICAgICAgdXNlU3luY1NjaGVkdWxpbmcgPSBjb25maWcudXNlU3luY1NjaGVkdWxpbmcsXG4gICAgICBwcmVwYXJlRm9yQ29tbWl0ID0gY29uZmlnLnByZXBhcmVGb3JDb21taXQsXG4gICAgICByZXNldEFmdGVyQ29tbWl0ID0gY29uZmlnLnJlc2V0QWZ0ZXJDb21taXQ7XG5cbiAgLy8gUmVwcmVzZW50cyB0aGUgY3VycmVudCB0aW1lIGluIG1zLlxuXG4gIHZhciBzdGFydFRpbWUgPSBub3coKTtcbiAgdmFyIG1vc3RSZWNlbnRDdXJyZW50VGltZSA9IG1zVG9FeHBpcmF0aW9uVGltZSgwKTtcblxuICAvLyBSZXByZXNlbnRzIHRoZSBleHBpcmF0aW9uIHRpbWUgdGhhdCBpbmNvbWluZyB1cGRhdGVzIHNob3VsZCB1c2UuIChJZiB0aGlzXG4gIC8vIGlzIE5vV29yaywgdXNlIHRoZSBkZWZhdWx0IHN0cmF0ZWd5OiBhc3luYyB1cGRhdGVzIGluIGFzeW5jIG1vZGUsIHN5bmNcbiAgLy8gdXBkYXRlcyBpbiBzeW5jIG1vZGUuKVxuICB2YXIgZXhwaXJhdGlvbkNvbnRleHQgPSBOb1dvcms7XG5cbiAgdmFyIGlzV29ya2luZyA9IGZhbHNlO1xuXG4gIC8vIFRoZSBuZXh0IHdvcmsgaW4gcHJvZ3Jlc3MgZmliZXIgdGhhdCB3ZSdyZSBjdXJyZW50bHkgd29ya2luZyBvbi5cbiAgdmFyIG5leHRVbml0T2ZXb3JrID0gbnVsbDtcbiAgdmFyIG5leHRSb290ID0gbnVsbDtcbiAgLy8gVGhlIHRpbWUgYXQgd2hpY2ggd2UncmUgY3VycmVudGx5IHJlbmRlcmluZyB3b3JrLlxuICB2YXIgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuXG4gIC8vIFRoZSBuZXh0IGZpYmVyIHdpdGggYW4gZWZmZWN0IHRoYXQgd2UncmUgY3VycmVudGx5IGNvbW1pdHRpbmcuXG4gIHZhciBuZXh0RWZmZWN0ID0gbnVsbDtcblxuICAvLyBLZWVwIHRyYWNrIG9mIHdoaWNoIGZpYmVycyBoYXZlIGNhcHR1cmVkIGFuIGVycm9yIHRoYXQgbmVlZCB0byBiZSBoYW5kbGVkLlxuICAvLyBXb3JrIGlzIHJlbW92ZWQgZnJvbSB0aGlzIGNvbGxlY3Rpb24gYWZ0ZXIgY29tcG9uZW50RGlkQ2F0Y2ggaXMgY2FsbGVkLlxuICB2YXIgY2FwdHVyZWRFcnJvcnMgPSBudWxsO1xuICAvLyBLZWVwIHRyYWNrIG9mIHdoaWNoIGZpYmVycyBoYXZlIGZhaWxlZCBkdXJpbmcgdGhlIGN1cnJlbnQgYmF0Y2ggb2Ygd29yay5cbiAgLy8gVGhpcyBpcyBhIGRpZmZlcmVudCBzZXQgdGhhbiBjYXB0dXJlZEVycm9ycywgYmVjYXVzZSBpdCBpcyBub3QgcmVzZXQgdW50aWxcbiAgLy8gdGhlIGVuZCBvZiB0aGUgYmF0Y2guIFRoaXMgaXMgbmVlZGVkIHRvIHByb3BhZ2F0ZSBlcnJvcnMgY29ycmVjdGx5IGlmIGFcbiAgLy8gc3VidHJlZSBmYWlscyBtb3JlIHRoYW4gb25jZS5cbiAgdmFyIGZhaWxlZEJvdW5kYXJpZXMgPSBudWxsO1xuICAvLyBFcnJvciBib3VuZGFyaWVzIHRoYXQgY2FwdHVyZWQgYW4gZXJyb3IgZHVyaW5nIHRoZSBjdXJyZW50IGNvbW1pdC5cbiAgdmFyIGNvbW1pdFBoYXNlQm91bmRhcmllcyA9IG51bGw7XG4gIHZhciBmaXJzdFVuY2F1Z2h0RXJyb3IgPSBudWxsO1xuICB2YXIgZGlkRmF0YWwgPSBmYWxzZTtcblxuICB2YXIgaXNDb21taXR0aW5nID0gZmFsc2U7XG4gIHZhciBpc1VubW91bnRpbmcgPSBmYWxzZTtcblxuICAvLyBVc2VkIGZvciBwZXJmb3JtYW5jZSB0cmFja2luZy5cbiAgdmFyIGludGVycnVwdGVkQnkgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIHJlc2V0Q29udGV4dFN0YWNrKCkge1xuICAgIC8vIFJlc2V0IHRoZSBzdGFja1xuICAgIHJlc2V0JDEoKTtcbiAgICAvLyBSZXNldCB0aGUgY3Vyc29yc1xuICAgIHJlc2V0Q29udGV4dCgpO1xuICAgIHJlc2V0SG9zdENvbnRhaW5lcigpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0QWxsSG9zdEVmZmVjdHMoKSB7XG4gICAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50RmliZXIobmV4dEVmZmVjdCk7XG4gICAgICB9XG4gICAgICByZWNvcmRFZmZlY3QoKTtcblxuICAgICAgdmFyIGVmZmVjdFRhZyA9IG5leHRFZmZlY3QuZWZmZWN0VGFnO1xuICAgICAgaWYgKGVmZmVjdFRhZyAmIENvbnRlbnRSZXNldCkge1xuICAgICAgICBjb21taXRSZXNldFRleHRDb250ZW50KG5leHRFZmZlY3QpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWZmZWN0VGFnICYgUmVmKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gbmV4dEVmZmVjdC5hbHRlcm5hdGU7XG4gICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgY29tbWl0RGV0YWNoUmVmKGN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBmb2xsb3dpbmcgc3dpdGNoIHN0YXRlbWVudCBpcyBvbmx5IGNvbmNlcm5lZCBhYm91dCBwbGFjZW1lbnQsXG4gICAgICAvLyB1cGRhdGVzLCBhbmQgZGVsZXRpb25zLiBUbyBhdm9pZCBuZWVkaW5nIHRvIGFkZCBhIGNhc2UgZm9yIGV2ZXJ5XG4gICAgICAvLyBwb3NzaWJsZSBiaXRtYXAgdmFsdWUsIHdlIHJlbW92ZSB0aGUgc2Vjb25kYXJ5IGVmZmVjdHMgZnJvbSB0aGVcbiAgICAgIC8vIGVmZmVjdCB0YWcgYW5kIHN3aXRjaCBvbiB0aGF0IHZhbHVlLlxuICAgICAgdmFyIHByaW1hcnlFZmZlY3RUYWcgPSBlZmZlY3RUYWcgJiB+KENhbGxiYWNrIHwgRXJyIHwgQ29udGVudFJlc2V0IHwgUmVmIHwgUGVyZm9ybWVkV29yayk7XG4gICAgICBzd2l0Y2ggKHByaW1hcnlFZmZlY3RUYWcpIHtcbiAgICAgICAgY2FzZSBQbGFjZW1lbnQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29tbWl0UGxhY2VtZW50KG5leHRFZmZlY3QpO1xuICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIFwicGxhY2VtZW50XCIgZnJvbSBlZmZlY3QgdGFnIHNvIHRoYXQgd2Uga25vdyB0aGF0IHRoaXMgaXMgaW5zZXJ0ZWQsIGJlZm9yZVxuICAgICAgICAgICAgLy8gYW55IGxpZmUtY3ljbGVzIGxpa2UgY29tcG9uZW50RGlkTW91bnQgZ2V0cyBjYWxsZWQuXG4gICAgICAgICAgICAvLyBUT0RPOiBmaW5kRE9NTm9kZSBkb2Vzbid0IHJlbHkgb24gdGhpcyBhbnkgbW9yZSBidXQgaXNNb3VudGVkXG4gICAgICAgICAgICAvLyBkb2VzIGFuZCBpc01vdW50ZWQgaXMgZGVwcmVjYXRlZCBhbnl3YXkgc28gd2Ugc2hvdWxkIGJlIGFibGVcbiAgICAgICAgICAgIC8vIHRvIGtpbGwgdGhpcy5cbiAgICAgICAgICAgIG5leHRFZmZlY3QuZWZmZWN0VGFnICY9IH5QbGFjZW1lbnQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgUGxhY2VtZW50QW5kVXBkYXRlOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIFBsYWNlbWVudFxuICAgICAgICAgICAgY29tbWl0UGxhY2VtZW50KG5leHRFZmZlY3QpO1xuICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIFwicGxhY2VtZW50XCIgZnJvbSBlZmZlY3QgdGFnIHNvIHRoYXQgd2Uga25vdyB0aGF0IHRoaXMgaXMgaW5zZXJ0ZWQsIGJlZm9yZVxuICAgICAgICAgICAgLy8gYW55IGxpZmUtY3ljbGVzIGxpa2UgY29tcG9uZW50RGlkTW91bnQgZ2V0cyBjYWxsZWQuXG4gICAgICAgICAgICBuZXh0RWZmZWN0LmVmZmVjdFRhZyAmPSB+UGxhY2VtZW50O1xuXG4gICAgICAgICAgICAvLyBVcGRhdGVcbiAgICAgICAgICAgIHZhciBfY3VycmVudCA9IG5leHRFZmZlY3QuYWx0ZXJuYXRlO1xuICAgICAgICAgICAgY29tbWl0V29yayhfY3VycmVudCwgbmV4dEVmZmVjdCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgVXBkYXRlOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfY3VycmVudDIgPSBuZXh0RWZmZWN0LmFsdGVybmF0ZTtcbiAgICAgICAgICAgIGNvbW1pdFdvcmsoX2N1cnJlbnQyLCBuZXh0RWZmZWN0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBEZWxldGlvbjpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpc1VubW91bnRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgY29tbWl0RGVsZXRpb24obmV4dEVmZmVjdCk7XG4gICAgICAgICAgICBpc1VubW91bnRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5leHRFZmZlY3QgPSBuZXh0RWZmZWN0Lm5leHRFZmZlY3Q7XG4gICAgfVxuXG4gICAge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5yZXNldEN1cnJlbnRGaWJlcigpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdEFsbExpZmVDeWNsZXMoKSB7XG4gICAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgIHZhciBlZmZlY3RUYWcgPSBuZXh0RWZmZWN0LmVmZmVjdFRhZztcblxuICAgICAgaWYgKGVmZmVjdFRhZyAmIChVcGRhdGUgfCBDYWxsYmFjaykpIHtcbiAgICAgICAgcmVjb3JkRWZmZWN0KCk7XG4gICAgICAgIHZhciBjdXJyZW50ID0gbmV4dEVmZmVjdC5hbHRlcm5hdGU7XG4gICAgICAgIGNvbW1pdExpZmVDeWNsZXMoY3VycmVudCwgbmV4dEVmZmVjdCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlZmZlY3RUYWcgJiBSZWYpIHtcbiAgICAgICAgcmVjb3JkRWZmZWN0KCk7XG4gICAgICAgIGNvbW1pdEF0dGFjaFJlZihuZXh0RWZmZWN0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVmZmVjdFRhZyAmIEVycikge1xuICAgICAgICByZWNvcmRFZmZlY3QoKTtcbiAgICAgICAgY29tbWl0RXJyb3JIYW5kbGluZyhuZXh0RWZmZWN0KTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5leHQgPSBuZXh0RWZmZWN0Lm5leHRFZmZlY3Q7XG4gICAgICAvLyBFbnN1cmUgdGhhdCB3ZSBjbGVhbiB0aGVzZSB1cCBzbyB0aGF0IHdlIGRvbid0IGFjY2lkZW50YWxseSBrZWVwIHRoZW0uXG4gICAgICAvLyBJJ20gbm90IGFjdHVhbGx5IHN1cmUgdGhpcyBtYXR0ZXJzIGJlY2F1c2Ugd2UgY2FuJ3QgcmVzZXQgZmlyc3RFZmZlY3RcbiAgICAgIC8vIGFuZCBsYXN0RWZmZWN0IHNpbmNlIHRoZXkncmUgb24gZXZlcnkgbm9kZSwgbm90IGp1c3QgdGhlIGVmZmVjdGZ1bFxuICAgICAgLy8gb25lcy4gU28gd2UgaGF2ZSB0byBjbGVhbiBldmVyeXRoaW5nIGFzIHdlIHJldXNlIG5vZGVzIGFueXdheS5cbiAgICAgIG5leHRFZmZlY3QubmV4dEVmZmVjdCA9IG51bGw7XG4gICAgICAvLyBFbnN1cmUgdGhhdCB3ZSByZXNldCB0aGUgZWZmZWN0VGFnIGhlcmUgc28gdGhhdCB3ZSBjYW4gcmVseSBvbiBlZmZlY3RcbiAgICAgIC8vIHRhZ3MgdG8gcmVhc29uIGFib3V0IHRoZSBjdXJyZW50IGxpZmUtY3ljbGUuXG4gICAgICBuZXh0RWZmZWN0ID0gbmV4dDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXRSb290KGZpbmlzaGVkV29yaykge1xuICAgIC8vIFdlIGtlZXAgdHJhY2sgb2YgdGhpcyBzbyB0aGF0IGNhcHR1cmVFcnJvciBjYW4gY29sbGVjdCBhbnkgYm91bmRhcmllc1xuICAgIC8vIHRoYXQgY2FwdHVyZSBhbiBlcnJvciBkdXJpbmcgdGhlIGNvbW1pdCBwaGFzZS4gVGhlIHJlYXNvbiB0aGVzZSBhcmVuJ3RcbiAgICAvLyBsb2NhbCB0byB0aGlzIGZ1bmN0aW9uIGlzIGJlY2F1c2UgZXJyb3JzIHRoYXQgb2NjdXIgZHVyaW5nIGNXVSBhcmVcbiAgICAvLyBjYXB0dXJlZCBlbHNld2hlcmUsIHRvIHByZXZlbnQgdGhlIHVubW91bnQgZnJvbSBiZWluZyBpbnRlcnJ1cHRlZC5cbiAgICBpc1dvcmtpbmcgPSB0cnVlO1xuICAgIGlzQ29tbWl0dGluZyA9IHRydWU7XG4gICAgc3RhcnRDb21taXRUaW1lcigpO1xuXG4gICAgdmFyIHJvb3QgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICEocm9vdC5jdXJyZW50ICE9PSBmaW5pc2hlZFdvcmspID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGNvbW1pdCB0aGUgc2FtZSB0cmVlIGFzIGJlZm9yZS4gVGhpcyBpcyBwcm9iYWJseSBhIGJ1ZyByZWxhdGVkIHRvIHRoZSByZXR1cm4gZmllbGQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgcm9vdC5pc1JlYWR5Rm9yQ29tbWl0ID0gZmFsc2U7XG5cbiAgICAvLyBSZXNldCB0aGlzIHRvIG51bGwgYmVmb3JlIGNhbGxpbmcgbGlmZWN5Y2xlc1xuICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuXG4gICAgdmFyIGZpcnN0RWZmZWN0ID0gdm9pZCAwO1xuICAgIGlmIChmaW5pc2hlZFdvcmsuZWZmZWN0VGFnID4gUGVyZm9ybWVkV29yaykge1xuICAgICAgLy8gQSBmaWJlcidzIGVmZmVjdCBsaXN0IGNvbnNpc3RzIG9ubHkgb2YgaXRzIGNoaWxkcmVuLCBub3QgaXRzZWxmLiBTbyBpZlxuICAgICAgLy8gdGhlIHJvb3QgaGFzIGFuIGVmZmVjdCwgd2UgbmVlZCB0byBhZGQgaXQgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdC4gVGhlXG4gICAgICAvLyByZXN1bHRpbmcgbGlzdCBpcyB0aGUgc2V0IHRoYXQgd291bGQgYmVsb25nIHRvIHRoZSByb290J3MgcGFyZW50LCBpZlxuICAgICAgLy8gaXQgaGFkIG9uZTsgdGhhdCBpcywgYWxsIHRoZSBlZmZlY3RzIGluIHRoZSB0cmVlIGluY2x1ZGluZyB0aGUgcm9vdC5cbiAgICAgIGlmIChmaW5pc2hlZFdvcmsubGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICBmaW5pc2hlZFdvcmsubGFzdEVmZmVjdC5uZXh0RWZmZWN0ID0gZmluaXNoZWRXb3JrO1xuICAgICAgICBmaXJzdEVmZmVjdCA9IGZpbmlzaGVkV29yay5maXJzdEVmZmVjdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpcnN0RWZmZWN0ID0gZmluaXNoZWRXb3JrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGVyZSBpcyBubyBlZmZlY3Qgb24gdGhlIHJvb3QuXG4gICAgICBmaXJzdEVmZmVjdCA9IGZpbmlzaGVkV29yay5maXJzdEVmZmVjdDtcbiAgICB9XG5cbiAgICBwcmVwYXJlRm9yQ29tbWl0KCk7XG5cbiAgICAvLyBDb21taXQgYWxsIHRoZSBzaWRlLWVmZmVjdHMgd2l0aGluIGEgdHJlZS4gV2UnbGwgZG8gdGhpcyBpbiB0d28gcGFzc2VzLlxuICAgIC8vIFRoZSBmaXJzdCBwYXNzIHBlcmZvcm1zIGFsbCB0aGUgaG9zdCBpbnNlcnRpb25zLCB1cGRhdGVzLCBkZWxldGlvbnMgYW5kXG4gICAgLy8gcmVmIHVubW91bnRzLlxuICAgIG5leHRFZmZlY3QgPSBmaXJzdEVmZmVjdDtcbiAgICBzdGFydENvbW1pdEhvc3RFZmZlY3RzVGltZXIoKTtcbiAgICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgdmFyIGRpZEVycm9yID0gZmFsc2U7XG4gICAgICB2YXIgX2Vycm9yID0gdm9pZCAwO1xuICAgICAge1xuICAgICAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2skMShudWxsLCBjb21taXRBbGxIb3N0RWZmZWN0cywgbnVsbCk7XG4gICAgICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICAgICAgZGlkRXJyb3IgPSB0cnVlO1xuICAgICAgICAgIF9lcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGRpZEVycm9yKSB7XG4gICAgICAgICEobmV4dEVmZmVjdCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgaGF2ZSBuZXh0IGVmZmVjdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgICAgY2FwdHVyZUVycm9yKG5leHRFZmZlY3QsIF9lcnJvcik7XG4gICAgICAgIC8vIENsZWFuLXVwXG4gICAgICAgIGlmIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgbmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBzdG9wQ29tbWl0SG9zdEVmZmVjdHNUaW1lcigpO1xuXG4gICAgcmVzZXRBZnRlckNvbW1pdCgpO1xuXG4gICAgLy8gVGhlIHdvcmstaW4tcHJvZ3Jlc3MgdHJlZSBpcyBub3cgdGhlIGN1cnJlbnQgdHJlZS4gVGhpcyBtdXN0IGNvbWUgYWZ0ZXJcbiAgICAvLyB0aGUgZmlyc3QgcGFzcyBvZiB0aGUgY29tbWl0IHBoYXNlLCBzbyB0aGF0IHRoZSBwcmV2aW91cyB0cmVlIGlzIHN0aWxsXG4gICAgLy8gY3VycmVudCBkdXJpbmcgY29tcG9uZW50V2lsbFVubW91bnQsIGJ1dCBiZWZvcmUgdGhlIHNlY29uZCBwYXNzLCBzbyB0aGF0XG4gICAgLy8gdGhlIGZpbmlzaGVkIHdvcmsgaXMgY3VycmVudCBkdXJpbmcgY29tcG9uZW50RGlkTW91bnQvVXBkYXRlLlxuICAgIHJvb3QuY3VycmVudCA9IGZpbmlzaGVkV29yaztcblxuICAgIC8vIEluIHRoZSBzZWNvbmQgcGFzcyB3ZSdsbCBwZXJmb3JtIGFsbCBsaWZlLWN5Y2xlcyBhbmQgcmVmIGNhbGxiYWNrcy5cbiAgICAvLyBMaWZlLWN5Y2xlcyBoYXBwZW4gYXMgYSBzZXBhcmF0ZSBwYXNzIHNvIHRoYXQgYWxsIHBsYWNlbWVudHMsIHVwZGF0ZXMsXG4gICAgLy8gYW5kIGRlbGV0aW9ucyBpbiB0aGUgZW50aXJlIHRyZWUgaGF2ZSBhbHJlYWR5IGJlZW4gaW52b2tlZC5cbiAgICAvLyBUaGlzIHBhc3MgYWxzbyB0cmlnZ2VycyBhbnkgcmVuZGVyZXItc3BlY2lmaWMgaW5pdGlhbCBlZmZlY3RzLlxuICAgIG5leHRFZmZlY3QgPSBmaXJzdEVmZmVjdDtcbiAgICBzdGFydENvbW1pdExpZmVDeWNsZXNUaW1lcigpO1xuICAgIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICB2YXIgX2RpZEVycm9yID0gZmFsc2U7XG4gICAgICB2YXIgX2Vycm9yMiA9IHZvaWQgMDtcbiAgICAgIHtcbiAgICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrJDEobnVsbCwgY29tbWl0QWxsTGlmZUN5Y2xlcywgbnVsbCk7XG4gICAgICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICAgICAgX2RpZEVycm9yID0gdHJ1ZTtcbiAgICAgICAgICBfZXJyb3IyID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoX2RpZEVycm9yKSB7XG4gICAgICAgICEobmV4dEVmZmVjdCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgaGF2ZSBuZXh0IGVmZmVjdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgICAgY2FwdHVyZUVycm9yKG5leHRFZmZlY3QsIF9lcnJvcjIpO1xuICAgICAgICBpZiAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgIG5leHRFZmZlY3QgPSBuZXh0RWZmZWN0Lm5leHRFZmZlY3Q7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpc0NvbW1pdHRpbmcgPSBmYWxzZTtcbiAgICBpc1dvcmtpbmcgPSBmYWxzZTtcbiAgICBzdG9wQ29tbWl0TGlmZUN5Y2xlc1RpbWVyKCk7XG4gICAgc3RvcENvbW1pdFRpbWVyKCk7XG4gICAgaWYgKHR5cGVvZiBvbkNvbW1pdFJvb3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG9uQ29tbWl0Um9vdChmaW5pc2hlZFdvcmsuc3RhdGVOb2RlKTtcbiAgICB9XG4gICAgaWYgKHRydWUgJiYgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbCkge1xuICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vbkNvbW1pdFdvcmsoZmluaXNoZWRXb3JrKTtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBjYXVnaHQgYW55IGVycm9ycyBkdXJpbmcgdGhpcyBjb21taXQsIHNjaGVkdWxlIHRoZWlyIGJvdW5kYXJpZXNcbiAgICAvLyB0byB1cGRhdGUuXG4gICAgaWYgKGNvbW1pdFBoYXNlQm91bmRhcmllcykge1xuICAgICAgY29tbWl0UGhhc2VCb3VuZGFyaWVzLmZvckVhY2goc2NoZWR1bGVFcnJvclJlY292ZXJ5KTtcbiAgICAgIGNvbW1pdFBoYXNlQm91bmRhcmllcyA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGZpcnN0VW5jYXVnaHRFcnJvciAhPT0gbnVsbCkge1xuICAgICAgdmFyIF9lcnJvcjMgPSBmaXJzdFVuY2F1Z2h0RXJyb3I7XG4gICAgICBmaXJzdFVuY2F1Z2h0RXJyb3IgPSBudWxsO1xuICAgICAgb25VbmNhdWdodEVycm9yKF9lcnJvcjMpO1xuICAgIH1cblxuICAgIHZhciByZW1haW5pbmdUaW1lID0gcm9vdC5jdXJyZW50LmV4cGlyYXRpb25UaW1lO1xuXG4gICAgaWYgKHJlbWFpbmluZ1RpbWUgPT09IE5vV29yaykge1xuICAgICAgY2FwdHVyZWRFcnJvcnMgPSBudWxsO1xuICAgICAgZmFpbGVkQm91bmRhcmllcyA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlbWFpbmluZ1RpbWU7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldEV4cGlyYXRpb25UaW1lKHdvcmtJblByb2dyZXNzLCByZW5kZXJUaW1lKSB7XG4gICAgaWYgKHJlbmRlclRpbWUgIT09IE5ldmVyICYmIHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID09PSBOZXZlcikge1xuICAgICAgLy8gVGhlIGNoaWxkcmVuIG9mIHRoaXMgY29tcG9uZW50IGFyZSBoaWRkZW4uIERvbid0IGJ1YmJsZSB0aGVpclxuICAgICAgLy8gZXhwaXJhdGlvbiB0aW1lcy5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgcGVuZGluZyB1cGRhdGVzLlxuICAgIHZhciBuZXdFeHBpcmF0aW9uVGltZSA9IGdldFVwZGF0ZUV4cGlyYXRpb25UaW1lKHdvcmtJblByb2dyZXNzKTtcblxuICAgIC8vIFRPRE86IENhbGxzIG5lZWQgdG8gdmlzaXQgc3RhdGVOb2RlXG5cbiAgICAvLyBCdWJibGUgdXAgdGhlIGVhcmxpZXN0IGV4cGlyYXRpb24gdGltZS5cbiAgICB2YXIgY2hpbGQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIGlmIChjaGlsZC5leHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrICYmIChuZXdFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IG5ld0V4cGlyYXRpb25UaW1lID4gY2hpbGQuZXhwaXJhdGlvblRpbWUpKSB7XG4gICAgICAgIG5ld0V4cGlyYXRpb25UaW1lID0gY2hpbGQuZXhwaXJhdGlvblRpbWU7XG4gICAgICB9XG4gICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgfVxuICAgIHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID0gbmV3RXhwaXJhdGlvblRpbWU7XG4gIH1cblxuICBmdW5jdGlvbiBjb21wbGV0ZVVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpIHtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgLy8gVGhlIGN1cnJlbnQsIGZsdXNoZWQsIHN0YXRlIG9mIHRoaXMgZmliZXIgaXMgdGhlIGFsdGVybmF0ZS5cbiAgICAgIC8vIElkZWFsbHkgbm90aGluZyBzaG91bGQgcmVseSBvbiB0aGlzLCBidXQgcmVseWluZyBvbiBpdCBoZXJlXG4gICAgICAvLyBtZWFucyB0aGF0IHdlIGRvbid0IG5lZWQgYW4gYWRkaXRpb25hbCBmaWVsZCBvbiB0aGUgd29yayBpblxuICAgICAgLy8gcHJvZ3Jlc3MuXG4gICAgICB2YXIgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcbiAgICAgIHtcbiAgICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50RmliZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgfVxuICAgICAgdmFyIG5leHQgPSBjb21wbGV0ZVdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICB7XG4gICAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIucmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJldHVybkZpYmVyID0gd29ya0luUHJvZ3Jlc3NbJ3JldHVybiddO1xuICAgICAgdmFyIHNpYmxpbmdGaWJlciA9IHdvcmtJblByb2dyZXNzLnNpYmxpbmc7XG5cbiAgICAgIHJlc2V0RXhwaXJhdGlvblRpbWUod29ya0luUHJvZ3Jlc3MsIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSk7XG5cbiAgICAgIGlmIChuZXh0ICE9PSBudWxsKSB7XG4gICAgICAgIHN0b3BXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBpZiAodHJ1ZSAmJiBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sKSB7XG4gICAgICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vbkNvbXBsZXRlV29yayh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgY29tcGxldGluZyB0aGlzIHdvcmsgc3Bhd25lZCBuZXcgd29yaywgZG8gdGhhdCBuZXh0LiBXZSdsbCBjb21lXG4gICAgICAgIC8vIGJhY2sgaGVyZSBhZ2Fpbi5cbiAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXR1cm5GaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAvLyBBcHBlbmQgYWxsIHRoZSBlZmZlY3RzIG9mIHRoZSBzdWJ0cmVlIGFuZCB0aGlzIGZpYmVyIG9udG8gdGhlIGVmZmVjdFxuICAgICAgICAvLyBsaXN0IG9mIHRoZSBwYXJlbnQuIFRoZSBjb21wbGV0aW9uIG9yZGVyIG9mIHRoZSBjaGlsZHJlbiBhZmZlY3RzIHRoZVxuICAgICAgICAvLyBzaWRlLWVmZmVjdCBvcmRlci5cbiAgICAgICAgaWYgKHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuRmliZXIuZmlyc3RFZmZlY3QgPSB3b3JrSW5Qcm9ncmVzcy5maXJzdEVmZmVjdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MubGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChyZXR1cm5GaWJlci5sYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0Lm5leHRFZmZlY3QgPSB3b3JrSW5Qcm9ncmVzcy5maXJzdEVmZmVjdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IHdvcmtJblByb2dyZXNzLmxhc3RFZmZlY3Q7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGlzIGZpYmVyIGhhZCBzaWRlLWVmZmVjdHMsIHdlIGFwcGVuZCBpdCBBRlRFUiB0aGUgY2hpbGRyZW4nc1xuICAgICAgICAvLyBzaWRlLWVmZmVjdHMuIFdlIGNhbiBwZXJmb3JtIGNlcnRhaW4gc2lkZS1lZmZlY3RzIGVhcmxpZXIgaWZcbiAgICAgICAgLy8gbmVlZGVkLCBieSBkb2luZyBtdWx0aXBsZSBwYXNzZXMgb3ZlciB0aGUgZWZmZWN0IGxpc3QuIFdlIGRvbid0IHdhbnRcbiAgICAgICAgLy8gdG8gc2NoZWR1bGUgb3VyIG93biBzaWRlLWVmZmVjdCBvbiBvdXIgb3duIGxpc3QgYmVjYXVzZSBpZiBlbmQgdXBcbiAgICAgICAgLy8gcmV1c2luZyBjaGlsZHJlbiB3ZSdsbCBzY2hlZHVsZSB0aGlzIGVmZmVjdCBvbnRvIGl0c2VsZiBzaW5jZSB3ZSdyZVxuICAgICAgICAvLyBhdCB0aGUgZW5kLlxuICAgICAgICB2YXIgZWZmZWN0VGFnID0gd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnO1xuICAgICAgICAvLyBTa2lwIGJvdGggTm9Xb3JrIGFuZCBQZXJmb3JtZWRXb3JrIHRhZ3Mgd2hlbiBjcmVhdGluZyB0aGUgZWZmZWN0IGxpc3QuXG4gICAgICAgIC8vIFBlcmZvcm1lZFdvcmsgZWZmZWN0IGlzIHJlYWQgYnkgUmVhY3QgRGV2VG9vbHMgYnV0IHNob3VsZG4ndCBiZSBjb21taXR0ZWQuXG4gICAgICAgIGlmIChlZmZlY3RUYWcgPiBQZXJmb3JtZWRXb3JrKSB7XG4gICAgICAgICAgaWYgKHJldHVybkZpYmVyLmxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QubmV4dEVmZmVjdCA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3RvcFdvcmtUaW1lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBpZiAodHJ1ZSAmJiBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sKSB7XG4gICAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25Db21wbGV0ZVdvcmsod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2libGluZ0ZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG1vcmUgd29yayB0byBkbyBpbiB0aGlzIHJldHVybkZpYmVyLCBkbyB0aGF0IG5leHQuXG4gICAgICAgIHJldHVybiBzaWJsaW5nRmliZXI7XG4gICAgICB9IGVsc2UgaWYgKHJldHVybkZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gbW9yZSB3b3JrIGluIHRoaXMgcmV0dXJuRmliZXIuIENvbXBsZXRlIHRoZSByZXR1cm5GaWJlci5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSByZXR1cm5GaWJlcjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXZSd2ZSByZWFjaGVkIHRoZSByb290LlxuICAgICAgICB2YXIgcm9vdCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgcm9vdC5pc1JlYWR5Rm9yQ29tbWl0ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gV2l0aG91dCB0aGlzIGV4cGxpY2l0IG51bGwgcmV0dXJuIEZsb3cgY29tcGxhaW5zIG9mIGludmFsaWQgcmV0dXJuIHR5cGVcbiAgICAvLyBUT0RPIFJlbW92ZSB0aGUgYWJvdmUgd2hpbGUodHJ1ZSkgbG9vcFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnJlYWNoYWJsZVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybVVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpIHtcbiAgICAvLyBUaGUgY3VycmVudCwgZmx1c2hlZCwgc3RhdGUgb2YgdGhpcyBmaWJlciBpcyB0aGUgYWx0ZXJuYXRlLlxuICAgIC8vIElkZWFsbHkgbm90aGluZyBzaG91bGQgcmVseSBvbiB0aGlzLCBidXQgcmVseWluZyBvbiBpdCBoZXJlXG4gICAgLy8gbWVhbnMgdGhhdCB3ZSBkb24ndCBuZWVkIGFuIGFkZGl0aW9uYWwgZmllbGQgb24gdGhlIHdvcmsgaW5cbiAgICAvLyBwcm9ncmVzcy5cbiAgICB2YXIgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcblxuICAgIC8vIFNlZSBpZiBiZWdpbm5pbmcgdGhpcyB3b3JrIHNwYXducyBtb3JlIHdvcmsuXG4gICAgc3RhcnRXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuc2V0Q3VycmVudEZpYmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICB2YXIgbmV4dCA9IGJlZ2luV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgfVxuICAgIGlmICh0cnVlICYmIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wpIHtcbiAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25CZWdpbldvcmsod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIGlmIChuZXh0ID09PSBudWxsKSB7XG4gICAgICAvLyBJZiB0aGlzIGRvZXNuJ3Qgc3Bhd24gbmV3IHdvcmssIGNvbXBsZXRlIHRoZSBjdXJyZW50IHdvcmsuXG4gICAgICBuZXh0ID0gY29tcGxldGVVbml0T2ZXb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gbnVsbDtcblxuICAgIHJldHVybiBuZXh0O1xuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybUZhaWxlZFVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpIHtcbiAgICAvLyBUaGUgY3VycmVudCwgZmx1c2hlZCwgc3RhdGUgb2YgdGhpcyBmaWJlciBpcyB0aGUgYWx0ZXJuYXRlLlxuICAgIC8vIElkZWFsbHkgbm90aGluZyBzaG91bGQgcmVseSBvbiB0aGlzLCBidXQgcmVseWluZyBvbiBpdCBoZXJlXG4gICAgLy8gbWVhbnMgdGhhdCB3ZSBkb24ndCBuZWVkIGFuIGFkZGl0aW9uYWwgZmllbGQgb24gdGhlIHdvcmsgaW5cbiAgICAvLyBwcm9ncmVzcy5cbiAgICB2YXIgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcblxuICAgIC8vIFNlZSBpZiBiZWdpbm5pbmcgdGhpcyB3b3JrIHNwYXducyBtb3JlIHdvcmsuXG4gICAgc3RhcnRXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuc2V0Q3VycmVudEZpYmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gICAgdmFyIG5leHQgPSBiZWdpbkZhaWxlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5yZXNldEN1cnJlbnRGaWJlcigpO1xuICAgIH1cbiAgICBpZiAodHJ1ZSAmJiBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sKSB7XG4gICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uQmVnaW5Xb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBpZiAobmV4dCA9PT0gbnVsbCkge1xuICAgICAgLy8gSWYgdGhpcyBkb2Vzbid0IHNwYXduIG5ldyB3b3JrLCBjb21wbGV0ZSB0aGUgY3VycmVudCB3b3JrLlxuICAgICAgbmV4dCA9IGNvbXBsZXRlVW5pdE9mV29yayh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IG51bGw7XG5cbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdvcmtMb29wKGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKGNhcHR1cmVkRXJyb3JzICE9PSBudWxsKSB7XG4gICAgICAvLyBJZiB0aGVyZSBhcmUgdW5oYW5kbGVkIGVycm9ycywgc3dpdGNoIHRvIHRoZSBzbG93IHdvcmsgbG9vcC5cbiAgICAgIC8vIFRPRE86IEhvdyB0byBhdm9pZCB0aGlzIGNoZWNrIGluIHRoZSBmYXN0IHBhdGg/IE1heWJlIHRoZSByZW5kZXJlclxuICAgICAgLy8gY291bGQga2VlcCB0cmFjayBvZiB3aGljaCByb290cyBoYXZlIHVuaGFuZGxlZCBlcnJvcnMgYW5kIGNhbGwgYVxuICAgICAgLy8gZm9ya2VkIHZlcnNpb24gb2YgcmVuZGVyUm9vdC5cbiAgICAgIHNsb3dXb3JrTG9vcFRoYXRDaGVja3NGb3JGYWlsZWRXb3JrKGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSA+IGV4cGlyYXRpb25UaW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSA8PSBtb3N0UmVjZW50Q3VycmVudFRpbWUpIHtcbiAgICAgIC8vIEZsdXNoIGFsbCBleHBpcmVkIHdvcmsuXG4gICAgICB3aGlsZSAobmV4dFVuaXRPZldvcmsgIT09IG51bGwpIHtcbiAgICAgICAgbmV4dFVuaXRPZldvcmsgPSBwZXJmb3JtVW5pdE9mV29yayhuZXh0VW5pdE9mV29yayk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZsdXNoIGFzeW5jaHJvbm91cyB3b3JrIHVudGlsIHRoZSBkZWFkbGluZSBydW5zIG91dCBvZiB0aW1lLlxuICAgICAgd2hpbGUgKG5leHRVbml0T2ZXb3JrICE9PSBudWxsICYmICFzaG91bGRZaWVsZCgpKSB7XG4gICAgICAgIG5leHRVbml0T2ZXb3JrID0gcGVyZm9ybVVuaXRPZldvcmsobmV4dFVuaXRPZldvcmspO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNsb3dXb3JrTG9vcFRoYXRDaGVja3NGb3JGYWlsZWRXb3JrKGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSA+IGV4cGlyYXRpb25UaW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSA8PSBtb3N0UmVjZW50Q3VycmVudFRpbWUpIHtcbiAgICAgIC8vIEZsdXNoIGFsbCBleHBpcmVkIHdvcmsuXG4gICAgICB3aGlsZSAobmV4dFVuaXRPZldvcmsgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKGhhc0NhcHR1cmVkRXJyb3IobmV4dFVuaXRPZldvcmspKSB7XG4gICAgICAgICAgLy8gVXNlIGEgZm9ya2VkIHZlcnNpb24gb2YgcGVyZm9ybVVuaXRPZldvcmtcbiAgICAgICAgICBuZXh0VW5pdE9mV29yayA9IHBlcmZvcm1GYWlsZWRVbml0T2ZXb3JrKG5leHRVbml0T2ZXb3JrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0VW5pdE9mV29yayA9IHBlcmZvcm1Vbml0T2ZXb3JrKG5leHRVbml0T2ZXb3JrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGbHVzaCBhc3luY2hyb25vdXMgd29yayB1bnRpbCB0aGUgZGVhZGxpbmUgcnVucyBvdXQgb2YgdGltZS5cbiAgICAgIHdoaWxlIChuZXh0VW5pdE9mV29yayAhPT0gbnVsbCAmJiAhc2hvdWxkWWllbGQoKSkge1xuICAgICAgICBpZiAoaGFzQ2FwdHVyZWRFcnJvcihuZXh0VW5pdE9mV29yaykpIHtcbiAgICAgICAgICAvLyBVc2UgYSBmb3JrZWQgdmVyc2lvbiBvZiBwZXJmb3JtVW5pdE9mV29ya1xuICAgICAgICAgIG5leHRVbml0T2ZXb3JrID0gcGVyZm9ybUZhaWxlZFVuaXRPZldvcmsobmV4dFVuaXRPZldvcmspO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHRVbml0T2ZXb3JrID0gcGVyZm9ybVVuaXRPZldvcmsobmV4dFVuaXRPZldvcmspO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVuZGVyUm9vdENhdGNoQmxvY2socm9vdCwgZmFpbGVkV29yaywgYm91bmRhcnksIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gV2UncmUgZ29pbmcgdG8gcmVzdGFydCB0aGUgZXJyb3IgYm91bmRhcnkgdGhhdCBjYXB0dXJlZCB0aGUgZXJyb3IuXG4gICAgLy8gQ29uY2VwdHVhbGx5LCB3ZSdyZSB1bndpbmRpbmcgdGhlIHN0YWNrLiBXZSBuZWVkIHRvIHVud2luZCB0aGVcbiAgICAvLyBjb250ZXh0IHN0YWNrLCB0b28uXG4gICAgdW53aW5kQ29udGV4dHMoZmFpbGVkV29yaywgYm91bmRhcnkpO1xuXG4gICAgLy8gUmVzdGFydCB0aGUgZXJyb3IgYm91bmRhcnkgdXNpbmcgYSBmb3JrZWQgdmVyc2lvbiBvZlxuICAgIC8vIHBlcmZvcm1Vbml0T2ZXb3JrIHRoYXQgZGVsZXRlcyB0aGUgYm91bmRhcnkncyBjaGlsZHJlbi4gVGhlIGVudGlyZVxuICAgIC8vIGZhaWxlZCBzdWJyZWUgd2lsbCBiZSB1bm1vdW50ZWQuIER1cmluZyB0aGUgY29tbWl0IHBoYXNlLCBhIHNwZWNpYWxcbiAgICAvLyBsaWZlY3ljbGUgbWV0aG9kIGlzIGNhbGxlZCBvbiB0aGUgZXJyb3IgYm91bmRhcnksIHdoaWNoIHRyaWdnZXJzXG4gICAgLy8gYSByZS1yZW5kZXIuXG4gICAgbmV4dFVuaXRPZldvcmsgPSBwZXJmb3JtRmFpbGVkVW5pdE9mV29yayhib3VuZGFyeSk7XG5cbiAgICAvLyBDb250aW51ZSB3b3JraW5nLlxuICAgIHdvcmtMb29wKGV4cGlyYXRpb25UaW1lKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbmRlclJvb3Qocm9vdCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAhIWlzV29ya2luZyA/IGludmFyaWFudChmYWxzZSwgJ3JlbmRlclJvb3Qgd2FzIGNhbGxlZCByZWN1cnNpdmVseS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICBpc1dvcmtpbmcgPSB0cnVlO1xuXG4gICAgLy8gV2UncmUgYWJvdXQgdG8gbXV0YXRlIHRoZSB3b3JrLWluLXByb2dyZXNzIHRyZWUuIElmIHRoZSByb290IHdhcyBwZW5kaW5nXG4gICAgLy8gY29tbWl0LCBpdCBubyBsb25nZXIgaXM6IHdlJ2xsIG5lZWQgdG8gY29tcGxldGUgaXQgYWdhaW4uXG4gICAgcm9vdC5pc1JlYWR5Rm9yQ29tbWl0ID0gZmFsc2U7XG5cbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBzdGFydGluZyBmcm9tIGEgZnJlc2ggc3RhY2ssIG9yIGlmIHdlJ3JlIHJlc3VtaW5nIGZyb21cbiAgICAvLyBwcmV2aW91c2x5IHlpZWxkZWQgd29yay5cbiAgICBpZiAocm9vdCAhPT0gbmV4dFJvb3QgfHwgZXhwaXJhdGlvblRpbWUgIT09IG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSB8fCBuZXh0VW5pdE9mV29yayA9PT0gbnVsbCkge1xuICAgICAgLy8gUmVzZXQgdGhlIHN0YWNrIGFuZCBzdGFydCB3b3JraW5nIGZyb20gdGhlIHJvb3QuXG4gICAgICByZXNldENvbnRleHRTdGFjaygpO1xuICAgICAgbmV4dFJvb3QgPSByb290O1xuICAgICAgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgICBuZXh0VW5pdE9mV29yayA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKG5leHRSb290LmN1cnJlbnQsIG51bGwsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG5cbiAgICBzdGFydFdvcmtMb29wVGltZXIobmV4dFVuaXRPZldvcmspO1xuXG4gICAgdmFyIGRpZEVycm9yID0gZmFsc2U7XG4gICAgdmFyIGVycm9yID0gbnVsbDtcbiAgICB7XG4gICAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2skMShudWxsLCB3b3JrTG9vcCwgbnVsbCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgaWYgKGhhc0NhdWdodEVycm9yKCkpIHtcbiAgICAgICAgZGlkRXJyb3IgPSB0cnVlO1xuICAgICAgICBlcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBbiBlcnJvciB3YXMgdGhyb3duIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLlxuICAgIHdoaWxlIChkaWRFcnJvcikge1xuICAgICAgaWYgKGRpZEZhdGFsKSB7XG4gICAgICAgIC8vIFRoaXMgd2FzIGEgZmF0YWwgZXJyb3IuIERvbid0IGF0dGVtcHQgdG8gcmVjb3ZlciBmcm9tIGl0LlxuICAgICAgICBmaXJzdFVuY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHZhciBmYWlsZWRXb3JrID0gbmV4dFVuaXRPZldvcms7XG4gICAgICBpZiAoZmFpbGVkV29yayA9PT0gbnVsbCkge1xuICAgICAgICAvLyBBbiBlcnJvciB3YXMgdGhyb3duIGJ1dCB0aGVyZSdzIG5vIGN1cnJlbnQgdW5pdCBvZiB3b3JrLiBUaGlzIGNhblxuICAgICAgICAvLyBoYXBwZW4gZHVyaW5nIHRoZSBjb21taXQgcGhhc2UgaWYgdGhlcmUncyBhIGJ1ZyBpbiB0aGUgcmVuZGVyZXIuXG4gICAgICAgIGRpZEZhdGFsID0gdHJ1ZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFwiQ2FwdHVyZVwiIHRoZSBlcnJvciBieSBmaW5kaW5nIHRoZSBuZWFyZXN0IGJvdW5kYXJ5LiBJZiB0aGVyZSBpcyBub1xuICAgICAgLy8gZXJyb3IgYm91bmRhcnksIHdlIHVzZSB0aGUgcm9vdC5cbiAgICAgIHZhciBib3VuZGFyeSA9IGNhcHR1cmVFcnJvcihmYWlsZWRXb3JrLCBlcnJvcik7XG4gICAgICAhKGJvdW5kYXJ5ICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1Nob3VsZCBoYXZlIGZvdW5kIGFuIGVycm9yIGJvdW5kYXJ5LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gICAgICBpZiAoZGlkRmF0YWwpIHtcbiAgICAgICAgLy8gVGhlIGVycm9yIHdlIGp1c3QgY2FwdHVyZWQgd2FzIGEgZmF0YWwgZXJyb3IuIFRoaXMgaGFwcGVuc1xuICAgICAgICAvLyB3aGVuIHRoZSBlcnJvciBwcm9wYWdhdGVzIHRvIHRoZSByb290IG1vcmUgdGhhbiBvbmNlLlxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgZGlkRXJyb3IgPSBmYWxzZTtcbiAgICAgIGVycm9yID0gbnVsbDtcbiAgICAgIHtcbiAgICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrJDEobnVsbCwgcmVuZGVyUm9vdENhdGNoQmxvY2ssIG51bGwsIHJvb3QsIGZhaWxlZFdvcmssIGJvdW5kYXJ5LCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICAgICAgZGlkRXJyb3IgPSB0cnVlO1xuICAgICAgICAgIGVycm9yID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBXZSdyZSBmaW5pc2hlZCB3b3JraW5nLiBFeGl0IHRoZSBlcnJvciBsb29wLlxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIHVuY2F1Z2h0RXJyb3IgPSBmaXJzdFVuY2F1Z2h0RXJyb3I7XG5cbiAgICAvLyBXZSdyZSBkb25lIHBlcmZvcm1pbmcgd29yay4gVGltZSB0byBjbGVhbiB1cC5cbiAgICBzdG9wV29ya0xvb3BUaW1lcihpbnRlcnJ1cHRlZEJ5KTtcbiAgICBpbnRlcnJ1cHRlZEJ5ID0gbnVsbDtcbiAgICBpc1dvcmtpbmcgPSBmYWxzZTtcbiAgICBkaWRGYXRhbCA9IGZhbHNlO1xuICAgIGZpcnN0VW5jYXVnaHRFcnJvciA9IG51bGw7XG5cbiAgICBpZiAodW5jYXVnaHRFcnJvciAhPT0gbnVsbCkge1xuICAgICAgb25VbmNhdWdodEVycm9yKHVuY2F1Z2h0RXJyb3IpO1xuICAgIH1cblxuICAgIHJldHVybiByb290LmlzUmVhZHlGb3JDb21taXQgPyByb290LmN1cnJlbnQuYWx0ZXJuYXRlIDogbnVsbDtcbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIGJvdW5kYXJ5IHRoYXQgY2FwdHVyZWQgdGhlIGVycm9yLCBvciBudWxsIGlmIHRoZSBlcnJvciBpcyBpZ25vcmVkXG4gIGZ1bmN0aW9uIGNhcHR1cmVFcnJvcihmYWlsZWRXb3JrLCBlcnJvcikge1xuICAgIC8vIEl0IGlzIG5vIGxvbmdlciB2YWxpZCBiZWNhdXNlIHdlIGV4aXRlZCB0aGUgdXNlciBjb2RlLlxuICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuICAgIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIucmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICB9XG5cbiAgICAvLyBTZWFyY2ggZm9yIHRoZSBuZWFyZXN0IGVycm9yIGJvdW5kYXJ5LlxuICAgIHZhciBib3VuZGFyeSA9IG51bGw7XG5cbiAgICAvLyBQYXNzZWQgdG8gbG9nQ2FwdHVyZWRFcnJvcigpXG4gICAgdmFyIGVycm9yQm91bmRhcnlGb3VuZCA9IGZhbHNlO1xuICAgIHZhciB3aWxsUmV0cnkgPSBmYWxzZTtcbiAgICB2YXIgZXJyb3JCb3VuZGFyeU5hbWUgPSBudWxsO1xuXG4gICAgLy8gSG9zdCBjb250YWluZXJzIGFyZSBhIHNwZWNpYWwgY2FzZS4gSWYgdGhlIGZhaWxlZCB3b3JrIGl0c2VsZiBpcyBhIGhvc3RcbiAgICAvLyBjb250YWluZXIsIHRoZW4gaXQgYWN0cyBhcyBpdHMgb3duIGJvdW5kYXJ5LiBJbiBhbGwgb3RoZXIgY2FzZXMsIHdlXG4gICAgLy8gaWdub3JlIHRoZSB3b3JrIGl0c2VsZiBhbmQgb25seSBzZWFyY2ggdGhyb3VnaCB0aGUgcGFyZW50cy5cbiAgICBpZiAoZmFpbGVkV29yay50YWcgPT09IEhvc3RSb290KSB7XG4gICAgICBib3VuZGFyeSA9IGZhaWxlZFdvcms7XG5cbiAgICAgIGlmIChpc0ZhaWxlZEJvdW5kYXJ5KGZhaWxlZFdvcmspKSB7XG4gICAgICAgIC8vIElmIHRoaXMgcm9vdCBhbHJlYWR5IGZhaWxlZCwgdGhlcmUgbXVzdCBoYXZlIGJlZW4gYW4gZXJyb3Igd2hlblxuICAgICAgICAvLyBhdHRlbXB0aW5nIHRvIHVubW91bnQgaXQuIFRoaXMgaXMgYSB3b3JzdC1jYXNlIHNjZW5hcmlvIGFuZFxuICAgICAgICAvLyBzaG91bGQgb25seSBiZSBwb3NzaWJsZSBpZiB0aGVyZSdzIGEgYnVnIGluIHRoZSByZW5kZXJlci5cbiAgICAgICAgZGlkRmF0YWwgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbm9kZSA9IGZhaWxlZFdvcmtbJ3JldHVybiddO1xuICAgICAgd2hpbGUgKG5vZGUgIT09IG51bGwgJiYgYm91bmRhcnkgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGUudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IG5vZGUuc3RhdGVOb2RlO1xuICAgICAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkQ2F0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGVycm9yQm91bmRhcnlGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICBlcnJvckJvdW5kYXJ5TmFtZSA9IGdldENvbXBvbmVudE5hbWUobm9kZSk7XG5cbiAgICAgICAgICAgIC8vIEZvdW5kIGFuIGVycm9yIGJvdW5kYXJ5IVxuICAgICAgICAgICAgYm91bmRhcnkgPSBub2RlO1xuICAgICAgICAgICAgd2lsbFJldHJ5ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RSb290KSB7XG4gICAgICAgICAgLy8gVHJlYXQgdGhlIHJvb3QgbGlrZSBhIG5vLW9wIGVycm9yIGJvdW5kYXJ5XG4gICAgICAgICAgYm91bmRhcnkgPSBub2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRmFpbGVkQm91bmRhcnkobm9kZSkpIHtcbiAgICAgICAgICAvLyBUaGlzIGJvdW5kYXJ5IGlzIGFscmVhZHkgaW4gYSBmYWlsZWQgc3RhdGUuXG5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBjdXJyZW50bHkgdW5tb3VudGluZywgdGhhdCBtZWFucyB0aGlzIGVycm9yIHdhc1xuICAgICAgICAgIC8vIHRocm93biB3aGlsZSB1bm1vdW50aW5nIGEgZmFpbGVkIHN1YnRyZWUuIFdlIHNob3VsZCBpZ25vcmVcbiAgICAgICAgICAvLyB0aGUgZXJyb3IuXG4gICAgICAgICAgaWYgKGlzVW5tb3VudGluZykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgd2UncmUgaW4gdGhlIGNvbW1pdCBwaGFzZSwgd2Ugc2hvdWxkIGNoZWNrIHRvIHNlZSBpZlxuICAgICAgICAgIC8vIHRoaXMgYm91bmRhcnkgYWxyZWFkeSBjYXB0dXJlZCBhbiBlcnJvciBkdXJpbmcgdGhpcyBjb21taXQuXG4gICAgICAgICAgLy8gVGhpcyBjYXNlIGV4aXN0cyBiZWNhdXNlIG11bHRpcGxlIGVycm9ycyBjYW4gYmUgdGhyb3duIGR1cmluZ1xuICAgICAgICAgIC8vIGEgc2luZ2xlIGNvbW1pdCB3aXRob3V0IGludGVycnVwdGlvbi5cbiAgICAgICAgICBpZiAoY29tbWl0UGhhc2VCb3VuZGFyaWVzICE9PSBudWxsICYmIChjb21taXRQaGFzZUJvdW5kYXJpZXMuaGFzKG5vZGUpIHx8IG5vZGUuYWx0ZXJuYXRlICE9PSBudWxsICYmIGNvbW1pdFBoYXNlQm91bmRhcmllcy5oYXMobm9kZS5hbHRlcm5hdGUpKSkge1xuICAgICAgICAgICAgLy8gSWYgc28sIHdlIHNob3VsZCBpZ25vcmUgdGhpcyBlcnJvci5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFRoZSBlcnJvciBzaG91bGQgcHJvcGFnYXRlIHRvIHRoZSBuZXh0IGJvdW5kYXJ5IC3igJQgd2Uga2VlcCBsb29raW5nLlxuICAgICAgICAgIGJvdW5kYXJ5ID0gbnVsbDtcbiAgICAgICAgICB3aWxsUmV0cnkgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYm91bmRhcnkgIT09IG51bGwpIHtcbiAgICAgIC8vIEFkZCB0byB0aGUgY29sbGVjdGlvbiBvZiBmYWlsZWQgYm91bmRhcmllcy4gVGhpcyBsZXRzIHVzIGtub3cgdGhhdFxuICAgICAgLy8gc3Vic2VxdWVudCBlcnJvcnMgaW4gdGhpcyBzdWJ0cmVlIHNob3VsZCBwcm9wYWdhdGUgdG8gdGhlIG5leHQgYm91bmRhcnkuXG4gICAgICBpZiAoZmFpbGVkQm91bmRhcmllcyA9PT0gbnVsbCkge1xuICAgICAgICBmYWlsZWRCb3VuZGFyaWVzID0gbmV3IFNldCgpO1xuICAgICAgfVxuICAgICAgZmFpbGVkQm91bmRhcmllcy5hZGQoYm91bmRhcnkpO1xuXG4gICAgICAvLyBUaGlzIG1ldGhvZCBpcyB1bnNhZmUgb3V0c2lkZSBvZiB0aGUgYmVnaW4gYW5kIGNvbXBsZXRlIHBoYXNlcy5cbiAgICAgIC8vIFdlIG1pZ2h0IGJlIGluIHRoZSBjb21taXQgcGhhc2Ugd2hlbiBhbiBlcnJvciBpcyBjYXB0dXJlZC5cbiAgICAgIC8vIFRoZSByaXNrIGlzIHRoYXQgdGhlIHJldHVybiBwYXRoIGZyb20gdGhpcyBGaWJlciBtYXkgbm90IGJlIGFjY3VyYXRlLlxuICAgICAgLy8gVGhhdCByaXNrIGlzIGFjY2VwdGFibGUgZ2l2ZW4gdGhlIGJlbmVmaXQgb2YgcHJvdmlkaW5nIHVzZXJzIG1vcmUgY29udGV4dC5cbiAgICAgIHZhciBfY29tcG9uZW50U3RhY2sgPSBnZXRTdGFja0FkZGVuZHVtQnlXb3JrSW5Qcm9ncmVzc0ZpYmVyKGZhaWxlZFdvcmspO1xuICAgICAgdmFyIF9jb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmYWlsZWRXb3JrKTtcblxuICAgICAgLy8gQWRkIHRvIHRoZSBjb2xsZWN0aW9uIG9mIGNhcHR1cmVkIGVycm9ycy4gVGhpcyBpcyBzdG9yZWQgYXMgYSBnbG9iYWxcbiAgICAgIC8vIG1hcCBvZiBlcnJvcnMgYW5kIHRoZWlyIGNvbXBvbmVudCBzdGFjayBsb2NhdGlvbiBrZXllZCBieSB0aGUgYm91bmRhcmllc1xuICAgICAgLy8gdGhhdCBjYXB0dXJlIHRoZW0uIFdlIG1vc3RseSB1c2UgdGhpcyBNYXAgYXMgYSBTZXQ7IGl0J3MgYSBNYXAgb25seSB0b1xuICAgICAgLy8gYXZvaWQgYWRkaW5nIGEgZmllbGQgdG8gRmliZXIgdG8gc3RvcmUgdGhlIGVycm9yLlxuICAgICAgaWYgKGNhcHR1cmVkRXJyb3JzID09PSBudWxsKSB7XG4gICAgICAgIGNhcHR1cmVkRXJyb3JzID0gbmV3IE1hcCgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2FwdHVyZWRFcnJvciA9IHtcbiAgICAgICAgY29tcG9uZW50TmFtZTogX2NvbXBvbmVudE5hbWUsXG4gICAgICAgIGNvbXBvbmVudFN0YWNrOiBfY29tcG9uZW50U3RhY2ssXG4gICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgZXJyb3JCb3VuZGFyeTogZXJyb3JCb3VuZGFyeUZvdW5kID8gYm91bmRhcnkuc3RhdGVOb2RlIDogbnVsbCxcbiAgICAgICAgZXJyb3JCb3VuZGFyeUZvdW5kOiBlcnJvckJvdW5kYXJ5Rm91bmQsXG4gICAgICAgIGVycm9yQm91bmRhcnlOYW1lOiBlcnJvckJvdW5kYXJ5TmFtZSxcbiAgICAgICAgd2lsbFJldHJ5OiB3aWxsUmV0cnlcbiAgICAgIH07XG5cbiAgICAgIGNhcHR1cmVkRXJyb3JzLnNldChib3VuZGFyeSwgY2FwdHVyZWRFcnJvcik7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGxvZ0NhcHR1cmVkRXJyb3IoY2FwdHVyZWRFcnJvcik7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIFByZXZlbnQgY3ljbGUgaWYgbG9nQ2FwdHVyZWRFcnJvcigpIHRocm93cy5cbiAgICAgICAgLy8gQSBjeWNsZSBtYXkgc3RpbGwgb2NjdXIgaWYgbG9nQ2FwdHVyZWRFcnJvciByZW5kZXJzIGEgY29tcG9uZW50IHRoYXQgdGhyb3dzLlxuICAgICAgICB2YXIgc3VwcHJlc3NMb2dnaW5nID0gZSAmJiBlLnN1cHByZXNzUmVhY3RFcnJvckxvZ2dpbmc7XG4gICAgICAgIGlmICghc3VwcHJlc3NMb2dnaW5nKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiB3ZSdyZSBpbiB0aGUgY29tbWl0IHBoYXNlLCBkZWZlciBzY2hlZHVsaW5nIGFuIHVwZGF0ZSBvbiB0aGVcbiAgICAgIC8vIGJvdW5kYXJ5IHVudGlsIGFmdGVyIHRoZSBjb21taXQgaXMgY29tcGxldGVcbiAgICAgIGlmIChpc0NvbW1pdHRpbmcpIHtcbiAgICAgICAgaWYgKGNvbW1pdFBoYXNlQm91bmRhcmllcyA9PT0gbnVsbCkge1xuICAgICAgICAgIGNvbW1pdFBoYXNlQm91bmRhcmllcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb21taXRQaGFzZUJvdW5kYXJpZXMuYWRkKGJvdW5kYXJ5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSwgc2NoZWR1bGUgYW4gdXBkYXRlIG5vdy5cbiAgICAgICAgLy8gVE9ETzogSXMgdGhpcyBhY3R1YWxseSBuZWNlc3NhcnkgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2U/IElzIGl0XG4gICAgICAgIC8vIHBvc3NpYmxlIHRvIHVud2luZCBhbmQgY29udGludWUgcmVuZGVyaW5nIGF0IHRoZSBzYW1lIHByaW9yaXR5LFxuICAgICAgICAvLyB3aXRob3V0IGNvcnJ1cHRpbmcgaW50ZXJuYWwgc3RhdGU/XG4gICAgICAgIHNjaGVkdWxlRXJyb3JSZWNvdmVyeShib3VuZGFyeSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYm91bmRhcnk7XG4gICAgfSBlbHNlIGlmIChmaXJzdFVuY2F1Z2h0RXJyb3IgPT09IG51bGwpIHtcbiAgICAgIC8vIElmIG5vIGJvdW5kYXJ5IGlzIGZvdW5kLCB3ZSdsbCBuZWVkIHRvIHRocm93IHRoZSBlcnJvclxuICAgICAgZmlyc3RVbmNhdWdodEVycm9yID0gZXJyb3I7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzQ2FwdHVyZWRFcnJvcihmaWJlcikge1xuICAgIC8vIFRPRE86IGNhcHR1cmVkRXJyb3JzIHNob3VsZCBzdG9yZSB0aGUgYm91bmRhcnkgaW5zdGFuY2UsIHRvIGF2b2lkIG5lZWRpbmdcbiAgICAvLyB0byBjaGVjayB0aGUgYWx0ZXJuYXRlLlxuICAgIHJldHVybiBjYXB0dXJlZEVycm9ycyAhPT0gbnVsbCAmJiAoY2FwdHVyZWRFcnJvcnMuaGFzKGZpYmVyKSB8fCBmaWJlci5hbHRlcm5hdGUgIT09IG51bGwgJiYgY2FwdHVyZWRFcnJvcnMuaGFzKGZpYmVyLmFsdGVybmF0ZSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNGYWlsZWRCb3VuZGFyeShmaWJlcikge1xuICAgIC8vIFRPRE86IGZhaWxlZEJvdW5kYXJpZXMgc2hvdWxkIHN0b3JlIHRoZSBib3VuZGFyeSBpbnN0YW5jZSwgdG8gYXZvaWRcbiAgICAvLyBuZWVkaW5nIHRvIGNoZWNrIHRoZSBhbHRlcm5hdGUuXG4gICAgcmV0dXJuIGZhaWxlZEJvdW5kYXJpZXMgIT09IG51bGwgJiYgKGZhaWxlZEJvdW5kYXJpZXMuaGFzKGZpYmVyKSB8fCBmaWJlci5hbHRlcm5hdGUgIT09IG51bGwgJiYgZmFpbGVkQm91bmRhcmllcy5oYXMoZmliZXIuYWx0ZXJuYXRlKSk7XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXRFcnJvckhhbmRsaW5nKGVmZmVjdGZ1bEZpYmVyKSB7XG4gICAgdmFyIGNhcHR1cmVkRXJyb3IgPSB2b2lkIDA7XG4gICAgaWYgKGNhcHR1cmVkRXJyb3JzICE9PSBudWxsKSB7XG4gICAgICBjYXB0dXJlZEVycm9yID0gY2FwdHVyZWRFcnJvcnMuZ2V0KGVmZmVjdGZ1bEZpYmVyKTtcbiAgICAgIGNhcHR1cmVkRXJyb3JzWydkZWxldGUnXShlZmZlY3RmdWxGaWJlcik7XG4gICAgICBpZiAoY2FwdHVyZWRFcnJvciA9PSBudWxsKSB7XG4gICAgICAgIGlmIChlZmZlY3RmdWxGaWJlci5hbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgICBlZmZlY3RmdWxGaWJlciA9IGVmZmVjdGZ1bEZpYmVyLmFsdGVybmF0ZTtcbiAgICAgICAgICBjYXB0dXJlZEVycm9yID0gY2FwdHVyZWRFcnJvcnMuZ2V0KGVmZmVjdGZ1bEZpYmVyKTtcbiAgICAgICAgICBjYXB0dXJlZEVycm9yc1snZGVsZXRlJ10oZWZmZWN0ZnVsRmliZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgIShjYXB0dXJlZEVycm9yICE9IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnTm8gZXJyb3IgZm9yIGdpdmVuIHVuaXQgb2Ygd29yay4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcblxuICAgIHN3aXRjaCAoZWZmZWN0ZnVsRmliZXIudGFnKSB7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICB2YXIgaW5zdGFuY2UgPSBlZmZlY3RmdWxGaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgICAgdmFyIGluZm8gPSB7XG4gICAgICAgICAgY29tcG9uZW50U3RhY2s6IGNhcHR1cmVkRXJyb3IuY29tcG9uZW50U3RhY2tcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBBbGxvdyB0aGUgYm91bmRhcnkgdG8gaGFuZGxlIHRoZSBlcnJvciwgdXN1YWxseSBieSBzY2hlZHVsaW5nXG4gICAgICAgIC8vIGFuIHVwZGF0ZSB0byBpdHNlbGZcbiAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50RGlkQ2F0Y2goY2FwdHVyZWRFcnJvci5lcnJvciwgaW5mbyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIGlmIChmaXJzdFVuY2F1Z2h0RXJyb3IgPT09IG51bGwpIHtcbiAgICAgICAgICBmaXJzdFVuY2F1Z2h0RXJyb3IgPSBjYXB0dXJlZEVycm9yLmVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ0ludmFsaWQgdHlwZSBvZiB3b3JrLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVud2luZENvbnRleHRzKGZyb20sIHRvKSB7XG4gICAgdmFyIG5vZGUgPSBmcm9tO1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKG5vZGUudGFnKSB7XG4gICAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgICAgcG9wQ29udGV4dFByb3ZpZGVyKG5vZGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgcG9wSG9zdENvbnRleHQobm9kZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgcG9wSG9zdENvbnRhaW5lcihub2RlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICAgIHBvcEhvc3RDb250YWluZXIobm9kZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAobm9kZSA9PT0gdG8gfHwgbm9kZS5hbHRlcm5hdGUgPT09IHRvKSB7XG4gICAgICAgIHN0b3BGYWlsZWRXb3JrVGltZXIobm9kZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RvcFdvcmtUaW1lcihub2RlKTtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21wdXRlQXN5bmNFeHBpcmF0aW9uKCkge1xuICAgIC8vIEdpdmVuIHRoZSBjdXJyZW50IGNsb2NrIHRpbWUsIHJldHVybnMgYW4gZXhwaXJhdGlvbiB0aW1lLiBXZSB1c2Ugcm91bmRpbmdcbiAgICAvLyB0byBiYXRjaCBsaWtlIHVwZGF0ZXMgdG9nZXRoZXIuXG4gICAgLy8gU2hvdWxkIGNvbXBsZXRlIHdpdGhpbiB+MTAwMG1zLiAxMjAwbXMgbWF4LlxuICAgIHZhciBjdXJyZW50VGltZSA9IHJlY2FsY3VsYXRlQ3VycmVudFRpbWUoKTtcbiAgICB2YXIgZXhwaXJhdGlvbk1zID0gMTAwMDtcbiAgICB2YXIgYnVja2V0U2l6ZU1zID0gMjAwO1xuICAgIHJldHVybiBjb21wdXRlRXhwaXJhdGlvbkJ1Y2tldChjdXJyZW50VGltZSwgZXhwaXJhdGlvbk1zLCBidWNrZXRTaXplTXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcihmaWJlcikge1xuICAgIHZhciBleHBpcmF0aW9uVGltZSA9IHZvaWQgMDtcbiAgICBpZiAoZXhwaXJhdGlvbkNvbnRleHQgIT09IE5vV29yaykge1xuICAgICAgLy8gQW4gZXhwbGljaXQgZXhwaXJhdGlvbiBjb250ZXh0IHdhcyBzZXQ7XG4gICAgICBleHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25Db250ZXh0O1xuICAgIH0gZWxzZSBpZiAoaXNXb3JraW5nKSB7XG4gICAgICBpZiAoaXNDb21taXR0aW5nKSB7XG4gICAgICAgIC8vIFVwZGF0ZXMgdGhhdCBvY2N1ciBkdXJpbmcgdGhlIGNvbW1pdCBwaGFzZSBzaG91bGQgaGF2ZSBzeW5jIHByaW9yaXR5XG4gICAgICAgIC8vIGJ5IGRlZmF1bHQuXG4gICAgICAgIGV4cGlyYXRpb25UaW1lID0gU3luYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFVwZGF0ZXMgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2Ugc2hvdWxkIGV4cGlyZSBhdCB0aGUgc2FtZSB0aW1lIGFzXG4gICAgICAgIC8vIHRoZSB3b3JrIHRoYXQgaXMgYmVpbmcgcmVuZGVyZWQuXG4gICAgICAgIGV4cGlyYXRpb25UaW1lID0gbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBObyBleHBsaWNpdCBleHBpcmF0aW9uIGNvbnRleHQgd2FzIHNldCwgYW5kIHdlJ3JlIG5vdCBjdXJyZW50bHlcbiAgICAgIC8vIHBlcmZvcm1pbmcgd29yay4gQ2FsY3VsYXRlIGEgbmV3IGV4cGlyYXRpb24gdGltZS5cbiAgICAgIGlmICh1c2VTeW5jU2NoZWR1bGluZyAmJiAhKGZpYmVyLmludGVybmFsQ29udGV4dFRhZyAmIEFzeW5jVXBkYXRlcykpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIHN5bmMgdXBkYXRlXG4gICAgICAgIGV4cGlyYXRpb25UaW1lID0gU3luYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYW4gYXN5bmMgdXBkYXRlXG4gICAgICAgIGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUFzeW5jRXhwaXJhdGlvbigpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXhwaXJhdGlvblRpbWU7XG4gIH1cblxuICBmdW5jdGlvbiBzY2hlZHVsZVdvcmsoZmliZXIsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgcmV0dXJuIHNjaGVkdWxlV29ya0ltcGwoZmliZXIsIGV4cGlyYXRpb25UaW1lLCBmYWxzZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja1Jvb3ROZWVkc0NsZWFyaW5nKHJvb3QsIGZpYmVyLCBleHBpcmF0aW9uVGltZSkge1xuICAgIGlmICghaXNXb3JraW5nICYmIHJvb3QgPT09IG5leHRSb290ICYmIGV4cGlyYXRpb25UaW1lIDwgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAvLyBSZXN0YXJ0IHRoZSByb290IGZyb20gdGhlIHRvcC5cbiAgICAgIGlmIChuZXh0VW5pdE9mV29yayAhPT0gbnVsbCkge1xuICAgICAgICAvLyBUaGlzIGlzIGFuIGludGVycnVwdGlvbi4gKFVzZWQgZm9yIHBlcmZvcm1hbmNlIHRyYWNraW5nLilcbiAgICAgICAgaW50ZXJydXB0ZWRCeSA9IGZpYmVyO1xuICAgICAgfVxuICAgICAgbmV4dFJvb3QgPSBudWxsO1xuICAgICAgbmV4dFVuaXRPZldvcmsgPSBudWxsO1xuICAgICAgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlV29ya0ltcGwoZmliZXIsIGV4cGlyYXRpb25UaW1lLCBpc0Vycm9yUmVjb3ZlcnkpIHtcbiAgICByZWNvcmRTY2hlZHVsZVVwZGF0ZSgpO1xuXG4gICAge1xuICAgICAgaWYgKCFpc0Vycm9yUmVjb3ZlcnkgJiYgZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgIHdhcm5BYm91dEludmFsaWRVcGRhdGVzKGluc3RhbmNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbm9kZSA9IGZpYmVyO1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICAvLyBXYWxrIHRoZSBwYXJlbnQgcGF0aCB0byB0aGUgcm9vdCBhbmQgdXBkYXRlIGVhY2ggbm9kZSdzXG4gICAgICAvLyBleHBpcmF0aW9uIHRpbWUuXG4gICAgICBpZiAobm9kZS5leHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IG5vZGUuZXhwaXJhdGlvblRpbWUgPiBleHBpcmF0aW9uVGltZSkge1xuICAgICAgICBub2RlLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgICB9XG4gICAgICBpZiAobm9kZS5hbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGUuYWx0ZXJuYXRlLmV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgbm9kZS5hbHRlcm5hdGUuZXhwaXJhdGlvblRpbWUgPiBleHBpcmF0aW9uVGltZSkge1xuICAgICAgICAgIG5vZGUuYWx0ZXJuYXRlLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChub2RlWydyZXR1cm4nXSA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RSb290KSB7XG4gICAgICAgICAgdmFyIHJvb3QgPSBub2RlLnN0YXRlTm9kZTtcblxuICAgICAgICAgIGNoZWNrUm9vdE5lZWRzQ2xlYXJpbmcocm9vdCwgZmliZXIsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICByZXF1ZXN0V29yayhyb290LCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgY2hlY2tSb290TmVlZHNDbGVhcmluZyhyb290LCBmaWJlciwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICghaXNFcnJvclJlY292ZXJ5ICYmIGZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgd2FybkFib3V0VXBkYXRlT25Vbm1vdW50ZWQoZmliZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzY2hlZHVsZUVycm9yUmVjb3ZlcnkoZmliZXIpIHtcbiAgICBzY2hlZHVsZVdvcmtJbXBsKGZpYmVyLCBTeW5jLCB0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY2FsY3VsYXRlQ3VycmVudFRpbWUoKSB7XG4gICAgLy8gU3VidHJhY3QgaW5pdGlhbCB0aW1lIHNvIGl0IGZpdHMgaW5zaWRlIDMyYml0c1xuICAgIHZhciBtcyA9IG5vdygpIC0gc3RhcnRUaW1lO1xuICAgIG1vc3RSZWNlbnRDdXJyZW50VGltZSA9IG1zVG9FeHBpcmF0aW9uVGltZShtcyk7XG4gICAgcmV0dXJuIG1vc3RSZWNlbnRDdXJyZW50VGltZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZmVycmVkVXBkYXRlcyhmbikge1xuICAgIHZhciBwcmV2aW91c0V4cGlyYXRpb25Db250ZXh0ID0gZXhwaXJhdGlvbkNvbnRleHQ7XG4gICAgZXhwaXJhdGlvbkNvbnRleHQgPSBjb21wdXRlQXN5bmNFeHBpcmF0aW9uKCk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmbigpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBleHBpcmF0aW9uQ29udGV4dCA9IHByZXZpb3VzRXhwaXJhdGlvbkNvbnRleHQ7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc3luY1VwZGF0ZXMoZm4pIHtcbiAgICB2YXIgcHJldmlvdXNFeHBpcmF0aW9uQ29udGV4dCA9IGV4cGlyYXRpb25Db250ZXh0O1xuICAgIGV4cGlyYXRpb25Db250ZXh0ID0gU3luYztcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZuKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGV4cGlyYXRpb25Db250ZXh0ID0gcHJldmlvdXNFeHBpcmF0aW9uQ29udGV4dDtcbiAgICB9XG4gIH1cblxuICAvLyBUT0RPOiBFdmVyeXRoaW5nIGJlbG93IHRoaXMgaXMgd3JpdHRlbiBhcyBpZiBpdCBoYXMgYmVlbiBsaWZ0ZWQgdG8gdGhlXG4gIC8vIHJlbmRlcmVycy4gSSdsbCBkbyB0aGlzIGluIGEgZm9sbG93LXVwLlxuXG4gIC8vIExpbmtlZC1saXN0IG9mIHJvb3RzXG4gIHZhciBmaXJzdFNjaGVkdWxlZFJvb3QgPSBudWxsO1xuICB2YXIgbGFzdFNjaGVkdWxlZFJvb3QgPSBudWxsO1xuXG4gIHZhciBjYWxsYmFja0V4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuICB2YXIgY2FsbGJhY2tJRCA9IC0xO1xuICB2YXIgaXNSZW5kZXJpbmcgPSBmYWxzZTtcbiAgdmFyIG5leHRGbHVzaGVkUm9vdCA9IG51bGw7XG4gIHZhciBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuICB2YXIgZGVhZGxpbmVEaWRFeHBpcmUgPSBmYWxzZTtcbiAgdmFyIGhhc1VuaGFuZGxlZEVycm9yID0gZmFsc2U7XG4gIHZhciB1bmhhbmRsZWRFcnJvciA9IG51bGw7XG4gIHZhciBkZWFkbGluZSA9IG51bGw7XG5cbiAgdmFyIGlzQmF0Y2hpbmdVcGRhdGVzID0gZmFsc2U7XG4gIHZhciBpc1VuYmF0Y2hpbmdVcGRhdGVzID0gZmFsc2U7XG5cbiAgLy8gVXNlIHRoZXNlIHRvIHByZXZlbnQgYW4gaW5maW5pdGUgbG9vcCBvZiBuZXN0ZWQgdXBkYXRlc1xuICB2YXIgTkVTVEVEX1VQREFURV9MSU1JVCA9IDEwMDA7XG4gIHZhciBuZXN0ZWRVcGRhdGVDb3VudCA9IDA7XG5cbiAgdmFyIHRpbWVIZXVyaXN0aWNGb3JVbml0T2ZXb3JrID0gMTtcblxuICBmdW5jdGlvbiBzY2hlZHVsZUNhbGxiYWNrV2l0aEV4cGlyYXRpb24oZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAoY2FsbGJhY2tFeHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrKSB7XG4gICAgICAvLyBBIGNhbGxiYWNrIGlzIGFscmVhZHkgc2NoZWR1bGVkLiBDaGVjayBpdHMgZXhwaXJhdGlvbiB0aW1lICh0aW1lb3V0KS5cbiAgICAgIGlmIChleHBpcmF0aW9uVGltZSA+IGNhbGxiYWNrRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgLy8gRXhpc3RpbmcgY2FsbGJhY2sgaGFzIHN1ZmZpY2llbnQgdGltZW91dC4gRXhpdC5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRXhpc3RpbmcgY2FsbGJhY2sgaGFzIGluc3VmZmljaWVudCB0aW1lb3V0LiBDYW5jZWwgYW5kIHNjaGVkdWxlIGFcbiAgICAgICAgLy8gbmV3IG9uZS5cbiAgICAgICAgY2FuY2VsRGVmZXJyZWRDYWxsYmFjayhjYWxsYmFja0lEKTtcbiAgICAgIH1cbiAgICAgIC8vIFRoZSByZXF1ZXN0IGNhbGxiYWNrIHRpbWVyIGlzIGFscmVhZHkgcnVubmluZy4gRG9uJ3Qgc3RhcnQgYSBuZXcgb25lLlxuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydFJlcXVlc3RDYWxsYmFja1RpbWVyKCk7XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSBhIHRpbWVvdXQgZm9yIHRoZSBnaXZlbiBleHBpcmF0aW9uIHRpbWUuXG4gICAgdmFyIGN1cnJlbnRNcyA9IG5vdygpIC0gc3RhcnRUaW1lO1xuICAgIHZhciBleHBpcmF0aW9uTXMgPSBleHBpcmF0aW9uVGltZVRvTXMoZXhwaXJhdGlvblRpbWUpO1xuICAgIHZhciB0aW1lb3V0ID0gZXhwaXJhdGlvbk1zIC0gY3VycmVudE1zO1xuXG4gICAgY2FsbGJhY2tFeHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICAgIGNhbGxiYWNrSUQgPSBzY2hlZHVsZURlZmVycmVkQ2FsbGJhY2socGVyZm9ybUFzeW5jV29yaywgeyB0aW1lb3V0OiB0aW1lb3V0IH0pO1xuICB9XG5cbiAgLy8gcmVxdWVzdFdvcmsgaXMgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIgd2hlbmV2ZXIgYSByb290IHJlY2VpdmVzIGFuIHVwZGF0ZS5cbiAgLy8gSXQncyB1cCB0byB0aGUgcmVuZGVyZXIgdG8gY2FsbCByZW5kZXJSb290IGF0IHNvbWUgcG9pbnQgaW4gdGhlIGZ1dHVyZS5cbiAgZnVuY3Rpb24gcmVxdWVzdFdvcmsocm9vdCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAobmVzdGVkVXBkYXRlQ291bnQgPiBORVNURURfVVBEQVRFX0xJTUlUKSB7XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdNYXhpbXVtIHVwZGF0ZSBkZXB0aCBleGNlZWRlZC4gVGhpcyBjYW4gaGFwcGVuIHdoZW4gYSBjb21wb25lbnQgcmVwZWF0ZWRseSBjYWxscyBzZXRTdGF0ZSBpbnNpZGUgY29tcG9uZW50V2lsbFVwZGF0ZSBvciBjb21wb25lbnREaWRVcGRhdGUuIFJlYWN0IGxpbWl0cyB0aGUgbnVtYmVyIG9mIG5lc3RlZCB1cGRhdGVzIHRvIHByZXZlbnQgaW5maW5pdGUgbG9vcHMuJyk7XG4gICAgfVxuXG4gICAgLy8gQWRkIHRoZSByb290IHRvIHRoZSBzY2hlZHVsZS5cbiAgICAvLyBDaGVjayBpZiB0aGlzIHJvb3QgaXMgYWxyZWFkeSBwYXJ0IG9mIHRoZSBzY2hlZHVsZS5cbiAgICBpZiAocm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9PT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyByb290IGlzIG5vdCBhbHJlYWR5IHNjaGVkdWxlZC4gQWRkIGl0LlxuICAgICAgcm9vdC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICAgICAgaWYgKGxhc3RTY2hlZHVsZWRSb290ID09PSBudWxsKSB7XG4gICAgICAgIGZpcnN0U2NoZWR1bGVkUm9vdCA9IGxhc3RTY2hlZHVsZWRSb290ID0gcm9vdDtcbiAgICAgICAgcm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IHJvb3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYXN0U2NoZWR1bGVkUm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IHJvb3Q7XG4gICAgICAgIGxhc3RTY2hlZHVsZWRSb290ID0gcm9vdDtcbiAgICAgICAgbGFzdFNjaGVkdWxlZFJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSBmaXJzdFNjaGVkdWxlZFJvb3Q7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgcm9vdCBpcyBhbHJlYWR5IHNjaGVkdWxlZCwgYnV0IGl0cyBwcmlvcml0eSBtYXkgaGF2ZSBpbmNyZWFzZWQuXG4gICAgICB2YXIgcmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSByb290LnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lO1xuICAgICAgaWYgKHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgZXhwaXJhdGlvblRpbWUgPCByZW1haW5pbmdFeHBpcmF0aW9uVGltZSkge1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHByaW9yaXR5LlxuICAgICAgICByb290LnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzUmVuZGVyaW5nKSB7XG4gICAgICAvLyBQcmV2ZW50IHJlZW50cmFuY3kuIFJlbWFpbmluZyB3b3JrIHdpbGwgYmUgc2NoZWR1bGVkIGF0IHRoZSBlbmQgb2ZcbiAgICAgIC8vIHRoZSBjdXJyZW50bHkgcmVuZGVyaW5nIGJhdGNoLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc0JhdGNoaW5nVXBkYXRlcykge1xuICAgICAgLy8gRmx1c2ggd29yayBhdCB0aGUgZW5kIG9mIHRoZSBiYXRjaC5cbiAgICAgIGlmIChpc1VuYmF0Y2hpbmdVcGRhdGVzKSB7XG4gICAgICAgIC8vIC4uLnVubGVzcyB3ZSdyZSBpbnNpZGUgdW5iYXRjaGVkVXBkYXRlcywgaW4gd2hpY2ggY2FzZSB3ZSBzaG91bGRcbiAgICAgICAgLy8gZmx1c2ggaXQgbm93LlxuICAgICAgICBuZXh0Rmx1c2hlZFJvb3QgPSByb290O1xuICAgICAgICBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lID0gU3luYztcbiAgICAgICAgcGVyZm9ybVdvcmtPblJvb3QobmV4dEZsdXNoZWRSb290LCBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBHZXQgcmlkIG9mIFN5bmMgYW5kIHVzZSBjdXJyZW50IHRpbWU/XG4gICAgaWYgKGV4cGlyYXRpb25UaW1lID09PSBTeW5jKSB7XG4gICAgICBwZXJmb3JtV29yayhTeW5jLCBudWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NoZWR1bGVDYWxsYmFja1dpdGhFeHBpcmF0aW9uKGV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kSGlnaGVzdFByaW9yaXR5Um9vdCgpIHtcbiAgICB2YXIgaGlnaGVzdFByaW9yaXR5V29yayA9IE5vV29yaztcbiAgICB2YXIgaGlnaGVzdFByaW9yaXR5Um9vdCA9IG51bGw7XG5cbiAgICBpZiAobGFzdFNjaGVkdWxlZFJvb3QgIT09IG51bGwpIHtcbiAgICAgIHZhciBwcmV2aW91c1NjaGVkdWxlZFJvb3QgPSBsYXN0U2NoZWR1bGVkUm9vdDtcbiAgICAgIHZhciByb290ID0gZmlyc3RTY2hlZHVsZWRSb290O1xuICAgICAgd2hpbGUgKHJvb3QgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gcm9vdC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZTtcbiAgICAgICAgaWYgKHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID09PSBOb1dvcmspIHtcbiAgICAgICAgICAvLyBUaGlzIHJvb3Qgbm8gbG9uZ2VyIGhhcyB3b3JrLiBSZW1vdmUgaXQgZnJvbSB0aGUgc2NoZWR1bGVyLlxuXG4gICAgICAgICAgLy8gVE9ETzogVGhpcyBjaGVjayBpcyByZWR1ZGFudCwgYnV0IEZsb3cgaXMgY29uZnVzZWQgYnkgdGhlIGJyYW5jaFxuICAgICAgICAgIC8vIGJlbG93IHdoZXJlIHdlIHNldCBsYXN0U2NoZWR1bGVkUm9vdCB0byBudWxsLCBldmVuIHRob3VnaCB3ZSBicmVha1xuICAgICAgICAgIC8vIGZyb20gdGhlIGxvb3AgcmlnaHQgYWZ0ZXIuXG4gICAgICAgICAgIShwcmV2aW91c1NjaGVkdWxlZFJvb3QgIT09IG51bGwgJiYgbGFzdFNjaGVkdWxlZFJvb3QgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnU2hvdWxkIGhhdmUgYSBwcmV2aW91cyBhbmQgbGFzdCByb290LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgICAgIGlmIChyb290ID09PSByb290Lm5leHRTY2hlZHVsZWRSb290KSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBvbmx5IHJvb3QgaW4gdGhlIGxpc3QuXG4gICAgICAgICAgICByb290Lm5leHRTY2hlZHVsZWRSb290ID0gbnVsbDtcbiAgICAgICAgICAgIGZpcnN0U2NoZWR1bGVkUm9vdCA9IGxhc3RTY2hlZHVsZWRSb290ID0gbnVsbDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSBpZiAocm9vdCA9PT0gZmlyc3RTY2hlZHVsZWRSb290KSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCByb290IGluIHRoZSBsaXN0LlxuICAgICAgICAgICAgdmFyIG5leHQgPSByb290Lm5leHRTY2hlZHVsZWRSb290O1xuICAgICAgICAgICAgZmlyc3RTY2hlZHVsZWRSb290ID0gbmV4dDtcbiAgICAgICAgICAgIGxhc3RTY2hlZHVsZWRSb290Lm5leHRTY2hlZHVsZWRSb290ID0gbmV4dDtcbiAgICAgICAgICAgIHJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSBpZiAocm9vdCA9PT0gbGFzdFNjaGVkdWxlZFJvb3QpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGxhc3Qgcm9vdCBpbiB0aGUgbGlzdC5cbiAgICAgICAgICAgIGxhc3RTY2hlZHVsZWRSb290ID0gcHJldmlvdXNTY2hlZHVsZWRSb290O1xuICAgICAgICAgICAgbGFzdFNjaGVkdWxlZFJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSBmaXJzdFNjaGVkdWxlZFJvb3Q7XG4gICAgICAgICAgICByb290Lm5leHRTY2hlZHVsZWRSb290ID0gbnVsbDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcmV2aW91c1NjaGVkdWxlZFJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSByb290Lm5leHRTY2hlZHVsZWRSb290O1xuICAgICAgICAgICAgcm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJvb3QgPSBwcmV2aW91c1NjaGVkdWxlZFJvb3QubmV4dFNjaGVkdWxlZFJvb3Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGhpZ2hlc3RQcmlvcml0eVdvcmsgPT09IE5vV29yayB8fCByZW1haW5pbmdFeHBpcmF0aW9uVGltZSA8IGhpZ2hlc3RQcmlvcml0eVdvcmspIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcHJpb3JpdHksIGlmIGl0J3MgaGlnaGVyXG4gICAgICAgICAgICBoaWdoZXN0UHJpb3JpdHlXb3JrID0gcmVtYWluaW5nRXhwaXJhdGlvblRpbWU7XG4gICAgICAgICAgICBoaWdoZXN0UHJpb3JpdHlSb290ID0gcm9vdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJvb3QgPT09IGxhc3RTY2hlZHVsZWRSb290KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJldmlvdXNTY2hlZHVsZWRSb290ID0gcm9vdDtcbiAgICAgICAgICByb290ID0gcm9vdC5uZXh0U2NoZWR1bGVkUm9vdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHRoZSBuZXh0IHJvb3QgaXMgdGhlIHNhbWUgYXMgdGhlIHByZXZpb3VzIHJvb3QsIHRoaXMgaXMgYSBuZXN0ZWRcbiAgICAvLyB1cGRhdGUuIFRvIHByZXZlbnQgYW4gaW5maW5pdGUgbG9vcCwgaW5jcmVtZW50IHRoZSBuZXN0ZWQgdXBkYXRlIGNvdW50LlxuICAgIHZhciBwcmV2aW91c0ZsdXNoZWRSb290ID0gbmV4dEZsdXNoZWRSb290O1xuICAgIGlmIChwcmV2aW91c0ZsdXNoZWRSb290ICE9PSBudWxsICYmIHByZXZpb3VzRmx1c2hlZFJvb3QgPT09IGhpZ2hlc3RQcmlvcml0eVJvb3QpIHtcbiAgICAgIG5lc3RlZFVwZGF0ZUNvdW50Kys7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlc2V0IHdoZW5ldmVyIHdlIHN3aXRjaCByb290cy5cbiAgICAgIG5lc3RlZFVwZGF0ZUNvdW50ID0gMDtcbiAgICB9XG4gICAgbmV4dEZsdXNoZWRSb290ID0gaGlnaGVzdFByaW9yaXR5Um9vdDtcbiAgICBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lID0gaGlnaGVzdFByaW9yaXR5V29yaztcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlcmZvcm1Bc3luY1dvcmsoZGwpIHtcbiAgICBwZXJmb3JtV29yayhOb1dvcmssIGRsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlcmZvcm1Xb3JrKG1pbkV4cGlyYXRpb25UaW1lLCBkbCkge1xuICAgIGRlYWRsaW5lID0gZGw7XG5cbiAgICAvLyBLZWVwIHdvcmtpbmcgb24gcm9vdHMgdW50aWwgdGhlcmUncyBubyBtb3JlIHdvcmssIG9yIHVudGlsIHRoZSB3ZSByZWFjaFxuICAgIC8vIHRoZSBkZWFkbGluZS5cbiAgICBmaW5kSGlnaGVzdFByaW9yaXR5Um9vdCgpO1xuXG4gICAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkgJiYgZGVhZGxpbmUgIT09IG51bGwpIHtcbiAgICAgIHZhciBkaWRFeHBpcmUgPSBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lIDwgcmVjYWxjdWxhdGVDdXJyZW50VGltZSgpO1xuICAgICAgc3RvcFJlcXVlc3RDYWxsYmFja1RpbWVyKGRpZEV4cGlyZSk7XG4gICAgfVxuXG4gICAgd2hpbGUgKG5leHRGbHVzaGVkUm9vdCAhPT0gbnVsbCAmJiBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lICE9PSBOb1dvcmsgJiYgKG1pbkV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgbmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSA8PSBtaW5FeHBpcmF0aW9uVGltZSkgJiYgIWRlYWRsaW5lRGlkRXhwaXJlKSB7XG4gICAgICBwZXJmb3JtV29ya09uUm9vdChuZXh0Rmx1c2hlZFJvb3QsIG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUpO1xuICAgICAgLy8gRmluZCB0aGUgbmV4dCBoaWdoZXN0IHByaW9yaXR5IHdvcmsuXG4gICAgICBmaW5kSGlnaGVzdFByaW9yaXR5Um9vdCgpO1xuICAgIH1cblxuICAgIC8vIFdlJ3JlIGRvbmUgZmx1c2hpbmcgd29yay4gRWl0aGVyIHdlIHJhbiBvdXQgb2YgdGltZSBpbiB0aGlzIGNhbGxiYWNrLFxuICAgIC8vIG9yIHRoZXJlJ3Mgbm8gbW9yZSB3b3JrIGxlZnQgd2l0aCBzdWZmaWNpZW50IHByaW9yaXR5LlxuXG4gICAgLy8gSWYgd2UncmUgaW5zaWRlIGEgY2FsbGJhY2ssIHNldCB0aGlzIHRvIGZhbHNlIHNpbmNlIHdlIGp1c3QgY29tcGxldGVkIGl0LlxuICAgIGlmIChkZWFkbGluZSAhPT0gbnVsbCkge1xuICAgICAgY2FsbGJhY2tFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcbiAgICAgIGNhbGxiYWNrSUQgPSAtMTtcbiAgICB9XG4gICAgLy8gSWYgdGhlcmUncyB3b3JrIGxlZnQgb3Zlciwgc2NoZWR1bGUgYSBuZXcgY2FsbGJhY2suXG4gICAgaWYgKG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgIT09IE5vV29yaykge1xuICAgICAgc2NoZWR1bGVDYWxsYmFja1dpdGhFeHBpcmF0aW9uKG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUpO1xuICAgIH1cblxuICAgIC8vIENsZWFuLXVwLlxuICAgIGRlYWRsaW5lID0gbnVsbDtcbiAgICBkZWFkbGluZURpZEV4cGlyZSA9IGZhbHNlO1xuICAgIG5lc3RlZFVwZGF0ZUNvdW50ID0gMDtcblxuICAgIGlmIChoYXNVbmhhbmRsZWRFcnJvcikge1xuICAgICAgdmFyIF9lcnJvcjQgPSB1bmhhbmRsZWRFcnJvcjtcbiAgICAgIHVuaGFuZGxlZEVycm9yID0gbnVsbDtcbiAgICAgIGhhc1VuaGFuZGxlZEVycm9yID0gZmFsc2U7XG4gICAgICB0aHJvdyBfZXJyb3I0O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBlcmZvcm1Xb3JrT25Sb290KHJvb3QsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgISFpc1JlbmRlcmluZyA/IGludmFyaWFudChmYWxzZSwgJ3BlcmZvcm1Xb3JrT25Sb290IHdhcyBjYWxsZWQgcmVjdXJzaXZlbHkuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG5cbiAgICBpc1JlbmRlcmluZyA9IHRydWU7XG5cbiAgICAvLyBDaGVjayBpZiB0aGlzIGlzIGFzeW5jIHdvcmsgb3Igc3luYy9leHBpcmVkIHdvcmsuXG4gICAgLy8gVE9ETzogUGFzcyBjdXJyZW50IHRpbWUgYXMgYXJndW1lbnQgdG8gcmVuZGVyUm9vdCwgY29tbWl0Um9vdFxuICAgIGlmIChleHBpcmF0aW9uVGltZSA8PSByZWNhbGN1bGF0ZUN1cnJlbnRUaW1lKCkpIHtcbiAgICAgIC8vIEZsdXNoIHN5bmMgd29yay5cbiAgICAgIHZhciBmaW5pc2hlZFdvcmsgPSByb290LmZpbmlzaGVkV29yaztcbiAgICAgIGlmIChmaW5pc2hlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgICAgLy8gVGhpcyByb290IGlzIGFscmVhZHkgY29tcGxldGUuIFdlIGNhbiBjb21taXQgaXQuXG4gICAgICAgIHJvb3QuZmluaXNoZWRXb3JrID0gbnVsbDtcbiAgICAgICAgcm9vdC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IGNvbW1pdFJvb3QoZmluaXNoZWRXb3JrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QuZmluaXNoZWRXb3JrID0gbnVsbDtcbiAgICAgICAgZmluaXNoZWRXb3JrID0gcmVuZGVyUm9vdChyb290LCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgIGlmIChmaW5pc2hlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSd2ZSBjb21wbGV0ZWQgdGhlIHJvb3QuIENvbW1pdCBpdC5cbiAgICAgICAgICByb290LnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gY29tbWl0Um9vdChmaW5pc2hlZFdvcmspO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZsdXNoIGFzeW5jIHdvcmsuXG4gICAgICB2YXIgX2ZpbmlzaGVkV29yayA9IHJvb3QuZmluaXNoZWRXb3JrO1xuICAgICAgaWYgKF9maW5pc2hlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgICAgLy8gVGhpcyByb290IGlzIGFscmVhZHkgY29tcGxldGUuIFdlIGNhbiBjb21taXQgaXQuXG4gICAgICAgIHJvb3QuZmluaXNoZWRXb3JrID0gbnVsbDtcbiAgICAgICAgcm9vdC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IGNvbW1pdFJvb3QoX2ZpbmlzaGVkV29yayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb290LmZpbmlzaGVkV29yayA9IG51bGw7XG4gICAgICAgIF9maW5pc2hlZFdvcmsgPSByZW5kZXJSb290KHJvb3QsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgaWYgKF9maW5pc2hlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSd2ZSBjb21wbGV0ZWQgdGhlIHJvb3QuIENoZWNrIHRoZSBkZWFkbGluZSBvbmUgbW9yZSB0aW1lXG4gICAgICAgICAgLy8gYmVmb3JlIGNvbW1pdHRpbmcuXG4gICAgICAgICAgaWYgKCFzaG91bGRZaWVsZCgpKSB7XG4gICAgICAgICAgICAvLyBTdGlsbCB0aW1lIGxlZnQuIENvbW1pdCB0aGUgcm9vdC5cbiAgICAgICAgICAgIHJvb3QucmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSBjb21taXRSb290KF9maW5pc2hlZFdvcmspO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGVyZSdzIG5vIHRpbWUgbGVmdC4gTWFyayB0aGlzIHJvb3QgYXMgY29tcGxldGUuIFdlJ2xsIGNvbWVcbiAgICAgICAgICAgIC8vIGJhY2sgYW5kIGNvbW1pdCBpdCBsYXRlci5cbiAgICAgICAgICAgIHJvb3QuZmluaXNoZWRXb3JrID0gX2ZpbmlzaGVkV29yaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpc1JlbmRlcmluZyA9IGZhbHNlO1xuICB9XG5cbiAgLy8gV2hlbiB3b3JraW5nIG9uIGFzeW5jIHdvcmssIHRoZSByZWNvbmNpbGVyIGFza3MgdGhlIHJlbmRlcmVyIGlmIGl0IHNob3VsZFxuICAvLyB5aWVsZCBleGVjdXRpb24uIEZvciBET00sIHdlIGltcGxlbWVudCB0aGlzIHdpdGggcmVxdWVzdElkbGVDYWxsYmFjay5cbiAgZnVuY3Rpb24gc2hvdWxkWWllbGQoKSB7XG4gICAgaWYgKGRlYWRsaW5lID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChkZWFkbGluZS50aW1lUmVtYWluaW5nKCkgPiB0aW1lSGV1cmlzdGljRm9yVW5pdE9mV29yaykge1xuICAgICAgLy8gRGlzcmVnYXJkIGRlYWRsaW5lLmRpZFRpbWVvdXQuIE9ubHkgZXhwaXJlZCB3b3JrIHNob3VsZCBiZSBmbHVzaGVkXG4gICAgICAvLyBkdXJpbmcgYSB0aW1lb3V0LiBUaGlzIHBhdGggaXMgb25seSBoaXQgZm9yIG5vbi1leHBpcmVkIHdvcmsuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGRlYWRsaW5lRGlkRXhwaXJlID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIFRPRE86IE5vdCBoYXBweSBhYm91dCB0aGlzIGhvb2suIENvbmNlcHR1YWxseSwgcmVuZGVyUm9vdCBzaG91bGQgcmV0dXJuIGFcbiAgLy8gdHVwbGUgb2YgKGlzUmVhZHlGb3JDb21taXQsIGRpZEVycm9yLCBlcnJvcilcbiAgZnVuY3Rpb24gb25VbmNhdWdodEVycm9yKGVycm9yKSB7XG4gICAgIShuZXh0Rmx1c2hlZFJvb3QgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnU2hvdWxkIGJlIHdvcmtpbmcgb24gYSByb290LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgIC8vIFVuc2NoZWR1bGUgdGhpcyByb290IHNvIHdlIGRvbid0IHdvcmsgb24gaXQgYWdhaW4gdW50aWwgdGhlcmUnc1xuICAgIC8vIGFub3RoZXIgdXBkYXRlLlxuICAgIG5leHRGbHVzaGVkUm9vdC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcbiAgICBpZiAoIWhhc1VuaGFuZGxlZEVycm9yKSB7XG4gICAgICBoYXNVbmhhbmRsZWRFcnJvciA9IHRydWU7XG4gICAgICB1bmhhbmRsZWRFcnJvciA9IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE86IEJhdGNoaW5nIHNob3VsZCBiZSBpbXBsZW1lbnRlZCBhdCB0aGUgcmVuZGVyZXIgbGV2ZWwsIG5vdCBpbnNpZGVcbiAgLy8gdGhlIHJlY29uY2lsZXIuXG4gIGZ1bmN0aW9uIGJhdGNoZWRVcGRhdGVzKGZuLCBhKSB7XG4gICAgdmFyIHByZXZpb3VzSXNCYXRjaGluZ1VwZGF0ZXMgPSBpc0JhdGNoaW5nVXBkYXRlcztcbiAgICBpc0JhdGNoaW5nVXBkYXRlcyA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmbihhKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNCYXRjaGluZ1VwZGF0ZXMgPSBwcmV2aW91c0lzQmF0Y2hpbmdVcGRhdGVzO1xuICAgICAgaWYgKCFpc0JhdGNoaW5nVXBkYXRlcyAmJiAhaXNSZW5kZXJpbmcpIHtcbiAgICAgICAgcGVyZm9ybVdvcmsoU3luYywgbnVsbCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gVE9ETzogQmF0Y2hpbmcgc2hvdWxkIGJlIGltcGxlbWVudGVkIGF0IHRoZSByZW5kZXJlciBsZXZlbCwgbm90IGluc2lkZVxuICAvLyB0aGUgcmVjb25jaWxlci5cbiAgZnVuY3Rpb24gdW5iYXRjaGVkVXBkYXRlcyhmbikge1xuICAgIGlmIChpc0JhdGNoaW5nVXBkYXRlcyAmJiAhaXNVbmJhdGNoaW5nVXBkYXRlcykge1xuICAgICAgaXNVbmJhdGNoaW5nVXBkYXRlcyA9IHRydWU7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlzVW5iYXRjaGluZ1VwZGF0ZXMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZuKCk7XG4gIH1cblxuICAvLyBUT0RPOiBCYXRjaGluZyBzaG91bGQgYmUgaW1wbGVtZW50ZWQgYXQgdGhlIHJlbmRlcmVyIGxldmVsLCBub3Qgd2l0aGluXG4gIC8vIHRoZSByZWNvbmNpbGVyLlxuICBmdW5jdGlvbiBmbHVzaFN5bmMoZm4pIHtcbiAgICB2YXIgcHJldmlvdXNJc0JhdGNoaW5nVXBkYXRlcyA9IGlzQmF0Y2hpbmdVcGRhdGVzO1xuICAgIGlzQmF0Y2hpbmdVcGRhdGVzID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHN5bmNVcGRhdGVzKGZuKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNCYXRjaGluZ1VwZGF0ZXMgPSBwcmV2aW91c0lzQmF0Y2hpbmdVcGRhdGVzO1xuICAgICAgISFpc1JlbmRlcmluZyA/IGludmFyaWFudChmYWxzZSwgJ2ZsdXNoU3luYyB3YXMgY2FsbGVkIGZyb20gaW5zaWRlIGEgbGlmZWN5Y2xlIG1ldGhvZC4gSXQgY2Fubm90IGJlIGNhbGxlZCB3aGVuIFJlYWN0IGlzIGFscmVhZHkgcmVuZGVyaW5nLicpIDogdm9pZCAwO1xuICAgICAgcGVyZm9ybVdvcmsoU3luYywgbnVsbCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjb21wdXRlQXN5bmNFeHBpcmF0aW9uOiBjb21wdXRlQXN5bmNFeHBpcmF0aW9uLFxuICAgIGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXI6IGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIsXG4gICAgc2NoZWR1bGVXb3JrOiBzY2hlZHVsZVdvcmssXG4gICAgYmF0Y2hlZFVwZGF0ZXM6IGJhdGNoZWRVcGRhdGVzLFxuICAgIHVuYmF0Y2hlZFVwZGF0ZXM6IHVuYmF0Y2hlZFVwZGF0ZXMsXG4gICAgZmx1c2hTeW5jOiBmbHVzaFN5bmMsXG4gICAgZGVmZXJyZWRVcGRhdGVzOiBkZWZlcnJlZFVwZGF0ZXNcbiAgfTtcbn07XG5cbntcbiAgdmFyIGRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMgPSBmYWxzZTtcbn1cblxuLy8gMCBpcyBQUk9ELCAxIGlzIERFVi5cbi8vIE1pZ2h0IGFkZCBQUk9GSUxFIGxhdGVyLlxuXG5cbmZ1bmN0aW9uIGdldENvbnRleHRGb3JTdWJ0cmVlKHBhcmVudENvbXBvbmVudCkge1xuICBpZiAoIXBhcmVudENvbXBvbmVudCkge1xuICAgIHJldHVybiBlbXB0eU9iamVjdDtcbiAgfVxuXG4gIHZhciBmaWJlciA9IGdldChwYXJlbnRDb21wb25lbnQpO1xuICB2YXIgcGFyZW50Q29udGV4dCA9IGZpbmRDdXJyZW50VW5tYXNrZWRDb250ZXh0KGZpYmVyKTtcbiAgcmV0dXJuIGlzQ29udGV4dFByb3ZpZGVyKGZpYmVyKSA/IHByb2Nlc3NDaGlsZENvbnRleHQoZmliZXIsIHBhcmVudENvbnRleHQpIDogcGFyZW50Q29udGV4dDtcbn1cblxudmFyIFJlYWN0RmliZXJSZWNvbmNpbGVyJDEgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gIHZhciBnZXRQdWJsaWNJbnN0YW5jZSA9IGNvbmZpZy5nZXRQdWJsaWNJbnN0YW5jZTtcblxuICB2YXIgX1JlYWN0RmliZXJTY2hlZHVsZXIgPSBSZWFjdEZpYmVyU2NoZWR1bGVyKGNvbmZpZyksXG4gICAgICBjb21wdXRlQXN5bmNFeHBpcmF0aW9uID0gX1JlYWN0RmliZXJTY2hlZHVsZXIuY29tcHV0ZUFzeW5jRXhwaXJhdGlvbixcbiAgICAgIGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIgPSBfUmVhY3RGaWJlclNjaGVkdWxlci5jb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyLFxuICAgICAgc2NoZWR1bGVXb3JrID0gX1JlYWN0RmliZXJTY2hlZHVsZXIuc2NoZWR1bGVXb3JrLFxuICAgICAgYmF0Y2hlZFVwZGF0ZXMgPSBfUmVhY3RGaWJlclNjaGVkdWxlci5iYXRjaGVkVXBkYXRlcyxcbiAgICAgIHVuYmF0Y2hlZFVwZGF0ZXMgPSBfUmVhY3RGaWJlclNjaGVkdWxlci51bmJhdGNoZWRVcGRhdGVzLFxuICAgICAgZmx1c2hTeW5jID0gX1JlYWN0RmliZXJTY2hlZHVsZXIuZmx1c2hTeW5jLFxuICAgICAgZGVmZXJyZWRVcGRhdGVzID0gX1JlYWN0RmliZXJTY2hlZHVsZXIuZGVmZXJyZWRVcGRhdGVzO1xuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlVG9wTGV2ZWxVcGRhdGUoY3VycmVudCwgZWxlbWVudCwgY2FsbGJhY2spIHtcbiAgICB7XG4gICAgICBpZiAoUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5waGFzZSA9PT0gJ3JlbmRlcicgJiYgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5jdXJyZW50ICE9PSBudWxsICYmICFkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMgPSB0cnVlO1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnUmVuZGVyIG1ldGhvZHMgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGU7ICcgKyAndHJpZ2dlcmluZyBuZXN0ZWQgY29tcG9uZW50IHVwZGF0ZXMgZnJvbSByZW5kZXIgaXMgbm90IGFsbG93ZWQuICcgKyAnSWYgbmVjZXNzYXJ5LCB0cmlnZ2VyIG5lc3RlZCB1cGRhdGVzIGluIGNvbXBvbmVudERpZFVwZGF0ZS5cXG5cXG4nICsgJ0NoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mICVzLicsIGdldENvbXBvbmVudE5hbWUoUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5jdXJyZW50KSB8fCAnVW5rbm93bicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjYWxsYmFjaztcbiAgICB7XG4gICAgICB3YXJuaW5nKGNhbGxiYWNrID09PSBudWxsIHx8IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJywgJ3JlbmRlciguLi4pOiBFeHBlY3RlZCB0aGUgbGFzdCBvcHRpb25hbCBgY2FsbGJhY2tgIGFyZ3VtZW50IHRvIGJlIGEgJyArICdmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIHZhciBleHBpcmF0aW9uVGltZSA9IHZvaWQgMDtcbiAgICAvLyBDaGVjayBpZiB0aGUgdG9wLWxldmVsIGVsZW1lbnQgaXMgYW4gYXN5bmMgd3JhcHBlciBjb21wb25lbnQuIElmIHNvLFxuICAgIC8vIHRyZWF0IHVwZGF0ZXMgdG8gdGhlIHJvb3QgYXMgYXN5bmMuIFRoaXMgaXMgYSBiaXQgd2VpcmQgYnV0IGxldHMgdXNcbiAgICAvLyBhdm9pZCBhIHNlcGFyYXRlIGByZW5kZXJBc3luY2AgQVBJLlxuICAgIGlmIChlbmFibGVBc3luY1N1YnRyZWVBUEkgJiYgZWxlbWVudCAhPSBudWxsICYmIGVsZW1lbnQudHlwZSAhPSBudWxsICYmIGVsZW1lbnQudHlwZS5wcm90b3R5cGUgIT0gbnVsbCAmJiBlbGVtZW50LnR5cGUucHJvdG90eXBlLnVuc3RhYmxlX2lzQXN5bmNSZWFjdENvbXBvbmVudCA9PT0gdHJ1ZSkge1xuICAgICAgZXhwaXJhdGlvblRpbWUgPSBjb21wdXRlQXN5bmNFeHBpcmF0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcihjdXJyZW50KTtcbiAgICB9XG5cbiAgICB2YXIgdXBkYXRlID0ge1xuICAgICAgZXhwaXJhdGlvblRpbWU6IGV4cGlyYXRpb25UaW1lLFxuICAgICAgcGFydGlhbFN0YXRlOiB7IGVsZW1lbnQ6IGVsZW1lbnQgfSxcbiAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgIGlzUmVwbGFjZTogZmFsc2UsXG4gICAgICBpc0ZvcmNlZDogZmFsc2UsXG4gICAgICBuZXh0Q2FsbGJhY2s6IG51bGwsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcbiAgICBpbnNlcnRVcGRhdGVJbnRvRmliZXIoY3VycmVudCwgdXBkYXRlKTtcbiAgICBzY2hlZHVsZVdvcmsoY3VycmVudCwgZXhwaXJhdGlvblRpbWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZEhvc3RJbnN0YW5jZShmaWJlcikge1xuICAgIHZhciBob3N0RmliZXIgPSBmaW5kQ3VycmVudEhvc3RGaWJlcihmaWJlcik7XG4gICAgaWYgKGhvc3RGaWJlciA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBob3N0RmliZXIuc3RhdGVOb2RlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjcmVhdGVDb250YWluZXI6IGZ1bmN0aW9uIChjb250YWluZXJJbmZvLCBoeWRyYXRlKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRmliZXJSb290KGNvbnRhaW5lckluZm8sIGh5ZHJhdGUpO1xuICAgIH0sXG4gICAgdXBkYXRlQ29udGFpbmVyOiBmdW5jdGlvbiAoZWxlbWVudCwgY29udGFpbmVyLCBwYXJlbnRDb21wb25lbnQsIGNhbGxiYWNrKSB7XG4gICAgICAvLyBUT0RPOiBJZiB0aGlzIGlzIGEgbmVzdGVkIGNvbnRhaW5lciwgdGhpcyB3b24ndCBiZSB0aGUgcm9vdC5cbiAgICAgIHZhciBjdXJyZW50ID0gY29udGFpbmVyLmN1cnJlbnQ7XG5cbiAgICAgIHtcbiAgICAgICAgaWYgKFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wpIHtcbiAgICAgICAgICBpZiAoY3VycmVudC5hbHRlcm5hdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25Nb3VudENvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vblVubW91bnRDb250YWluZXIoY29udGFpbmVyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vblVwZGF0ZUNvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IGdldENvbnRleHRGb3JTdWJ0cmVlKHBhcmVudENvbXBvbmVudCk7XG4gICAgICBpZiAoY29udGFpbmVyLmNvbnRleHQgPT09IG51bGwpIHtcbiAgICAgICAgY29udGFpbmVyLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGFpbmVyLnBlbmRpbmdDb250ZXh0ID0gY29udGV4dDtcbiAgICAgIH1cblxuICAgICAgc2NoZWR1bGVUb3BMZXZlbFVwZGF0ZShjdXJyZW50LCBlbGVtZW50LCBjYWxsYmFjayk7XG4gICAgfSxcblxuXG4gICAgYmF0Y2hlZFVwZGF0ZXM6IGJhdGNoZWRVcGRhdGVzLFxuXG4gICAgdW5iYXRjaGVkVXBkYXRlczogdW5iYXRjaGVkVXBkYXRlcyxcblxuICAgIGRlZmVycmVkVXBkYXRlczogZGVmZXJyZWRVcGRhdGVzLFxuXG4gICAgZmx1c2hTeW5jOiBmbHVzaFN5bmMsXG5cbiAgICBnZXRQdWJsaWNSb290SW5zdGFuY2U6IGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICAgIHZhciBjb250YWluZXJGaWJlciA9IGNvbnRhaW5lci5jdXJyZW50O1xuICAgICAgaWYgKCFjb250YWluZXJGaWJlci5jaGlsZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoY29udGFpbmVyRmliZXIuY2hpbGQudGFnKSB7XG4gICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICByZXR1cm4gZ2V0UHVibGljSW5zdGFuY2UoY29udGFpbmVyRmliZXIuY2hpbGQuc3RhdGVOb2RlKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gY29udGFpbmVyRmliZXIuY2hpbGQuc3RhdGVOb2RlO1xuICAgICAgfVxuICAgIH0sXG5cblxuICAgIGZpbmRIb3N0SW5zdGFuY2U6IGZpbmRIb3N0SW5zdGFuY2UsXG5cbiAgICBmaW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFsczogZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICB2YXIgaG9zdEZpYmVyID0gZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzKGZpYmVyKTtcbiAgICAgIGlmIChob3N0RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gaG9zdEZpYmVyLnN0YXRlTm9kZTtcbiAgICB9LFxuICAgIGluamVjdEludG9EZXZUb29sczogZnVuY3Rpb24gKGRldlRvb2xzQ29uZmlnKSB7XG4gICAgICB2YXIgZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UgPSBkZXZUb29sc0NvbmZpZy5maW5kRmliZXJCeUhvc3RJbnN0YW5jZTtcblxuICAgICAgcmV0dXJuIGluamVjdEludGVybmFscyhfYXNzaWduKHt9LCBkZXZUb29sc0NvbmZpZywge1xuICAgICAgICBmaW5kSG9zdEluc3RhbmNlQnlGaWJlcjogZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgICAgcmV0dXJuIGZpbmRIb3N0SW5zdGFuY2UoZmliZXIpO1xuICAgICAgICB9LFxuICAgICAgICBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZTogZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICAgICAgaWYgKCFmaW5kRmliZXJCeUhvc3RJbnN0YW5jZSkge1xuICAgICAgICAgICAgLy8gTWlnaHQgbm90IGJlIGltcGxlbWVudGVkIGJ5IHRoZSByZW5kZXJlci5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgfVxuICB9O1xufTtcblxudmFyIFJlYWN0RmliZXJSZWNvbmNpbGVyJDIgPSBPYmplY3QuZnJlZXplKHtcblx0ZGVmYXVsdDogUmVhY3RGaWJlclJlY29uY2lsZXIkMVxufSk7XG5cbnZhciBSZWFjdEZpYmVyUmVjb25jaWxlciQzID0gKCBSZWFjdEZpYmVyUmVjb25jaWxlciQyICYmIFJlYWN0RmliZXJSZWNvbmNpbGVyJDEgKSB8fCBSZWFjdEZpYmVyUmVjb25jaWxlciQyO1xuXG4vLyBUT0RPOiBidW5kbGUgRmxvdyB0eXBlcyB3aXRoIHRoZSBwYWNrYWdlLlxuXG5cblxuLy8gVE9ETzogZGVjaWRlIG9uIHRoZSB0b3AtbGV2ZWwgZXhwb3J0IGZvcm0uXG4vLyBUaGlzIGlzIGhhY2t5IGJ1dCBtYWtlcyBpdCB3b3JrIHdpdGggYm90aCBSb2xsdXAgYW5kIEplc3QuXG52YXIgcmVhY3RSZWNvbmNpbGVyID0gUmVhY3RGaWJlclJlY29uY2lsZXIkM1snZGVmYXVsdCddID8gUmVhY3RGaWJlclJlY29uY2lsZXIkM1snZGVmYXVsdCddIDogUmVhY3RGaWJlclJlY29uY2lsZXIkMztcblxuZnVuY3Rpb24gY3JlYXRlUG9ydGFsJDEoY2hpbGRyZW4sIGNvbnRhaW5lckluZm8sXG4vLyBUT0RPOiBmaWd1cmUgb3V0IHRoZSBBUEkgZm9yIGNyb3NzLXJlbmRlcmVyIGltcGxlbWVudGF0aW9uLlxuaW1wbGVtZW50YXRpb24pIHtcbiAgdmFyIGtleSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogbnVsbDtcblxuICByZXR1cm4ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93IHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBQb3J0YWxcbiAgICAkJHR5cGVvZjogUkVBQ1RfUE9SVEFMX1RZUEUsXG4gICAga2V5OiBrZXkgPT0gbnVsbCA/IG51bGwgOiAnJyArIGtleSxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgY29udGFpbmVySW5mbzogY29udGFpbmVySW5mbyxcbiAgICBpbXBsZW1lbnRhdGlvbjogaW1wbGVtZW50YXRpb25cbiAgfTtcbn1cblxuLy8gVE9ETzogdGhpcyBpcyBzcGVjaWFsIGJlY2F1c2UgaXQgZ2V0cyBpbXBvcnRlZCBkdXJpbmcgYnVpbGQuXG5cbnZhciBSZWFjdFZlcnNpb24gPSAnMTYuMi4wJztcblxuLy8gYSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUsIHN0b3JpbmcgdGhlIHRpbWUgZm9yIHRoZSBzdGFydCBvZiB0aGUgZnJhbWUsIHRoZW5cbi8vIHNjaGVkdWxpbmcgYSBwb3N0TWVzc2FnZSB3aGljaCBnZXRzIHNjaGVkdWxlZCBhZnRlciBwYWludC4gV2l0aGluIHRoZVxuLy8gcG9zdE1lc3NhZ2UgaGFuZGxlciBkbyBhcyBtdWNoIHdvcmsgYXMgcG9zc2libGUgdW50aWwgdGltZSArIGZyYW1lIHJhdGUuXG4vLyBCeSBzZXBhcmF0aW5nIHRoZSBpZGxlIGNhbGwgaW50byBhIHNlcGFyYXRlIGV2ZW50IHRpY2sgd2UgZW5zdXJlIHRoYXRcbi8vIGxheW91dCwgcGFpbnQgYW5kIG90aGVyIGJyb3dzZXIgd29yayBpcyBjb3VudGVkIGFnYWluc3QgdGhlIGF2YWlsYWJsZSB0aW1lLlxuLy8gVGhlIGZyYW1lIHJhdGUgaXMgZHluYW1pY2FsbHkgYWRqdXN0ZWQuXG5cbntcbiAgaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiB0eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgd2FybmluZyhmYWxzZSwgJ1JlYWN0IGRlcGVuZHMgb24gcmVxdWVzdEFuaW1hdGlvbkZyYW1lLiBNYWtlIHN1cmUgdGhhdCB5b3UgbG9hZCBhICcgKyAncG9seWZpbGwgaW4gb2xkZXIgYnJvd3NlcnMuIGh0dHA6Ly9mYi5tZS9yZWFjdC1wb2x5ZmlsbHMnKTtcbiAgfVxufVxuXG52YXIgaGFzTmF0aXZlUGVyZm9ybWFuY2VOb3cgPSB0eXBlb2YgcGVyZm9ybWFuY2UgPT09ICdvYmplY3QnICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5ub3cgPT09ICdmdW5jdGlvbic7XG5cbnZhciBub3cgPSB2b2lkIDA7XG5pZiAoaGFzTmF0aXZlUGVyZm9ybWFuY2VOb3cpIHtcbiAgbm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtcbiAgfTtcbn0gZWxzZSB7XG4gIG5vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gRGF0ZS5ub3coKTtcbiAgfTtcbn1cblxuLy8gVE9ETzogVGhlcmUncyBubyB3YXkgdG8gY2FuY2VsLCBiZWNhdXNlIEZpYmVyIGRvZXNuJ3QgYXRtLlxudmFyIHJJQyA9IHZvaWQgMDtcbnZhciBjSUMgPSB2b2lkIDA7XG5cbmlmICghRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHJJQyA9IGZ1bmN0aW9uIChmcmFtZUNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgZnJhbWVDYWxsYmFjayh7XG4gICAgICAgIHRpbWVSZW1haW5pbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuICBjSUMgPSBmdW5jdGlvbiAodGltZW91dElEKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJRCk7XG4gIH07XG59IGVsc2UgaWYgKHR5cGVvZiByZXF1ZXN0SWRsZUNhbGxiYWNrICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBjYW5jZWxJZGxlQ2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgLy8gUG9seWZpbGwgcmVxdWVzdElkbGVDYWxsYmFjayBhbmQgY2FuY2VsSWRsZUNhbGxiYWNrXG5cbiAgdmFyIHNjaGVkdWxlZFJJQ0NhbGxiYWNrID0gbnVsbDtcbiAgdmFyIGlzSWRsZVNjaGVkdWxlZCA9IGZhbHNlO1xuICB2YXIgdGltZW91dFRpbWUgPSAtMTtcblxuICB2YXIgaXNBbmltYXRpb25GcmFtZVNjaGVkdWxlZCA9IGZhbHNlO1xuXG4gIHZhciBmcmFtZURlYWRsaW5lID0gMDtcbiAgLy8gV2Ugc3RhcnQgb3V0IGFzc3VtaW5nIHRoYXQgd2UgcnVuIGF0IDMwZnBzIGJ1dCB0aGVuIHRoZSBoZXVyaXN0aWMgdHJhY2tpbmdcbiAgLy8gd2lsbCBhZGp1c3QgdGhpcyB2YWx1ZSB0byBhIGZhc3RlciBmcHMgaWYgd2UgZ2V0IG1vcmUgZnJlcXVlbnQgYW5pbWF0aW9uXG4gIC8vIGZyYW1lcy5cbiAgdmFyIHByZXZpb3VzRnJhbWVUaW1lID0gMzM7XG4gIHZhciBhY3RpdmVGcmFtZVRpbWUgPSAzMztcblxuICB2YXIgZnJhbWVEZWFkbGluZU9iamVjdDtcbiAgaWYgKGhhc05hdGl2ZVBlcmZvcm1hbmNlTm93KSB7XG4gICAgZnJhbWVEZWFkbGluZU9iamVjdCA9IHtcbiAgICAgIGRpZFRpbWVvdXQ6IGZhbHNlLFxuICAgICAgdGltZVJlbWFpbmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBXZSBhc3N1bWUgdGhhdCBpZiB3ZSBoYXZlIGEgcGVyZm9ybWFuY2UgdGltZXIgdGhhdCB0aGUgckFGIGNhbGxiYWNrXG4gICAgICAgIC8vIGdldHMgYSBwZXJmb3JtYW5jZSB0aW1lciB2YWx1ZS4gTm90IHN1cmUgaWYgdGhpcyBpcyBhbHdheXMgdHJ1ZS5cbiAgICAgICAgdmFyIHJlbWFpbmluZyA9IGZyYW1lRGVhZGxpbmUgLSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgcmV0dXJuIHJlbWFpbmluZyA+IDAgPyByZW1haW5pbmcgOiAwO1xuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgZnJhbWVEZWFkbGluZU9iamVjdCA9IHtcbiAgICAgIGRpZFRpbWVvdXQ6IGZhbHNlLFxuICAgICAgdGltZVJlbWFpbmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBGYWxsYmFjayB0byBEYXRlLm5vdygpXG4gICAgICAgIHZhciByZW1haW5pbmcgPSBmcmFtZURlYWRsaW5lIC0gRGF0ZS5ub3coKTtcbiAgICAgICAgcmV0dXJuIHJlbWFpbmluZyA+IDAgPyByZW1haW5pbmcgOiAwO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBXZSB1c2UgdGhlIHBvc3RNZXNzYWdlIHRyaWNrIHRvIGRlZmVyIGlkbGUgd29yayB1bnRpbCBhZnRlciB0aGUgcmVwYWludC5cbiAgdmFyIG1lc3NhZ2VLZXkgPSAnX19yZWFjdElkbGVDYWxsYmFjayQnICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG4gIHZhciBpZGxlVGljayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmIChldmVudC5zb3VyY2UgIT09IHdpbmRvdyB8fCBldmVudC5kYXRhICE9PSBtZXNzYWdlS2V5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaXNJZGxlU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgICB2YXIgY3VycmVudFRpbWUgPSBub3coKTtcbiAgICBpZiAoZnJhbWVEZWFkbGluZSAtIGN1cnJlbnRUaW1lIDw9IDApIHtcbiAgICAgIC8vIFRoZXJlJ3Mgbm8gdGltZSBsZWZ0IGluIHRoaXMgaWRsZSBwZXJpb2QuIENoZWNrIGlmIHRoZSBjYWxsYmFjayBoYXNcbiAgICAgIC8vIGEgdGltZW91dCBhbmQgd2hldGhlciBpdCdzIGJlZW4gZXhjZWVkZWQuXG4gICAgICBpZiAodGltZW91dFRpbWUgIT09IC0xICYmIHRpbWVvdXRUaW1lIDw9IGN1cnJlbnRUaW1lKSB7XG4gICAgICAgIC8vIEV4Y2VlZGVkIHRoZSB0aW1lb3V0LiBJbnZva2UgdGhlIGNhbGxiYWNrIGV2ZW4gdGhvdWdoIHRoZXJlJ3Mgbm9cbiAgICAgICAgLy8gdGltZSBsZWZ0LlxuICAgICAgICBmcmFtZURlYWRsaW5lT2JqZWN0LmRpZFRpbWVvdXQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm8gdGltZW91dC5cbiAgICAgICAgaWYgKCFpc0FuaW1hdGlvbkZyYW1lU2NoZWR1bGVkKSB7XG4gICAgICAgICAgLy8gU2NoZWR1bGUgYW5vdGhlciBhbmltYXRpb24gY2FsbGJhY2sgc28gd2UgcmV0cnkgbGF0ZXIuXG4gICAgICAgICAgaXNBbmltYXRpb25GcmFtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvblRpY2spO1xuICAgICAgICB9XG4gICAgICAgIC8vIEV4aXQgd2l0aG91dCBpbnZva2luZyB0aGUgY2FsbGJhY2suXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlcmUncyBzdGlsbCB0aW1lIGxlZnQgaW4gdGhpcyBpZGxlIHBlcmlvZC5cbiAgICAgIGZyYW1lRGVhZGxpbmVPYmplY3QuZGlkVGltZW91dCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRpbWVvdXRUaW1lID0gLTE7XG4gICAgdmFyIGNhbGxiYWNrID0gc2NoZWR1bGVkUklDQ2FsbGJhY2s7XG4gICAgc2NoZWR1bGVkUklDQ2FsbGJhY2sgPSBudWxsO1xuICAgIGlmIChjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgY2FsbGJhY2soZnJhbWVEZWFkbGluZU9iamVjdCk7XG4gICAgfVxuICB9O1xuICAvLyBBc3N1bWVzIHRoYXQgd2UgaGF2ZSBhZGRFdmVudExpc3RlbmVyIGluIHRoaXMgZW52aXJvbm1lbnQuIE1pZ2h0IG5lZWRcbiAgLy8gc29tZXRoaW5nIGJldHRlciBmb3Igb2xkIElFLlxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGlkbGVUaWNrLCBmYWxzZSk7XG5cbiAgdmFyIGFuaW1hdGlvblRpY2sgPSBmdW5jdGlvbiAocmFmVGltZSkge1xuICAgIGlzQW5pbWF0aW9uRnJhbWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICB2YXIgbmV4dEZyYW1lVGltZSA9IHJhZlRpbWUgLSBmcmFtZURlYWRsaW5lICsgYWN0aXZlRnJhbWVUaW1lO1xuICAgIGlmIChuZXh0RnJhbWVUaW1lIDwgYWN0aXZlRnJhbWVUaW1lICYmIHByZXZpb3VzRnJhbWVUaW1lIDwgYWN0aXZlRnJhbWVUaW1lKSB7XG4gICAgICBpZiAobmV4dEZyYW1lVGltZSA8IDgpIHtcbiAgICAgICAgLy8gRGVmZW5zaXZlIGNvZGluZy4gV2UgZG9uJ3Qgc3VwcG9ydCBoaWdoZXIgZnJhbWUgcmF0ZXMgdGhhbiAxMjBoei5cbiAgICAgICAgLy8gSWYgd2UgZ2V0IGxvd2VyIHRoYW4gdGhhdCwgaXQgaXMgcHJvYmFibHkgYSBidWcuXG4gICAgICAgIG5leHRGcmFtZVRpbWUgPSA4O1xuICAgICAgfVxuICAgICAgLy8gSWYgb25lIGZyYW1lIGdvZXMgbG9uZywgdGhlbiB0aGUgbmV4dCBvbmUgY2FuIGJlIHNob3J0IHRvIGNhdGNoIHVwLlxuICAgICAgLy8gSWYgdHdvIGZyYW1lcyBhcmUgc2hvcnQgaW4gYSByb3csIHRoZW4gdGhhdCdzIGFuIGluZGljYXRpb24gdGhhdCB3ZVxuICAgICAgLy8gYWN0dWFsbHkgaGF2ZSBhIGhpZ2hlciBmcmFtZSByYXRlIHRoYW4gd2hhdCB3ZSdyZSBjdXJyZW50bHkgb3B0aW1pemluZy5cbiAgICAgIC8vIFdlIGFkanVzdCBvdXIgaGV1cmlzdGljIGR5bmFtaWNhbGx5IGFjY29yZGluZ2x5LiBGb3IgZXhhbXBsZSwgaWYgd2UncmVcbiAgICAgIC8vIHJ1bm5pbmcgb24gMTIwaHogZGlzcGxheSBvciA5MGh6IFZSIGRpc3BsYXkuXG4gICAgICAvLyBUYWtlIHRoZSBtYXggb2YgdGhlIHR3byBpbiBjYXNlIG9uZSBvZiB0aGVtIHdhcyBhbiBhbm9tYWx5IGR1ZSB0b1xuICAgICAgLy8gbWlzc2VkIGZyYW1lIGRlYWRsaW5lcy5cbiAgICAgIGFjdGl2ZUZyYW1lVGltZSA9IG5leHRGcmFtZVRpbWUgPCBwcmV2aW91c0ZyYW1lVGltZSA/IHByZXZpb3VzRnJhbWVUaW1lIDogbmV4dEZyYW1lVGltZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJldmlvdXNGcmFtZVRpbWUgPSBuZXh0RnJhbWVUaW1lO1xuICAgIH1cbiAgICBmcmFtZURlYWRsaW5lID0gcmFmVGltZSArIGFjdGl2ZUZyYW1lVGltZTtcbiAgICBpZiAoIWlzSWRsZVNjaGVkdWxlZCkge1xuICAgICAgaXNJZGxlU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZShtZXNzYWdlS2V5LCAnKicpO1xuICAgIH1cbiAgfTtcblxuICBySUMgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAvLyBUaGlzIGFzc3VtZXMgdGhhdCB3ZSBvbmx5IHNjaGVkdWxlIG9uZSBjYWxsYmFjayBhdCBhIHRpbWUgYmVjYXVzZSB0aGF0J3NcbiAgICAvLyBob3cgRmliZXIgdXNlcyBpdC5cbiAgICBzY2hlZHVsZWRSSUNDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIGlmIChvcHRpb25zICE9IG51bGwgJiYgdHlwZW9mIG9wdGlvbnMudGltZW91dCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRpbWVvdXRUaW1lID0gbm93KCkgKyBvcHRpb25zLnRpbWVvdXQ7XG4gICAgfVxuICAgIGlmICghaXNBbmltYXRpb25GcmFtZVNjaGVkdWxlZCkge1xuICAgICAgLy8gSWYgckFGIGRpZG4ndCBhbHJlYWR5IHNjaGVkdWxlIG9uZSwgd2UgbmVlZCB0byBzY2hlZHVsZSBhIGZyYW1lLlxuICAgICAgLy8gVE9ETzogSWYgdGhpcyByQUYgZG9lc24ndCBtYXRlcmlhbGl6ZSBiZWNhdXNlIHRoZSBicm93c2VyIHRocm90dGxlcywgd2VcbiAgICAgIC8vIG1pZ2h0IHdhbnQgdG8gc3RpbGwgaGF2ZSBzZXRUaW1lb3V0IHRyaWdnZXIgcklDIGFzIGEgYmFja3VwIHRvIGVuc3VyZVxuICAgICAgLy8gdGhhdCB3ZSBrZWVwIHBlcmZvcm1pbmcgd29yay5cbiAgICAgIGlzQW5pbWF0aW9uRnJhbWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvblRpY2spO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfTtcblxuICBjSUMgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2NoZWR1bGVkUklDQ2FsbGJhY2sgPSBudWxsO1xuICAgIGlzSWRsZVNjaGVkdWxlZCA9IGZhbHNlO1xuICAgIHRpbWVvdXRUaW1lID0gLTE7XG4gIH07XG59IGVsc2Uge1xuICBySUMgPSB3aW5kb3cucmVxdWVzdElkbGVDYWxsYmFjaztcbiAgY0lDID0gd2luZG93LmNhbmNlbElkbGVDYWxsYmFjaztcbn1cblxuLyoqXG4gKiBGb3JrZWQgZnJvbSBmYmpzL3dhcm5pbmc6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmJqcy9ibG9iL2U2NmJhMjBhZDViZTQzM2ViNTQ0MjNmMmIwOTdkODI5MzI0ZDlkZTYvcGFja2FnZXMvZmJqcy9zcmMvX19mb3Jrc19fL3dhcm5pbmcuanNcbiAqXG4gKiBPbmx5IGNoYW5nZSBpcyB3ZSB1c2UgY29uc29sZS53YXJuIGluc3RlYWQgb2YgY29uc29sZS5lcnJvcixcbiAqIGFuZCBkbyBub3RoaW5nIHdoZW4gJ2NvbnNvbGUnIGlzIG5vdCBzdXBwb3J0ZWQuXG4gKiBUaGlzIHJlYWxseSBzaW1wbGlmaWVzIHRoZSBjb2RlLlxuICogLS0tXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIGxvd1ByaW9yaXR5V2FybmluZyA9IGZ1bmN0aW9uICgpIHt9O1xuXG57XG4gIHZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xuXG4gIGxvd1ByaW9yaXR5V2FybmluZyA9IGZ1bmN0aW9uIChjb25kaXRpb24sIGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICsgJ21lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yID4gMiA/IF9sZW4yIC0gMiA6IDApLCBfa2V5MiA9IDI7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nLmFwcGx5KHVuZGVmaW5lZCwgW2Zvcm1hdF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBsb3dQcmlvcml0eVdhcm5pbmckMSA9IGxvd1ByaW9yaXR5V2FybmluZztcblxuLy8gaXNBdHRyaWJ1dGVOYW1lU2FmZSgpIGlzIGN1cnJlbnRseSBkdXBsaWNhdGVkIGluIERPTU1hcmt1cE9wZXJhdGlvbnMuXG4vLyBUT0RPOiBGaW5kIGEgYmV0dGVyIHBsYWNlIGZvciB0aGlzLlxudmFyIFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYID0gbmV3IFJlZ0V4cCgnXlsnICsgQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiArICddWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xudmFyIGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUgPSB7fTtcbnZhciB2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGlzQXR0cmlidXRlTmFtZVNhZmUoYXR0cmlidXRlTmFtZSkge1xuICBpZiAodmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlLmhhc093blByb3BlcnR5KGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUuaGFzT3duUHJvcGVydHkoYXR0cmlidXRlTmFtZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYLnRlc3QoYXR0cmlidXRlTmFtZSkpIHtcbiAgICB2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGVbYXR0cmlidXRlTmFtZV0gPSB0cnVlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGVbYXR0cmlidXRlTmFtZV0gPSB0cnVlO1xuICB7XG4gICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXR0cmlidXRlIG5hbWU6IGAlc2AnLCBhdHRyaWJ1dGVOYW1lKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIHNob3VsZElnbm9yZVZhbHVlKCkgaXMgY3VycmVudGx5IGR1cGxpY2F0ZWQgaW4gRE9NTWFya3VwT3BlcmF0aW9ucy5cbi8vIFRPRE86IEZpbmQgYSBiZXR0ZXIgcGxhY2UgZm9yIHRoaXMuXG5mdW5jdGlvbiBzaG91bGRJZ25vcmVWYWx1ZShwcm9wZXJ0eUluZm8sIHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsIHx8IHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUgJiYgIXZhbHVlIHx8IHByb3BlcnR5SW5mby5oYXNOdW1lcmljVmFsdWUgJiYgaXNOYU4odmFsdWUpIHx8IHByb3BlcnR5SW5mby5oYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZSAmJiB2YWx1ZSA8IDEgfHwgcHJvcGVydHlJbmZvLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUgJiYgdmFsdWUgPT09IGZhbHNlO1xufVxuXG4vKipcbiAqIE9wZXJhdGlvbnMgZm9yIGRlYWxpbmcgd2l0aCBET00gcHJvcGVydGllcy5cbiAqL1xuXG5cblxuXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBvbiBhIG5vZGUuIE9ubHkgdXNlZCBpbiBERVYgZm9yIFNTUiB2YWxpZGF0aW9uLlxuICogVGhlIFwiZXhwZWN0ZWRcIiBhcmd1bWVudCBpcyB1c2VkIGFzIGEgaGludCBvZiB3aGF0IHRoZSBleHBlY3RlZCB2YWx1ZSBpcy5cbiAqIFNvbWUgcHJvcGVydGllcyBoYXZlIG11bHRpcGxlIGVxdWl2YWxlbnQgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZUZvclByb3BlcnR5KG5vZGUsIG5hbWUsIGV4cGVjdGVkKSB7XG4gIHtcbiAgICB2YXIgcHJvcGVydHlJbmZvID0gZ2V0UHJvcGVydHlJbmZvKG5hbWUpO1xuICAgIGlmIChwcm9wZXJ0eUluZm8pIHtcbiAgICAgIHZhciBtdXRhdGlvbk1ldGhvZCA9IHByb3BlcnR5SW5mby5tdXRhdGlvbk1ldGhvZDtcbiAgICAgIGlmIChtdXRhdGlvbk1ldGhvZCB8fCBwcm9wZXJ0eUluZm8ubXVzdFVzZVByb3BlcnR5KSB7XG4gICAgICAgIHJldHVybiBub2RlW3Byb3BlcnR5SW5mby5wcm9wZXJ0eU5hbWVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZTtcblxuICAgICAgICB2YXIgc3RyaW5nVmFsdWUgPSBudWxsO1xuXG4gICAgICAgIGlmIChwcm9wZXJ0eUluZm8uaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSkge1xuICAgICAgICAgIGlmIChub2RlLmhhc0F0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gbm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNob3VsZElnbm9yZVZhbHVlKHByb3BlcnR5SW5mbywgZXhwZWN0ZWQpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJycgKyBleHBlY3RlZCkge1xuICAgICAgICAgICAgICByZXR1cm4gZXhwZWN0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG5vZGUuaGFzQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgICAgICAgaWYgKHNob3VsZElnbm9yZVZhbHVlKHByb3BlcnR5SW5mbywgZXhwZWN0ZWQpKSB7XG4gICAgICAgICAgICAvLyBXZSBoYWQgYW4gYXR0cmlidXRlIGJ1dCBzaG91bGRuJ3QgaGF2ZSBoYWQgb25lLCBzbyByZWFkIGl0XG4gICAgICAgICAgICAvLyBmb3IgdGhlIGVycm9yIG1lc3NhZ2UuXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIHdhcyBhIGJvb2xlYW4sIGl0IGRvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIHZhbHVlIGlzXG4gICAgICAgICAgICAvLyB0aGUgZmFjdCB0aGF0IHdlIGhhdmUgaXQgaXMgdGhlIHNhbWUgYXMgdGhlIGV4cGVjdGVkLlxuICAgICAgICAgICAgcmV0dXJuIGV4cGVjdGVkO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBFdmVuIGlmIHRoaXMgcHJvcGVydHkgdXNlcyBhIG5hbWVzcGFjZSB3ZSB1c2UgZ2V0QXR0cmlidXRlXG4gICAgICAgICAgLy8gYmVjYXVzZSB3ZSBhc3N1bWUgaXRzIG5hbWVzcGFjZWQgbmFtZSBpcyB0aGUgc2FtZSBhcyBvdXIgY29uZmlnLlxuICAgICAgICAgIC8vIFRvIHVzZSBnZXRBdHRyaWJ1dGVOUyB3ZSBuZWVkIHRoZSBsb2NhbCBuYW1lIHdoaWNoIHdlIGRvbid0IGhhdmVcbiAgICAgICAgICAvLyBpbiBvdXIgY29uZmlnIGF0bS5cbiAgICAgICAgICBzdHJpbmdWYWx1ZSA9IG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNob3VsZElnbm9yZVZhbHVlKHByb3BlcnR5SW5mbywgZXhwZWN0ZWQpKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmluZ1ZhbHVlID09PSBudWxsID8gZXhwZWN0ZWQgOiBzdHJpbmdWYWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHJpbmdWYWx1ZSA9PT0gJycgKyBleHBlY3RlZCkge1xuICAgICAgICAgIHJldHVybiBleHBlY3RlZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gc3RyaW5nVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIGZvciBhIGF0dHJpYnV0ZSBvbiBhIG5vZGUuIE9ubHkgdXNlZCBpbiBERVYgZm9yIFNTUiB2YWxpZGF0aW9uLlxuICogVGhlIHRoaXJkIGFyZ3VtZW50IGlzIHVzZWQgYXMgYSBoaW50IG9mIHdoYXQgdGhlIGV4cGVjdGVkIHZhbHVlIGlzLiBTb21lXG4gKiBhdHRyaWJ1dGVzIGhhdmUgbXVsdGlwbGUgZXF1aXZhbGVudCB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlRm9yQXR0cmlidXRlKG5vZGUsIG5hbWUsIGV4cGVjdGVkKSB7XG4gIHtcbiAgICBpZiAoIWlzQXR0cmlidXRlTmFtZVNhZmUobmFtZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFub2RlLmhhc0F0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgcmV0dXJuIGV4cGVjdGVkID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBudWxsO1xuICAgIH1cbiAgICB2YXIgdmFsdWUgPSBub2RlLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICBpZiAodmFsdWUgPT09ICcnICsgZXhwZWN0ZWQpIHtcbiAgICAgIHJldHVybiBleHBlY3RlZDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbi8qKlxuICogU2V0cyB0aGUgdmFsdWUgZm9yIGEgcHJvcGVydHkgb24gYSBub2RlLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqL1xuZnVuY3Rpb24gc2V0VmFsdWVGb3JQcm9wZXJ0eShub2RlLCBuYW1lLCB2YWx1ZSkge1xuICB2YXIgcHJvcGVydHlJbmZvID0gZ2V0UHJvcGVydHlJbmZvKG5hbWUpO1xuXG4gIGlmIChwcm9wZXJ0eUluZm8gJiYgc2hvdWxkU2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKSkge1xuICAgIHZhciBtdXRhdGlvbk1ldGhvZCA9IHByb3BlcnR5SW5mby5tdXRhdGlvbk1ldGhvZDtcbiAgICBpZiAobXV0YXRpb25NZXRob2QpIHtcbiAgICAgIG11dGF0aW9uTWV0aG9kKG5vZGUsIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHNob3VsZElnbm9yZVZhbHVlKHByb3BlcnR5SW5mbywgdmFsdWUpKSB7XG4gICAgICBkZWxldGVWYWx1ZUZvclByb3BlcnR5KG5vZGUsIG5hbWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAocHJvcGVydHlJbmZvLm11c3RVc2VQcm9wZXJ0eSkge1xuICAgICAgLy8gQ29udHJhcnkgdG8gYHNldEF0dHJpYnV0ZWAsIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBwcm9wZXJseVxuICAgICAgLy8gYHRvU3RyaW5nYGVkIGJ5IElFOC85LlxuICAgICAgbm9kZVtwcm9wZXJ0eUluZm8ucHJvcGVydHlOYW1lXSA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lO1xuICAgICAgdmFyIG5hbWVzcGFjZSA9IHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lc3BhY2U7XG4gICAgICAvLyBgc2V0QXR0cmlidXRlYCB3aXRoIG9iamVjdHMgYmVjb21lcyBvbmx5IGBbb2JqZWN0XWAgaW4gSUU4LzksXG4gICAgICAvLyAoJycgKyB2YWx1ZSkgbWFrZXMgaXQgb3V0cHV0IHRoZSBjb3JyZWN0IHRvU3RyaW5nKCktdmFsdWUuXG4gICAgICBpZiAobmFtZXNwYWNlKSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlTlMobmFtZXNwYWNlLCBhdHRyaWJ1dGVOYW1lLCAnJyArIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSB8fCBwcm9wZXJ0eUluZm8uaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSAmJiB2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCAnJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCAnJyArIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2V0VmFsdWVGb3JBdHRyaWJ1dGUobm9kZSwgbmFtZSwgc2hvdWxkU2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKSA/IHZhbHVlIDogbnVsbCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAge1xuICAgIFxuICB9XG59XG5cbmZ1bmN0aW9uIHNldFZhbHVlRm9yQXR0cmlidXRlKG5vZGUsIG5hbWUsIHZhbHVlKSB7XG4gIGlmICghaXNBdHRyaWJ1dGVOYW1lU2FmZShuYW1lKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICB9IGVsc2Uge1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKG5hbWUsICcnICsgdmFsdWUpO1xuICB9XG5cbiAge1xuICAgIFxuICB9XG59XG5cbi8qKlxuICogRGVsZXRlcyBhbiBhdHRyaWJ1dGVzIGZyb20gYSBub2RlLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqL1xuZnVuY3Rpb24gZGVsZXRlVmFsdWVGb3JBdHRyaWJ1dGUobm9kZSwgbmFtZSkge1xuICBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbn1cblxuLyoqXG4gKiBEZWxldGVzIHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBvbiBhIG5vZGUuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICovXG5mdW5jdGlvbiBkZWxldGVWYWx1ZUZvclByb3BlcnR5KG5vZGUsIG5hbWUpIHtcbiAgdmFyIHByb3BlcnR5SW5mbyA9IGdldFByb3BlcnR5SW5mbyhuYW1lKTtcbiAgaWYgKHByb3BlcnR5SW5mbykge1xuICAgIHZhciBtdXRhdGlvbk1ldGhvZCA9IHByb3BlcnR5SW5mby5tdXRhdGlvbk1ldGhvZDtcbiAgICBpZiAobXV0YXRpb25NZXRob2QpIHtcbiAgICAgIG11dGF0aW9uTWV0aG9kKG5vZGUsIHVuZGVmaW5lZCk7XG4gICAgfSBlbHNlIGlmIChwcm9wZXJ0eUluZm8ubXVzdFVzZVByb3BlcnR5KSB7XG4gICAgICB2YXIgcHJvcE5hbWUgPSBwcm9wZXJ0eUluZm8ucHJvcGVydHlOYW1lO1xuICAgICAgaWYgKHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUpIHtcbiAgICAgICAgbm9kZVtwcm9wTmFtZV0gPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVbcHJvcE5hbWVdID0gJyc7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gIH1cbn1cblxudmFyIFJlYWN0Q29udHJvbGxlZFZhbHVlUHJvcFR5cGVzID0ge1xuICBjaGVja1Byb3BUeXBlczogbnVsbFxufTtcblxue1xuICB2YXIgaGFzUmVhZE9ubHlWYWx1ZSA9IHtcbiAgICBidXR0b246IHRydWUsXG4gICAgY2hlY2tib3g6IHRydWUsXG4gICAgaW1hZ2U6IHRydWUsXG4gICAgaGlkZGVuOiB0cnVlLFxuICAgIHJhZGlvOiB0cnVlLFxuICAgIHJlc2V0OiB0cnVlLFxuICAgIHN1Ym1pdDogdHJ1ZVxuICB9O1xuXG4gIHZhciBwcm9wVHlwZXMgPSB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIChwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICAgIGlmICghcHJvcHNbcHJvcE5hbWVdIHx8IGhhc1JlYWRPbmx5VmFsdWVbcHJvcHMudHlwZV0gfHwgcHJvcHMub25DaGFuZ2UgfHwgcHJvcHMucmVhZE9ubHkgfHwgcHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdZb3UgcHJvdmlkZWQgYSBgdmFsdWVgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gJyArICdgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmICcgKyAndGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdFZhbHVlYC4gT3RoZXJ3aXNlLCAnICsgJ3NldCBlaXRoZXIgYG9uQ2hhbmdlYCBvciBgcmVhZE9ubHlgLicpO1xuICAgIH0sXG4gICAgY2hlY2tlZDogZnVuY3Rpb24gKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgICAgaWYgKCFwcm9wc1twcm9wTmFtZV0gfHwgcHJvcHMub25DaGFuZ2UgfHwgcHJvcHMucmVhZE9ubHkgfHwgcHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdZb3UgcHJvdmlkZWQgYSBgY2hlY2tlZGAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiAnICsgJ2BvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgJyArICd0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0Q2hlY2tlZGAuIE90aGVyd2lzZSwgJyArICdzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC4nKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFByb3ZpZGUgYSBsaW5rZWQgYHZhbHVlYCBhdHRyaWJ1dGUgZm9yIGNvbnRyb2xsZWQgZm9ybXMuIFlvdSBzaG91bGQgbm90IHVzZVxuICAgKiB0aGlzIG91dHNpZGUgb2YgdGhlIFJlYWN0RE9NIGNvbnRyb2xsZWQgZm9ybSBjb21wb25lbnRzLlxuICAgKi9cbiAgUmVhY3RDb250cm9sbGVkVmFsdWVQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBmdW5jdGlvbiAodGFnTmFtZSwgcHJvcHMsIGdldFN0YWNrKSB7XG4gICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBwcm9wcywgJ3Byb3AnLCB0YWdOYW1lLCBnZXRTdGFjayk7XG4gIH07XG59XG5cbi8vIFRPRE86IGRpcmVjdCBpbXBvcnRzIGxpa2Ugc29tZS1wYWNrYWdlL3NyYy8qIGFyZSBiYWQuIEZpeCBtZS5cbnZhciBnZXRDdXJyZW50RmliZXJPd25lck5hbWUkMiA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lO1xudmFyIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMyA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bTtcblxudmFyIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSA9IGZhbHNlO1xudmFyIGRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQgPSBmYWxzZTtcbnZhciBkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkID0gZmFsc2U7XG52YXIgZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBpc0NvbnRyb2xsZWQocHJvcHMpIHtcbiAgdmFyIHVzZXNDaGVja2VkID0gcHJvcHMudHlwZSA9PT0gJ2NoZWNrYm94JyB8fCBwcm9wcy50eXBlID09PSAncmFkaW8nO1xuICByZXR1cm4gdXNlc0NoZWNrZWQgPyBwcm9wcy5jaGVja2VkICE9IG51bGwgOiBwcm9wcy52YWx1ZSAhPSBudWxsO1xufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYW4gPGlucHV0PiBob3N0IGNvbXBvbmVudCB0aGF0IGFsbG93cyBzZXR0aW5nIHRoZXNlIG9wdGlvbmFsXG4gKiBwcm9wczogYGNoZWNrZWRgLCBgdmFsdWVgLCBgZGVmYXVsdENoZWNrZWRgLCBhbmQgYGRlZmF1bHRWYWx1ZWAuXG4gKlxuICogSWYgYGNoZWNrZWRgIG9yIGB2YWx1ZWAgYXJlIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnNcbiAqIHRoYXQgYWZmZWN0IHRoZSBjaGVja2VkIHN0YXRlIG9yIHZhbHVlIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LlxuICpcbiAqIElmIHRoZXkgYXJlIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBub3RcbiAqIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC4gSW5zdGVhZCwgdGhlIHByb3BzIG11c3QgY2hhbmdlIGluIG9yZGVyIGZvclxuICogdGhlIHJlbmRlcmVkIGVsZW1lbnQgdG8gYmUgdXBkYXRlZC5cbiAqXG4gKiBUaGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIGJlIGluaXRpYWxpemVkIGFzIHVuY2hlY2tlZCAob3IgYGRlZmF1bHRDaGVja2VkYClcbiAqIHdpdGggYW4gZW1wdHkgdmFsdWUgKG9yIGBkZWZhdWx0VmFsdWVgKS5cbiAqXG4gKiBTZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMi9XRC1odG1sNS0yMDEyMTAyNS90aGUtaW5wdXQtZWxlbWVudC5odG1sXG4gKi9cblxuZnVuY3Rpb24gZ2V0SG9zdFByb3BzKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gIHZhciBjaGVja2VkID0gcHJvcHMuY2hlY2tlZDtcblxuICB2YXIgaG9zdFByb3BzID0gX2Fzc2lnbih7XG4gICAgLy8gTWFrZSBzdXJlIHdlIHNldCAudHlwZSBiZWZvcmUgYW55IG90aGVyIHByb3BlcnRpZXMgKHNldHRpbmcgLnZhbHVlXG4gICAgLy8gYmVmb3JlIC50eXBlIG1lYW5zIC52YWx1ZSBpcyBsb3N0IGluIElFMTEgYW5kIGJlbG93KVxuICAgIHR5cGU6IHVuZGVmaW5lZCxcbiAgICAvLyBNYWtlIHN1cmUgd2Ugc2V0IC5zdGVwIGJlZm9yZSAudmFsdWUgKHNldHRpbmcgLnZhbHVlIGJlZm9yZSAuc3RlcFxuICAgIC8vIG1lYW5zIC52YWx1ZSBpcyByb3VuZGVkIG9uIG1vdW50LCBiYXNlZCB1cG9uIHN0ZXAgcHJlY2lzaW9uKVxuICAgIHN0ZXA6IHVuZGVmaW5lZCxcbiAgICAvLyBNYWtlIHN1cmUgd2Ugc2V0IC5taW4gJiAubWF4IGJlZm9yZSAudmFsdWUgKHRvIGVuc3VyZSBwcm9wZXIgb3JkZXJcbiAgICAvLyBpbiBjb3JuZXIgY2FzZXMgc3VjaCBhcyBtaW4gb3IgbWF4IGRlcml2aW5nIGZyb20gdmFsdWUsIGUuZy4gSXNzdWUgIzcxNzApXG4gICAgbWluOiB1bmRlZmluZWQsXG4gICAgbWF4OiB1bmRlZmluZWRcbiAgfSwgcHJvcHMsIHtcbiAgICBkZWZhdWx0Q2hlY2tlZDogdW5kZWZpbmVkLFxuICAgIGRlZmF1bHRWYWx1ZTogdW5kZWZpbmVkLFxuICAgIHZhbHVlOiB2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiBub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlLFxuICAgIGNoZWNrZWQ6IGNoZWNrZWQgIT0gbnVsbCA/IGNoZWNrZWQgOiBub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbENoZWNrZWRcbiAgfSk7XG5cbiAgcmV0dXJuIGhvc3RQcm9wcztcbn1cblxuZnVuY3Rpb24gaW5pdFdyYXBwZXJTdGF0ZShlbGVtZW50LCBwcm9wcykge1xuICB7XG4gICAgUmVhY3RDb250cm9sbGVkVmFsdWVQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoJ2lucHV0JywgcHJvcHMsIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMyk7XG5cbiAgICBpZiAocHJvcHMuY2hlY2tlZCAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRDaGVja2VkICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICclcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCBjaGVja2VkIGFuZCBkZWZhdWx0Q2hlY2tlZCBwcm9wcy4gJyArICdJbnB1dCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgY2hlY2tlZCBwcm9wLCBvciB0aGUgZGVmYXVsdENoZWNrZWQgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJywgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lJDIoKSB8fCAnQSBjb21wb25lbnQnLCBwcm9wcy50eXBlKTtcbiAgICAgIGRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnJXMgY29udGFpbnMgYW4gaW5wdXQgb2YgdHlwZSAlcyB3aXRoIGJvdGggdmFsdWUgYW5kIGRlZmF1bHRWYWx1ZSBwcm9wcy4gJyArICdJbnB1dCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnLCBnZXRDdXJyZW50RmliZXJPd25lck5hbWUkMigpIHx8ICdBIGNvbXBvbmVudCcsIHByb3BzLnR5cGUpO1xuICAgICAgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB2YXIgZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlO1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIG5vZGUuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICBpbml0aWFsQ2hlY2tlZDogcHJvcHMuY2hlY2tlZCAhPSBudWxsID8gcHJvcHMuY2hlY2tlZCA6IHByb3BzLmRlZmF1bHRDaGVja2VkLFxuICAgIGluaXRpYWxWYWx1ZTogcHJvcHMudmFsdWUgIT0gbnVsbCA/IHByb3BzLnZhbHVlIDogZGVmYXVsdFZhbHVlLFxuICAgIGNvbnRyb2xsZWQ6IGlzQ29udHJvbGxlZChwcm9wcylcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ2hlY2tlZChlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHZhciBjaGVja2VkID0gcHJvcHMuY2hlY2tlZDtcbiAgaWYgKGNoZWNrZWQgIT0gbnVsbCkge1xuICAgIHNldFZhbHVlRm9yUHJvcGVydHkobm9kZSwgJ2NoZWNrZWQnLCBjaGVja2VkKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVXcmFwcGVyKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAge1xuICAgIHZhciBjb250cm9sbGVkID0gaXNDb250cm9sbGVkKHByb3BzKTtcblxuICAgIGlmICghbm9kZS5fd3JhcHBlclN0YXRlLmNvbnRyb2xsZWQgJiYgY29udHJvbGxlZCAmJiAhZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ0EgY29tcG9uZW50IGlzIGNoYW5naW5nIGFuIHVuY29udHJvbGxlZCBpbnB1dCBvZiB0eXBlICVzIHRvIGJlIGNvbnRyb2xsZWQuICcgKyAnSW5wdXQgZWxlbWVudHMgc2hvdWxkIG5vdCBzd2l0Y2ggZnJvbSB1bmNvbnRyb2xsZWQgdG8gY29udHJvbGxlZCAob3IgdmljZSB2ZXJzYSkuICcgKyAnRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgZm9yIHRoZSBsaWZldGltZSBvZiB0aGUgY29tcG9uZW50LiBNb3JlIGluZm86IGh0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJXMnLCBwcm9wcy50eXBlLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDMoKSk7XG4gICAgICBkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG5vZGUuX3dyYXBwZXJTdGF0ZS5jb250cm9sbGVkICYmICFjb250cm9sbGVkICYmICFkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnQSBjb21wb25lbnQgaXMgY2hhbmdpbmcgYSBjb250cm9sbGVkIGlucHV0IG9mIHR5cGUgJXMgdG8gYmUgdW5jb250cm9sbGVkLiAnICsgJ0lucHV0IGVsZW1lbnRzIHNob3VsZCBub3Qgc3dpdGNoIGZyb20gY29udHJvbGxlZCB0byB1bmNvbnRyb2xsZWQgKG9yIHZpY2UgdmVyc2EpLiAnICsgJ0RlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGZvciB0aGUgbGlmZXRpbWUgb2YgdGhlIGNvbXBvbmVudC4gTW9yZSBpbmZvOiBodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cyVzJywgcHJvcHMudHlwZSwgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQzKCkpO1xuICAgICAgZGlkV2FybkNvbnRyb2xsZWRUb1VuY29udHJvbGxlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlQ2hlY2tlZChlbGVtZW50LCBwcm9wcyk7XG5cbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgaWYgKHZhbHVlID09PSAwICYmIG5vZGUudmFsdWUgPT09ICcnKSB7XG4gICAgICBub2RlLnZhbHVlID0gJzAnO1xuICAgICAgLy8gTm90ZTogSUU5IHJlcG9ydHMgYSBudW1iZXIgaW5wdXRzIGFzICd0ZXh0Jywgc28gY2hlY2sgcHJvcHMgaW5zdGVhZC5cbiAgICB9IGVsc2UgaWYgKHByb3BzLnR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBTaW11bGF0ZSBgaW5wdXQudmFsdWVBc051bWJlcmAuIElFOSBkb2VzIG5vdCBzdXBwb3J0IGl0XG4gICAgICB2YXIgdmFsdWVBc051bWJlciA9IHBhcnNlRmxvYXQobm9kZS52YWx1ZSkgfHwgMDtcblxuICAgICAgaWYgKFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICB2YWx1ZSAhPSB2YWx1ZUFzTnVtYmVyIHx8XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgIHZhbHVlID09IHZhbHVlQXNOdW1iZXIgJiYgbm9kZS52YWx1ZSAhPSB2YWx1ZSkge1xuICAgICAgICAvLyBDYXN0IGB2YWx1ZWAgdG8gYSBzdHJpbmcgdG8gZW5zdXJlIHRoZSB2YWx1ZSBpcyBzZXQgY29ycmVjdGx5LiBXaGlsZVxuICAgICAgICAvLyBicm93c2VycyB0eXBpY2FsbHkgZG8gdGhpcyBhcyBuZWNlc3NhcnksIGpzZG9tIGRvZXNuJ3QuXG4gICAgICAgIG5vZGUudmFsdWUgPSAnJyArIHZhbHVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZS52YWx1ZSAhPT0gJycgKyB2YWx1ZSkge1xuICAgICAgLy8gQ2FzdCBgdmFsdWVgIHRvIGEgc3RyaW5nIHRvIGVuc3VyZSB0aGUgdmFsdWUgaXMgc2V0IGNvcnJlY3RseS4gV2hpbGVcbiAgICAgIC8vIGJyb3dzZXJzIHR5cGljYWxseSBkbyB0aGlzIGFzIG5lY2Vzc2FyeSwganNkb20gZG9lc24ndC5cbiAgICAgIG5vZGUudmFsdWUgPSAnJyArIHZhbHVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAocHJvcHMudmFsdWUgPT0gbnVsbCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xuICAgICAgLy8gSW4gQ2hyb21lLCBhc3NpZ25pbmcgZGVmYXVsdFZhbHVlIHRvIGNlcnRhaW4gaW5wdXQgdHlwZXMgdHJpZ2dlcnMgaW5wdXQgdmFsaWRhdGlvbi5cbiAgICAgIC8vIEZvciBudW1iZXIgaW5wdXRzLCB0aGUgZGlzcGxheSB2YWx1ZSBsb3NlcyB0cmFpbGluZyBkZWNpbWFsIHBvaW50cy4gRm9yIGVtYWlsIGlucHV0cyxcbiAgICAgIC8vIENocm9tZSByYWlzZXMgXCJUaGUgc3BlY2lmaWVkIHZhbHVlIDx4PiBpcyBub3QgYSB2YWxpZCBlbWFpbCBhZGRyZXNzXCIuXG4gICAgICAvL1xuICAgICAgLy8gSGVyZSB3ZSBjaGVjayB0byBzZWUgaWYgdGhlIGRlZmF1bHRWYWx1ZSBoYXMgYWN0dWFsbHkgY2hhbmdlZCwgYXZvaWRpbmcgdGhlc2UgcHJvYmxlbXNcbiAgICAgIC8vIHdoZW4gdGhlIHVzZXIgaXMgaW5wdXR0aW5nIHRleHRcbiAgICAgIC8vXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcyNTNcbiAgICAgIGlmIChub2RlLmRlZmF1bHRWYWx1ZSAhPT0gJycgKyBwcm9wcy5kZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgbm9kZS5kZWZhdWx0VmFsdWUgPSAnJyArIHByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb3BzLmNoZWNrZWQgPT0gbnVsbCAmJiBwcm9wcy5kZWZhdWx0Q2hlY2tlZCAhPSBudWxsKSB7XG4gICAgICBub2RlLmRlZmF1bHRDaGVja2VkID0gISFwcm9wcy5kZWZhdWx0Q2hlY2tlZDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9zdE1vdW50V3JhcHBlcihlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG5cbiAgLy8gRGV0YWNoIHZhbHVlIGZyb20gZGVmYXVsdFZhbHVlLiBXZSB3b24ndCBkbyBhbnl0aGluZyBpZiB3ZSdyZSB3b3JraW5nIG9uXG4gIC8vIHN1Ym1pdCBvciByZXNldCBpbnB1dHMgYXMgdGhvc2UgdmFsdWVzICYgZGVmYXVsdFZhbHVlcyBhcmUgbGlua2VkLiBUaGV5XG4gIC8vIGFyZSBub3QgcmVzZXRhYmxlIG5vZGVzIHNvIHRoaXMgb3BlcmF0aW9uIGRvZXNuJ3QgbWF0dGVyIGFuZCBhY3R1YWxseVxuICAvLyByZW1vdmVzIGJyb3dzZXItZGVmYXVsdCB2YWx1ZXMgKGVnIFwiU3VibWl0IFF1ZXJ5XCIpIHdoZW4gbm8gdmFsdWUgaXNcbiAgLy8gcHJvdmlkZWQuXG5cbiAgc3dpdGNoIChwcm9wcy50eXBlKSB7XG4gICAgY2FzZSAnc3VibWl0JzpcbiAgICBjYXNlICdyZXNldCc6XG4gICAgICBicmVhaztcbiAgICBjYXNlICdjb2xvcic6XG4gICAgY2FzZSAnZGF0ZSc6XG4gICAgY2FzZSAnZGF0ZXRpbWUnOlxuICAgIGNhc2UgJ2RhdGV0aW1lLWxvY2FsJzpcbiAgICBjYXNlICdtb250aCc6XG4gICAgY2FzZSAndGltZSc6XG4gICAgY2FzZSAnd2Vlayc6XG4gICAgICAvLyBUaGlzIGZpeGVzIHRoZSBuby1zaG93IGlzc3VlIG9uIGlPUyBTYWZhcmkgYW5kIEFuZHJvaWQgQ2hyb21lOlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MjMzXG4gICAgICBub2RlLnZhbHVlID0gJyc7XG4gICAgICBub2RlLnZhbHVlID0gbm9kZS5kZWZhdWx0VmFsdWU7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgbm9kZS52YWx1ZSA9IG5vZGUudmFsdWU7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIC8vIE5vcm1hbGx5LCB3ZSdkIGp1c3QgZG8gYG5vZGUuY2hlY2tlZCA9IG5vZGUuY2hlY2tlZGAgdXBvbiBpbml0aWFsIG1vdW50LCBsZXNzIHRoaXMgYnVnXG4gIC8vIHRoaXMgaXMgbmVlZGVkIHRvIHdvcmsgYXJvdW5kIGEgY2hyb21lIGJ1ZyB3aGVyZSBzZXR0aW5nIGRlZmF1bHRDaGVja2VkXG4gIC8vIHdpbGwgc29tZXRpbWVzIGluZmx1ZW5jZSB0aGUgdmFsdWUgb2YgY2hlY2tlZCAoZXZlbiBhZnRlciBkZXRhY2htZW50KS5cbiAgLy8gUmVmZXJlbmNlOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD02MDg0MTZcbiAgLy8gV2UgbmVlZCB0byB0ZW1wb3JhcmlseSB1bnNldCBuYW1lIHRvIGF2b2lkIGRpc3J1cHRpbmcgcmFkaW8gYnV0dG9uIGdyb3Vwcy5cbiAgdmFyIG5hbWUgPSBub2RlLm5hbWU7XG4gIGlmIChuYW1lICE9PSAnJykge1xuICAgIG5vZGUubmFtZSA9ICcnO1xuICB9XG4gIG5vZGUuZGVmYXVsdENoZWNrZWQgPSAhbm9kZS5kZWZhdWx0Q2hlY2tlZDtcbiAgbm9kZS5kZWZhdWx0Q2hlY2tlZCA9ICFub2RlLmRlZmF1bHRDaGVja2VkO1xuICBpZiAobmFtZSAhPT0gJycpIHtcbiAgICBub2RlLm5hbWUgPSBuYW1lO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMShlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHVwZGF0ZVdyYXBwZXIobm9kZSwgcHJvcHMpO1xuICB1cGRhdGVOYW1lZENvdXNpbnMobm9kZSwgcHJvcHMpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVOYW1lZENvdXNpbnMocm9vdE5vZGUsIHByb3BzKSB7XG4gIHZhciBuYW1lID0gcHJvcHMubmFtZTtcbiAgaWYgKHByb3BzLnR5cGUgPT09ICdyYWRpbycgJiYgbmFtZSAhPSBudWxsKSB7XG4gICAgdmFyIHF1ZXJ5Um9vdCA9IHJvb3ROb2RlO1xuXG4gICAgd2hpbGUgKHF1ZXJ5Um9vdC5wYXJlbnROb2RlKSB7XG4gICAgICBxdWVyeVJvb3QgPSBxdWVyeVJvb3QucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICAvLyBJZiBgcm9vdE5vZGUuZm9ybWAgd2FzIG5vbi1udWxsLCB0aGVuIHdlIGNvdWxkIHRyeSBgZm9ybS5lbGVtZW50c2AsXG4gICAgLy8gYnV0IHRoYXQgc29tZXRpbWVzIGJlaGF2ZXMgc3RyYW5nZWx5IGluIElFOC4gV2UgY291bGQgYWxzbyB0cnkgdXNpbmdcbiAgICAvLyBgZm9ybS5nZXRFbGVtZW50c0J5TmFtZWAsIGJ1dCB0aGF0IHdpbGwgb25seSByZXR1cm4gZGlyZWN0IGNoaWxkcmVuXG4gICAgLy8gYW5kIHdvbid0IGluY2x1ZGUgaW5wdXRzIHRoYXQgdXNlIHRoZSBIVE1MNSBgZm9ybT1gIGF0dHJpYnV0ZS4gU2luY2VcbiAgICAvLyB0aGUgaW5wdXQgbWlnaHQgbm90IGV2ZW4gYmUgaW4gYSBmb3JtLiBJdCBtaWdodCBub3QgZXZlbiBiZSBpbiB0aGVcbiAgICAvLyBkb2N1bWVudC4gTGV0J3MganVzdCB1c2UgdGhlIGxvY2FsIGBxdWVyeVNlbGVjdG9yQWxsYCB0byBlbnN1cmUgd2UgZG9uJ3RcbiAgICAvLyBtaXNzIGFueXRoaW5nLlxuICAgIHZhciBncm91cCA9IHF1ZXJ5Um9vdC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFtuYW1lPScgKyBKU09OLnN0cmluZ2lmeSgnJyArIG5hbWUpICsgJ11bdHlwZT1cInJhZGlvXCJdJyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgb3RoZXJOb2RlID0gZ3JvdXBbaV07XG4gICAgICBpZiAob3RoZXJOb2RlID09PSByb290Tm9kZSB8fCBvdGhlck5vZGUuZm9ybSAhPT0gcm9vdE5vZGUuZm9ybSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBpZiByYWRpbyBidXR0b25zIHJlbmRlcmVkIGJ5IGRpZmZlcmVudCBjb3BpZXMgb2YgUmVhY3RcbiAgICAgIC8vIGFuZCB0aGUgc2FtZSBuYW1lIGFyZSByZW5kZXJlZCBpbnRvIHRoZSBzYW1lIGZvcm0gKHNhbWUgYXMgIzE5MzkpLlxuICAgICAgLy8gVGhhdCdzIHByb2JhYmx5IG9rYXk7IHdlIGRvbid0IHN1cHBvcnQgaXQganVzdCBhcyB3ZSBkb24ndCBzdXBwb3J0XG4gICAgICAvLyBtaXhpbmcgUmVhY3QgcmFkaW8gYnV0dG9ucyB3aXRoIG5vbi1SZWFjdCBvbmVzLlxuICAgICAgdmFyIG90aGVyUHJvcHMgPSBnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlJDEob3RoZXJOb2RlKTtcbiAgICAgICFvdGhlclByb3BzID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RET01JbnB1dDogTWl4aW5nIFJlYWN0IGFuZCBub24tUmVhY3QgcmFkaW8gaW5wdXRzIHdpdGggdGhlIHNhbWUgYG5hbWVgIGlzIG5vdCBzdXBwb3J0ZWQuJykgOiB2b2lkIDA7XG5cbiAgICAgIC8vIFdlIG5lZWQgdXBkYXRlIHRoZSB0cmFja2VkIHZhbHVlIG9uIHRoZSBuYW1lZCBjb3VzaW4gc2luY2UgdGhlIHZhbHVlXG4gICAgICAvLyB3YXMgY2hhbmdlZCBidXQgdGhlIGlucHV0IHNhdyBubyBldmVudCBvciB2YWx1ZSBzZXRcbiAgICAgIHVwZGF0ZVZhbHVlSWZDaGFuZ2VkKG90aGVyTm9kZSk7XG5cbiAgICAgIC8vIElmIHRoaXMgaXMgYSBjb250cm9sbGVkIHJhZGlvIGJ1dHRvbiBncm91cCwgZm9yY2luZyB0aGUgaW5wdXQgdGhhdFxuICAgICAgLy8gd2FzIHByZXZpb3VzbHkgY2hlY2tlZCB0byB1cGRhdGUgd2lsbCBjYXVzZSBpdCB0byBiZSBjb21lIHJlLWNoZWNrZWRcbiAgICAgIC8vIGFzIGFwcHJvcHJpYXRlLlxuICAgICAgdXBkYXRlV3JhcHBlcihvdGhlck5vZGUsIG90aGVyUHJvcHMpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmbGF0dGVuQ2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgdmFyIGNvbnRlbnQgPSAnJztcblxuICAvLyBGbGF0dGVuIGNoaWxkcmVuIGFuZCB3YXJuIGlmIHRoZXkgYXJlbid0IHN0cmluZ3Mgb3IgbnVtYmVycztcbiAgLy8gaW52YWxpZCB0eXBlcyBhcmUgaWdub3JlZC5cbiAgLy8gV2UgY2FuIHNpbGVudGx5IHNraXAgdGhlbSBiZWNhdXNlIGludmFsaWQgRE9NIG5lc3Rpbmcgd2FybmluZ1xuICAvLyBjYXRjaGVzIHRoZXNlIGNhc2VzIGluIEZpYmVyLlxuICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgY2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICBjb250ZW50ICs9IGNoaWxkO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGNvbnRlbnQ7XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyBhbiA8b3B0aW9uPiBob3N0IGNvbXBvbmVudCB0aGF0IHdhcm5zIHdoZW4gYHNlbGVjdGVkYCBpcyBzZXQuXG4gKi9cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wcyhlbGVtZW50LCBwcm9wcykge1xuICAvLyBUT0RPICh5dW5nc3RlcnMpOiBSZW1vdmUgc3VwcG9ydCBmb3IgYHNlbGVjdGVkYCBpbiA8b3B0aW9uPi5cbiAge1xuICAgIHdhcm5pbmcocHJvcHMuc2VsZWN0ZWQgPT0gbnVsbCwgJ1VzZSB0aGUgYGRlZmF1bHRWYWx1ZWAgb3IgYHZhbHVlYCBwcm9wcyBvbiA8c2VsZWN0PiBpbnN0ZWFkIG9mICcgKyAnc2V0dGluZyBgc2VsZWN0ZWRgIG9uIDxvcHRpb24+LicpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBvc3RNb3VudFdyYXBwZXIkMShlbGVtZW50LCBwcm9wcykge1xuICAvLyB2YWx1ZT1cIlwiIHNob3VsZCBtYWtlIGEgdmFsdWUgYXR0cmlidXRlICgjNjIxOSlcbiAgaWYgKHByb3BzLnZhbHVlICE9IG51bGwpIHtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndmFsdWUnLCBwcm9wcy52YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0SG9zdFByb3BzJDEoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIGhvc3RQcm9wcyA9IF9hc3NpZ24oeyBjaGlsZHJlbjogdW5kZWZpbmVkIH0sIHByb3BzKTtcbiAgdmFyIGNvbnRlbnQgPSBmbGF0dGVuQ2hpbGRyZW4ocHJvcHMuY2hpbGRyZW4pO1xuXG4gIGlmIChjb250ZW50KSB7XG4gICAgaG9zdFByb3BzLmNoaWxkcmVuID0gY29udGVudDtcbiAgfVxuXG4gIHJldHVybiBob3N0UHJvcHM7XG59XG5cbi8vIFRPRE86IGRpcmVjdCBpbXBvcnRzIGxpa2Ugc29tZS1wYWNrYWdlL3NyYy8qIGFyZSBiYWQuIEZpeCBtZS5cbnZhciBnZXRDdXJyZW50RmliZXJPd25lck5hbWUkMyA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lO1xudmFyIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kNCA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bTtcblxuXG57XG4gIHZhciBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUkMSA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHZhciBvd25lck5hbWUgPSBnZXRDdXJyZW50RmliZXJPd25lck5hbWUkMygpO1xuICBpZiAob3duZXJOYW1lKSB7XG4gICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG93bmVyTmFtZSArICdgLic7XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgdmFsdWVQcm9wTmFtZXMgPSBbJ3ZhbHVlJywgJ2RlZmF1bHRWYWx1ZSddO1xuXG4vKipcbiAqIFZhbGlkYXRpb24gZnVuY3Rpb24gZm9yIGB2YWx1ZWAgYW5kIGBkZWZhdWx0VmFsdWVgLlxuICovXG5mdW5jdGlvbiBjaGVja1NlbGVjdFByb3BUeXBlcyhwcm9wcykge1xuICBSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygnc2VsZWN0JywgcHJvcHMsIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kNCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZVByb3BOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcm9wTmFtZSA9IHZhbHVlUHJvcE5hbWVzW2ldO1xuICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShwcm9wc1twcm9wTmFtZV0pO1xuICAgIGlmIChwcm9wcy5tdWx0aXBsZSAmJiAhaXNBcnJheSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1RoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhbiBhcnJheSBpZiAnICsgJ2BtdWx0aXBsZWAgaXMgdHJ1ZS4lcycsIHByb3BOYW1lLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSk7XG4gICAgfSBlbHNlIGlmICghcHJvcHMubXVsdGlwbGUgJiYgaXNBcnJheSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1RoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhIHNjYWxhciAnICsgJ3ZhbHVlIGlmIGBtdWx0aXBsZWAgaXMgZmFsc2UuJXMnLCBwcm9wTmFtZSwgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVPcHRpb25zKG5vZGUsIG11bHRpcGxlLCBwcm9wVmFsdWUsIHNldERlZmF1bHRTZWxlY3RlZCkge1xuICB2YXIgb3B0aW9ucyA9IG5vZGUub3B0aW9ucztcblxuICBpZiAobXVsdGlwbGUpIHtcbiAgICB2YXIgc2VsZWN0ZWRWYWx1ZXMgPSBwcm9wVmFsdWU7XG4gICAgdmFyIHNlbGVjdGVkVmFsdWUgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBQcmVmaXggdG8gYXZvaWQgY2hhb3Mgd2l0aCBzcGVjaWFsIGtleXMuXG4gICAgICBzZWxlY3RlZFZhbHVlWyckJyArIHNlbGVjdGVkVmFsdWVzW2ldXSA9IHRydWU7XG4gICAgfVxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBvcHRpb25zLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIHNlbGVjdGVkID0gc2VsZWN0ZWRWYWx1ZS5oYXNPd25Qcm9wZXJ0eSgnJCcgKyBvcHRpb25zW19pXS52YWx1ZSk7XG4gICAgICBpZiAob3B0aW9uc1tfaV0uc2VsZWN0ZWQgIT09IHNlbGVjdGVkKSB7XG4gICAgICAgIG9wdGlvbnNbX2ldLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZWN0ZWQgJiYgc2V0RGVmYXVsdFNlbGVjdGVkKSB7XG4gICAgICAgIG9wdGlvbnNbX2ldLmRlZmF1bHRTZWxlY3RlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIERvIG5vdCBzZXQgYHNlbGVjdC52YWx1ZWAgYXMgZXhhY3QgYmVoYXZpb3IgaXNuJ3QgY29uc2lzdGVudCBhY3Jvc3MgYWxsXG4gICAgLy8gYnJvd3NlcnMgZm9yIGFsbCBjYXNlcy5cbiAgICB2YXIgX3NlbGVjdGVkVmFsdWUgPSAnJyArIHByb3BWYWx1ZTtcbiAgICB2YXIgZGVmYXVsdFNlbGVjdGVkID0gbnVsbDtcbiAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBvcHRpb25zLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgIGlmIChvcHRpb25zW19pMl0udmFsdWUgPT09IF9zZWxlY3RlZFZhbHVlKSB7XG4gICAgICAgIG9wdGlvbnNbX2kyXS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIGlmIChzZXREZWZhdWx0U2VsZWN0ZWQpIHtcbiAgICAgICAgICBvcHRpb25zW19pMl0uZGVmYXVsdFNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZGVmYXVsdFNlbGVjdGVkID09PSBudWxsICYmICFvcHRpb25zW19pMl0uZGlzYWJsZWQpIHtcbiAgICAgICAgZGVmYXVsdFNlbGVjdGVkID0gb3B0aW9uc1tfaTJdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGVmYXVsdFNlbGVjdGVkICE9PSBudWxsKSB7XG4gICAgICBkZWZhdWx0U2VsZWN0ZWQuc2VsZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYSA8c2VsZWN0PiBob3N0IGNvbXBvbmVudCB0aGF0IGFsbG93cyBvcHRpb25hbGx5IHNldHRpbmcgdGhlXG4gKiBwcm9wcyBgdmFsdWVgIGFuZCBgZGVmYXVsdFZhbHVlYC4gSWYgYG11bHRpcGxlYCBpcyBmYWxzZSwgdGhlIHByb3AgbXVzdCBiZSBhXG4gKiBzdHJpbmdhYmxlLiBJZiBgbXVsdGlwbGVgIGlzIHRydWUsIHRoZSBwcm9wIG11c3QgYmUgYW4gYXJyYXkgb2Ygc3RyaW5nYWJsZXMuXG4gKlxuICogSWYgYHZhbHVlYCBpcyBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zIHRoYXQgY2hhbmdlIHRoZVxuICogc2VsZWN0ZWQgb3B0aW9uIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSByZW5kZXJlZCBvcHRpb25zLlxuICpcbiAqIElmIGl0IGlzIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIG9wdGlvbnMgd2lsbCBub3RcbiAqIHVwZGF0ZSBpbiByZXNwb25zZSB0byB1c2VyIGFjdGlvbnMuIEluc3RlYWQsIHRoZSBgdmFsdWVgIHByb3AgbXVzdCBjaGFuZ2UgaW5cbiAqIG9yZGVyIGZvciB0aGUgcmVuZGVyZWQgb3B0aW9ucyB0byB1cGRhdGUuXG4gKlxuICogSWYgYGRlZmF1bHRWYWx1ZWAgaXMgcHJvdmlkZWQsIGFueSBvcHRpb25zIHdpdGggdGhlIHN1cHBsaWVkIHZhbHVlcyB3aWxsIGJlXG4gKiBzZWxlY3RlZC5cbiAqL1xuXG5mdW5jdGlvbiBnZXRIb3N0UHJvcHMkMihlbGVtZW50LCBwcm9wcykge1xuICByZXR1cm4gX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICB2YWx1ZTogdW5kZWZpbmVkXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpbml0V3JhcHBlclN0YXRlJDEoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB7XG4gICAgY2hlY2tTZWxlY3RQcm9wVHlwZXMocHJvcHMpO1xuICB9XG5cbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gIG5vZGUuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICBpbml0aWFsVmFsdWU6IHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IHByb3BzLmRlZmF1bHRWYWx1ZSxcbiAgICB3YXNNdWx0aXBsZTogISFwcm9wcy5tdWx0aXBsZVxuICB9O1xuXG4gIHtcbiAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlJDEpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdTZWxlY3QgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIHNlbGVjdCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycpO1xuICAgICAgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlJDEgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwb3N0TW91bnRXcmFwcGVyJDIoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICBub2RlLm11bHRpcGxlID0gISFwcm9wcy5tdWx0aXBsZTtcbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCB2YWx1ZSwgZmFsc2UpO1xuICB9IGVsc2UgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCBwcm9wcy5kZWZhdWx0VmFsdWUsIHRydWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBvc3RVcGRhdGVXcmFwcGVyKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgLy8gQWZ0ZXIgdGhlIGluaXRpYWwgbW91bnQsIHdlIGNvbnRyb2wgc2VsZWN0ZWQtbmVzcyBtYW51YWxseSBzbyBkb24ndCBwYXNzXG4gIC8vIHRoaXMgdmFsdWUgZG93blxuICBub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlID0gdW5kZWZpbmVkO1xuXG4gIHZhciB3YXNNdWx0aXBsZSA9IG5vZGUuX3dyYXBwZXJTdGF0ZS53YXNNdWx0aXBsZTtcbiAgbm9kZS5fd3JhcHBlclN0YXRlLndhc011bHRpcGxlID0gISFwcm9wcy5tdWx0aXBsZTtcblxuICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHZhbHVlLCBmYWxzZSk7XG4gIH0gZWxzZSBpZiAod2FzTXVsdGlwbGUgIT09ICEhcHJvcHMubXVsdGlwbGUpIHtcbiAgICAvLyBGb3Igc2ltcGxpY2l0eSwgcmVhcHBseSBgZGVmYXVsdFZhbHVlYCBpZiBgbXVsdGlwbGVgIGlzIHRvZ2dsZWQuXG4gICAgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHByb3BzLmRlZmF1bHRWYWx1ZSwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJldmVydCB0aGUgc2VsZWN0IGJhY2sgdG8gaXRzIGRlZmF1bHQgdW5zZWxlY3RlZCBzdGF0ZS5cbiAgICAgIHVwZGF0ZU9wdGlvbnMobm9kZSwgISFwcm9wcy5tdWx0aXBsZSwgcHJvcHMubXVsdGlwbGUgPyBbXSA6ICcnLCBmYWxzZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMihlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHZhciB2YWx1ZSA9IHByb3BzLnZhbHVlO1xuXG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCB2YWx1ZSwgZmFsc2UpO1xuICB9XG59XG5cbi8vIFRPRE86IGRpcmVjdCBpbXBvcnRzIGxpa2Ugc29tZS1wYWNrYWdlL3NyYy8qIGFyZSBiYWQuIEZpeCBtZS5cbnZhciBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDUgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW07XG5cbnZhciBkaWRXYXJuVmFsRGVmYXVsdFZhbCA9IGZhbHNlO1xuXG4vKipcbiAqIEltcGxlbWVudHMgYSA8dGV4dGFyZWE+IGhvc3QgY29tcG9uZW50IHRoYXQgYWxsb3dzIHNldHRpbmcgYHZhbHVlYCwgYW5kXG4gKiBgZGVmYXVsdFZhbHVlYC4gVGhpcyBkaWZmZXJzIGZyb20gdGhlIHRyYWRpdGlvbmFsIERPTSBBUEkgYmVjYXVzZSB2YWx1ZSBpc1xuICogdXN1YWxseSBzZXQgYXMgUENEQVRBIGNoaWxkcmVuLlxuICpcbiAqIElmIGB2YWx1ZWAgaXMgbm90IHN1cHBsaWVkIChvciBudWxsL3VuZGVmaW5lZCksIHVzZXIgYWN0aW9ucyB0aGF0IGFmZmVjdCB0aGVcbiAqIHZhbHVlIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LlxuICpcbiAqIElmIGB2YWx1ZWAgaXMgc3VwcGxpZWQgKGFuZCBub3QgbnVsbC91bmRlZmluZWQpLCB0aGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsXG4gKiBub3QgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LiBJbnN0ZWFkLCB0aGUgYHZhbHVlYCBwcm9wIG11c3QgY2hhbmdlIGluXG4gKiBvcmRlciBmb3IgdGhlIHJlbmRlcmVkIGVsZW1lbnQgdG8gYmUgdXBkYXRlZC5cbiAqXG4gKiBUaGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIGJlIGluaXRpYWxpemVkIHdpdGggYW4gZW1wdHkgdmFsdWUsIHRoZSBwcm9wXG4gKiBgZGVmYXVsdFZhbHVlYCBpZiBzcGVjaWZpZWQsIG9yIHRoZSBjaGlsZHJlbiBjb250ZW50IChkZXByZWNhdGVkKS5cbiAqL1xuXG5mdW5jdGlvbiBnZXRIb3N0UHJvcHMkMyhlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gICEocHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIGRvZXMgbm90IG1ha2Ugc2Vuc2Ugb24gPHRleHRhcmVhPi4nKSA6IHZvaWQgMDtcblxuICAvLyBBbHdheXMgc2V0IGNoaWxkcmVuIHRvIHRoZSBzYW1lIHRoaW5nLiBJbiBJRTksIHRoZSBzZWxlY3Rpb24gcmFuZ2Ugd2lsbFxuICAvLyBnZXQgcmVzZXQgaWYgYHRleHRDb250ZW50YCBpcyBtdXRhdGVkLiAgV2UgY291bGQgYWRkIGEgY2hlY2sgaW4gc2V0VGV4dENvbnRlbnRcbiAgLy8gdG8gb25seSBzZXQgdGhlIHZhbHVlIGlmL3doZW4gdGhlIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgbm9kZSB2YWx1ZSAod2hpY2ggd291bGRcbiAgLy8gY29tcGxldGVseSBzb2x2ZSB0aGlzIElFOSBidWcpLCBidXQgU2ViYXN0aWFuK1NvcGhpZSBzZWVtZWQgdG8gbGlrZSB0aGlzXG4gIC8vIHNvbHV0aW9uLiBUaGUgdmFsdWUgY2FuIGJlIGEgYm9vbGVhbiBvciBvYmplY3Qgc28gdGhhdCdzIHdoeSBpdCdzIGZvcmNlZFxuICAvLyB0byBiZSBhIHN0cmluZy5cbiAgdmFyIGhvc3RQcm9wcyA9IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICBkZWZhdWx0VmFsdWU6IHVuZGVmaW5lZCxcbiAgICBjaGlsZHJlbjogJycgKyBub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlXG4gIH0pO1xuXG4gIHJldHVybiBob3N0UHJvcHM7XG59XG5cbmZ1bmN0aW9uIGluaXRXcmFwcGVyU3RhdGUkMihlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHtcbiAgICBSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygndGV4dGFyZWEnLCBwcm9wcywgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQ1KTtcbiAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbERlZmF1bHRWYWwpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdUZXh0YXJlYSBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgdGV4dGFyZWEgJyArICdhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJyk7XG4gICAgICBkaWRXYXJuVmFsRGVmYXVsdFZhbCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGluaXRpYWxWYWx1ZSA9IHByb3BzLnZhbHVlO1xuXG4gIC8vIE9ubHkgYm90aGVyIGZldGNoaW5nIGRlZmF1bHQgdmFsdWUgaWYgd2UncmUgZ29pbmcgdG8gdXNlIGl0XG4gIGlmIChpbml0aWFsVmFsdWUgPT0gbnVsbCkge1xuICAgIHZhciBkZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gICAgLy8gVE9ETyAoeXVuZ3N0ZXJzKTogUmVtb3ZlIHN1cHBvcnQgZm9yIGNoaWxkcmVuIGNvbnRlbnQgaW4gPHRleHRhcmVhPi5cbiAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcbiAgICBpZiAoY2hpbGRyZW4gIT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnVXNlIHRoZSBgZGVmYXVsdFZhbHVlYCBvciBgdmFsdWVgIHByb3BzIGluc3RlYWQgb2Ygc2V0dGluZyAnICsgJ2NoaWxkcmVuIG9uIDx0ZXh0YXJlYT4uJyk7XG4gICAgICB9XG4gICAgICAhKGRlZmF1bHRWYWx1ZSA9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ0lmIHlvdSBzdXBwbHkgYGRlZmF1bHRWYWx1ZWAgb24gYSA8dGV4dGFyZWE+LCBkbyBub3QgcGFzcyBjaGlsZHJlbi4nKSA6IHZvaWQgMDtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAhKGNoaWxkcmVuLmxlbmd0aCA8PSAxKSA/IGludmFyaWFudChmYWxzZSwgJzx0ZXh0YXJlYT4gY2FuIG9ubHkgaGF2ZSBhdCBtb3N0IG9uZSBjaGlsZC4nKSA6IHZvaWQgMDtcbiAgICAgICAgY2hpbGRyZW4gPSBjaGlsZHJlblswXTtcbiAgICAgIH1cblxuICAgICAgZGVmYXVsdFZhbHVlID0gJycgKyBjaGlsZHJlbjtcbiAgICB9XG4gICAgaWYgKGRlZmF1bHRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICBkZWZhdWx0VmFsdWUgPSAnJztcbiAgICB9XG4gICAgaW5pdGlhbFZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICB9XG5cbiAgbm9kZS5fd3JhcHBlclN0YXRlID0ge1xuICAgIGluaXRpYWxWYWx1ZTogJycgKyBpbml0aWFsVmFsdWVcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlV3JhcHBlciQxKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgLy8gQ2FzdCBgdmFsdWVgIHRvIGEgc3RyaW5nIHRvIGVuc3VyZSB0aGUgdmFsdWUgaXMgc2V0IGNvcnJlY3RseS4gV2hpbGVcbiAgICAvLyBicm93c2VycyB0eXBpY2FsbHkgZG8gdGhpcyBhcyBuZWNlc3NhcnksIGpzZG9tIGRvZXNuJ3QuXG4gICAgdmFyIG5ld1ZhbHVlID0gJycgKyB2YWx1ZTtcblxuICAgIC8vIFRvIGF2b2lkIHNpZGUgZWZmZWN0cyAoc3VjaCBhcyBsb3NpbmcgdGV4dCBzZWxlY3Rpb24pLCBvbmx5IHNldCB2YWx1ZSBpZiBjaGFuZ2VkXG4gICAgaWYgKG5ld1ZhbHVlICE9PSBub2RlLnZhbHVlKSB7XG4gICAgICBub2RlLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgfVxuICAgIGlmIChwcm9wcy5kZWZhdWx0VmFsdWUgPT0gbnVsbCkge1xuICAgICAgbm9kZS5kZWZhdWx0VmFsdWUgPSBuZXdWYWx1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgbm9kZS5kZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9zdE1vdW50V3JhcHBlciQzKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgLy8gVGhpcyBpcyBpbiBwb3N0TW91bnQgYmVjYXVzZSB3ZSBuZWVkIGFjY2VzcyB0byB0aGUgRE9NIG5vZGUsIHdoaWNoIGlzIG5vdFxuICAvLyBhdmFpbGFibGUgdW50aWwgYWZ0ZXIgdGhlIGNvbXBvbmVudCBoYXMgbW91bnRlZC5cbiAgdmFyIHRleHRDb250ZW50ID0gbm9kZS50ZXh0Q29udGVudDtcblxuICAvLyBPbmx5IHNldCBub2RlLnZhbHVlIGlmIHRleHRDb250ZW50IGlzIGVxdWFsIHRvIHRoZSBleHBlY3RlZFxuICAvLyBpbml0aWFsIHZhbHVlLiBJbiBJRTEwL0lFMTEgdGhlcmUgaXMgYSBidWcgd2hlcmUgdGhlIHBsYWNlaG9sZGVyIGF0dHJpYnV0ZVxuICAvLyB3aWxsIHBvcHVsYXRlIHRleHRDb250ZW50IGFzIHdlbGwuXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vaXNzdWVzLzEwMTUyNS9cbiAgaWYgKHRleHRDb250ZW50ID09PSBub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlKSB7XG4gICAgbm9kZS52YWx1ZSA9IHRleHRDb250ZW50O1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMyhlbGVtZW50LCBwcm9wcykge1xuICAvLyBET00gY29tcG9uZW50IGlzIHN0aWxsIG1vdW50ZWQ7IHVwZGF0ZVxuICB1cGRhdGVXcmFwcGVyJDEoZWxlbWVudCwgcHJvcHMpO1xufVxuXG52YXIgSFRNTF9OQU1FU1BBQ0UkMSA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJztcbnZhciBNQVRIX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJztcbnZhciBTVkdfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcblxudmFyIE5hbWVzcGFjZXMgPSB7XG4gIGh0bWw6IEhUTUxfTkFNRVNQQUNFJDEsXG4gIG1hdGhtbDogTUFUSF9OQU1FU1BBQ0UsXG4gIHN2ZzogU1ZHX05BTUVTUEFDRVxufTtcblxuLy8gQXNzdW1lcyB0aGVyZSBpcyBubyBwYXJlbnQgbmFtZXNwYWNlLlxuZnVuY3Rpb24gZ2V0SW50cmluc2ljTmFtZXNwYWNlKHR5cGUpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnc3ZnJzpcbiAgICAgIHJldHVybiBTVkdfTkFNRVNQQUNFO1xuICAgIGNhc2UgJ21hdGgnOlxuICAgICAgcmV0dXJuIE1BVEhfTkFNRVNQQUNFO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gSFRNTF9OQU1FU1BBQ0UkMTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRDaGlsZE5hbWVzcGFjZShwYXJlbnROYW1lc3BhY2UsIHR5cGUpIHtcbiAgaWYgKHBhcmVudE5hbWVzcGFjZSA9PSBudWxsIHx8IHBhcmVudE5hbWVzcGFjZSA9PT0gSFRNTF9OQU1FU1BBQ0UkMSkge1xuICAgIC8vIE5vIChvciBkZWZhdWx0KSBwYXJlbnQgbmFtZXNwYWNlOiBwb3RlbnRpYWwgZW50cnkgcG9pbnQuXG4gICAgcmV0dXJuIGdldEludHJpbnNpY05hbWVzcGFjZSh0eXBlKTtcbiAgfVxuICBpZiAocGFyZW50TmFtZXNwYWNlID09PSBTVkdfTkFNRVNQQUNFICYmIHR5cGUgPT09ICdmb3JlaWduT2JqZWN0Jykge1xuICAgIC8vIFdlJ3JlIGxlYXZpbmcgU1ZHLlxuICAgIHJldHVybiBIVE1MX05BTUVTUEFDRSQxO1xuICB9XG4gIC8vIEJ5IGRlZmF1bHQsIHBhc3MgbmFtZXNwYWNlIGJlbG93LlxuICByZXR1cm4gcGFyZW50TmFtZXNwYWNlO1xufVxuXG4vKiBnbG9iYWxzIE1TQXBwICovXG5cbi8qKlxuICogQ3JlYXRlIGEgZnVuY3Rpb24gd2hpY2ggaGFzICd1bnNhZmUnIHByaXZpbGVnZXMgKHJlcXVpcmVkIGJ5IHdpbmRvd3M4IGFwcHMpXG4gKi9cbnZhciBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgaWYgKHR5cGVvZiBNU0FwcCAhPT0gJ3VuZGVmaW5lZCcgJiYgTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgIE1TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmdW5jO1xuICB9XG59O1xuXG4vLyBTVkcgdGVtcCBjb250YWluZXIgZm9yIElFIGxhY2tpbmcgaW5uZXJIVE1MXG52YXIgcmV1c2FibGVTVkdDb250YWluZXIgPSB2b2lkIDA7XG5cbi8qKlxuICogU2V0IHRoZSBpbm5lckhUTUwgcHJvcGVydHkgb2YgYSBub2RlXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuICogQGludGVybmFsXG4gKi9cbnZhciBzZXRJbm5lckhUTUwgPSBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uIChub2RlLCBodG1sKSB7XG4gIC8vIElFIGRvZXMgbm90IGhhdmUgaW5uZXJIVE1MIGZvciBTVkcgbm9kZXMsIHNvIGluc3RlYWQgd2UgaW5qZWN0IHRoZVxuICAvLyBuZXcgbWFya3VwIGluIGEgdGVtcCBub2RlIGFuZCB0aGVuIG1vdmUgdGhlIGNoaWxkIG5vZGVzIGFjcm9zcyBpbnRvXG4gIC8vIHRoZSB0YXJnZXQgbm9kZVxuXG4gIGlmIChub2RlLm5hbWVzcGFjZVVSSSA9PT0gTmFtZXNwYWNlcy5zdmcgJiYgISgnaW5uZXJIVE1MJyBpbiBub2RlKSkge1xuICAgIHJldXNhYmxlU1ZHQ29udGFpbmVyID0gcmV1c2FibGVTVkdDb250YWluZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgcmV1c2FibGVTVkdDb250YWluZXIuaW5uZXJIVE1MID0gJzxzdmc+JyArIGh0bWwgKyAnPC9zdmc+JztcbiAgICB2YXIgc3ZnTm9kZSA9IHJldXNhYmxlU1ZHQ29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKG5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgbm9kZS5yZW1vdmVDaGlsZChub2RlLmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgICB3aGlsZSAoc3ZnTm9kZS5maXJzdENoaWxkKSB7XG4gICAgICBub2RlLmFwcGVuZENoaWxkKHN2Z05vZGUuZmlyc3RDaGlsZCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG5vZGUuaW5uZXJIVE1MID0gaHRtbDtcbiAgfVxufSk7XG5cbi8qKlxuICogU2V0IHRoZSB0ZXh0Q29udGVudCBwcm9wZXJ0eSBvZiBhIG5vZGUsIGVuc3VyaW5nIHRoYXQgd2hpdGVzcGFjZSBpcyBwcmVzZXJ2ZWRcbiAqIGV2ZW4gaW4gSUU4LiBpbm5lclRleHQgaXMgYSBwb29yIHN1YnN0aXR1dGUgZm9yIHRleHRDb250ZW50IGFuZCwgYW1vbmcgbWFueVxuICogaXNzdWVzLCBpbnNlcnRzIDxicj4gaW5zdGVhZCBvZiB0aGUgbGl0ZXJhbCBuZXdsaW5lIGNoYXJzLiBpbm5lckhUTUwgYmVoYXZlc1xuICogYXMgaXQgc2hvdWxkLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgc2V0VGV4dENvbnRlbnQgPSBmdW5jdGlvbiAobm9kZSwgdGV4dCkge1xuICBpZiAodGV4dCkge1xuICAgIHZhciBmaXJzdENoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuXG4gICAgaWYgKGZpcnN0Q2hpbGQgJiYgZmlyc3RDaGlsZCA9PT0gbm9kZS5sYXN0Q2hpbGQgJiYgZmlyc3RDaGlsZC5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFKSB7XG4gICAgICBmaXJzdENoaWxkLm5vZGVWYWx1ZSA9IHRleHQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xufTtcblxuLyoqXG4gKiBDU1MgcHJvcGVydGllcyB3aGljaCBhY2NlcHQgbnVtYmVycyBidXQgYXJlIG5vdCBpbiB1bml0cyBvZiBcInB4XCIuXG4gKi9cbnZhciBpc1VuaXRsZXNzTnVtYmVyID0ge1xuICBhbmltYXRpb25JdGVyYXRpb25Db3VudDogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VPdXRzZXQ6IHRydWUsXG4gIGJvcmRlckltYWdlU2xpY2U6IHRydWUsXG4gIGJvcmRlckltYWdlV2lkdGg6IHRydWUsXG4gIGJveEZsZXg6IHRydWUsXG4gIGJveEZsZXhHcm91cDogdHJ1ZSxcbiAgYm94T3JkaW5hbEdyb3VwOiB0cnVlLFxuICBjb2x1bW5Db3VudDogdHJ1ZSxcbiAgY29sdW1uczogdHJ1ZSxcbiAgZmxleDogdHJ1ZSxcbiAgZmxleEdyb3c6IHRydWUsXG4gIGZsZXhQb3NpdGl2ZTogdHJ1ZSxcbiAgZmxleFNocmluazogdHJ1ZSxcbiAgZmxleE5lZ2F0aXZlOiB0cnVlLFxuICBmbGV4T3JkZXI6IHRydWUsXG4gIGdyaWRSb3c6IHRydWUsXG4gIGdyaWRSb3dFbmQ6IHRydWUsXG4gIGdyaWRSb3dTcGFuOiB0cnVlLFxuICBncmlkUm93U3RhcnQ6IHRydWUsXG4gIGdyaWRDb2x1bW46IHRydWUsXG4gIGdyaWRDb2x1bW5FbmQ6IHRydWUsXG4gIGdyaWRDb2x1bW5TcGFuOiB0cnVlLFxuICBncmlkQ29sdW1uU3RhcnQ6IHRydWUsXG4gIGZvbnRXZWlnaHQ6IHRydWUsXG4gIGxpbmVDbGFtcDogdHJ1ZSxcbiAgbGluZUhlaWdodDogdHJ1ZSxcbiAgb3BhY2l0eTogdHJ1ZSxcbiAgb3JkZXI6IHRydWUsXG4gIG9ycGhhbnM6IHRydWUsXG4gIHRhYlNpemU6IHRydWUsXG4gIHdpZG93czogdHJ1ZSxcbiAgekluZGV4OiB0cnVlLFxuICB6b29tOiB0cnVlLFxuXG4gIC8vIFNWRy1yZWxhdGVkIHByb3BlcnRpZXNcbiAgZmlsbE9wYWNpdHk6IHRydWUsXG4gIGZsb29kT3BhY2l0eTogdHJ1ZSxcbiAgc3RvcE9wYWNpdHk6IHRydWUsXG4gIHN0cm9rZURhc2hhcnJheTogdHJ1ZSxcbiAgc3Ryb2tlRGFzaG9mZnNldDogdHJ1ZSxcbiAgc3Ryb2tlTWl0ZXJsaW1pdDogdHJ1ZSxcbiAgc3Ryb2tlT3BhY2l0eTogdHJ1ZSxcbiAgc3Ryb2tlV2lkdGg6IHRydWVcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeCB2ZW5kb3Itc3BlY2lmaWMgcHJlZml4LCBlZzogV2Via2l0XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHN0eWxlIG5hbWUsIGVnOiB0cmFuc2l0aW9uRHVyYXRpb25cbiAqIEByZXR1cm4ge3N0cmluZ30gc3R5bGUgbmFtZSBwcmVmaXhlZCB3aXRoIGBwcmVmaXhgLCBwcm9wZXJseSBjYW1lbENhc2VkLCBlZzpcbiAqIFdlYmtpdFRyYW5zaXRpb25EdXJhdGlvblxuICovXG5mdW5jdGlvbiBwcmVmaXhLZXkocHJlZml4LCBrZXkpIHtcbiAgcmV0dXJuIHByZWZpeCArIGtleS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGtleS5zdWJzdHJpbmcoMSk7XG59XG5cbi8qKlxuICogU3VwcG9ydCBzdHlsZSBuYW1lcyB0aGF0IG1heSBjb21lIHBhc3NlZCBpbiBwcmVmaXhlZCBieSBhZGRpbmcgcGVybXV0YXRpb25zXG4gKiBvZiB2ZW5kb3IgcHJlZml4ZXMuXG4gKi9cbnZhciBwcmVmaXhlcyA9IFsnV2Via2l0JywgJ21zJywgJ01veicsICdPJ107XG5cbi8vIFVzaW5nIE9iamVjdC5rZXlzIGhlcmUsIG9yIGVsc2UgdGhlIHZhbmlsbGEgZm9yLWluIGxvb3AgbWFrZXMgSUU4IGdvIGludG8gYW5cbi8vIGluZmluaXRlIGxvb3AsIGJlY2F1c2UgaXQgaXRlcmF0ZXMgb3ZlciB0aGUgbmV3bHkgYWRkZWQgcHJvcHMgdG9vLlxuT2JqZWN0LmtleXMoaXNVbml0bGVzc051bWJlcikuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICBwcmVmaXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICBpc1VuaXRsZXNzTnVtYmVyW3ByZWZpeEtleShwcmVmaXgsIHByb3ApXSA9IGlzVW5pdGxlc3NOdW1iZXJbcHJvcF07XG4gIH0pO1xufSk7XG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIGludG8gdGhlIHByb3BlciBjc3Mgd3JpdGFibGUgdmFsdWUuIFRoZSBzdHlsZSBuYW1lIGBuYW1lYFxuICogc2hvdWxkIGJlIGxvZ2ljYWwgKG5vIGh5cGhlbnMpLCBhcyBzcGVjaWZpZWRcbiAqIGluIGBDU1NQcm9wZXJ0eS5pc1VuaXRsZXNzTnVtYmVyYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBDU1MgcHJvcGVydHkgbmFtZSBzdWNoIGFzIGB0b3BNYXJnaW5gLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBDU1MgcHJvcGVydHkgdmFsdWUgc3VjaCBhcyBgMTBweGAuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IE5vcm1hbGl6ZWQgc3R5bGUgdmFsdWUgd2l0aCBkaW1lbnNpb25zIGFwcGxpZWQuXG4gKi9cbmZ1bmN0aW9uIGRhbmdlcm91c1N0eWxlVmFsdWUobmFtZSwgdmFsdWUsIGlzQ3VzdG9tUHJvcGVydHkpIHtcbiAgLy8gTm90ZSB0aGF0IHdlJ3ZlIHJlbW92ZWQgZXNjYXBlVGV4dEZvckJyb3dzZXIoKSBjYWxscyBoZXJlIHNpbmNlIHRoZVxuICAvLyB3aG9sZSBzdHJpbmcgd2lsbCBiZSBlc2NhcGVkIHdoZW4gdGhlIGF0dHJpYnV0ZSBpcyBpbmplY3RlZCBpbnRvXG4gIC8vIHRoZSBtYXJrdXAuIElmIHlvdSBwcm92aWRlIHVuc2FmZSB1c2VyIGRhdGEgaGVyZSB0aGV5IGNhbiBpbmplY3RcbiAgLy8gYXJiaXRyYXJ5IENTUyB3aGljaCBtYXkgYmUgcHJvYmxlbWF0aWMgKEkgY291bGRuJ3QgcmVwcm8gdGhpcyk6XG4gIC8vIGh0dHBzOi8vd3d3Lm93YXNwLm9yZy9pbmRleC5waHAvWFNTX0ZpbHRlcl9FdmFzaW9uX0NoZWF0X1NoZWV0XG4gIC8vIGh0dHA6Ly93d3cudGhlc3Bhbm5lci5jby51ay8yMDA3LzExLzI2L3VsdGltYXRlLXhzcy1jc3MtaW5qZWN0aW9uL1xuICAvLyBUaGlzIGlzIG5vdCBhbiBYU1MgaG9sZSBidXQgaW5zdGVhZCBhIHBvdGVudGlhbCBDU1MgaW5qZWN0aW9uIGlzc3VlXG4gIC8vIHdoaWNoIGhhcyBsZWFkIHRvIGEgZ3JlYXRlciBkaXNjdXNzaW9uIGFib3V0IGhvdyB3ZSdyZSBnb2luZyB0b1xuICAvLyB0cnVzdCBVUkxzIG1vdmluZyBmb3J3YXJkLiBTZWUgIzIxMTU5MDFcblxuICB2YXIgaXNFbXB0eSA9IHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgfHwgdmFsdWUgPT09ICcnO1xuICBpZiAoaXNFbXB0eSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmICghaXNDdXN0b21Qcm9wZXJ0eSAmJiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIHZhbHVlICE9PSAwICYmICEoaXNVbml0bGVzc051bWJlci5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBpc1VuaXRsZXNzTnVtYmVyW25hbWVdKSkge1xuICAgIHJldHVybiB2YWx1ZSArICdweCc7IC8vIFByZXN1bWVzIGltcGxpY2l0ICdweCcgc3VmZml4IGZvciB1bml0bGVzcyBudW1iZXJzXG4gIH1cblxuICByZXR1cm4gKCcnICsgdmFsdWUpLnRyaW0oKTtcbn1cblxudmFyIHdhcm5WYWxpZFN0eWxlID0gZW1wdHlGdW5jdGlvbjtcblxue1xuICAvLyAnbXNUcmFuc2Zvcm0nIGlzIGNvcnJlY3QsIGJ1dCB0aGUgb3RoZXIgcHJlZml4ZXMgc2hvdWxkIGJlIGNhcGl0YWxpemVkXG4gIHZhciBiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4gPSAvXig/OndlYmtpdHxtb3p8bylbQS1aXS87XG5cbiAgLy8gc3R5bGUgdmFsdWVzIHNob3VsZG4ndCBjb250YWluIGEgc2VtaWNvbG9uXG4gIHZhciBiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4gPSAvO1xccyokLztcblxuICB2YXIgd2FybmVkU3R5bGVOYW1lcyA9IHt9O1xuICB2YXIgd2FybmVkU3R5bGVWYWx1ZXMgPSB7fTtcbiAgdmFyIHdhcm5lZEZvck5hTlZhbHVlID0gZmFsc2U7XG4gIHZhciB3YXJuZWRGb3JJbmZpbml0eVZhbHVlID0gZmFsc2U7XG5cbiAgdmFyIHdhcm5IeXBoZW5hdGVkU3R5bGVOYW1lID0gZnVuY3Rpb24gKG5hbWUsIGdldFN0YWNrKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlTmFtZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0gPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsICdVbnN1cHBvcnRlZCBzdHlsZSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPyVzJywgbmFtZSwgY2FtZWxpemVTdHlsZU5hbWUobmFtZSksIGdldFN0YWNrKCkpO1xuICB9O1xuXG4gIHZhciB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUgPSBmdW5jdGlvbiAobmFtZSwgZ2V0U3RhY2spIHtcbiAgICBpZiAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRTdHlsZU5hbWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ1Vuc3VwcG9ydGVkIHZlbmRvci1wcmVmaXhlZCBzdHlsZSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPyVzJywgbmFtZSwgbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSksIGdldFN0YWNrKCkpO1xuICB9O1xuXG4gIHZhciB3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIGdldFN0YWNrKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlVmFsdWVzLmhhc093blByb3BlcnR5KHZhbHVlKSAmJiB3YXJuZWRTdHlsZVZhbHVlc1t2YWx1ZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZVZhbHVlc1t2YWx1ZV0gPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsIFwiU3R5bGUgcHJvcGVydHkgdmFsdWVzIHNob3VsZG4ndCBjb250YWluIGEgc2VtaWNvbG9uLiBcIiArICdUcnkgXCIlczogJXNcIiBpbnN0ZWFkLiVzJywgbmFtZSwgdmFsdWUucmVwbGFjZShiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4sICcnKSwgZ2V0U3RhY2soKSk7XG4gIH07XG5cbiAgdmFyIHdhcm5TdHlsZVZhbHVlSXNOYU4gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIGdldFN0YWNrKSB7XG4gICAgaWYgKHdhcm5lZEZvck5hTlZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkRm9yTmFOVmFsdWUgPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsICdgTmFOYCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvciB0aGUgYCVzYCBjc3Mgc3R5bGUgcHJvcGVydHkuJXMnLCBuYW1lLCBnZXRTdGFjaygpKTtcbiAgfTtcblxuICB2YXIgd2FyblN0eWxlVmFsdWVJc0luZmluaXR5ID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBnZXRTdGFjaykge1xuICAgIGlmICh3YXJuZWRGb3JJbmZpbml0eVZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkRm9ySW5maW5pdHlWYWx1ZSA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ2BJbmZpbml0eWAgaXMgYW4gaW52YWxpZCB2YWx1ZSBmb3IgdGhlIGAlc2AgY3NzIHN0eWxlIHByb3BlcnR5LiVzJywgbmFtZSwgZ2V0U3RhY2soKSk7XG4gIH07XG5cbiAgd2FyblZhbGlkU3R5bGUgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIGdldFN0YWNrKSB7XG4gICAgaWYgKG5hbWUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgIHdhcm5IeXBoZW5hdGVkU3R5bGVOYW1lKG5hbWUsIGdldFN0YWNrKTtcbiAgICB9IGVsc2UgaWYgKGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybi50ZXN0KG5hbWUpKSB7XG4gICAgICB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUobmFtZSwgZ2V0U3RhY2spO1xuICAgIH0gZWxzZSBpZiAoYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuLnRlc3QodmFsdWUpKSB7XG4gICAgICB3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24obmFtZSwgdmFsdWUsIGdldFN0YWNrKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgICB3YXJuU3R5bGVWYWx1ZUlzTmFOKG5hbWUsIHZhbHVlLCBnZXRTdGFjayk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgd2FyblN0eWxlVmFsdWVJc0luZmluaXR5KG5hbWUsIHZhbHVlLCBnZXRTdGFjayk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG52YXIgd2FyblZhbGlkU3R5bGUkMSA9IHdhcm5WYWxpZFN0eWxlO1xuXG4vKipcbiAqIE9wZXJhdGlvbnMgZm9yIGRlYWxpbmcgd2l0aCBDU1MgcHJvcGVydGllcy5cbiAqL1xuXG4vKipcbiAqIFRoaXMgY3JlYXRlcyBhIHN0cmluZyB0aGF0IGlzIGV4cGVjdGVkIHRvIGJlIGVxdWl2YWxlbnQgdG8gdGhlIHN0eWxlXG4gKiBhdHRyaWJ1dGUgZ2VuZXJhdGVkIGJ5IHNlcnZlci1zaWRlIHJlbmRlcmluZy4gSXQgYnktcGFzc2VzIHdhcm5pbmdzIGFuZFxuICogc2VjdXJpdHkgY2hlY2tzIHNvIGl0J3Mgbm90IHNhZmUgdG8gdXNlIHRoaXMgdmFsdWUgZm9yIGFueXRoaW5nIG90aGVyIHRoYW5cbiAqIGNvbXBhcmlzb24uIEl0IGlzIG9ubHkgdXNlZCBpbiBERVYgZm9yIFNTUiB2YWxpZGF0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVEYW5nZXJvdXNTdHJpbmdGb3JTdHlsZXMoc3R5bGVzKSB7XG4gIHtcbiAgICB2YXIgc2VyaWFsaXplZCA9ICcnO1xuICAgIHZhciBkZWxpbWl0ZXIgPSAnJztcbiAgICBmb3IgKHZhciBzdHlsZU5hbWUgaW4gc3R5bGVzKSB7XG4gICAgICBpZiAoIXN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIHN0eWxlVmFsdWUgPSBzdHlsZXNbc3R5bGVOYW1lXTtcbiAgICAgIGlmIChzdHlsZVZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGlzQ3VzdG9tUHJvcGVydHkgPSBzdHlsZU5hbWUuaW5kZXhPZignLS0nKSA9PT0gMDtcbiAgICAgICAgc2VyaWFsaXplZCArPSBkZWxpbWl0ZXIgKyBoeXBoZW5hdGVTdHlsZU5hbWUoc3R5bGVOYW1lKSArICc6JztcbiAgICAgICAgc2VyaWFsaXplZCArPSBkYW5nZXJvdXNTdHlsZVZhbHVlKHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSwgaXNDdXN0b21Qcm9wZXJ0eSk7XG5cbiAgICAgICAgZGVsaW1pdGVyID0gJzsnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VyaWFsaXplZCB8fCBudWxsO1xuICB9XG59XG5cbi8qKlxuICogU2V0cyB0aGUgdmFsdWUgZm9yIG11bHRpcGxlIHN0eWxlcyBvbiBhIG5vZGUuICBJZiBhIHZhbHVlIGlzIHNwZWNpZmllZCBhc1xuICogJycgKGVtcHR5IHN0cmluZyksIHRoZSBjb3JyZXNwb25kaW5nIHN0eWxlIHByb3BlcnR5IHdpbGwgYmUgdW5zZXQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge29iamVjdH0gc3R5bGVzXG4gKi9cbmZ1bmN0aW9uIHNldFZhbHVlRm9yU3R5bGVzKG5vZGUsIHN0eWxlcywgZ2V0U3RhY2spIHtcbiAgdmFyIHN0eWxlID0gbm9kZS5zdHlsZTtcbiAgZm9yICh2YXIgc3R5bGVOYW1lIGluIHN0eWxlcykge1xuICAgIGlmICghc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgaXNDdXN0b21Qcm9wZXJ0eSA9IHN0eWxlTmFtZS5pbmRleE9mKCctLScpID09PSAwO1xuICAgIHtcbiAgICAgIGlmICghaXNDdXN0b21Qcm9wZXJ0eSkge1xuICAgICAgICB3YXJuVmFsaWRTdHlsZSQxKHN0eWxlTmFtZSwgc3R5bGVzW3N0eWxlTmFtZV0sIGdldFN0YWNrKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHN0eWxlVmFsdWUgPSBkYW5nZXJvdXNTdHlsZVZhbHVlKHN0eWxlTmFtZSwgc3R5bGVzW3N0eWxlTmFtZV0sIGlzQ3VzdG9tUHJvcGVydHkpO1xuICAgIGlmIChzdHlsZU5hbWUgPT09ICdmbG9hdCcpIHtcbiAgICAgIHN0eWxlTmFtZSA9ICdjc3NGbG9hdCc7XG4gICAgfVxuICAgIGlmIChpc0N1c3RvbVByb3BlcnR5KSB7XG4gICAgICBzdHlsZS5zZXRQcm9wZXJ0eShzdHlsZU5hbWUsIHN0eWxlVmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZVtzdHlsZU5hbWVdID0gc3R5bGVWYWx1ZTtcbiAgICB9XG4gIH1cbn1cblxuLy8gRm9yIEhUTUwsIGNlcnRhaW4gdGFncyBzaG91bGQgb21pdCB0aGVpciBjbG9zZSB0YWcuIFdlIGtlZXAgYSB3aGl0ZWxpc3QgZm9yXG4vLyB0aG9zZSBzcGVjaWFsLWNhc2UgdGFncy5cblxudmFyIG9taXR0ZWRDbG9zZVRhZ3MgPSB7XG4gIGFyZWE6IHRydWUsXG4gIGJhc2U6IHRydWUsXG4gIGJyOiB0cnVlLFxuICBjb2w6IHRydWUsXG4gIGVtYmVkOiB0cnVlLFxuICBocjogdHJ1ZSxcbiAgaW1nOiB0cnVlLFxuICBpbnB1dDogdHJ1ZSxcbiAga2V5Z2VuOiB0cnVlLFxuICBsaW5rOiB0cnVlLFxuICBtZXRhOiB0cnVlLFxuICBwYXJhbTogdHJ1ZSxcbiAgc291cmNlOiB0cnVlLFxuICB0cmFjazogdHJ1ZSxcbiAgd2JyOiB0cnVlXG59O1xuXG4vLyBGb3IgSFRNTCwgY2VydGFpbiB0YWdzIGNhbm5vdCBoYXZlIGNoaWxkcmVuLiBUaGlzIGhhcyB0aGUgc2FtZSBwdXJwb3NlIGFzXG4vLyBgb21pdHRlZENsb3NlVGFnc2AgZXhjZXB0IHRoYXQgYG1lbnVpdGVtYCBzaG91bGQgc3RpbGwgaGF2ZSBpdHMgY2xvc2luZyB0YWcuXG5cbnZhciB2b2lkRWxlbWVudFRhZ3MgPSBfYXNzaWduKHtcbiAgbWVudWl0ZW06IHRydWVcbn0sIG9taXR0ZWRDbG9zZVRhZ3MpO1xuXG52YXIgSFRNTCQxID0gJ19faHRtbCc7XG5cbmZ1bmN0aW9uIGFzc2VydFZhbGlkUHJvcHModGFnLCBwcm9wcywgZ2V0U3RhY2spIHtcbiAgaWYgKCFwcm9wcykge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBOb3RlIHRoZSB1c2Ugb2YgYD09YCB3aGljaCBjaGVja3MgZm9yIG51bGwgb3IgdW5kZWZpbmVkLlxuICBpZiAodm9pZEVsZW1lbnRUYWdzW3RhZ10pIHtcbiAgICAhKHByb3BzLmNoaWxkcmVuID09IG51bGwgJiYgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICclcyBpcyBhIHZvaWQgZWxlbWVudCB0YWcgYW5kIG11c3QgbmVpdGhlciBoYXZlIGBjaGlsZHJlbmAgbm9yIHVzZSBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLiVzJywgdGFnLCBnZXRTdGFjaygpKSA6IHZvaWQgMDtcbiAgfVxuICBpZiAocHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgIT0gbnVsbCkge1xuICAgICEocHJvcHMuY2hpbGRyZW4gPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW4gb25seSBzZXQgb25lIG9mIGBjaGlsZHJlbmAgb3IgYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKSA6IHZvaWQgMDtcbiAgICAhKHR5cGVvZiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PT0gJ29iamVjdCcgJiYgSFRNTCQxIGluIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKSA/IGludmFyaWFudChmYWxzZSwgJ2Bwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAgbXVzdCBiZSBpbiB0aGUgZm9ybSBge19faHRtbDogLi4ufWAuIFBsZWFzZSB2aXNpdCBodHRwczovL2ZiLm1lL3JlYWN0LWludmFyaWFudC1kYW5nZXJvdXNseS1zZXQtaW5uZXItaHRtbCBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKSA6IHZvaWQgMDtcbiAgfVxuICB7XG4gICAgd2FybmluZyhwcm9wcy5zdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcgfHwgIXByb3BzLmNvbnRlbnRFZGl0YWJsZSB8fCBwcm9wcy5jaGlsZHJlbiA9PSBudWxsLCAnQSBjb21wb25lbnQgaXMgYGNvbnRlbnRFZGl0YWJsZWAgYW5kIGNvbnRhaW5zIGBjaGlsZHJlbmAgbWFuYWdlZCBieSAnICsgJ1JlYWN0LiBJdCBpcyBub3cgeW91ciByZXNwb25zaWJpbGl0eSB0byBndWFyYW50ZWUgdGhhdCBub25lIG9mICcgKyAndGhvc2Ugbm9kZXMgYXJlIHVuZXhwZWN0ZWRseSBtb2RpZmllZCBvciBkdXBsaWNhdGVkLiBUaGlzIGlzICcgKyAncHJvYmFibHkgbm90IGludGVudGlvbmFsLiVzJywgZ2V0U3RhY2soKSk7XG4gIH1cbiAgIShwcm9wcy5zdHlsZSA9PSBudWxsIHx8IHR5cGVvZiBwcm9wcy5zdHlsZSA9PT0gJ29iamVjdCcpID8gaW52YXJpYW50KGZhbHNlLCAnVGhlIGBzdHlsZWAgcHJvcCBleHBlY3RzIGEgbWFwcGluZyBmcm9tIHN0eWxlIHByb3BlcnRpZXMgdG8gdmFsdWVzLCBub3QgYSBzdHJpbmcuIEZvciBleGFtcGxlLCBzdHlsZT17e21hcmdpblJpZ2h0OiBzcGFjaW5nICsgXFwnZW1cXCd9fSB3aGVuIHVzaW5nIEpTWC4lcycsIGdldFN0YWNrKCkpIDogdm9pZCAwO1xufVxuXG5mdW5jdGlvbiBpc0N1c3RvbUNvbXBvbmVudCh0YWdOYW1lLCBwcm9wcykge1xuICBpZiAodGFnTmFtZS5pbmRleE9mKCctJykgPT09IC0xKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBwcm9wcy5pcyA9PT0gJ3N0cmluZyc7XG4gIH1cbiAgc3dpdGNoICh0YWdOYW1lKSB7XG4gICAgLy8gVGhlc2UgYXJlIHJlc2VydmVkIFNWRyBhbmQgTWF0aE1MIGVsZW1lbnRzLlxuICAgIC8vIFdlIGRvbid0IG1pbmQgdGhpcyB3aGl0ZWxpc3QgdG9vIG11Y2ggYmVjYXVzZSB3ZSBleHBlY3QgaXQgdG8gbmV2ZXIgZ3Jvdy5cbiAgICAvLyBUaGUgYWx0ZXJuYXRpdmUgaXMgdG8gdHJhY2sgdGhlIG5hbWVzcGFjZSBpbiBhIGZldyBwbGFjZXMgd2hpY2ggaXMgY29udm9sdXRlZC5cbiAgICAvLyBodHRwczovL3czYy5naXRodWIuaW8vd2ViY29tcG9uZW50cy9zcGVjL2N1c3RvbS8jY3VzdG9tLWVsZW1lbnRzLWNvcmUtY29uY2VwdHNcbiAgICBjYXNlICdhbm5vdGF0aW9uLXhtbCc6XG4gICAgY2FzZSAnY29sb3ItcHJvZmlsZSc6XG4gICAgY2FzZSAnZm9udC1mYWNlJzpcbiAgICBjYXNlICdmb250LWZhY2Utc3JjJzpcbiAgICBjYXNlICdmb250LWZhY2UtdXJpJzpcbiAgICBjYXNlICdmb250LWZhY2UtZm9ybWF0JzpcbiAgICBjYXNlICdmb250LWZhY2UtbmFtZSc6XG4gICAgY2FzZSAnbWlzc2luZy1nbHlwaCc6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbnZhciBhcmlhUHJvcGVydGllcyA9IHtcbiAgJ2FyaWEtY3VycmVudCc6IDAsIC8vIHN0YXRlXG4gICdhcmlhLWRldGFpbHMnOiAwLFxuICAnYXJpYS1kaXNhYmxlZCc6IDAsIC8vIHN0YXRlXG4gICdhcmlhLWhpZGRlbic6IDAsIC8vIHN0YXRlXG4gICdhcmlhLWludmFsaWQnOiAwLCAvLyBzdGF0ZVxuICAnYXJpYS1rZXlzaG9ydGN1dHMnOiAwLFxuICAnYXJpYS1sYWJlbCc6IDAsXG4gICdhcmlhLXJvbGVkZXNjcmlwdGlvbic6IDAsXG4gIC8vIFdpZGdldCBBdHRyaWJ1dGVzXG4gICdhcmlhLWF1dG9jb21wbGV0ZSc6IDAsXG4gICdhcmlhLWNoZWNrZWQnOiAwLFxuICAnYXJpYS1leHBhbmRlZCc6IDAsXG4gICdhcmlhLWhhc3BvcHVwJzogMCxcbiAgJ2FyaWEtbGV2ZWwnOiAwLFxuICAnYXJpYS1tb2RhbCc6IDAsXG4gICdhcmlhLW11bHRpbGluZSc6IDAsXG4gICdhcmlhLW11bHRpc2VsZWN0YWJsZSc6IDAsXG4gICdhcmlhLW9yaWVudGF0aW9uJzogMCxcbiAgJ2FyaWEtcGxhY2Vob2xkZXInOiAwLFxuICAnYXJpYS1wcmVzc2VkJzogMCxcbiAgJ2FyaWEtcmVhZG9ubHknOiAwLFxuICAnYXJpYS1yZXF1aXJlZCc6IDAsXG4gICdhcmlhLXNlbGVjdGVkJzogMCxcbiAgJ2FyaWEtc29ydCc6IDAsXG4gICdhcmlhLXZhbHVlbWF4JzogMCxcbiAgJ2FyaWEtdmFsdWVtaW4nOiAwLFxuICAnYXJpYS12YWx1ZW5vdyc6IDAsXG4gICdhcmlhLXZhbHVldGV4dCc6IDAsXG4gIC8vIExpdmUgUmVnaW9uIEF0dHJpYnV0ZXNcbiAgJ2FyaWEtYXRvbWljJzogMCxcbiAgJ2FyaWEtYnVzeSc6IDAsXG4gICdhcmlhLWxpdmUnOiAwLFxuICAnYXJpYS1yZWxldmFudCc6IDAsXG4gIC8vIERyYWctYW5kLURyb3AgQXR0cmlidXRlc1xuICAnYXJpYS1kcm9wZWZmZWN0JzogMCxcbiAgJ2FyaWEtZ3JhYmJlZCc6IDAsXG4gIC8vIFJlbGF0aW9uc2hpcCBBdHRyaWJ1dGVzXG4gICdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnOiAwLFxuICAnYXJpYS1jb2xjb3VudCc6IDAsXG4gICdhcmlhLWNvbGluZGV4JzogMCxcbiAgJ2FyaWEtY29sc3Bhbic6IDAsXG4gICdhcmlhLWNvbnRyb2xzJzogMCxcbiAgJ2FyaWEtZGVzY3JpYmVkYnknOiAwLFxuICAnYXJpYS1lcnJvcm1lc3NhZ2UnOiAwLFxuICAnYXJpYS1mbG93dG8nOiAwLFxuICAnYXJpYS1sYWJlbGxlZGJ5JzogMCxcbiAgJ2FyaWEtb3ducyc6IDAsXG4gICdhcmlhLXBvc2luc2V0JzogMCxcbiAgJ2FyaWEtcm93Y291bnQnOiAwLFxuICAnYXJpYS1yb3dpbmRleCc6IDAsXG4gICdhcmlhLXJvd3NwYW4nOiAwLFxuICAnYXJpYS1zZXRzaXplJzogMFxufTtcblxudmFyIHdhcm5lZFByb3BlcnRpZXMgPSB7fTtcbnZhciByQVJJQSA9IG5ldyBSZWdFeHAoJ14oYXJpYSktWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xudmFyIHJBUklBQ2FtZWwgPSBuZXcgUmVnRXhwKCdeKGFyaWEpW0EtWl1bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIGdldFN0YWNrQWRkZW5kdW0oKSB7XG4gIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuICByZXR1cm4gc3RhY2sgIT0gbnVsbCA/IHN0YWNrIDogJyc7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydHkodGFnTmFtZSwgbmFtZSkge1xuICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh3YXJuZWRQcm9wZXJ0aWVzLCBuYW1lKSAmJiB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAockFSSUFDYW1lbC50ZXN0KG5hbWUpKSB7XG4gICAgdmFyIGFyaWFOYW1lID0gJ2FyaWEtJyArIG5hbWUuc2xpY2UoNCkudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgY29ycmVjdE5hbWUgPSBhcmlhUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShhcmlhTmFtZSkgPyBhcmlhTmFtZSA6IG51bGw7XG5cbiAgICAvLyBJZiB0aGlzIGlzIGFuIGFyaWEtKiBhdHRyaWJ1dGUsIGJ1dCBpcyBub3QgbGlzdGVkIGluIHRoZSBrbm93biBET01cbiAgICAvLyBET00gcHJvcGVydGllcywgdGhlbiBpdCBpcyBhbiBpbnZhbGlkIGFyaWEtKiBhdHRyaWJ1dGUuXG4gICAgaWYgKGNvcnJlY3ROYW1lID09IG51bGwpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIEFSSUEgYXR0cmlidXRlIGAlc2AuIEFSSUEgYXR0cmlidXRlcyBmb2xsb3cgdGhlIHBhdHRlcm4gYXJpYS0qIGFuZCBtdXN0IGJlIGxvd2VyY2FzZS4lcycsIG5hbWUsIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBhcmlhLSogYXR0cmlidXRlcyBzaG91bGQgYmUgbG93ZXJjYXNlOyBzdWdnZXN0IHRoZSBsb3dlcmNhc2UgdmVyc2lvbi5cbiAgICBpZiAobmFtZSAhPT0gY29ycmVjdE5hbWUpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIEFSSUEgYXR0cmlidXRlIGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgPyVzJywgbmFtZSwgY29ycmVjdE5hbWUsIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChyQVJJQS50ZXN0KG5hbWUpKSB7XG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBzdGFuZGFyZE5hbWUgPSBhcmlhUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkgPyBsb3dlckNhc2VkTmFtZSA6IG51bGw7XG5cbiAgICAvLyBJZiB0aGlzIGlzIGFuIGFyaWEtKiBhdHRyaWJ1dGUsIGJ1dCBpcyBub3QgbGlzdGVkIGluIHRoZSBrbm93biBET01cbiAgICAvLyBET00gcHJvcGVydGllcywgdGhlbiBpdCBpcyBhbiBpbnZhbGlkIGFyaWEtKiBhdHRyaWJ1dGUuXG4gICAgaWYgKHN0YW5kYXJkTmFtZSA9PSBudWxsKSB7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gYXJpYS0qIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGxvd2VyY2FzZTsgc3VnZ2VzdCB0aGUgbG93ZXJjYXNlIHZlcnNpb24uXG4gICAgaWYgKG5hbWUgIT09IHN0YW5kYXJkTmFtZSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1Vua25vd24gQVJJQSBhdHRyaWJ1dGUgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JXMnLCBuYW1lLCBzdGFuZGFyZE5hbWUsIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiB3YXJuSW52YWxpZEFSSUFQcm9wcyh0eXBlLCBwcm9wcykge1xuICB2YXIgaW52YWxpZFByb3BzID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgdmFyIGlzVmFsaWQgPSB2YWxpZGF0ZVByb3BlcnR5KHR5cGUsIGtleSk7XG4gICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICBpbnZhbGlkUHJvcHMucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuXG4gIHZhciB1bmtub3duUHJvcFN0cmluZyA9IGludmFsaWRQcm9wcy5tYXAoZnVuY3Rpb24gKHByb3ApIHtcbiAgICByZXR1cm4gJ2AnICsgcHJvcCArICdgJztcbiAgfSkuam9pbignLCAnKTtcblxuICBpZiAoaW52YWxpZFByb3BzLmxlbmd0aCA9PT0gMSkge1xuICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGFyaWEgcHJvcCAlcyBvbiA8JXM+IHRhZy4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vZmIubWUvaW52YWxpZC1hcmlhLXByb3AlcycsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlLCBnZXRTdGFja0FkZGVuZHVtKCkpO1xuICB9IGVsc2UgaWYgKGludmFsaWRQcm9wcy5sZW5ndGggPiAxKSB7XG4gICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXJpYSBwcm9wcyAlcyBvbiA8JXM+IHRhZy4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vZmIubWUvaW52YWxpZC1hcmlhLXByb3AlcycsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlLCBnZXRTdGFja0FkZGVuZHVtKCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyh0eXBlLCBwcm9wcykge1xuICBpZiAoaXNDdXN0b21Db21wb25lbnQodHlwZSwgcHJvcHMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdhcm5JbnZhbGlkQVJJQVByb3BzKHR5cGUsIHByb3BzKTtcbn1cblxudmFyIGRpZFdhcm5WYWx1ZU51bGwgPSBmYWxzZTtcblxuZnVuY3Rpb24gZ2V0U3RhY2tBZGRlbmR1bSQxKCkge1xuICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcbiAgcmV0dXJuIHN0YWNrICE9IG51bGwgPyBzdGFjayA6ICcnO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnRpZXMkMSh0eXBlLCBwcm9wcykge1xuICBpZiAodHlwZSAhPT0gJ2lucHV0JyAmJiB0eXBlICE9PSAndGV4dGFyZWEnICYmIHR5cGUgIT09ICdzZWxlY3QnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHByb3BzICE9IG51bGwgJiYgcHJvcHMudmFsdWUgPT09IG51bGwgJiYgIWRpZFdhcm5WYWx1ZU51bGwpIHtcbiAgICBkaWRXYXJuVmFsdWVOdWxsID0gdHJ1ZTtcbiAgICBpZiAodHlwZSA9PT0gJ3NlbGVjdCcgJiYgcHJvcHMubXVsdGlwbGUpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdgdmFsdWVgIHByb3Agb24gYCVzYCBzaG91bGQgbm90IGJlIG51bGwuICcgKyAnQ29uc2lkZXIgdXNpbmcgYW4gZW1wdHkgYXJyYXkgd2hlbiBgbXVsdGlwbGVgIGlzIHNldCB0byBgdHJ1ZWAgJyArICd0byBjbGVhciB0aGUgY29tcG9uZW50IG9yIGB1bmRlZmluZWRgIGZvciB1bmNvbnRyb2xsZWQgY29tcG9uZW50cy4lcycsIHR5cGUsIGdldFN0YWNrQWRkZW5kdW0kMSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ2B2YWx1ZWAgcHJvcCBvbiBgJXNgIHNob3VsZCBub3QgYmUgbnVsbC4gJyArICdDb25zaWRlciB1c2luZyBhbiBlbXB0eSBzdHJpbmcgdG8gY2xlYXIgdGhlIGNvbXBvbmVudCBvciBgdW5kZWZpbmVkYCAnICsgJ2ZvciB1bmNvbnRyb2xsZWQgY29tcG9uZW50cy4lcycsIHR5cGUsIGdldFN0YWNrQWRkZW5kdW0kMSgpKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gV2hlbiBhZGRpbmcgYXR0cmlidXRlcyB0byB0aGUgSFRNTCBvciBTVkcgd2hpdGVsaXN0LCBiZSBzdXJlIHRvXG4vLyBhbHNvIGFkZCB0aGVtIHRvIHRoaXMgbW9kdWxlIHRvIGVuc3VyZSBjYXNpbmcgYW5kIGluY29ycmVjdCBuYW1lXG4vLyB3YXJuaW5ncy5cbnZhciBwb3NzaWJsZVN0YW5kYXJkTmFtZXMgPSB7XG4gIC8vIEhUTUxcbiAgYWNjZXB0OiAnYWNjZXB0JyxcbiAgYWNjZXB0Y2hhcnNldDogJ2FjY2VwdENoYXJzZXQnLFxuICAnYWNjZXB0LWNoYXJzZXQnOiAnYWNjZXB0Q2hhcnNldCcsXG4gIGFjY2Vzc2tleTogJ2FjY2Vzc0tleScsXG4gIGFjdGlvbjogJ2FjdGlvbicsXG4gIGFsbG93ZnVsbHNjcmVlbjogJ2FsbG93RnVsbFNjcmVlbicsXG4gIGFsdDogJ2FsdCcsXG4gIGFzOiAnYXMnLFxuICBhc3luYzogJ2FzeW5jJyxcbiAgYXV0b2NhcGl0YWxpemU6ICdhdXRvQ2FwaXRhbGl6ZScsXG4gIGF1dG9jb21wbGV0ZTogJ2F1dG9Db21wbGV0ZScsXG4gIGF1dG9jb3JyZWN0OiAnYXV0b0NvcnJlY3QnLFxuICBhdXRvZm9jdXM6ICdhdXRvRm9jdXMnLFxuICBhdXRvcGxheTogJ2F1dG9QbGF5JyxcbiAgYXV0b3NhdmU6ICdhdXRvU2F2ZScsXG4gIGNhcHR1cmU6ICdjYXB0dXJlJyxcbiAgY2VsbHBhZGRpbmc6ICdjZWxsUGFkZGluZycsXG4gIGNlbGxzcGFjaW5nOiAnY2VsbFNwYWNpbmcnLFxuICBjaGFsbGVuZ2U6ICdjaGFsbGVuZ2UnLFxuICBjaGFyc2V0OiAnY2hhclNldCcsXG4gIGNoZWNrZWQ6ICdjaGVja2VkJyxcbiAgY2hpbGRyZW46ICdjaGlsZHJlbicsXG4gIGNpdGU6ICdjaXRlJyxcbiAgJ2NsYXNzJzogJ2NsYXNzTmFtZScsXG4gIGNsYXNzaWQ6ICdjbGFzc0lEJyxcbiAgY2xhc3NuYW1lOiAnY2xhc3NOYW1lJyxcbiAgY29sczogJ2NvbHMnLFxuICBjb2xzcGFuOiAnY29sU3BhbicsXG4gIGNvbnRlbnQ6ICdjb250ZW50JyxcbiAgY29udGVudGVkaXRhYmxlOiAnY29udGVudEVkaXRhYmxlJyxcbiAgY29udGV4dG1lbnU6ICdjb250ZXh0TWVudScsXG4gIGNvbnRyb2xzOiAnY29udHJvbHMnLFxuICBjb250cm9sc2xpc3Q6ICdjb250cm9sc0xpc3QnLFxuICBjb29yZHM6ICdjb29yZHMnLFxuICBjcm9zc29yaWdpbjogJ2Nyb3NzT3JpZ2luJyxcbiAgZGFuZ2Vyb3VzbHlzZXRpbm5lcmh0bWw6ICdkYW5nZXJvdXNseVNldElubmVySFRNTCcsXG4gIGRhdGE6ICdkYXRhJyxcbiAgZGF0ZXRpbWU6ICdkYXRlVGltZScsXG4gICdkZWZhdWx0JzogJ2RlZmF1bHQnLFxuICBkZWZhdWx0Y2hlY2tlZDogJ2RlZmF1bHRDaGVja2VkJyxcbiAgZGVmYXVsdHZhbHVlOiAnZGVmYXVsdFZhbHVlJyxcbiAgZGVmZXI6ICdkZWZlcicsXG4gIGRpcjogJ2RpcicsXG4gIGRpc2FibGVkOiAnZGlzYWJsZWQnLFxuICBkb3dubG9hZDogJ2Rvd25sb2FkJyxcbiAgZHJhZ2dhYmxlOiAnZHJhZ2dhYmxlJyxcbiAgZW5jdHlwZTogJ2VuY1R5cGUnLFxuICAnZm9yJzogJ2h0bWxGb3InLFxuICBmb3JtOiAnZm9ybScsXG4gIGZvcm1tZXRob2Q6ICdmb3JtTWV0aG9kJyxcbiAgZm9ybWFjdGlvbjogJ2Zvcm1BY3Rpb24nLFxuICBmb3JtZW5jdHlwZTogJ2Zvcm1FbmNUeXBlJyxcbiAgZm9ybW5vdmFsaWRhdGU6ICdmb3JtTm9WYWxpZGF0ZScsXG4gIGZvcm10YXJnZXQ6ICdmb3JtVGFyZ2V0JyxcbiAgZnJhbWVib3JkZXI6ICdmcmFtZUJvcmRlcicsXG4gIGhlYWRlcnM6ICdoZWFkZXJzJyxcbiAgaGVpZ2h0OiAnaGVpZ2h0JyxcbiAgaGlkZGVuOiAnaGlkZGVuJyxcbiAgaGlnaDogJ2hpZ2gnLFxuICBocmVmOiAnaHJlZicsXG4gIGhyZWZsYW5nOiAnaHJlZkxhbmcnLFxuICBodG1sZm9yOiAnaHRtbEZvcicsXG4gIGh0dHBlcXVpdjogJ2h0dHBFcXVpdicsXG4gICdodHRwLWVxdWl2JzogJ2h0dHBFcXVpdicsXG4gIGljb246ICdpY29uJyxcbiAgaWQ6ICdpZCcsXG4gIGlubmVyaHRtbDogJ2lubmVySFRNTCcsXG4gIGlucHV0bW9kZTogJ2lucHV0TW9kZScsXG4gIGludGVncml0eTogJ2ludGVncml0eScsXG4gIGlzOiAnaXMnLFxuICBpdGVtaWQ6ICdpdGVtSUQnLFxuICBpdGVtcHJvcDogJ2l0ZW1Qcm9wJyxcbiAgaXRlbXJlZjogJ2l0ZW1SZWYnLFxuICBpdGVtc2NvcGU6ICdpdGVtU2NvcGUnLFxuICBpdGVtdHlwZTogJ2l0ZW1UeXBlJyxcbiAga2V5cGFyYW1zOiAna2V5UGFyYW1zJyxcbiAga2V5dHlwZTogJ2tleVR5cGUnLFxuICBraW5kOiAna2luZCcsXG4gIGxhYmVsOiAnbGFiZWwnLFxuICBsYW5nOiAnbGFuZycsXG4gIGxpc3Q6ICdsaXN0JyxcbiAgbG9vcDogJ2xvb3AnLFxuICBsb3c6ICdsb3cnLFxuICBtYW5pZmVzdDogJ21hbmlmZXN0JyxcbiAgbWFyZ2lud2lkdGg6ICdtYXJnaW5XaWR0aCcsXG4gIG1hcmdpbmhlaWdodDogJ21hcmdpbkhlaWdodCcsXG4gIG1heDogJ21heCcsXG4gIG1heGxlbmd0aDogJ21heExlbmd0aCcsXG4gIG1lZGlhOiAnbWVkaWEnLFxuICBtZWRpYWdyb3VwOiAnbWVkaWFHcm91cCcsXG4gIG1ldGhvZDogJ21ldGhvZCcsXG4gIG1pbjogJ21pbicsXG4gIG1pbmxlbmd0aDogJ21pbkxlbmd0aCcsXG4gIG11bHRpcGxlOiAnbXVsdGlwbGUnLFxuICBtdXRlZDogJ211dGVkJyxcbiAgbmFtZTogJ25hbWUnLFxuICBub25jZTogJ25vbmNlJyxcbiAgbm92YWxpZGF0ZTogJ25vVmFsaWRhdGUnLFxuICBvcGVuOiAnb3BlbicsXG4gIG9wdGltdW06ICdvcHRpbXVtJyxcbiAgcGF0dGVybjogJ3BhdHRlcm4nLFxuICBwbGFjZWhvbGRlcjogJ3BsYWNlaG9sZGVyJyxcbiAgcGxheXNpbmxpbmU6ICdwbGF5c0lubGluZScsXG4gIHBvc3RlcjogJ3Bvc3RlcicsXG4gIHByZWxvYWQ6ICdwcmVsb2FkJyxcbiAgcHJvZmlsZTogJ3Byb2ZpbGUnLFxuICByYWRpb2dyb3VwOiAncmFkaW9Hcm91cCcsXG4gIHJlYWRvbmx5OiAncmVhZE9ubHknLFxuICByZWZlcnJlcnBvbGljeTogJ3JlZmVycmVyUG9saWN5JyxcbiAgcmVsOiAncmVsJyxcbiAgcmVxdWlyZWQ6ICdyZXF1aXJlZCcsXG4gIHJldmVyc2VkOiAncmV2ZXJzZWQnLFxuICByb2xlOiAncm9sZScsXG4gIHJvd3M6ICdyb3dzJyxcbiAgcm93c3BhbjogJ3Jvd1NwYW4nLFxuICBzYW5kYm94OiAnc2FuZGJveCcsXG4gIHNjb3BlOiAnc2NvcGUnLFxuICBzY29wZWQ6ICdzY29wZWQnLFxuICBzY3JvbGxpbmc6ICdzY3JvbGxpbmcnLFxuICBzZWFtbGVzczogJ3NlYW1sZXNzJyxcbiAgc2VsZWN0ZWQ6ICdzZWxlY3RlZCcsXG4gIHNoYXBlOiAnc2hhcGUnLFxuICBzaXplOiAnc2l6ZScsXG4gIHNpemVzOiAnc2l6ZXMnLFxuICBzcGFuOiAnc3BhbicsXG4gIHNwZWxsY2hlY2s6ICdzcGVsbENoZWNrJyxcbiAgc3JjOiAnc3JjJyxcbiAgc3JjZG9jOiAnc3JjRG9jJyxcbiAgc3JjbGFuZzogJ3NyY0xhbmcnLFxuICBzcmNzZXQ6ICdzcmNTZXQnLFxuICBzdGFydDogJ3N0YXJ0JyxcbiAgc3RlcDogJ3N0ZXAnLFxuICBzdHlsZTogJ3N0eWxlJyxcbiAgc3VtbWFyeTogJ3N1bW1hcnknLFxuICB0YWJpbmRleDogJ3RhYkluZGV4JyxcbiAgdGFyZ2V0OiAndGFyZ2V0JyxcbiAgdGl0bGU6ICd0aXRsZScsXG4gIHR5cGU6ICd0eXBlJyxcbiAgdXNlbWFwOiAndXNlTWFwJyxcbiAgdmFsdWU6ICd2YWx1ZScsXG4gIHdpZHRoOiAnd2lkdGgnLFxuICB3bW9kZTogJ3dtb2RlJyxcbiAgd3JhcDogJ3dyYXAnLFxuXG4gIC8vIFNWR1xuICBhYm91dDogJ2Fib3V0JyxcbiAgYWNjZW50aGVpZ2h0OiAnYWNjZW50SGVpZ2h0JyxcbiAgJ2FjY2VudC1oZWlnaHQnOiAnYWNjZW50SGVpZ2h0JyxcbiAgYWNjdW11bGF0ZTogJ2FjY3VtdWxhdGUnLFxuICBhZGRpdGl2ZTogJ2FkZGl0aXZlJyxcbiAgYWxpZ25tZW50YmFzZWxpbmU6ICdhbGlnbm1lbnRCYXNlbGluZScsXG4gICdhbGlnbm1lbnQtYmFzZWxpbmUnOiAnYWxpZ25tZW50QmFzZWxpbmUnLFxuICBhbGxvd3Jlb3JkZXI6ICdhbGxvd1Jlb3JkZXInLFxuICBhbHBoYWJldGljOiAnYWxwaGFiZXRpYycsXG4gIGFtcGxpdHVkZTogJ2FtcGxpdHVkZScsXG4gIGFyYWJpY2Zvcm06ICdhcmFiaWNGb3JtJyxcbiAgJ2FyYWJpYy1mb3JtJzogJ2FyYWJpY0Zvcm0nLFxuICBhc2NlbnQ6ICdhc2NlbnQnLFxuICBhdHRyaWJ1dGVuYW1lOiAnYXR0cmlidXRlTmFtZScsXG4gIGF0dHJpYnV0ZXR5cGU6ICdhdHRyaWJ1dGVUeXBlJyxcbiAgYXV0b3JldmVyc2U6ICdhdXRvUmV2ZXJzZScsXG4gIGF6aW11dGg6ICdhemltdXRoJyxcbiAgYmFzZWZyZXF1ZW5jeTogJ2Jhc2VGcmVxdWVuY3knLFxuICBiYXNlbGluZXNoaWZ0OiAnYmFzZWxpbmVTaGlmdCcsXG4gICdiYXNlbGluZS1zaGlmdCc6ICdiYXNlbGluZVNoaWZ0JyxcbiAgYmFzZXByb2ZpbGU6ICdiYXNlUHJvZmlsZScsXG4gIGJib3g6ICdiYm94JyxcbiAgYmVnaW46ICdiZWdpbicsXG4gIGJpYXM6ICdiaWFzJyxcbiAgYnk6ICdieScsXG4gIGNhbGNtb2RlOiAnY2FsY01vZGUnLFxuICBjYXBoZWlnaHQ6ICdjYXBIZWlnaHQnLFxuICAnY2FwLWhlaWdodCc6ICdjYXBIZWlnaHQnLFxuICBjbGlwOiAnY2xpcCcsXG4gIGNsaXBwYXRoOiAnY2xpcFBhdGgnLFxuICAnY2xpcC1wYXRoJzogJ2NsaXBQYXRoJyxcbiAgY2xpcHBhdGh1bml0czogJ2NsaXBQYXRoVW5pdHMnLFxuICBjbGlwcnVsZTogJ2NsaXBSdWxlJyxcbiAgJ2NsaXAtcnVsZSc6ICdjbGlwUnVsZScsXG4gIGNvbG9yOiAnY29sb3InLFxuICBjb2xvcmludGVycG9sYXRpb246ICdjb2xvckludGVycG9sYXRpb24nLFxuICAnY29sb3ItaW50ZXJwb2xhdGlvbic6ICdjb2xvckludGVycG9sYXRpb24nLFxuICBjb2xvcmludGVycG9sYXRpb25maWx0ZXJzOiAnY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVycycsXG4gICdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnOiAnY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVycycsXG4gIGNvbG9ycHJvZmlsZTogJ2NvbG9yUHJvZmlsZScsXG4gICdjb2xvci1wcm9maWxlJzogJ2NvbG9yUHJvZmlsZScsXG4gIGNvbG9ycmVuZGVyaW5nOiAnY29sb3JSZW5kZXJpbmcnLFxuICAnY29sb3ItcmVuZGVyaW5nJzogJ2NvbG9yUmVuZGVyaW5nJyxcbiAgY29udGVudHNjcmlwdHR5cGU6ICdjb250ZW50U2NyaXB0VHlwZScsXG4gIGNvbnRlbnRzdHlsZXR5cGU6ICdjb250ZW50U3R5bGVUeXBlJyxcbiAgY3Vyc29yOiAnY3Vyc29yJyxcbiAgY3g6ICdjeCcsXG4gIGN5OiAnY3knLFxuICBkOiAnZCcsXG4gIGRhdGF0eXBlOiAnZGF0YXR5cGUnLFxuICBkZWNlbGVyYXRlOiAnZGVjZWxlcmF0ZScsXG4gIGRlc2NlbnQ6ICdkZXNjZW50JyxcbiAgZGlmZnVzZWNvbnN0YW50OiAnZGlmZnVzZUNvbnN0YW50JyxcbiAgZGlyZWN0aW9uOiAnZGlyZWN0aW9uJyxcbiAgZGlzcGxheTogJ2Rpc3BsYXknLFxuICBkaXZpc29yOiAnZGl2aXNvcicsXG4gIGRvbWluYW50YmFzZWxpbmU6ICdkb21pbmFudEJhc2VsaW5lJyxcbiAgJ2RvbWluYW50LWJhc2VsaW5lJzogJ2RvbWluYW50QmFzZWxpbmUnLFxuICBkdXI6ICdkdXInLFxuICBkeDogJ2R4JyxcbiAgZHk6ICdkeScsXG4gIGVkZ2Vtb2RlOiAnZWRnZU1vZGUnLFxuICBlbGV2YXRpb246ICdlbGV2YXRpb24nLFxuICBlbmFibGViYWNrZ3JvdW5kOiAnZW5hYmxlQmFja2dyb3VuZCcsXG4gICdlbmFibGUtYmFja2dyb3VuZCc6ICdlbmFibGVCYWNrZ3JvdW5kJyxcbiAgZW5kOiAnZW5kJyxcbiAgZXhwb25lbnQ6ICdleHBvbmVudCcsXG4gIGV4dGVybmFscmVzb3VyY2VzcmVxdWlyZWQ6ICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJyxcbiAgZmlsbDogJ2ZpbGwnLFxuICBmaWxsb3BhY2l0eTogJ2ZpbGxPcGFjaXR5JyxcbiAgJ2ZpbGwtb3BhY2l0eSc6ICdmaWxsT3BhY2l0eScsXG4gIGZpbGxydWxlOiAnZmlsbFJ1bGUnLFxuICAnZmlsbC1ydWxlJzogJ2ZpbGxSdWxlJyxcbiAgZmlsdGVyOiAnZmlsdGVyJyxcbiAgZmlsdGVycmVzOiAnZmlsdGVyUmVzJyxcbiAgZmlsdGVydW5pdHM6ICdmaWx0ZXJVbml0cycsXG4gIGZsb29kb3BhY2l0eTogJ2Zsb29kT3BhY2l0eScsXG4gICdmbG9vZC1vcGFjaXR5JzogJ2Zsb29kT3BhY2l0eScsXG4gIGZsb29kY29sb3I6ICdmbG9vZENvbG9yJyxcbiAgJ2Zsb29kLWNvbG9yJzogJ2Zsb29kQ29sb3InLFxuICBmb2N1c2FibGU6ICdmb2N1c2FibGUnLFxuICBmb250ZmFtaWx5OiAnZm9udEZhbWlseScsXG4gICdmb250LWZhbWlseSc6ICdmb250RmFtaWx5JyxcbiAgZm9udHNpemU6ICdmb250U2l6ZScsXG4gICdmb250LXNpemUnOiAnZm9udFNpemUnLFxuICBmb250c2l6ZWFkanVzdDogJ2ZvbnRTaXplQWRqdXN0JyxcbiAgJ2ZvbnQtc2l6ZS1hZGp1c3QnOiAnZm9udFNpemVBZGp1c3QnLFxuICBmb250c3RyZXRjaDogJ2ZvbnRTdHJldGNoJyxcbiAgJ2ZvbnQtc3RyZXRjaCc6ICdmb250U3RyZXRjaCcsXG4gIGZvbnRzdHlsZTogJ2ZvbnRTdHlsZScsXG4gICdmb250LXN0eWxlJzogJ2ZvbnRTdHlsZScsXG4gIGZvbnR2YXJpYW50OiAnZm9udFZhcmlhbnQnLFxuICAnZm9udC12YXJpYW50JzogJ2ZvbnRWYXJpYW50JyxcbiAgZm9udHdlaWdodDogJ2ZvbnRXZWlnaHQnLFxuICAnZm9udC13ZWlnaHQnOiAnZm9udFdlaWdodCcsXG4gIGZvcm1hdDogJ2Zvcm1hdCcsXG4gIGZyb206ICdmcm9tJyxcbiAgZng6ICdmeCcsXG4gIGZ5OiAnZnknLFxuICBnMTogJ2cxJyxcbiAgZzI6ICdnMicsXG4gIGdseXBobmFtZTogJ2dseXBoTmFtZScsXG4gICdnbHlwaC1uYW1lJzogJ2dseXBoTmFtZScsXG4gIGdseXBob3JpZW50YXRpb25ob3Jpem9udGFsOiAnZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWwnLFxuICAnZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCc6ICdnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbCcsXG4gIGdseXBob3JpZW50YXRpb252ZXJ0aWNhbDogJ2dseXBoT3JpZW50YXRpb25WZXJ0aWNhbCcsXG4gICdnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCc6ICdnbHlwaE9yaWVudGF0aW9uVmVydGljYWwnLFxuICBnbHlwaHJlZjogJ2dseXBoUmVmJyxcbiAgZ3JhZGllbnR0cmFuc2Zvcm06ICdncmFkaWVudFRyYW5zZm9ybScsXG4gIGdyYWRpZW50dW5pdHM6ICdncmFkaWVudFVuaXRzJyxcbiAgaGFuZ2luZzogJ2hhbmdpbmcnLFxuICBob3JpemFkdng6ICdob3JpekFkdlgnLFxuICAnaG9yaXotYWR2LXgnOiAnaG9yaXpBZHZYJyxcbiAgaG9yaXpvcmlnaW54OiAnaG9yaXpPcmlnaW5YJyxcbiAgJ2hvcml6LW9yaWdpbi14JzogJ2hvcml6T3JpZ2luWCcsXG4gIGlkZW9ncmFwaGljOiAnaWRlb2dyYXBoaWMnLFxuICBpbWFnZXJlbmRlcmluZzogJ2ltYWdlUmVuZGVyaW5nJyxcbiAgJ2ltYWdlLXJlbmRlcmluZyc6ICdpbWFnZVJlbmRlcmluZycsXG4gIGluMjogJ2luMicsXG4gICdpbic6ICdpbicsXG4gIGlubGlzdDogJ2lubGlzdCcsXG4gIGludGVyY2VwdDogJ2ludGVyY2VwdCcsXG4gIGsxOiAnazEnLFxuICBrMjogJ2syJyxcbiAgazM6ICdrMycsXG4gIGs0OiAnazQnLFxuICBrOiAnaycsXG4gIGtlcm5lbG1hdHJpeDogJ2tlcm5lbE1hdHJpeCcsXG4gIGtlcm5lbHVuaXRsZW5ndGg6ICdrZXJuZWxVbml0TGVuZ3RoJyxcbiAga2VybmluZzogJ2tlcm5pbmcnLFxuICBrZXlwb2ludHM6ICdrZXlQb2ludHMnLFxuICBrZXlzcGxpbmVzOiAna2V5U3BsaW5lcycsXG4gIGtleXRpbWVzOiAna2V5VGltZXMnLFxuICBsZW5ndGhhZGp1c3Q6ICdsZW5ndGhBZGp1c3QnLFxuICBsZXR0ZXJzcGFjaW5nOiAnbGV0dGVyU3BhY2luZycsXG4gICdsZXR0ZXItc3BhY2luZyc6ICdsZXR0ZXJTcGFjaW5nJyxcbiAgbGlnaHRpbmdjb2xvcjogJ2xpZ2h0aW5nQ29sb3InLFxuICAnbGlnaHRpbmctY29sb3InOiAnbGlnaHRpbmdDb2xvcicsXG4gIGxpbWl0aW5nY29uZWFuZ2xlOiAnbGltaXRpbmdDb25lQW5nbGUnLFxuICBsb2NhbDogJ2xvY2FsJyxcbiAgbWFya2VyZW5kOiAnbWFya2VyRW5kJyxcbiAgJ21hcmtlci1lbmQnOiAnbWFya2VyRW5kJyxcbiAgbWFya2VyaGVpZ2h0OiAnbWFya2VySGVpZ2h0JyxcbiAgbWFya2VybWlkOiAnbWFya2VyTWlkJyxcbiAgJ21hcmtlci1taWQnOiAnbWFya2VyTWlkJyxcbiAgbWFya2Vyc3RhcnQ6ICdtYXJrZXJTdGFydCcsXG4gICdtYXJrZXItc3RhcnQnOiAnbWFya2VyU3RhcnQnLFxuICBtYXJrZXJ1bml0czogJ21hcmtlclVuaXRzJyxcbiAgbWFya2Vyd2lkdGg6ICdtYXJrZXJXaWR0aCcsXG4gIG1hc2s6ICdtYXNrJyxcbiAgbWFza2NvbnRlbnR1bml0czogJ21hc2tDb250ZW50VW5pdHMnLFxuICBtYXNrdW5pdHM6ICdtYXNrVW5pdHMnLFxuICBtYXRoZW1hdGljYWw6ICdtYXRoZW1hdGljYWwnLFxuICBtb2RlOiAnbW9kZScsXG4gIG51bW9jdGF2ZXM6ICdudW1PY3RhdmVzJyxcbiAgb2Zmc2V0OiAnb2Zmc2V0JyxcbiAgb3BhY2l0eTogJ29wYWNpdHknLFxuICBvcGVyYXRvcjogJ29wZXJhdG9yJyxcbiAgb3JkZXI6ICdvcmRlcicsXG4gIG9yaWVudDogJ29yaWVudCcsXG4gIG9yaWVudGF0aW9uOiAnb3JpZW50YXRpb24nLFxuICBvcmlnaW46ICdvcmlnaW4nLFxuICBvdmVyZmxvdzogJ292ZXJmbG93JyxcbiAgb3ZlcmxpbmVwb3NpdGlvbjogJ292ZXJsaW5lUG9zaXRpb24nLFxuICAnb3ZlcmxpbmUtcG9zaXRpb24nOiAnb3ZlcmxpbmVQb3NpdGlvbicsXG4gIG92ZXJsaW5ldGhpY2tuZXNzOiAnb3ZlcmxpbmVUaGlja25lc3MnLFxuICAnb3ZlcmxpbmUtdGhpY2tuZXNzJzogJ292ZXJsaW5lVGhpY2tuZXNzJyxcbiAgcGFpbnRvcmRlcjogJ3BhaW50T3JkZXInLFxuICAncGFpbnQtb3JkZXInOiAncGFpbnRPcmRlcicsXG4gIHBhbm9zZTE6ICdwYW5vc2UxJyxcbiAgJ3Bhbm9zZS0xJzogJ3Bhbm9zZTEnLFxuICBwYXRobGVuZ3RoOiAncGF0aExlbmd0aCcsXG4gIHBhdHRlcm5jb250ZW50dW5pdHM6ICdwYXR0ZXJuQ29udGVudFVuaXRzJyxcbiAgcGF0dGVybnRyYW5zZm9ybTogJ3BhdHRlcm5UcmFuc2Zvcm0nLFxuICBwYXR0ZXJudW5pdHM6ICdwYXR0ZXJuVW5pdHMnLFxuICBwb2ludGVyZXZlbnRzOiAncG9pbnRlckV2ZW50cycsXG4gICdwb2ludGVyLWV2ZW50cyc6ICdwb2ludGVyRXZlbnRzJyxcbiAgcG9pbnRzOiAncG9pbnRzJyxcbiAgcG9pbnRzYXR4OiAncG9pbnRzQXRYJyxcbiAgcG9pbnRzYXR5OiAncG9pbnRzQXRZJyxcbiAgcG9pbnRzYXR6OiAncG9pbnRzQXRaJyxcbiAgcHJlZml4OiAncHJlZml4JyxcbiAgcHJlc2VydmVhbHBoYTogJ3ByZXNlcnZlQWxwaGEnLFxuICBwcmVzZXJ2ZWFzcGVjdHJhdGlvOiAncHJlc2VydmVBc3BlY3RSYXRpbycsXG4gIHByaW1pdGl2ZXVuaXRzOiAncHJpbWl0aXZlVW5pdHMnLFxuICBwcm9wZXJ0eTogJ3Byb3BlcnR5JyxcbiAgcjogJ3InLFxuICByYWRpdXM6ICdyYWRpdXMnLFxuICByZWZ4OiAncmVmWCcsXG4gIHJlZnk6ICdyZWZZJyxcbiAgcmVuZGVyaW5naW50ZW50OiAncmVuZGVyaW5nSW50ZW50JyxcbiAgJ3JlbmRlcmluZy1pbnRlbnQnOiAncmVuZGVyaW5nSW50ZW50JyxcbiAgcmVwZWF0Y291bnQ6ICdyZXBlYXRDb3VudCcsXG4gIHJlcGVhdGR1cjogJ3JlcGVhdER1cicsXG4gIHJlcXVpcmVkZXh0ZW5zaW9uczogJ3JlcXVpcmVkRXh0ZW5zaW9ucycsXG4gIHJlcXVpcmVkZmVhdHVyZXM6ICdyZXF1aXJlZEZlYXR1cmVzJyxcbiAgcmVzb3VyY2U6ICdyZXNvdXJjZScsXG4gIHJlc3RhcnQ6ICdyZXN0YXJ0JyxcbiAgcmVzdWx0OiAncmVzdWx0JyxcbiAgcmVzdWx0czogJ3Jlc3VsdHMnLFxuICByb3RhdGU6ICdyb3RhdGUnLFxuICByeDogJ3J4JyxcbiAgcnk6ICdyeScsXG4gIHNjYWxlOiAnc2NhbGUnLFxuICBzZWN1cml0eTogJ3NlY3VyaXR5JyxcbiAgc2VlZDogJ3NlZWQnLFxuICBzaGFwZXJlbmRlcmluZzogJ3NoYXBlUmVuZGVyaW5nJyxcbiAgJ3NoYXBlLXJlbmRlcmluZyc6ICdzaGFwZVJlbmRlcmluZycsXG4gIHNsb3BlOiAnc2xvcGUnLFxuICBzcGFjaW5nOiAnc3BhY2luZycsXG4gIHNwZWN1bGFyY29uc3RhbnQ6ICdzcGVjdWxhckNvbnN0YW50JyxcbiAgc3BlY3VsYXJleHBvbmVudDogJ3NwZWN1bGFyRXhwb25lbnQnLFxuICBzcGVlZDogJ3NwZWVkJyxcbiAgc3ByZWFkbWV0aG9kOiAnc3ByZWFkTWV0aG9kJyxcbiAgc3RhcnRvZmZzZXQ6ICdzdGFydE9mZnNldCcsXG4gIHN0ZGRldmlhdGlvbjogJ3N0ZERldmlhdGlvbicsXG4gIHN0ZW1oOiAnc3RlbWgnLFxuICBzdGVtdjogJ3N0ZW12JyxcbiAgc3RpdGNodGlsZXM6ICdzdGl0Y2hUaWxlcycsXG4gIHN0b3Bjb2xvcjogJ3N0b3BDb2xvcicsXG4gICdzdG9wLWNvbG9yJzogJ3N0b3BDb2xvcicsXG4gIHN0b3BvcGFjaXR5OiAnc3RvcE9wYWNpdHknLFxuICAnc3RvcC1vcGFjaXR5JzogJ3N0b3BPcGFjaXR5JyxcbiAgc3RyaWtldGhyb3VnaHBvc2l0aW9uOiAnc3RyaWtldGhyb3VnaFBvc2l0aW9uJyxcbiAgJ3N0cmlrZXRocm91Z2gtcG9zaXRpb24nOiAnc3RyaWtldGhyb3VnaFBvc2l0aW9uJyxcbiAgc3RyaWtldGhyb3VnaHRoaWNrbmVzczogJ3N0cmlrZXRocm91Z2hUaGlja25lc3MnLFxuICAnc3RyaWtldGhyb3VnaC10aGlja25lc3MnOiAnc3RyaWtldGhyb3VnaFRoaWNrbmVzcycsXG4gIHN0cmluZzogJ3N0cmluZycsXG4gIHN0cm9rZTogJ3N0cm9rZScsXG4gIHN0cm9rZWRhc2hhcnJheTogJ3N0cm9rZURhc2hhcnJheScsXG4gICdzdHJva2UtZGFzaGFycmF5JzogJ3N0cm9rZURhc2hhcnJheScsXG4gIHN0cm9rZWRhc2hvZmZzZXQ6ICdzdHJva2VEYXNob2Zmc2V0JyxcbiAgJ3N0cm9rZS1kYXNob2Zmc2V0JzogJ3N0cm9rZURhc2hvZmZzZXQnLFxuICBzdHJva2VsaW5lY2FwOiAnc3Ryb2tlTGluZWNhcCcsXG4gICdzdHJva2UtbGluZWNhcCc6ICdzdHJva2VMaW5lY2FwJyxcbiAgc3Ryb2tlbGluZWpvaW46ICdzdHJva2VMaW5lam9pbicsXG4gICdzdHJva2UtbGluZWpvaW4nOiAnc3Ryb2tlTGluZWpvaW4nLFxuICBzdHJva2VtaXRlcmxpbWl0OiAnc3Ryb2tlTWl0ZXJsaW1pdCcsXG4gICdzdHJva2UtbWl0ZXJsaW1pdCc6ICdzdHJva2VNaXRlcmxpbWl0JyxcbiAgc3Ryb2tld2lkdGg6ICdzdHJva2VXaWR0aCcsXG4gICdzdHJva2Utd2lkdGgnOiAnc3Ryb2tlV2lkdGgnLFxuICBzdHJva2VvcGFjaXR5OiAnc3Ryb2tlT3BhY2l0eScsXG4gICdzdHJva2Utb3BhY2l0eSc6ICdzdHJva2VPcGFjaXR5JyxcbiAgc3VwcHJlc3Njb250ZW50ZWRpdGFibGV3YXJuaW5nOiAnc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nJyxcbiAgc3VwcHJlc3NoeWRyYXRpb253YXJuaW5nOiAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJyxcbiAgc3VyZmFjZXNjYWxlOiAnc3VyZmFjZVNjYWxlJyxcbiAgc3lzdGVtbGFuZ3VhZ2U6ICdzeXN0ZW1MYW5ndWFnZScsXG4gIHRhYmxldmFsdWVzOiAndGFibGVWYWx1ZXMnLFxuICB0YXJnZXR4OiAndGFyZ2V0WCcsXG4gIHRhcmdldHk6ICd0YXJnZXRZJyxcbiAgdGV4dGFuY2hvcjogJ3RleHRBbmNob3InLFxuICAndGV4dC1hbmNob3InOiAndGV4dEFuY2hvcicsXG4gIHRleHRkZWNvcmF0aW9uOiAndGV4dERlY29yYXRpb24nLFxuICAndGV4dC1kZWNvcmF0aW9uJzogJ3RleHREZWNvcmF0aW9uJyxcbiAgdGV4dGxlbmd0aDogJ3RleHRMZW5ndGgnLFxuICB0ZXh0cmVuZGVyaW5nOiAndGV4dFJlbmRlcmluZycsXG4gICd0ZXh0LXJlbmRlcmluZyc6ICd0ZXh0UmVuZGVyaW5nJyxcbiAgdG86ICd0bycsXG4gIHRyYW5zZm9ybTogJ3RyYW5zZm9ybScsXG4gICd0eXBlb2YnOiAndHlwZW9mJyxcbiAgdTE6ICd1MScsXG4gIHUyOiAndTInLFxuICB1bmRlcmxpbmVwb3NpdGlvbjogJ3VuZGVybGluZVBvc2l0aW9uJyxcbiAgJ3VuZGVybGluZS1wb3NpdGlvbic6ICd1bmRlcmxpbmVQb3NpdGlvbicsXG4gIHVuZGVybGluZXRoaWNrbmVzczogJ3VuZGVybGluZVRoaWNrbmVzcycsXG4gICd1bmRlcmxpbmUtdGhpY2tuZXNzJzogJ3VuZGVybGluZVRoaWNrbmVzcycsXG4gIHVuaWNvZGU6ICd1bmljb2RlJyxcbiAgdW5pY29kZWJpZGk6ICd1bmljb2RlQmlkaScsXG4gICd1bmljb2RlLWJpZGknOiAndW5pY29kZUJpZGknLFxuICB1bmljb2RlcmFuZ2U6ICd1bmljb2RlUmFuZ2UnLFxuICAndW5pY29kZS1yYW5nZSc6ICd1bmljb2RlUmFuZ2UnLFxuICB1bml0c3BlcmVtOiAndW5pdHNQZXJFbScsXG4gICd1bml0cy1wZXItZW0nOiAndW5pdHNQZXJFbScsXG4gIHVuc2VsZWN0YWJsZTogJ3Vuc2VsZWN0YWJsZScsXG4gIHZhbHBoYWJldGljOiAndkFscGhhYmV0aWMnLFxuICAndi1hbHBoYWJldGljJzogJ3ZBbHBoYWJldGljJyxcbiAgdmFsdWVzOiAndmFsdWVzJyxcbiAgdmVjdG9yZWZmZWN0OiAndmVjdG9yRWZmZWN0JyxcbiAgJ3ZlY3Rvci1lZmZlY3QnOiAndmVjdG9yRWZmZWN0JyxcbiAgdmVyc2lvbjogJ3ZlcnNpb24nLFxuICB2ZXJ0YWR2eTogJ3ZlcnRBZHZZJyxcbiAgJ3ZlcnQtYWR2LXknOiAndmVydEFkdlknLFxuICB2ZXJ0b3JpZ2lueDogJ3ZlcnRPcmlnaW5YJyxcbiAgJ3ZlcnQtb3JpZ2luLXgnOiAndmVydE9yaWdpblgnLFxuICB2ZXJ0b3JpZ2lueTogJ3ZlcnRPcmlnaW5ZJyxcbiAgJ3ZlcnQtb3JpZ2luLXknOiAndmVydE9yaWdpblknLFxuICB2aGFuZ2luZzogJ3ZIYW5naW5nJyxcbiAgJ3YtaGFuZ2luZyc6ICd2SGFuZ2luZycsXG4gIHZpZGVvZ3JhcGhpYzogJ3ZJZGVvZ3JhcGhpYycsXG4gICd2LWlkZW9ncmFwaGljJzogJ3ZJZGVvZ3JhcGhpYycsXG4gIHZpZXdib3g6ICd2aWV3Qm94JyxcbiAgdmlld3RhcmdldDogJ3ZpZXdUYXJnZXQnLFxuICB2aXNpYmlsaXR5OiAndmlzaWJpbGl0eScsXG4gIHZtYXRoZW1hdGljYWw6ICd2TWF0aGVtYXRpY2FsJyxcbiAgJ3YtbWF0aGVtYXRpY2FsJzogJ3ZNYXRoZW1hdGljYWwnLFxuICB2b2NhYjogJ3ZvY2FiJyxcbiAgd2lkdGhzOiAnd2lkdGhzJyxcbiAgd29yZHNwYWNpbmc6ICd3b3JkU3BhY2luZycsXG4gICd3b3JkLXNwYWNpbmcnOiAnd29yZFNwYWNpbmcnLFxuICB3cml0aW5nbW9kZTogJ3dyaXRpbmdNb2RlJyxcbiAgJ3dyaXRpbmctbW9kZSc6ICd3cml0aW5nTW9kZScsXG4gIHgxOiAneDEnLFxuICB4MjogJ3gyJyxcbiAgeDogJ3gnLFxuICB4Y2hhbm5lbHNlbGVjdG9yOiAneENoYW5uZWxTZWxlY3RvcicsXG4gIHhoZWlnaHQ6ICd4SGVpZ2h0JyxcbiAgJ3gtaGVpZ2h0JzogJ3hIZWlnaHQnLFxuICB4bGlua2FjdHVhdGU6ICd4bGlua0FjdHVhdGUnLFxuICAneGxpbms6YWN0dWF0ZSc6ICd4bGlua0FjdHVhdGUnLFxuICB4bGlua2FyY3JvbGU6ICd4bGlua0FyY3JvbGUnLFxuICAneGxpbms6YXJjcm9sZSc6ICd4bGlua0FyY3JvbGUnLFxuICB4bGlua2hyZWY6ICd4bGlua0hyZWYnLFxuICAneGxpbms6aHJlZic6ICd4bGlua0hyZWYnLFxuICB4bGlua3JvbGU6ICd4bGlua1JvbGUnLFxuICAneGxpbms6cm9sZSc6ICd4bGlua1JvbGUnLFxuICB4bGlua3Nob3c6ICd4bGlua1Nob3cnLFxuICAneGxpbms6c2hvdyc6ICd4bGlua1Nob3cnLFxuICB4bGlua3RpdGxlOiAneGxpbmtUaXRsZScsXG4gICd4bGluazp0aXRsZSc6ICd4bGlua1RpdGxlJyxcbiAgeGxpbmt0eXBlOiAneGxpbmtUeXBlJyxcbiAgJ3hsaW5rOnR5cGUnOiAneGxpbmtUeXBlJyxcbiAgeG1sYmFzZTogJ3htbEJhc2UnLFxuICAneG1sOmJhc2UnOiAneG1sQmFzZScsXG4gIHhtbGxhbmc6ICd4bWxMYW5nJyxcbiAgJ3htbDpsYW5nJzogJ3htbExhbmcnLFxuICB4bWxuczogJ3htbG5zJyxcbiAgJ3htbDpzcGFjZSc6ICd4bWxTcGFjZScsXG4gIHhtbG5zeGxpbms6ICd4bWxuc1hsaW5rJyxcbiAgJ3htbG5zOnhsaW5rJzogJ3htbG5zWGxpbmsnLFxuICB4bWxzcGFjZTogJ3htbFNwYWNlJyxcbiAgeTE6ICd5MScsXG4gIHkyOiAneTInLFxuICB5OiAneScsXG4gIHljaGFubmVsc2VsZWN0b3I6ICd5Q2hhbm5lbFNlbGVjdG9yJyxcbiAgejogJ3onLFxuICB6b29tYW5kcGFuOiAnem9vbUFuZFBhbidcbn07XG5cbmZ1bmN0aW9uIGdldFN0YWNrQWRkZW5kdW0kMigpIHtcbiAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG4gIHJldHVybiBzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJztcbn1cblxue1xuICB2YXIgd2FybmVkUHJvcGVydGllcyQxID0ge307XG4gIHZhciBoYXNPd25Qcm9wZXJ0eSQxID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIEVWRU5UX05BTUVfUkVHRVggPSAvXm9uLi87XG4gIHZhciBJTlZBTElEX0VWRU5UX05BTUVfUkVHRVggPSAvXm9uW15BLVpdLztcbiAgdmFyIHJBUklBJDEgPSBuZXcgUmVnRXhwKCdeKGFyaWEpLVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcbiAgdmFyIHJBUklBQ2FtZWwkMSA9IG5ldyBSZWdFeHAoJ14oYXJpYSlbQS1aXVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcblxuICB2YXIgdmFsaWRhdGVQcm9wZXJ0eSQxID0gZnVuY3Rpb24gKHRhZ05hbWUsIG5hbWUsIHZhbHVlLCBjYW5Vc2VFdmVudFN5c3RlbSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSQxLmNhbGwod2FybmVkUHJvcGVydGllcyQxLCBuYW1lKSAmJiB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdvbmZvY3VzaW4nIHx8IGxvd2VyQ2FzZWROYW1lID09PSAnb25mb2N1c291dCcpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWFjdCB1c2VzIG9uRm9jdXMgYW5kIG9uQmx1ciBpbnN0ZWFkIG9mIG9uRm9jdXNJbiBhbmQgb25Gb2N1c091dC4gJyArICdBbGwgUmVhY3QgZXZlbnRzIGFyZSBub3JtYWxpemVkIHRvIGJ1YmJsZSwgc28gb25Gb2N1c0luIGFuZCBvbkZvY3VzT3V0ICcgKyAnYXJlIG5vdCBuZWVkZWQvc3VwcG9ydGVkIGJ5IFJlYWN0LicpO1xuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIFdlIGNhbid0IHJlbHkgb24gdGhlIGV2ZW50IHN5c3RlbSBiZWluZyBpbmplY3RlZCBvbiB0aGUgc2VydmVyLlxuICAgIGlmIChjYW5Vc2VFdmVudFN5c3RlbSkge1xuICAgICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSA/IHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXNbbG93ZXJDYXNlZE5hbWVdIDogbnVsbDtcbiAgICAgIGlmIChyZWdpc3RyYXRpb25OYW1lICE9IG51bGwpIHtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8lcycsIG5hbWUsIHJlZ2lzdHJhdGlvbk5hbWUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdVbmtub3duIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gSXQgd2lsbCBiZSBpZ25vcmVkLiVzJywgbmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKEVWRU5UX05BTUVfUkVHRVgudGVzdChuYW1lKSkge1xuICAgICAgLy8gSWYgbm8gZXZlbnQgcGx1Z2lucyBoYXZlIGJlZW4gaW5qZWN0ZWQsIHdlIGFyZSBpbiBhIHNlcnZlciBlbnZpcm9ubWVudC5cbiAgICAgIC8vIFNvIHdlIGNhbid0IHRlbGwgaWYgdGhlIGV2ZW50IG5hbWUgaXMgY29ycmVjdCBmb3Igc3VyZSwgYnV0IHdlIGNhbiBmaWx0ZXJcbiAgICAgIC8vIG91dCBrbm93biBiYWQgb25lcyBsaWtlIGBvbmNsaWNrYC4gV2UgY2FuJ3Qgc3VnZ2VzdCBhIHNwZWNpZmljIHJlcGxhY2VtZW50IHRob3VnaC5cbiAgICAgIGlmIChJTlZBTElEX0VWRU5UX05BTUVfUkVHRVgudGVzdChuYW1lKSkge1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBldmVudCBoYW5kbGVyIHByb3BlcnR5IGAlc2AuICcgKyAnUmVhY3QgZXZlbnRzIHVzZSB0aGUgY2FtZWxDYXNlIG5hbWluZyBjb252ZW50aW9uLCBmb3IgZXhhbXBsZSBgb25DbGlja2AuJXMnLCBuYW1lLCBnZXRTdGFja0FkZGVuZHVtJDIoKSk7XG4gICAgICB9XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gTGV0IHRoZSBBUklBIGF0dHJpYnV0ZSBob29rIHZhbGlkYXRlIEFSSUEgYXR0cmlidXRlc1xuICAgIGlmIChyQVJJQSQxLnRlc3QobmFtZSkgfHwgckFSSUFDYW1lbCQxLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChsb3dlckNhc2VkTmFtZSA9PT0gJ2lubmVyaHRtbCcpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdEaXJlY3RseSBzZXR0aW5nIHByb3BlcnR5IGBpbm5lckhUTUxgIGlzIG5vdCBwZXJtaXR0ZWQuICcgKyAnRm9yIG1vcmUgaW5mb3JtYXRpb24sIGxvb2t1cCBkb2N1bWVudGF0aW9uIG9uIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuJyk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnYXJpYScpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdUaGUgYGFyaWFgIGF0dHJpYnV0ZSBpcyByZXNlcnZlZCBmb3IgZnV0dXJlIHVzZSBpbiBSZWFjdC4gJyArICdQYXNzIGluZGl2aWR1YWwgYGFyaWEtYCBhdHRyaWJ1dGVzIGluc3RlYWQuJyk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnaXMnICYmIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1JlY2VpdmVkIGEgYCVzYCBmb3IgYSBzdHJpbmcgYXR0cmlidXRlIGBpc2AuIElmIHRoaXMgaXMgZXhwZWN0ZWQsIGNhc3QgJyArICd0aGUgdmFsdWUgdG8gYSBzdHJpbmcuJXMnLCB0eXBlb2YgdmFsdWUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWx1ZSkpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWNlaXZlZCBOYU4gZm9yIHRoZSBgJXNgIGF0dHJpYnV0ZS4gSWYgdGhpcyBpcyBleHBlY3RlZCwgY2FzdCAnICsgJ3RoZSB2YWx1ZSB0byBhIHN0cmluZy4lcycsIG5hbWUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgaXNSZXNlcnZlZCA9IGlzUmVzZXJ2ZWRQcm9wKG5hbWUpO1xuXG4gICAgLy8gS25vd24gYXR0cmlidXRlcyBzaG91bGQgbWF0Y2ggdGhlIGNhc2luZyBzcGVjaWZpZWQgaW4gdGhlIHByb3BlcnR5IGNvbmZpZy5cbiAgICBpZiAocG9zc2libGVTdGFuZGFyZE5hbWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSkge1xuICAgICAgdmFyIHN0YW5kYXJkTmFtZSA9IHBvc3NpYmxlU3RhbmRhcmROYW1lc1tsb3dlckNhc2VkTmFtZV07XG4gICAgICBpZiAoc3RhbmRhcmROYW1lICE9PSBuYW1lKSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIERPTSBwcm9wZXJ0eSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8lcycsIG5hbWUsIHN0YW5kYXJkTmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc1Jlc2VydmVkICYmIG5hbWUgIT09IGxvd2VyQ2FzZWROYW1lKSB7XG4gICAgICAvLyBVbmtub3duIGF0dHJpYnV0ZXMgc2hvdWxkIGhhdmUgbG93ZXJjYXNlIGNhc2luZyBzaW5jZSB0aGF0J3MgaG93IHRoZXlcbiAgICAgIC8vIHdpbGwgYmUgY2FzZWQgYW55d2F5IHdpdGggc2VydmVyIHJlbmRlcmluZy5cbiAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWFjdCBkb2VzIG5vdCByZWNvZ25pemUgdGhlIGAlc2AgcHJvcCBvbiBhIERPTSBlbGVtZW50LiBJZiB5b3UgJyArICdpbnRlbnRpb25hbGx5IHdhbnQgaXQgdG8gYXBwZWFyIGluIHRoZSBET00gYXMgYSBjdXN0b20gJyArICdhdHRyaWJ1dGUsIHNwZWxsIGl0IGFzIGxvd2VyY2FzZSBgJXNgIGluc3RlYWQuICcgKyAnSWYgeW91IGFjY2lkZW50YWxseSBwYXNzZWQgaXQgZnJvbSBhIHBhcmVudCBjb21wb25lbnQsIHJlbW92ZSAnICsgJ2l0IGZyb20gdGhlIERPTSBlbGVtZW50LiVzJywgbmFtZSwgbG93ZXJDYXNlZE5hbWUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgJiYgIXNob3VsZEF0dHJpYnV0ZUFjY2VwdEJvb2xlYW5WYWx1ZShuYW1lKSkge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWNlaXZlZCBgJXNgIGZvciBhIG5vbi1ib29sZWFuIGF0dHJpYnV0ZSBgJXNgLlxcblxcbicgKyAnSWYgeW91IHdhbnQgdG8gd3JpdGUgaXQgdG8gdGhlIERPTSwgcGFzcyBhIHN0cmluZyBpbnN0ZWFkOiAnICsgJyVzPVwiJXNcIiBvciAlcz17dmFsdWUudG9TdHJpbmcoKX0uJXMnLCB2YWx1ZSwgbmFtZSwgbmFtZSwgdmFsdWUsIG5hbWUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWNlaXZlZCBgJXNgIGZvciBhIG5vbi1ib29sZWFuIGF0dHJpYnV0ZSBgJXNgLlxcblxcbicgKyAnSWYgeW91IHdhbnQgdG8gd3JpdGUgaXQgdG8gdGhlIERPTSwgcGFzcyBhIHN0cmluZyBpbnN0ZWFkOiAnICsgJyVzPVwiJXNcIiBvciAlcz17dmFsdWUudG9TdHJpbmcoKX0uXFxuXFxuJyArICdJZiB5b3UgdXNlZCB0byBjb25kaXRpb25hbGx5IG9taXQgaXQgd2l0aCAlcz17Y29uZGl0aW9uICYmIHZhbHVlfSwgJyArICdwYXNzICVzPXtjb25kaXRpb24gPyB2YWx1ZSA6IHVuZGVmaW5lZH0gaW5zdGVhZC4lcycsIHZhbHVlLCBuYW1lLCBuYW1lLCB2YWx1ZSwgbmFtZSwgbmFtZSwgbmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgfVxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIE5vdyB0aGF0IHdlJ3ZlIHZhbGlkYXRlZCBjYXNpbmcsIGRvIG5vdCB2YWxpZGF0ZVxuICAgIC8vIGRhdGEgdHlwZXMgZm9yIHJlc2VydmVkIHByb3BzXG4gICAgaWYgKGlzUmVzZXJ2ZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIFdhcm4gd2hlbiBhIGtub3duIGF0dHJpYnV0ZSBpcyBhIGJhZCB0eXBlXG4gICAgaWYgKCFzaG91bGRTZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpKSB7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xufVxuXG52YXIgd2FyblVua25vd25Qcm9wZXJ0aWVzID0gZnVuY3Rpb24gKHR5cGUsIHByb3BzLCBjYW5Vc2VFdmVudFN5c3RlbSkge1xuICB2YXIgdW5rbm93blByb3BzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgIHZhciBpc1ZhbGlkID0gdmFsaWRhdGVQcm9wZXJ0eSQxKHR5cGUsIGtleSwgcHJvcHNba2V5XSwgY2FuVXNlRXZlbnRTeXN0ZW0pO1xuICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgdW5rbm93blByb3BzLnB1c2goa2V5KTtcbiAgICB9XG4gIH1cblxuICB2YXIgdW5rbm93blByb3BTdHJpbmcgPSB1bmtub3duUHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgcmV0dXJuICdgJyArIHByb3AgKyAnYCc7XG4gIH0pLmpvaW4oJywgJyk7XG4gIGlmICh1bmtub3duUHJvcHMubGVuZ3RoID09PSAxKSB7XG4gICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgdmFsdWUgZm9yIHByb3AgJXMgb24gPCVzPiB0YWcuIEVpdGhlciByZW1vdmUgaXQgZnJvbSB0aGUgZWxlbWVudCwgJyArICdvciBwYXNzIGEgc3RyaW5nIG9yIG51bWJlciB2YWx1ZSB0byBrZWVwIGl0IGluIHRoZSBET00uICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL2ZiLm1lL3JlYWN0LWF0dHJpYnV0ZS1iZWhhdmlvciVzJywgdW5rbm93blByb3BTdHJpbmcsIHR5cGUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgfSBlbHNlIGlmICh1bmtub3duUHJvcHMubGVuZ3RoID4gMSkge1xuICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIHZhbHVlcyBmb3IgcHJvcHMgJXMgb24gPCVzPiB0YWcuIEVpdGhlciByZW1vdmUgdGhlbSBmcm9tIHRoZSBlbGVtZW50LCAnICsgJ29yIHBhc3MgYSBzdHJpbmcgb3IgbnVtYmVyIHZhbHVlIHRvIGtlZXAgdGhlbSBpbiB0aGUgRE9NLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC1hdHRyaWJ1dGUtYmVoYXZpb3IlcycsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlLCBnZXRTdGFja0FkZGVuZHVtJDIoKSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyQyKHR5cGUsIHByb3BzLCBjYW5Vc2VFdmVudFN5c3RlbSkge1xuICBpZiAoaXNDdXN0b21Db21wb25lbnQodHlwZSwgcHJvcHMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdhcm5Vbmtub3duUHJvcGVydGllcyh0eXBlLCBwcm9wcywgY2FuVXNlRXZlbnRTeXN0ZW0pO1xufVxuXG4vLyBUT0RPOiBkaXJlY3QgaW1wb3J0cyBsaWtlIHNvbWUtcGFja2FnZS9zcmMvKiBhcmUgYmFkLiBGaXggbWUuXG52YXIgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lJDEgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlck93bmVyTmFtZTtcbnZhciBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDIgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW07XG5cbnZhciBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IGZhbHNlO1xudmFyIGRpZFdhcm5TaGFkeURPTSA9IGZhbHNlO1xuXG52YXIgREFOR0VST1VTTFlfU0VUX0lOTkVSX0hUTUwgPSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnO1xudmFyIFNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklORyA9ICdzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcnO1xudmFyIFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDEgPSAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJztcbnZhciBBVVRPRk9DVVMgPSAnYXV0b0ZvY3VzJztcbnZhciBDSElMRFJFTiA9ICdjaGlsZHJlbic7XG52YXIgU1RZTEUgPSAnc3R5bGUnO1xudmFyIEhUTUwgPSAnX19odG1sJztcblxudmFyIEhUTUxfTkFNRVNQQUNFID0gTmFtZXNwYWNlcy5odG1sO1xuXG5cbnZhciBnZXRTdGFjayA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnMoJycpO1xuXG57XG4gIGdldFN0YWNrID0gZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQyO1xuXG4gIHZhciB3YXJuZWRVbmtub3duVGFncyA9IHtcbiAgICAvLyBDaHJvbWUgaXMgdGhlIG9ubHkgbWFqb3IgYnJvd3NlciBub3Qgc2hpcHBpbmcgPHRpbWU+LiBCdXQgYXMgb2YgSnVseVxuICAgIC8vIDIwMTcgaXQgaW50ZW5kcyB0byBzaGlwIGl0IGR1ZSB0byB3aWRlc3ByZWFkIHVzYWdlLiBXZSBpbnRlbnRpb25hbGx5XG4gICAgLy8gKmRvbid0KiB3YXJuIGZvciA8dGltZT4gZXZlbiBpZiBpdCdzIHVucmVjb2duaXplZCBieSBDaHJvbWUgYmVjYXVzZVxuICAgIC8vIGl0IHNvb24gd2lsbCBiZSwgYW5kIG1hbnkgYXBwcyBoYXZlIGJlZW4gdXNpbmcgaXQgYW55d2F5LlxuICAgIHRpbWU6IHRydWUsXG4gICAgLy8gVGhlcmUgYXJlIHdvcmtpbmcgcG9seWZpbGxzIGZvciA8ZGlhbG9nPi4gTGV0IHBlb3BsZSB1c2UgaXQuXG4gICAgZGlhbG9nOiB0cnVlXG4gIH07XG5cbiAgdmFyIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQgPSBmdW5jdGlvbiAodHlwZSwgcHJvcHMpIHtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXModHlwZSwgcHJvcHMpO1xuICAgIHZhbGlkYXRlUHJvcGVydGllcyQxKHR5cGUsIHByb3BzKTtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXMkMih0eXBlLCBwcm9wcywgLyogY2FuVXNlRXZlbnRTeXN0ZW0gKi90cnVlKTtcbiAgfTtcblxuICAvLyBIVE1MIHBhcnNpbmcgbm9ybWFsaXplcyBDUiBhbmQgQ1JMRiB0byBMRi5cbiAgLy8gSXQgYWxzbyBjYW4gdHVybiBcXHUwMDAwIGludG8gXFx1RkZGRCBpbnNpZGUgYXR0cmlidXRlcy5cbiAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L3NpbmdsZS1wYWdlLmh0bWwjcHJlcHJvY2Vzc2luZy10aGUtaW5wdXQtc3RyZWFtXG4gIC8vIElmIHdlIGhhdmUgYSBtaXNtYXRjaCwgaXQgbWlnaHQgYmUgY2F1c2VkIGJ5IHRoYXQuXG4gIC8vIFdlIHdpbGwgc3RpbGwgcGF0Y2ggdXAgaW4gdGhpcyBjYXNlIGJ1dCBub3QgZmlyZSB0aGUgd2FybmluZy5cbiAgdmFyIE5PUk1BTElaRV9ORVdMSU5FU19SRUdFWCA9IC9cXHJcXG4/L2c7XG4gIHZhciBOT1JNQUxJWkVfTlVMTF9BTkRfUkVQTEFDRU1FTlRfUkVHRVggPSAvXFx1MDAwMHxcXHVGRkZEL2c7XG5cbiAgdmFyIG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChtYXJrdXApIHtcbiAgICB2YXIgbWFya3VwU3RyaW5nID0gdHlwZW9mIG1hcmt1cCA9PT0gJ3N0cmluZycgPyBtYXJrdXAgOiAnJyArIG1hcmt1cDtcbiAgICByZXR1cm4gbWFya3VwU3RyaW5nLnJlcGxhY2UoTk9STUFMSVpFX05FV0xJTkVTX1JFR0VYLCAnXFxuJykucmVwbGFjZShOT1JNQUxJWkVfTlVMTF9BTkRfUkVQTEFDRU1FTlRfUkVHRVgsICcnKTtcbiAgfTtcblxuICB2YXIgd2FybkZvclRleHREaWZmZXJlbmNlID0gZnVuY3Rpb24gKHNlcnZlclRleHQsIGNsaWVudFRleHQpIHtcbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5vcm1hbGl6ZWRDbGllbnRUZXh0ID0gbm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlKGNsaWVudFRleHQpO1xuICAgIHZhciBub3JtYWxpemVkU2VydmVyVGV4dCA9IG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZShzZXJ2ZXJUZXh0KTtcbiAgICBpZiAobm9ybWFsaXplZFNlcnZlclRleHQgPT09IG5vcm1hbGl6ZWRDbGllbnRUZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnVGV4dCBjb250ZW50IGRpZCBub3QgbWF0Y2guIFNlcnZlcjogXCIlc1wiIENsaWVudDogXCIlc1wiJywgbm9ybWFsaXplZFNlcnZlclRleHQsIG5vcm1hbGl6ZWRDbGllbnRUZXh0KTtcbiAgfTtcblxuICB2YXIgd2FybkZvclByb3BEaWZmZXJlbmNlID0gZnVuY3Rpb24gKHByb3BOYW1lLCBzZXJ2ZXJWYWx1ZSwgY2xpZW50VmFsdWUpIHtcbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5vcm1hbGl6ZWRDbGllbnRWYWx1ZSA9IG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZShjbGllbnRWYWx1ZSk7XG4gICAgdmFyIG5vcm1hbGl6ZWRTZXJ2ZXJWYWx1ZSA9IG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZShzZXJ2ZXJWYWx1ZSk7XG4gICAgaWYgKG5vcm1hbGl6ZWRTZXJ2ZXJWYWx1ZSA9PT0gbm9ybWFsaXplZENsaWVudFZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnUHJvcCBgJXNgIGRpZCBub3QgbWF0Y2guIFNlcnZlcjogJXMgQ2xpZW50OiAlcycsIHByb3BOYW1lLCBKU09OLnN0cmluZ2lmeShub3JtYWxpemVkU2VydmVyVmFsdWUpLCBKU09OLnN0cmluZ2lmeShub3JtYWxpemVkQ2xpZW50VmFsdWUpKTtcbiAgfTtcblxuICB2YXIgd2FybkZvckV4dHJhQXR0cmlidXRlcyA9IGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lcykge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgdmFyIG5hbWVzID0gW107XG4gICAgYXR0cmlidXRlTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgbmFtZXMucHVzaChuYW1lKTtcbiAgICB9KTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnRXh0cmEgYXR0cmlidXRlcyBmcm9tIHRoZSBzZXJ2ZXI6ICVzJywgbmFtZXMpO1xuICB9O1xuXG4gIHZhciB3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAocmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIgPT09IGZhbHNlKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnRXhwZWN0ZWQgYCVzYCBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLCBpbnN0ZWFkIGdvdCBgZmFsc2VgLlxcblxcbicgKyAnSWYgeW91IHVzZWQgdG8gY29uZGl0aW9uYWxseSBvbWl0IGl0IHdpdGggJXM9e2NvbmRpdGlvbiAmJiB2YWx1ZX0sICcgKyAncGFzcyAlcz17Y29uZGl0aW9uID8gdmFsdWUgOiB1bmRlZmluZWR9IGluc3RlYWQuJXMnLCByZWdpc3RyYXRpb25OYW1lLCByZWdpc3RyYXRpb25OYW1lLCByZWdpc3RyYXRpb25OYW1lLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDIoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdFeHBlY3RlZCBgJXNgIGxpc3RlbmVyIHRvIGJlIGEgZnVuY3Rpb24sIGluc3RlYWQgZ290IGEgdmFsdWUgb2YgYCVzYCB0eXBlLiVzJywgcmVnaXN0cmF0aW9uTmFtZSwgdHlwZW9mIGxpc3RlbmVyLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDIoKSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFBhcnNlIHRoZSBIVE1MIGFuZCByZWFkIGl0IGJhY2sgdG8gbm9ybWFsaXplIHRoZSBIVE1MIHN0cmluZyBzbyB0aGF0IGl0XG4gIC8vIGNhbiBiZSB1c2VkIGZvciBjb21wYXJpc29uLlxuICB2YXIgbm9ybWFsaXplSFRNTCA9IGZ1bmN0aW9uIChwYXJlbnQsIGh0bWwpIHtcbiAgICAvLyBXZSBjb3VsZCBoYXZlIGNyZWF0ZWQgYSBzZXBhcmF0ZSBkb2N1bWVudCBoZXJlIHRvIGF2b2lkXG4gICAgLy8gcmUtaW5pdGlhbGl6aW5nIGN1c3RvbSBlbGVtZW50cyBpZiB0aGV5IGV4aXN0LiBCdXQgdGhpcyBicmVha3NcbiAgICAvLyBob3cgPG5vc2NyaXB0PiBpcyBiZWluZyBoYW5kbGVkLiBTbyB3ZSB1c2UgdGhlIHNhbWUgZG9jdW1lbnQuXG4gICAgLy8gU2VlIHRoZSBkaXNjdXNzaW9uIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzExMTU3LlxuICAgIHZhciB0ZXN0RWxlbWVudCA9IHBhcmVudC5uYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFID8gcGFyZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChwYXJlbnQudGFnTmFtZSkgOiBwYXJlbnQub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50TlMocGFyZW50Lm5hbWVzcGFjZVVSSSwgcGFyZW50LnRhZ05hbWUpO1xuICAgIHRlc3RFbGVtZW50LmlubmVySFRNTCA9IGh0bWw7XG4gICAgcmV0dXJuIHRlc3RFbGVtZW50LmlubmVySFRNTDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgdmFyIGlzRG9jdW1lbnRPckZyYWdtZW50ID0gcm9vdENvbnRhaW5lckVsZW1lbnQubm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUgfHwgcm9vdENvbnRhaW5lckVsZW1lbnQubm9kZVR5cGUgPT09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREU7XG4gIHZhciBkb2MgPSBpc0RvY3VtZW50T3JGcmFnbWVudCA/IHJvb3RDb250YWluZXJFbGVtZW50IDogcm9vdENvbnRhaW5lckVsZW1lbnQub3duZXJEb2N1bWVudDtcbiAgbGlzdGVuVG8ocmVnaXN0cmF0aW9uTmFtZSwgZG9jKTtcbn1cblxuZnVuY3Rpb24gZ2V0T3duZXJEb2N1bWVudEZyb21Sb290Q29udGFpbmVyKHJvb3RDb250YWluZXJFbGVtZW50KSB7XG4gIHJldHVybiByb290Q29udGFpbmVyRWxlbWVudC5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSA/IHJvb3RDb250YWluZXJFbGVtZW50IDogcm9vdENvbnRhaW5lckVsZW1lbnQub3duZXJEb2N1bWVudDtcbn1cblxuLy8gVGhlcmUgYXJlIHNvIG1hbnkgbWVkaWEgZXZlbnRzLCBpdCBtYWtlcyBzZW5zZSB0byBqdXN0XG4vLyBtYWludGFpbiBhIGxpc3QgcmF0aGVyIHRoYW4gY3JlYXRlIGEgYHRyYXBCdWJibGVkRXZlbnRgIGZvciBlYWNoXG52YXIgbWVkaWFFdmVudHMgPSB7XG4gIHRvcEFib3J0OiAnYWJvcnQnLFxuICB0b3BDYW5QbGF5OiAnY2FucGxheScsXG4gIHRvcENhblBsYXlUaHJvdWdoOiAnY2FucGxheXRocm91Z2gnLFxuICB0b3BEdXJhdGlvbkNoYW5nZTogJ2R1cmF0aW9uY2hhbmdlJyxcbiAgdG9wRW1wdGllZDogJ2VtcHRpZWQnLFxuICB0b3BFbmNyeXB0ZWQ6ICdlbmNyeXB0ZWQnLFxuICB0b3BFbmRlZDogJ2VuZGVkJyxcbiAgdG9wRXJyb3I6ICdlcnJvcicsXG4gIHRvcExvYWRlZERhdGE6ICdsb2FkZWRkYXRhJyxcbiAgdG9wTG9hZGVkTWV0YWRhdGE6ICdsb2FkZWRtZXRhZGF0YScsXG4gIHRvcExvYWRTdGFydDogJ2xvYWRzdGFydCcsXG4gIHRvcFBhdXNlOiAncGF1c2UnLFxuICB0b3BQbGF5OiAncGxheScsXG4gIHRvcFBsYXlpbmc6ICdwbGF5aW5nJyxcbiAgdG9wUHJvZ3Jlc3M6ICdwcm9ncmVzcycsXG4gIHRvcFJhdGVDaGFuZ2U6ICdyYXRlY2hhbmdlJyxcbiAgdG9wU2Vla2VkOiAnc2Vla2VkJyxcbiAgdG9wU2Vla2luZzogJ3NlZWtpbmcnLFxuICB0b3BTdGFsbGVkOiAnc3RhbGxlZCcsXG4gIHRvcFN1c3BlbmQ6ICdzdXNwZW5kJyxcbiAgdG9wVGltZVVwZGF0ZTogJ3RpbWV1cGRhdGUnLFxuICB0b3BWb2x1bWVDaGFuZ2U6ICd2b2x1bWVjaGFuZ2UnLFxuICB0b3BXYWl0aW5nOiAnd2FpdGluZydcbn07XG5cbmZ1bmN0aW9uIHRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50KG5vZGUpIHtcbiAgLy8gTW9iaWxlIFNhZmFyaSBkb2VzIG5vdCBmaXJlIHByb3Blcmx5IGJ1YmJsZSBjbGljayBldmVudHMgb25cbiAgLy8gbm9uLWludGVyYWN0aXZlIGVsZW1lbnRzLCB3aGljaCBtZWFucyBkZWxlZ2F0ZWQgY2xpY2sgbGlzdGVuZXJzIGRvIG5vdFxuICAvLyBmaXJlLiBUaGUgd29ya2Fyb3VuZCBmb3IgdGhpcyBidWcgaW52b2x2ZXMgYXR0YWNoaW5nIGFuIGVtcHR5IGNsaWNrXG4gIC8vIGxpc3RlbmVyIG9uIHRoZSB0YXJnZXQgbm9kZS5cbiAgLy8gaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTAvMDkvY2xpY2tfZXZlbnRfZGVsLmh0bWxcbiAgLy8gSnVzdCBzZXQgaXQgdXNpbmcgdGhlIG9uY2xpY2sgcHJvcGVydHkgc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIG1hbmFnZSBhbnlcbiAgLy8gYm9va2tlZXBpbmcgZm9yIGl0LiBOb3Qgc3VyZSBpZiB3ZSBuZWVkIHRvIGNsZWFyIGl0IHdoZW4gdGhlIGxpc3RlbmVyIGlzXG4gIC8vIHJlbW92ZWQuXG4gIC8vIFRPRE86IE9ubHkgZG8gdGhpcyBmb3IgdGhlIHJlbGV2YW50IFNhZmFyaXMgbWF5YmU/XG4gIG5vZGUub25jbGljayA9IGVtcHR5RnVuY3Rpb247XG59XG5cbmZ1bmN0aW9uIHNldEluaXRpYWxET01Qcm9wZXJ0aWVzKHRhZywgZG9tRWxlbWVudCwgcm9vdENvbnRhaW5lckVsZW1lbnQsIG5leHRQcm9wcywgaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgZm9yICh2YXIgcHJvcEtleSBpbiBuZXh0UHJvcHMpIHtcbiAgICBpZiAoIW5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBuZXh0UHJvcCA9IG5leHRQcm9wc1twcm9wS2V5XTtcbiAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKG5leHRQcm9wKSB7XG4gICAgICAgICAgLy8gRnJlZXplIHRoZSBuZXh0IHN0eWxlIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBhc3N1bWUgaXQgd29uJ3QgYmVcbiAgICAgICAgICAvLyBtdXRhdGVkLiBXZSBoYXZlIGFscmVhZHkgd2FybmVkIGZvciB0aGlzIGluIHRoZSBwYXN0LlxuICAgICAgICAgIE9iamVjdC5mcmVlemUobmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBSZWxpZXMgb24gYHVwZGF0ZVN0eWxlc0J5SURgIG5vdCBtdXRhdGluZyBgc3R5bGVVcGRhdGVzYC5cbiAgICAgIHNldFZhbHVlRm9yU3R5bGVzKGRvbUVsZW1lbnQsIG5leHRQcm9wLCBnZXRTdGFjayk7XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCkge1xuICAgICAgdmFyIG5leHRIdG1sID0gbmV4dFByb3AgPyBuZXh0UHJvcFtIVE1MXSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChuZXh0SHRtbCAhPSBudWxsKSB7XG4gICAgICAgIHNldElubmVySFRNTChkb21FbGVtZW50LCBuZXh0SHRtbCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgaWYgKHR5cGVvZiBuZXh0UHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gQXZvaWQgc2V0dGluZyBpbml0aWFsIHRleHRDb250ZW50IHdoZW4gdGhlIHRleHQgaXMgZW1wdHkuIEluIElFMTEgc2V0dGluZ1xuICAgICAgICAvLyB0ZXh0Q29udGVudCBvbiBhIDx0ZXh0YXJlYT4gd2lsbCBjYXVzZSB0aGUgcGxhY2Vob2xkZXIgdG8gbm90XG4gICAgICAgIC8vIHNob3cgd2l0aGluIHRoZSA8dGV4dGFyZWE+IHVudGlsIGl0IGhhcyBiZWVuIGZvY3VzZWQgYW5kIGJsdXJyZWQgYWdhaW4uXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNjczMSNpc3N1ZWNvbW1lbnQtMjU0ODc0NTUzXG4gICAgICAgIHZhciBjYW5TZXRUZXh0Q29udGVudCA9IHRhZyAhPT0gJ3RleHRhcmVhJyB8fCBuZXh0UHJvcCAhPT0gJyc7XG4gICAgICAgIGlmIChjYW5TZXRUZXh0Q29udGVudCkge1xuICAgICAgICAgIHNldFRleHRDb250ZW50KGRvbUVsZW1lbnQsIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbmV4dFByb3AgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHNldFRleHRDb250ZW50KGRvbUVsZW1lbnQsICcnICsgbmV4dFByb3ApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gU1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HIHx8IHByb3BLZXkgPT09IFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDEpIHtcbiAgICAgIC8vIE5vb3BcbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IEFVVE9GT0NVUykge1xuICAgICAgLy8gV2UgcG9seWZpbGwgaXQgc2VwYXJhdGVseSBvbiB0aGUgY2xpZW50IGR1cmluZyBjb21taXQuXG4gICAgICAvLyBXZSBibGFja2xpc3QgaXQgaGVyZSByYXRoZXIgdGhhbiBpbiB0aGUgcHJvcGVydHkgbGlzdCBiZWNhdXNlIHdlIGVtaXQgaXQgaW4gU1NSLlxuICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgIGlmIChuZXh0UHJvcCAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0cnVlICYmIHR5cGVvZiBuZXh0UHJvcCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lcihwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsIHByb3BLZXkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgICAgIHNldFZhbHVlRm9yQXR0cmlidXRlKGRvbUVsZW1lbnQsIHByb3BLZXksIG5leHRQcm9wKTtcbiAgICB9IGVsc2UgaWYgKG5leHRQcm9wICE9IG51bGwpIHtcbiAgICAgIC8vIElmIHdlJ3JlIHVwZGF0aW5nIHRvIG51bGwgb3IgdW5kZWZpbmVkLCB3ZSBzaG91bGQgcmVtb3ZlIHRoZSBwcm9wZXJ0eVxuICAgICAgLy8gZnJvbSB0aGUgRE9NIG5vZGUgaW5zdGVhZCBvZiBpbmFkdmVydGVudGx5IHNldHRpbmcgdG8gYSBzdHJpbmcuIFRoaXNcbiAgICAgIC8vIGJyaW5ncyB1cyBpbiBsaW5lIHdpdGggdGhlIHNhbWUgYmVoYXZpb3Igd2UgaGF2ZSBvbiBpbml0aWFsIHJlbmRlci5cbiAgICAgIHNldFZhbHVlRm9yUHJvcGVydHkoZG9tRWxlbWVudCwgcHJvcEtleSwgbmV4dFByb3ApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVET01Qcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHVwZGF0ZVBheWxvYWQsIHdhc0N1c3RvbUNvbXBvbmVudFRhZywgaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgLy8gVE9ETzogSGFuZGxlIHdhc0N1c3RvbUNvbXBvbmVudFRhZ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHVwZGF0ZVBheWxvYWQubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2YXIgcHJvcEtleSA9IHVwZGF0ZVBheWxvYWRbaV07XG4gICAgdmFyIHByb3BWYWx1ZSA9IHVwZGF0ZVBheWxvYWRbaSArIDFdO1xuICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgc2V0VmFsdWVGb3JTdHlsZXMoZG9tRWxlbWVudCwgcHJvcFZhbHVlLCBnZXRTdGFjayk7XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCkge1xuICAgICAgc2V0SW5uZXJIVE1MKGRvbUVsZW1lbnQsIHByb3BWYWx1ZSk7XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgc2V0VGV4dENvbnRlbnQoZG9tRWxlbWVudCwgcHJvcFZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gICAgICBpZiAocHJvcFZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVGb3JBdHRyaWJ1dGUoZG9tRWxlbWVudCwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZVZhbHVlRm9yQXR0cmlidXRlKGRvbUVsZW1lbnQsIHByb3BLZXkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcFZhbHVlICE9IG51bGwpIHtcbiAgICAgIHNldFZhbHVlRm9yUHJvcGVydHkoZG9tRWxlbWVudCwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgd2UncmUgdXBkYXRpbmcgdG8gbnVsbCBvciB1bmRlZmluZWQsIHdlIHNob3VsZCByZW1vdmUgdGhlIHByb3BlcnR5XG4gICAgICAvLyBmcm9tIHRoZSBET00gbm9kZSBpbnN0ZWFkIG9mIGluYWR2ZXJ0ZW50bHkgc2V0dGluZyB0byBhIHN0cmluZy4gVGhpc1xuICAgICAgLy8gYnJpbmdzIHVzIGluIGxpbmUgd2l0aCB0aGUgc2FtZSBiZWhhdmlvciB3ZSBoYXZlIG9uIGluaXRpYWwgcmVuZGVyLlxuICAgICAgZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eShkb21FbGVtZW50LCBwcm9wS2V5KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCQxKHR5cGUsIHByb3BzLCByb290Q29udGFpbmVyRWxlbWVudCwgcGFyZW50TmFtZXNwYWNlKSB7XG4gIC8vIFdlIGNyZWF0ZSB0YWdzIGluIHRoZSBuYW1lc3BhY2Ugb2YgdGhlaXIgcGFyZW50IGNvbnRhaW5lciwgZXhjZXB0IEhUTUxcbiAgdmFyIG93bmVyRG9jdW1lbnQgPSBnZXRPd25lckRvY3VtZW50RnJvbVJvb3RDb250YWluZXIocm9vdENvbnRhaW5lckVsZW1lbnQpO1xuICB2YXIgZG9tRWxlbWVudDtcbiAgdmFyIG5hbWVzcGFjZVVSSSA9IHBhcmVudE5hbWVzcGFjZTtcbiAgaWYgKG5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICBuYW1lc3BhY2VVUkkgPSBnZXRJbnRyaW5zaWNOYW1lc3BhY2UodHlwZSk7XG4gIH1cbiAgaWYgKG5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICB7XG4gICAgICB2YXIgaXNDdXN0b21Db21wb25lbnRUYWcgPSBpc0N1c3RvbUNvbXBvbmVudCh0eXBlLCBwcm9wcyk7XG4gICAgICAvLyBTaG91bGQgdGhpcyBjaGVjayBiZSBnYXRlZCBieSBwYXJlbnQgbmFtZXNwYWNlPyBOb3Qgc3VyZSB3ZSB3YW50IHRvXG4gICAgICAvLyBhbGxvdyA8U1ZHPiBvciA8bUFUSD4uXG4gICAgICB3YXJuaW5nKGlzQ3VzdG9tQ29tcG9uZW50VGFnIHx8IHR5cGUgPT09IHR5cGUudG9Mb3dlckNhc2UoKSwgJzwlcyAvPiBpcyB1c2luZyB1cHBlcmNhc2UgSFRNTC4gQWx3YXlzIHVzZSBsb3dlcmNhc2UgSFRNTCB0YWdzICcgKyAnaW4gUmVhY3QuJywgdHlwZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICdzY3JpcHQnKSB7XG4gICAgICAvLyBDcmVhdGUgdGhlIHNjcmlwdCB2aWEgLmlubmVySFRNTCBzbyBpdHMgXCJwYXJzZXItaW5zZXJ0ZWRcIiBmbGFnIGlzXG4gICAgICAvLyBzZXQgdG8gdHJ1ZSBhbmQgaXQgZG9lcyBub3QgZXhlY3V0ZVxuICAgICAgdmFyIGRpdiA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBkaXYuaW5uZXJIVE1MID0gJzxzY3JpcHQ+PCcgKyAnL3NjcmlwdD4nOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAvLyBUaGlzIGlzIGd1YXJhbnRlZWQgdG8geWllbGQgYSBzY3JpcHQgZWxlbWVudC5cbiAgICAgIHZhciBmaXJzdENoaWxkID0gZGl2LmZpcnN0Q2hpbGQ7XG4gICAgICBkb21FbGVtZW50ID0gZGl2LnJlbW92ZUNoaWxkKGZpcnN0Q2hpbGQpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHByb3BzLmlzID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gJEZsb3dJc3N1ZSBgY3JlYXRlRWxlbWVudGAgc2hvdWxkIGJlIHVwZGF0ZWQgZm9yIFdlYiBDb21wb25lbnRzXG4gICAgICBkb21FbGVtZW50ID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KHR5cGUsIHsgaXM6IHByb3BzLmlzIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTZXBhcmF0ZSBlbHNlIGJyYW5jaCBpbnN0ZWFkIG9mIHVzaW5nIGBwcm9wcy5pcyB8fCB1bmRlZmluZWRgIGFib3ZlIGJlY2F1c2Ugb2YgYSBGaXJlZm94IGJ1Zy5cbiAgICAgIC8vIFNlZSBkaXNjdXNzaW9uIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzY4OTZcbiAgICAgIC8vIGFuZCBkaXNjdXNzaW9uIGluIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEyNzYyNDBcbiAgICAgIGRvbUVsZW1lbnQgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodHlwZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRvbUVsZW1lbnQgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VVUkksIHR5cGUpO1xuICB9XG5cbiAge1xuICAgIGlmIChuYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgICBpZiAoIWlzQ3VzdG9tQ29tcG9uZW50VGFnICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkb21FbGVtZW50KSA9PT0gJ1tvYmplY3QgSFRNTFVua25vd25FbGVtZW50XScgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh3YXJuZWRVbmtub3duVGFncywgdHlwZSkpIHtcbiAgICAgICAgd2FybmVkVW5rbm93blRhZ3NbdHlwZV0gPSB0cnVlO1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnVGhlIHRhZyA8JXM+IGlzIHVucmVjb2duaXplZCBpbiB0aGlzIGJyb3dzZXIuICcgKyAnSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIFJlYWN0IGNvbXBvbmVudCwgc3RhcnQgaXRzIG5hbWUgd2l0aCAnICsgJ2FuIHVwcGVyY2FzZSBsZXR0ZXIuJywgdHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRvbUVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHROb2RlJDEodGV4dCwgcm9vdENvbnRhaW5lckVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldE93bmVyRG9jdW1lbnRGcm9tUm9vdENvbnRhaW5lcihyb290Q29udGFpbmVyRWxlbWVudCkuY3JlYXRlVGV4dE5vZGUodGV4dCk7XG59XG5cbmZ1bmN0aW9uIHNldEluaXRpYWxQcm9wZXJ0aWVzJDEoZG9tRWxlbWVudCwgdGFnLCByYXdQcm9wcywgcm9vdENvbnRhaW5lckVsZW1lbnQpIHtcbiAgdmFyIGlzQ3VzdG9tQ29tcG9uZW50VGFnID0gaXNDdXN0b21Db21wb25lbnQodGFnLCByYXdQcm9wcyk7XG4gIHtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50KHRhZywgcmF3UHJvcHMpO1xuICAgIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZyAmJiAhZGlkV2FyblNoYWR5RE9NICYmIGRvbUVsZW1lbnQuc2hhZHlSb290KSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnJXMgaXMgdXNpbmcgc2hhZHkgRE9NLiBVc2luZyBzaGFkeSBET00gd2l0aCBSZWFjdCBjYW4gJyArICdjYXVzZSB0aGluZ3MgdG8gYnJlYWsgc3VidGx5LicsIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSQxKCkgfHwgJ0EgY29tcG9uZW50Jyk7XG4gICAgICBkaWRXYXJuU2hhZHlET00gPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE86IE1ha2Ugc3VyZSB0aGF0IHdlIGNoZWNrIGlzTW91bnRlZCBiZWZvcmUgZmlyaW5nIGFueSBvZiB0aGVzZSBldmVudHMuXG4gIHZhciBwcm9wcztcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpZnJhbWUnOlxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BMb2FkJywgJ2xvYWQnLCBkb21FbGVtZW50KTtcbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd2aWRlbyc6XG4gICAgY2FzZSAnYXVkaW8nOlxuICAgICAgLy8gQ3JlYXRlIGxpc3RlbmVyIGZvciBlYWNoIG1lZGlhIGV2ZW50XG4gICAgICBmb3IgKHZhciBldmVudCBpbiBtZWRpYUV2ZW50cykge1xuICAgICAgICBpZiAobWVkaWFFdmVudHMuaGFzT3duUHJvcGVydHkoZXZlbnQpKSB7XG4gICAgICAgICAgdHJhcEJ1YmJsZWRFdmVudChldmVudCwgbWVkaWFFdmVudHNbZXZlbnRdLCBkb21FbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BFcnJvcicsICdlcnJvcicsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2ltZyc6XG4gICAgY2FzZSAnaW1hZ2UnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wRXJyb3InLCAnZXJyb3InLCBkb21FbGVtZW50KTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcExvYWQnLCAnbG9hZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wUmVzZXQnLCAncmVzZXQnLCBkb21FbGVtZW50KTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcFN1Ym1pdCcsICdzdWJtaXQnLCBkb21FbGVtZW50KTtcbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdkZXRhaWxzJzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcFRvZ2dsZScsICd0b2dnbGUnLCBkb21FbGVtZW50KTtcbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICBpbml0V3JhcHBlclN0YXRlKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHByb3BzID0gZ2V0SG9zdFByb3BzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEludmFsaWQnLCAnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgLy8gRm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3ZSBhbHdheXMgbmVlZCB0byBlbnN1cmUgd2UncmUgbGlzdGVuaW5nXG4gICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICB2YWxpZGF0ZVByb3BzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHByb3BzID0gZ2V0SG9zdFByb3BzJDEoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUkMShkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBwcm9wcyA9IGdldEhvc3RQcm9wcyQyKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEludmFsaWQnLCAnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgLy8gRm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3ZSBhbHdheXMgbmVlZCB0byBlbnN1cmUgd2UncmUgbGlzdGVuaW5nXG4gICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUkMihkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBwcm9wcyA9IGdldEhvc3RQcm9wcyQzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEludmFsaWQnLCAnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgLy8gRm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3ZSBhbHdheXMgbmVlZCB0byBlbnN1cmUgd2UncmUgbGlzdGVuaW5nXG4gICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBwcm9wcyA9IHJhd1Byb3BzO1xuICB9XG5cbiAgYXNzZXJ0VmFsaWRQcm9wcyh0YWcsIHByb3BzLCBnZXRTdGFjayk7XG5cbiAgc2V0SW5pdGlhbERPTVByb3BlcnRpZXModGFnLCBkb21FbGVtZW50LCByb290Q29udGFpbmVyRWxlbWVudCwgcHJvcHMsIGlzQ3VzdG9tQ29tcG9uZW50VGFnKTtcblxuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIC8vIFRPRE86IE1ha2Ugc3VyZSB3ZSBjaGVjayBpZiB0aGlzIGlzIHN0aWxsIHVubW91bnRlZCBvciBkbyBhbnkgY2xlYW5cbiAgICAgIC8vIHVwIG5lY2Vzc2FyeSBzaW5jZSB3ZSBuZXZlciBzdG9wIHRyYWNraW5nIGFueW1vcmUuXG4gICAgICB0cmFjayhkb21FbGVtZW50KTtcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgLy8gVE9ETzogTWFrZSBzdXJlIHdlIGNoZWNrIGlmIHRoaXMgaXMgc3RpbGwgdW5tb3VudGVkIG9yIGRvIGFueSBjbGVhblxuICAgICAgLy8gdXAgbmVjZXNzYXJ5IHNpbmNlIHdlIG5ldmVyIHN0b3AgdHJhY2tpbmcgYW55bW9yZS5cbiAgICAgIHRyYWNrKGRvbUVsZW1lbnQpO1xuICAgICAgcG9zdE1vdW50V3JhcHBlciQzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICBwb3N0TW91bnRXcmFwcGVyJDEoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIkMihkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKHR5cGVvZiBwcm9wcy5vbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgY2FzdCBtYXkgbm90IGJlIHNvdW5kIGZvciBTVkcsIE1hdGhNTCBvciBjdXN0b20gZWxlbWVudHMuXG4gICAgICAgIHRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50KGRvbUVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cbn1cblxuLy8gQ2FsY3VsYXRlIHRoZSBkaWZmIGJldHdlZW4gdGhlIHR3byBvYmplY3RzLlxuZnVuY3Rpb24gZGlmZlByb3BlcnRpZXMkMShkb21FbGVtZW50LCB0YWcsIGxhc3RSYXdQcm9wcywgbmV4dFJhd1Byb3BzLCByb290Q29udGFpbmVyRWxlbWVudCkge1xuICB7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzSW5EZXZlbG9wbWVudCh0YWcsIG5leHRSYXdQcm9wcyk7XG4gIH1cblxuICB2YXIgdXBkYXRlUGF5bG9hZCA9IG51bGw7XG5cbiAgdmFyIGxhc3RQcm9wcztcbiAgdmFyIG5leHRQcm9wcztcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICBsYXN0UHJvcHMgPSBnZXRIb3N0UHJvcHMoZG9tRWxlbWVudCwgbGFzdFJhd1Byb3BzKTtcbiAgICAgIG5leHRQcm9wcyA9IGdldEhvc3RQcm9wcyhkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgIGxhc3RQcm9wcyA9IGdldEhvc3RQcm9wcyQxKGRvbUVsZW1lbnQsIGxhc3RSYXdQcm9wcyk7XG4gICAgICBuZXh0UHJvcHMgPSBnZXRIb3N0UHJvcHMkMShkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIGxhc3RQcm9wcyA9IGdldEhvc3RQcm9wcyQyKGRvbUVsZW1lbnQsIGxhc3RSYXdQcm9wcyk7XG4gICAgICBuZXh0UHJvcHMgPSBnZXRIb3N0UHJvcHMkMihkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgbGFzdFByb3BzID0gZ2V0SG9zdFByb3BzJDMoZG9tRWxlbWVudCwgbGFzdFJhd1Byb3BzKTtcbiAgICAgIG5leHRQcm9wcyA9IGdldEhvc3RQcm9wcyQzKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgbGFzdFByb3BzID0gbGFzdFJhd1Byb3BzO1xuICAgICAgbmV4dFByb3BzID0gbmV4dFJhd1Byb3BzO1xuICAgICAgaWYgKHR5cGVvZiBsYXN0UHJvcHMub25DbGljayAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgbmV4dFByb3BzLm9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBjYXN0IG1heSBub3QgYmUgc291bmQgZm9yIFNWRywgTWF0aE1MIG9yIGN1c3RvbSBlbGVtZW50cy5cbiAgICAgICAgdHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQoZG9tRWxlbWVudCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfVxuXG4gIGFzc2VydFZhbGlkUHJvcHModGFnLCBuZXh0UHJvcHMsIGdldFN0YWNrKTtcblxuICB2YXIgcHJvcEtleTtcbiAgdmFyIHN0eWxlTmFtZTtcbiAgdmFyIHN0eWxlVXBkYXRlcyA9IG51bGw7XG4gIGZvciAocHJvcEtleSBpbiBsYXN0UHJvcHMpIHtcbiAgICBpZiAobmV4dFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpIHx8ICFsYXN0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHwgbGFzdFByb3BzW3Byb3BLZXldID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgIHZhciBsYXN0U3R5bGUgPSBsYXN0UHJvcHNbcHJvcEtleV07XG4gICAgICBmb3IgKHN0eWxlTmFtZSBpbiBsYXN0U3R5bGUpIHtcbiAgICAgICAgaWYgKGxhc3RTdHlsZS5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XG4gICAgICAgICAgaWYgKCFzdHlsZVVwZGF0ZXMpIHtcbiAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9ICcnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCB8fCBwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgLy8gTm9vcC4gVGhpcyBpcyBoYW5kbGVkIGJ5IHRoZSBjbGVhciB0ZXh0IG1lY2hhbmlzbS5cbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IFNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklORyB8fCBwcm9wS2V5ID09PSBTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxKSB7XG4gICAgICAvLyBOb29wXG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBBVVRPRk9DVVMpIHtcbiAgICAgIC8vIE5vb3AuIEl0IGRvZXNuJ3Qgd29yayBvbiB1cGRhdGVzIGFueXdheS5cbiAgICB9IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgc3BlY2lhbCBjYXNlLiBJZiBhbnkgbGlzdGVuZXIgdXBkYXRlcyB3ZSBuZWVkIHRvIGVuc3VyZVxuICAgICAgLy8gdGhhdCB0aGUgXCJjdXJyZW50XCIgZmliZXIgcG9pbnRlciBnZXRzIHVwZGF0ZWQgc28gd2UgbmVlZCBhIGNvbW1pdFxuICAgICAgLy8gdG8gdXBkYXRlIHRoaXMgZWxlbWVudC5cbiAgICAgIGlmICghdXBkYXRlUGF5bG9hZCkge1xuICAgICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZvciBhbGwgb3RoZXIgZGVsZXRlZCBwcm9wZXJ0aWVzIHdlIGFkZCBpdCB0byB0aGUgcXVldWUuIFdlIHVzZVxuICAgICAgLy8gdGhlIHdoaXRlbGlzdCBpbiB0aGUgY29tbWl0IHBoYXNlIGluc3RlYWQuXG4gICAgICAodXBkYXRlUGF5bG9hZCA9IHVwZGF0ZVBheWxvYWQgfHwgW10pLnB1c2gocHJvcEtleSwgbnVsbCk7XG4gICAgfVxuICB9XG4gIGZvciAocHJvcEtleSBpbiBuZXh0UHJvcHMpIHtcbiAgICB2YXIgbmV4dFByb3AgPSBuZXh0UHJvcHNbcHJvcEtleV07XG4gICAgdmFyIGxhc3RQcm9wID0gbGFzdFByb3BzICE9IG51bGwgPyBsYXN0UHJvcHNbcHJvcEtleV0gOiB1bmRlZmluZWQ7XG4gICAgaWYgKCFuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHwgbmV4dFByb3AgPT09IGxhc3RQcm9wIHx8IG5leHRQcm9wID09IG51bGwgJiYgbGFzdFByb3AgPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAge1xuICAgICAgICBpZiAobmV4dFByb3ApIHtcbiAgICAgICAgICAvLyBGcmVlemUgdGhlIG5leHQgc3R5bGUgb2JqZWN0IHNvIHRoYXQgd2UgY2FuIGFzc3VtZSBpdCB3b24ndCBiZVxuICAgICAgICAgIC8vIG11dGF0ZWQuIFdlIGhhdmUgYWxyZWFkeSB3YXJuZWQgZm9yIHRoaXMgaW4gdGhlIHBhc3QuXG4gICAgICAgICAgT2JqZWN0LmZyZWV6ZShuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsYXN0UHJvcCkge1xuICAgICAgICAvLyBVbnNldCBzdHlsZXMgb24gYGxhc3RQcm9wYCBidXQgbm90IG9uIGBuZXh0UHJvcGAuXG4gICAgICAgIGZvciAoc3R5bGVOYW1lIGluIGxhc3RQcm9wKSB7XG4gICAgICAgICAgaWYgKGxhc3RQcm9wLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkgJiYgKCFuZXh0UHJvcCB8fCAhbmV4dFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkpIHtcbiAgICAgICAgICAgIGlmICghc3R5bGVVcGRhdGVzKSB7XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3R5bGVVcGRhdGVzW3N0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIHN0eWxlcyB0aGF0IGNoYW5nZWQgc2luY2UgYGxhc3RQcm9wYC5cbiAgICAgICAgZm9yIChzdHlsZU5hbWUgaW4gbmV4dFByb3ApIHtcbiAgICAgICAgICBpZiAobmV4dFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSAmJiBsYXN0UHJvcFtzdHlsZU5hbWVdICE9PSBuZXh0UHJvcFtzdHlsZU5hbWVdKSB7XG4gICAgICAgICAgICBpZiAoIXN0eWxlVXBkYXRlcykge1xuICAgICAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gbmV4dFByb3Bbc3R5bGVOYW1lXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJlbGllcyBvbiBgdXBkYXRlU3R5bGVzQnlJRGAgbm90IG11dGF0aW5nIGBzdHlsZVVwZGF0ZXNgLlxuICAgICAgICBpZiAoIXN0eWxlVXBkYXRlcykge1xuICAgICAgICAgIGlmICghdXBkYXRlUGF5bG9hZCkge1xuICAgICAgICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1cGRhdGVQYXlsb2FkLnB1c2gocHJvcEtleSwgc3R5bGVVcGRhdGVzKTtcbiAgICAgICAgfVxuICAgICAgICBzdHlsZVVwZGF0ZXMgPSBuZXh0UHJvcDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MKSB7XG4gICAgICB2YXIgbmV4dEh0bWwgPSBuZXh0UHJvcCA/IG5leHRQcm9wW0hUTUxdIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIGxhc3RIdG1sID0gbGFzdFByb3AgPyBsYXN0UHJvcFtIVE1MXSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChuZXh0SHRtbCAhPSBudWxsKSB7XG4gICAgICAgIGlmIChsYXN0SHRtbCAhPT0gbmV4dEh0bWwpIHtcbiAgICAgICAgICAodXBkYXRlUGF5bG9hZCA9IHVwZGF0ZVBheWxvYWQgfHwgW10pLnB1c2gocHJvcEtleSwgJycgKyBuZXh0SHRtbCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRPRE86IEl0IG1pZ2h0IGJlIHRvbyBsYXRlIHRvIGNsZWFyIHRoaXMgaWYgd2UgaGF2ZSBjaGlsZHJlblxuICAgICAgICAvLyBpbnNlcnRlZCBhbHJlYWR5LlxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gQ0hJTERSRU4pIHtcbiAgICAgIGlmIChsYXN0UHJvcCAhPT0gbmV4dFByb3AgJiYgKHR5cGVvZiBuZXh0UHJvcCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5leHRQcm9wID09PSAnbnVtYmVyJykpIHtcbiAgICAgICAgKHVwZGF0ZVBheWxvYWQgPSB1cGRhdGVQYXlsb2FkIHx8IFtdKS5wdXNoKHByb3BLZXksICcnICsgbmV4dFByb3ApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gU1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HIHx8IHByb3BLZXkgPT09IFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDEpIHtcbiAgICAgIC8vIE5vb3BcbiAgICB9IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICBpZiAobmV4dFByb3AgIT0gbnVsbCkge1xuICAgICAgICAvLyBXZSBlYWdlcmx5IGxpc3RlbiB0byB0aGlzIGV2ZW4gdGhvdWdoIHdlIGhhdmVuJ3QgY29tbWl0dGVkIHlldC5cbiAgICAgICAgaWYgKHRydWUgJiYgdHlwZW9mIG5leHRQcm9wICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgd2FybkZvckludmFsaWRFdmVudExpc3RlbmVyKHByb3BLZXksIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgcHJvcEtleSk7XG4gICAgICB9XG4gICAgICBpZiAoIXVwZGF0ZVBheWxvYWQgJiYgbGFzdFByb3AgIT09IG5leHRQcm9wKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2UuIElmIGFueSBsaXN0ZW5lciB1cGRhdGVzIHdlIG5lZWQgdG8gZW5zdXJlXG4gICAgICAgIC8vIHRoYXQgdGhlIFwiY3VycmVudFwiIHByb3BzIHBvaW50ZXIgZ2V0cyB1cGRhdGVkIHNvIHdlIG5lZWQgYSBjb21taXRcbiAgICAgICAgLy8gdG8gdXBkYXRlIHRoaXMgZWxlbWVudC5cbiAgICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGb3IgYW55IG90aGVyIHByb3BlcnR5IHdlIGFsd2F5cyBhZGQgaXQgdG8gdGhlIHF1ZXVlIGFuZCB0aGVuIHdlXG4gICAgICAvLyBmaWx0ZXIgaXQgb3V0IHVzaW5nIHRoZSB3aGl0ZWxpc3QgZHVyaW5nIHRoZSBjb21taXQuXG4gICAgICAodXBkYXRlUGF5bG9hZCA9IHVwZGF0ZVBheWxvYWQgfHwgW10pLnB1c2gocHJvcEtleSwgbmV4dFByb3ApO1xuICAgIH1cbiAgfVxuICBpZiAoc3R5bGVVcGRhdGVzKSB7XG4gICAgKHVwZGF0ZVBheWxvYWQgPSB1cGRhdGVQYXlsb2FkIHx8IFtdKS5wdXNoKFNUWUxFLCBzdHlsZVVwZGF0ZXMpO1xuICB9XG4gIHJldHVybiB1cGRhdGVQYXlsb2FkO1xufVxuXG4vLyBBcHBseSB0aGUgZGlmZi5cbmZ1bmN0aW9uIHVwZGF0ZVByb3BlcnRpZXMkMShkb21FbGVtZW50LCB1cGRhdGVQYXlsb2FkLCB0YWcsIGxhc3RSYXdQcm9wcywgbmV4dFJhd1Byb3BzKSB7XG4gIC8vIFVwZGF0ZSBjaGVja2VkICpiZWZvcmUqIG5hbWUuXG4gIC8vIEluIHRoZSBtaWRkbGUgb2YgYW4gdXBkYXRlLCBpdCBpcyBwb3NzaWJsZSB0byBoYXZlIG11bHRpcGxlIGNoZWNrZWQuXG4gIC8vIFdoZW4gYSBjaGVja2VkIHJhZGlvIHRyaWVzIHRvIGNoYW5nZSBuYW1lLCBicm93c2VyIG1ha2VzIGFub3RoZXIgcmFkaW8ncyBjaGVja2VkIGZhbHNlLlxuICBpZiAodGFnID09PSAnaW5wdXQnICYmIG5leHRSYXdQcm9wcy50eXBlID09PSAncmFkaW8nICYmIG5leHRSYXdQcm9wcy5uYW1lICE9IG51bGwpIHtcbiAgICB1cGRhdGVDaGVja2VkKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gIH1cblxuICB2YXIgd2FzQ3VzdG9tQ29tcG9uZW50VGFnID0gaXNDdXN0b21Db21wb25lbnQodGFnLCBsYXN0UmF3UHJvcHMpO1xuICB2YXIgaXNDdXN0b21Db21wb25lbnRUYWcgPSBpc0N1c3RvbUNvbXBvbmVudCh0YWcsIG5leHRSYXdQcm9wcyk7XG4gIC8vIEFwcGx5IHRoZSBkaWZmLlxuICB1cGRhdGVET01Qcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHVwZGF0ZVBheWxvYWQsIHdhc0N1c3RvbUNvbXBvbmVudFRhZywgaXNDdXN0b21Db21wb25lbnRUYWcpO1xuXG4gIC8vIFRPRE86IEVuc3VyZSB0aGF0IGFuIHVwZGF0ZSBnZXRzIHNjaGVkdWxlZCBpZiBhbnkgb2YgdGhlIHNwZWNpYWwgcHJvcHNcbiAgLy8gY2hhbmdlZC5cbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICAvLyBVcGRhdGUgdGhlIHdyYXBwZXIgYXJvdW5kIGlucHV0cyAqYWZ0ZXIqIHVwZGF0aW5nIHByb3BzLiBUaGlzIGhhcyB0b1xuICAgICAgLy8gaGFwcGVuIGFmdGVyIGB1cGRhdGVET01Qcm9wZXJ0aWVzYC4gT3RoZXJ3aXNlIEhUTUw1IGlucHV0IHZhbGlkYXRpb25zXG4gICAgICAvLyByYWlzZSB3YXJuaW5ncyBhbmQgcHJldmVudCB0aGUgbmV3IHZhbHVlIGZyb20gYmVpbmcgYXNzaWduZWQuXG4gICAgICB1cGRhdGVXcmFwcGVyKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICB1cGRhdGVXcmFwcGVyJDEoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAvLyA8c2VsZWN0PiB2YWx1ZSB1cGRhdGUgbmVlZHMgdG8gb2NjdXIgYWZ0ZXIgPG9wdGlvbj4gY2hpbGRyZW5cbiAgICAgIC8vIHJlY29uY2lsaWF0aW9uXG4gICAgICBwb3N0VXBkYXRlV3JhcHBlcihkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlmZkh5ZHJhdGVkUHJvcGVydGllcyQxKGRvbUVsZW1lbnQsIHRhZywgcmF3UHJvcHMsIHBhcmVudE5hbWVzcGFjZSwgcm9vdENvbnRhaW5lckVsZW1lbnQpIHtcbiAge1xuICAgIHZhciBzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcgPSByYXdQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxXSA9PT0gdHJ1ZTtcbiAgICB2YXIgaXNDdXN0b21Db21wb25lbnRUYWcgPSBpc0N1c3RvbUNvbXBvbmVudCh0YWcsIHJhd1Byb3BzKTtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50KHRhZywgcmF3UHJvcHMpO1xuICAgIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZyAmJiAhZGlkV2FyblNoYWR5RE9NICYmIGRvbUVsZW1lbnQuc2hhZHlSb290KSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnJXMgaXMgdXNpbmcgc2hhZHkgRE9NLiBVc2luZyBzaGFkeSBET00gd2l0aCBSZWFjdCBjYW4gJyArICdjYXVzZSB0aGluZ3MgdG8gYnJlYWsgc3VidGx5LicsIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSQxKCkgfHwgJ0EgY29tcG9uZW50Jyk7XG4gICAgICBkaWRXYXJuU2hhZHlET00gPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE86IE1ha2Ugc3VyZSB0aGF0IHdlIGNoZWNrIGlzTW91bnRlZCBiZWZvcmUgZmlyaW5nIGFueSBvZiB0aGVzZSBldmVudHMuXG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnaWZyYW1lJzpcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wTG9hZCcsICdsb2FkJywgZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd2aWRlbyc6XG4gICAgY2FzZSAnYXVkaW8nOlxuICAgICAgLy8gQ3JlYXRlIGxpc3RlbmVyIGZvciBlYWNoIG1lZGlhIGV2ZW50XG4gICAgICBmb3IgKHZhciBldmVudCBpbiBtZWRpYUV2ZW50cykge1xuICAgICAgICBpZiAobWVkaWFFdmVudHMuaGFzT3duUHJvcGVydHkoZXZlbnQpKSB7XG4gICAgICAgICAgdHJhcEJ1YmJsZWRFdmVudChldmVudCwgbWVkaWFFdmVudHNbZXZlbnRdLCBkb21FbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc291cmNlJzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEVycm9yJywgJ2Vycm9yJywgZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdpbWcnOlxuICAgIGNhc2UgJ2ltYWdlJzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEVycm9yJywgJ2Vycm9yJywgZG9tRWxlbWVudCk7XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BMb2FkJywgJ2xvYWQnLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wUmVzZXQnLCAncmVzZXQnLCBkb21FbGVtZW50KTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcFN1Ym1pdCcsICdzdWJtaXQnLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2RldGFpbHMnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wVG9nZ2xlJywgJ3RvZ2dsZScsIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgaW5pdFdyYXBwZXJTdGF0ZShkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BJbnZhbGlkJywgJ2ludmFsaWQnLCBkb21FbGVtZW50KTtcbiAgICAgIC8vIEZvciBjb250cm9sbGVkIGNvbXBvbmVudHMgd2UgYWx3YXlzIG5lZWQgdG8gZW5zdXJlIHdlJ3JlIGxpc3RlbmluZ1xuICAgICAgLy8gdG8gb25DaGFuZ2UuIEV2ZW4gaWYgdGhlcmUgaXMgbm8gbGlzdGVuZXIuXG4gICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgJ29uQ2hhbmdlJyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdvcHRpb24nOlxuICAgICAgdmFsaWRhdGVQcm9wcyhkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgaW5pdFdyYXBwZXJTdGF0ZSQxKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEludmFsaWQnLCAnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgLy8gRm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3ZSBhbHdheXMgbmVlZCB0byBlbnN1cmUgd2UncmUgbGlzdGVuaW5nXG4gICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUkMihkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BJbnZhbGlkJywgJ2ludmFsaWQnLCBkb21FbGVtZW50KTtcbiAgICAgIC8vIEZvciBjb250cm9sbGVkIGNvbXBvbmVudHMgd2UgYWx3YXlzIG5lZWQgdG8gZW5zdXJlIHdlJ3JlIGxpc3RlbmluZ1xuICAgICAgLy8gdG8gb25DaGFuZ2UuIEV2ZW4gaWYgdGhlcmUgaXMgbm8gbGlzdGVuZXIuXG4gICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgJ29uQ2hhbmdlJyk7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIGFzc2VydFZhbGlkUHJvcHModGFnLCByYXdQcm9wcywgZ2V0U3RhY2spO1xuXG4gIHtcbiAgICB2YXIgZXh0cmFBdHRyaWJ1dGVOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICB2YXIgYXR0cmlidXRlcyA9IGRvbUVsZW1lbnQuYXR0cmlidXRlcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuYW1lID0gYXR0cmlidXRlc1tpXS5uYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgLy8gQnVpbHQtaW4gU1NSIGF0dHJpYnV0ZSBpcyB3aGl0ZWxpc3RlZFxuICAgICAgICBjYXNlICdkYXRhLXJlYWN0cm9vdCc6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIENvbnRyb2xsZWQgYXR0cmlidXRlcyBhcmUgbm90IHZhbGlkYXRlZFxuICAgICAgICAvLyBUT0RPOiBPbmx5IGlnbm9yZSB0aGVtIG9uIGNvbnRyb2xsZWQgdGFncy5cbiAgICAgICAgY2FzZSAndmFsdWUnOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjaGVja2VkJzpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc2VsZWN0ZWQnOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIEludGVudGlvbmFsbHkgdXNlIHRoZSBvcmlnaW5hbCBuYW1lLlxuICAgICAgICAgIC8vIFNlZSBkaXNjdXNzaW9uIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzEwNjc2LlxuICAgICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXMuYWRkKGF0dHJpYnV0ZXNbaV0ubmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHVwZGF0ZVBheWxvYWQgPSBudWxsO1xuICBmb3IgKHZhciBwcm9wS2V5IGluIHJhd1Byb3BzKSB7XG4gICAgaWYgKCFyYXdQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBuZXh0UHJvcCA9IHJhd1Byb3BzW3Byb3BLZXldO1xuICAgIGlmIChwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgLy8gRm9yIHRleHQgY29udGVudCBjaGlsZHJlbiB3ZSBjb21wYXJlIGFnYWluc3QgdGV4dENvbnRlbnQuIFRoaXNcbiAgICAgIC8vIG1pZ2h0IG1hdGNoIGFkZGl0aW9uYWwgSFRNTCB0aGF0IGlzIGhpZGRlbiB3aGVuIHdlIHJlYWQgaXQgdXNpbmdcbiAgICAgIC8vIHRleHRDb250ZW50LiBFLmcuIFwiZm9vXCIgd2lsbCBtYXRjaCBcImY8c3Bhbj5vbzwvc3Bhbj5cIiBidXQgdGhhdCBzdGlsbFxuICAgICAgLy8gc2F0aXNmaWVzIG91ciByZXF1aXJlbWVudC4gT3VyIHJlcXVpcmVtZW50IGlzIG5vdCB0byBwcm9kdWNlIHBlcmZlY3RcbiAgICAgIC8vIEhUTUwgYW5kIGF0dHJpYnV0ZXMuIElkZWFsbHkgd2Ugc2hvdWxkIHByZXNlcnZlIHN0cnVjdHVyZSBidXQgaXQnc1xuICAgICAgLy8gb2sgbm90IHRvIGlmIHRoZSB2aXNpYmxlIGNvbnRlbnQgaXMgc3RpbGwgZW5vdWdoIHRvIGluZGljYXRlIHdoYXRcbiAgICAgIC8vIGV2ZW4gbGlzdGVuZXJzIHRoZXNlIG5vZGVzIG1pZ2h0IGJlIHdpcmVkIHVwIHRvLlxuICAgICAgLy8gVE9ETzogV2FybiBpZiB0aGVyZSBpcyBtb3JlIHRoYW4gYSBzaW5nbGUgdGV4dE5vZGUgYXMgYSBjaGlsZC5cbiAgICAgIC8vIFRPRE86IFNob3VsZCB3ZSB1c2UgZG9tRWxlbWVudC5maXJzdENoaWxkLm5vZGVWYWx1ZSB0byBjb21wYXJlP1xuICAgICAgaWYgKHR5cGVvZiBuZXh0UHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKGRvbUVsZW1lbnQudGV4dENvbnRlbnQgIT09IG5leHRQcm9wKSB7XG4gICAgICAgICAgaWYgKHRydWUgJiYgIXN1cHByZXNzSHlkcmF0aW9uV2FybmluZykge1xuICAgICAgICAgICAgd2FybkZvclRleHREaWZmZXJlbmNlKGRvbUVsZW1lbnQudGV4dENvbnRlbnQsIG5leHRQcm9wKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdXBkYXRlUGF5bG9hZCA9IFtDSElMRFJFTiwgbmV4dFByb3BdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBuZXh0UHJvcCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKGRvbUVsZW1lbnQudGV4dENvbnRlbnQgIT09ICcnICsgbmV4dFByb3ApIHtcbiAgICAgICAgICBpZiAodHJ1ZSAmJiAhc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nKSB7XG4gICAgICAgICAgICB3YXJuRm9yVGV4dERpZmZlcmVuY2UoZG9tRWxlbWVudC50ZXh0Q29udGVudCwgbmV4dFByb3ApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1cGRhdGVQYXlsb2FkID0gW0NISUxEUkVOLCAnJyArIG5leHRQcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgIGlmIChuZXh0UHJvcCAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0cnVlICYmIHR5cGVvZiBuZXh0UHJvcCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lcihwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsIHByb3BLZXkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBWYWxpZGF0ZSB0aGF0IHRoZSBwcm9wZXJ0aWVzIGNvcnJlc3BvbmQgdG8gdGhlaXIgZXhwZWN0ZWQgdmFsdWVzLlxuICAgICAgdmFyIHNlcnZlclZhbHVlO1xuICAgICAgdmFyIHByb3BlcnR5SW5mbztcbiAgICAgIGlmIChzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcpIHtcbiAgICAgICAgLy8gRG9uJ3QgYm90aGVyIGNvbXBhcmluZy4gV2UncmUgaWdub3JpbmcgYWxsIHRoZXNlIHdhcm5pbmdzLlxuICAgICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBTVVBQUkVTU19DT05URU5UX0VESVRBQkxFX1dBUk5JTkcgfHwgcHJvcEtleSA9PT0gU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkckMSB8fFxuICAgICAgLy8gQ29udHJvbGxlZCBhdHRyaWJ1dGVzIGFyZSBub3QgdmFsaWRhdGVkXG4gICAgICAvLyBUT0RPOiBPbmx5IGlnbm9yZSB0aGVtIG9uIGNvbnRyb2xsZWQgdGFncy5cbiAgICAgIHByb3BLZXkgPT09ICd2YWx1ZScgfHwgcHJvcEtleSA9PT0gJ2NoZWNrZWQnIHx8IHByb3BLZXkgPT09ICdzZWxlY3RlZCcpIHtcbiAgICAgICAgLy8gTm9vcFxuICAgICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCkge1xuICAgICAgICB2YXIgcmF3SHRtbCA9IG5leHRQcm9wID8gbmV4dFByb3BbSFRNTF0gfHwgJycgOiAnJztcbiAgICAgICAgdmFyIHNlcnZlckhUTUwgPSBkb21FbGVtZW50LmlubmVySFRNTDtcbiAgICAgICAgdmFyIGV4cGVjdGVkSFRNTCA9IG5vcm1hbGl6ZUhUTUwoZG9tRWxlbWVudCwgcmF3SHRtbCk7XG4gICAgICAgIGlmIChleHBlY3RlZEhUTUwgIT09IHNlcnZlckhUTUwpIHtcbiAgICAgICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UocHJvcEtleSwgc2VydmVySFRNTCwgZXhwZWN0ZWRIVE1MKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXNbJ2RlbGV0ZSddKHByb3BLZXkpO1xuICAgICAgICB2YXIgZXhwZWN0ZWRTdHlsZSA9IGNyZWF0ZURhbmdlcm91c1N0cmluZ0ZvclN0eWxlcyhuZXh0UHJvcCk7XG4gICAgICAgIHNlcnZlclZhbHVlID0gZG9tRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICAgIGlmIChleHBlY3RlZFN0eWxlICE9PSBzZXJ2ZXJWYWx1ZSkge1xuICAgICAgICAgIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZShwcm9wS2V5LCBzZXJ2ZXJWYWx1ZSwgZXhwZWN0ZWRTdHlsZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICBleHRyYUF0dHJpYnV0ZU5hbWVzWydkZWxldGUnXShwcm9wS2V5LnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICBzZXJ2ZXJWYWx1ZSA9IGdldFZhbHVlRm9yQXR0cmlidXRlKGRvbUVsZW1lbnQsIHByb3BLZXksIG5leHRQcm9wKTtcblxuICAgICAgICBpZiAobmV4dFByb3AgIT09IHNlcnZlclZhbHVlKSB7XG4gICAgICAgICAgd2FybkZvclByb3BEaWZmZXJlbmNlKHByb3BLZXksIHNlcnZlclZhbHVlLCBuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc2hvdWxkU2V0QXR0cmlidXRlKHByb3BLZXksIG5leHRQcm9wKSkge1xuICAgICAgICBpZiAocHJvcGVydHlJbmZvID0gZ2V0UHJvcGVydHlJbmZvKHByb3BLZXkpKSB7XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXNbJ2RlbGV0ZSddKHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgICBzZXJ2ZXJWYWx1ZSA9IGdldFZhbHVlRm9yUHJvcGVydHkoZG9tRWxlbWVudCwgcHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBvd25OYW1lc3BhY2UgPSBwYXJlbnROYW1lc3BhY2U7XG4gICAgICAgICAgaWYgKG93bk5hbWVzcGFjZSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAgICAgICAgIG93bk5hbWVzcGFjZSA9IGdldEludHJpbnNpY05hbWVzcGFjZSh0YWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3duTmFtZXNwYWNlID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgICAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lc1snZGVsZXRlJ10ocHJvcEtleS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lc1snZGVsZXRlJ10ocHJvcEtleSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlcnZlclZhbHVlID0gZ2V0VmFsdWVGb3JBdHRyaWJ1dGUoZG9tRWxlbWVudCwgcHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5leHRQcm9wICE9PSBzZXJ2ZXJWYWx1ZSkge1xuICAgICAgICAgIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZShwcm9wS2V5LCBzZXJ2ZXJWYWx1ZSwgbmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAge1xuICAgIC8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbiAgICBpZiAoZXh0cmFBdHRyaWJ1dGVOYW1lcy5zaXplID4gMCAmJiAhc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nKSB7XG4gICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICB3YXJuRm9yRXh0cmFBdHRyaWJ1dGVzKGV4dHJhQXR0cmlidXRlTmFtZXMpO1xuICAgIH1cbiAgfVxuXG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgLy8gVE9ETzogTWFrZSBzdXJlIHdlIGNoZWNrIGlmIHRoaXMgaXMgc3RpbGwgdW5tb3VudGVkIG9yIGRvIGFueSBjbGVhblxuICAgICAgLy8gdXAgbmVjZXNzYXJ5IHNpbmNlIHdlIG5ldmVyIHN0b3AgdHJhY2tpbmcgYW55bW9yZS5cbiAgICAgIHRyYWNrKGRvbUVsZW1lbnQpO1xuICAgICAgcG9zdE1vdW50V3JhcHBlcihkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICAvLyBUT0RPOiBNYWtlIHN1cmUgd2UgY2hlY2sgaWYgdGhpcyBpcyBzdGlsbCB1bm1vdW50ZWQgb3IgZG8gYW55IGNsZWFuXG4gICAgICAvLyB1cCBuZWNlc3Nhcnkgc2luY2Ugd2UgbmV2ZXIgc3RvcCB0cmFja2luZyBhbnltb3JlLlxuICAgICAgdHJhY2soZG9tRWxlbWVudCk7XG4gICAgICBwb3N0TW91bnRXcmFwcGVyJDMoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICBjYXNlICdvcHRpb24nOlxuICAgICAgLy8gRm9yIGlucHV0IGFuZCB0ZXh0YXJlYSB3ZSBjdXJyZW50IGFsd2F5cyBzZXQgdGhlIHZhbHVlIHByb3BlcnR5IGF0XG4gICAgICAvLyBwb3N0IG1vdW50IHRvIGZvcmNlIGl0IHRvIGRpdmVyZ2UgZnJvbSBhdHRyaWJ1dGVzLiBIb3dldmVyLCBmb3JcbiAgICAgIC8vIG9wdGlvbiBhbmQgc2VsZWN0IHdlIGRvbid0IHF1aXRlIGRvIHRoZSBzYW1lIHRoaW5nIGFuZCBzZWxlY3RcbiAgICAgIC8vIGlzIG5vdCByZXNpbGllbnQgdG8gdGhlIERPTSBzdGF0ZSBjaGFuZ2luZyBzbyB3ZSBkb24ndCBkbyB0aGF0IGhlcmUuXG4gICAgICAvLyBUT0RPOiBDb25zaWRlciBub3QgZG9pbmcgdGhpcyBmb3IgaW5wdXQgYW5kIHRleHRhcmVhLlxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGlmICh0eXBlb2YgcmF3UHJvcHMub25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBUT0RPOiBUaGlzIGNhc3QgbWF5IG5vdCBiZSBzb3VuZCBmb3IgU1ZHLCBNYXRoTUwgb3IgY3VzdG9tIGVsZW1lbnRzLlxuICAgICAgICB0cmFwQ2xpY2tPbk5vbkludGVyYWN0aXZlRWxlbWVudChkb21FbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIHVwZGF0ZVBheWxvYWQ7XG59XG5cbmZ1bmN0aW9uIGRpZmZIeWRyYXRlZFRleHQkMSh0ZXh0Tm9kZSwgdGV4dCkge1xuICB2YXIgaXNEaWZmZXJlbnQgPSB0ZXh0Tm9kZS5ub2RlVmFsdWUgIT09IHRleHQ7XG4gIHJldHVybiBpc0RpZmZlcmVudDtcbn1cblxuZnVuY3Rpb24gd2FybkZvclVubWF0Y2hlZFRleHQkMSh0ZXh0Tm9kZSwgdGV4dCkge1xuICB7XG4gICAgd2FybkZvclRleHREaWZmZXJlbmNlKHRleHROb2RlLm5vZGVWYWx1ZSwgdGV4dCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudCQxKHBhcmVudE5vZGUsIGNoaWxkKSB7XG4gIHtcbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGlkV2FybkludmFsaWRIeWRyYXRpb24gPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsICdEaWQgbm90IGV4cGVjdCBzZXJ2ZXIgSFRNTCB0byBjb250YWluIGEgPCVzPiBpbiA8JXM+LicsIGNoaWxkLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksIHBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dCQxKHBhcmVudE5vZGUsIGNoaWxkKSB7XG4gIHtcbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGlkV2FybkludmFsaWRIeWRyYXRpb24gPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsICdEaWQgbm90IGV4cGVjdCBzZXJ2ZXIgSFRNTCB0byBjb250YWluIHRoZSB0ZXh0IG5vZGUgXCIlc1wiIGluIDwlcz4uJywgY2hpbGQubm9kZVZhbHVlLCBwYXJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudCQxKHBhcmVudE5vZGUsIHRhZywgcHJvcHMpIHtcbiAge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ0V4cGVjdGVkIHNlcnZlciBIVE1MIHRvIGNvbnRhaW4gYSBtYXRjaGluZyA8JXM+IGluIDwlcz4uJywgdGFnLCBwYXJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dCQxKHBhcmVudE5vZGUsIHRleHQpIHtcbiAge1xuICAgIGlmICh0ZXh0ID09PSAnJykge1xuICAgICAgLy8gV2UgZXhwZWN0IHRvIGluc2VydCBlbXB0eSB0ZXh0IG5vZGVzIHNpbmNlIHRoZXkncmUgbm90IHJlcHJlc2VudGVkIGluXG4gICAgICAvLyB0aGUgSFRNTC5cbiAgICAgIC8vIFRPRE86IFJlbW92ZSB0aGlzIHNwZWNpYWwgY2FzZSBpZiB3ZSBjYW4ganVzdCBhdm9pZCBpbnNlcnRpbmcgZW1wdHlcbiAgICAgIC8vIHRleHQgbm9kZXMuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ0V4cGVjdGVkIHNlcnZlciBIVE1MIHRvIGNvbnRhaW4gYSBtYXRjaGluZyB0ZXh0IG5vZGUgZm9yIFwiJXNcIiBpbiA8JXM+LicsIHRleHQsIHBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZShkb21FbGVtZW50LCB0YWcsIHByb3BzKSB7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQxKGRvbUVsZW1lbnQsIHByb3BzKTtcbiAgICAgIHJldHVybjtcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICByZXN0b3JlQ29udHJvbGxlZFN0YXRlJDMoZG9tRWxlbWVudCwgcHJvcHMpO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICByZXN0b3JlQ29udHJvbGxlZFN0YXRlJDIoZG9tRWxlbWVudCwgcHJvcHMpO1xuICAgICAgcmV0dXJuO1xuICB9XG59XG5cbnZhciBSZWFjdERPTUZpYmVyQ29tcG9uZW50ID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQkMSxcblx0Y3JlYXRlVGV4dE5vZGU6IGNyZWF0ZVRleHROb2RlJDEsXG5cdHNldEluaXRpYWxQcm9wZXJ0aWVzOiBzZXRJbml0aWFsUHJvcGVydGllcyQxLFxuXHRkaWZmUHJvcGVydGllczogZGlmZlByb3BlcnRpZXMkMSxcblx0dXBkYXRlUHJvcGVydGllczogdXBkYXRlUHJvcGVydGllcyQxLFxuXHRkaWZmSHlkcmF0ZWRQcm9wZXJ0aWVzOiBkaWZmSHlkcmF0ZWRQcm9wZXJ0aWVzJDEsXG5cdGRpZmZIeWRyYXRlZFRleHQ6IGRpZmZIeWRyYXRlZFRleHQkMSxcblx0d2FybkZvclVubWF0Y2hlZFRleHQ6IHdhcm5Gb3JVbm1hdGNoZWRUZXh0JDEsXG5cdHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQ6IHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQkMSxcblx0d2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dDogd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dCQxLFxuXHR3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQ6IHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudCQxLFxuXHR3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQ6IHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dCQxLFxuXHRyZXN0b3JlQ29udHJvbGxlZFN0YXRlOiByZXN0b3JlQ29udHJvbGxlZFN0YXRlXG59KTtcblxuLy8gVE9ETzogZGlyZWN0IGltcG9ydHMgbGlrZSBzb21lLXBhY2thZ2Uvc3JjLyogYXJlIGJhZC4gRml4IG1lLlxudmFyIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kNiA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bTtcblxudmFyIHZhbGlkYXRlRE9NTmVzdGluZyA9IGVtcHR5RnVuY3Rpb247XG5cbntcbiAgLy8gVGhpcyB2YWxpZGF0aW9uIGNvZGUgd2FzIHdyaXR0ZW4gYmFzZWQgb24gdGhlIEhUTUw1IHBhcnNpbmcgc3BlYzpcbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaGFzLWFuLWVsZW1lbnQtaW4tc2NvcGVcbiAgLy9cbiAgLy8gTm90ZTogdGhpcyBkb2VzIG5vdCBjYXRjaCBhbGwgaW52YWxpZCBuZXN0aW5nLCBub3IgZG9lcyBpdCB0cnkgdG8gKGFzIGl0J3NcbiAgLy8gbm90IGNsZWFyIHdoYXQgcHJhY3RpY2FsIGJlbmVmaXQgZG9pbmcgc28gcHJvdmlkZXMpOyBpbnN0ZWFkLCB3ZSB3YXJuIG9ubHlcbiAgLy8gZm9yIGNhc2VzIHdoZXJlIHRoZSBwYXJzZXIgd2lsbCBnaXZlIGEgcGFyc2UgdHJlZSBkaWZmZXJpbmcgZnJvbSB3aGF0IFJlYWN0XG4gIC8vIGludGVuZGVkLiBGb3IgZXhhbXBsZSwgPGI+PGRpdj48L2Rpdj48L2I+IGlzIGludmFsaWQgYnV0IHdlIGRvbid0IHdhcm5cbiAgLy8gYmVjYXVzZSBpdCBzdGlsbCBwYXJzZXMgY29ycmVjdGx5OyB3ZSBkbyB3YXJuIGZvciBvdGhlciBjYXNlcyBsaWtlIG5lc3RlZFxuICAvLyA8cD4gdGFncyB3aGVyZSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzZWNvbmQgZWxlbWVudCBpbXBsaWNpdGx5IGNsb3NlcyB0aGVcbiAgLy8gZmlyc3QsIGNhdXNpbmcgYSBjb25mdXNpbmcgbWVzcy5cblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNzcGVjaWFsXG4gIHZhciBzcGVjaWFsVGFncyA9IFsnYWRkcmVzcycsICdhcHBsZXQnLCAnYXJlYScsICdhcnRpY2xlJywgJ2FzaWRlJywgJ2Jhc2UnLCAnYmFzZWZvbnQnLCAnYmdzb3VuZCcsICdibG9ja3F1b3RlJywgJ2JvZHknLCAnYnInLCAnYnV0dG9uJywgJ2NhcHRpb24nLCAnY2VudGVyJywgJ2NvbCcsICdjb2xncm91cCcsICdkZCcsICdkZXRhaWxzJywgJ2RpcicsICdkaXYnLCAnZGwnLCAnZHQnLCAnZW1iZWQnLCAnZmllbGRzZXQnLCAnZmlnY2FwdGlvbicsICdmaWd1cmUnLCAnZm9vdGVyJywgJ2Zvcm0nLCAnZnJhbWUnLCAnZnJhbWVzZXQnLCAnaDEnLCAnaDInLCAnaDMnLCAnaDQnLCAnaDUnLCAnaDYnLCAnaGVhZCcsICdoZWFkZXInLCAnaGdyb3VwJywgJ2hyJywgJ2h0bWwnLCAnaWZyYW1lJywgJ2ltZycsICdpbnB1dCcsICdpc2luZGV4JywgJ2xpJywgJ2xpbmsnLCAnbGlzdGluZycsICdtYWluJywgJ21hcnF1ZWUnLCAnbWVudScsICdtZW51aXRlbScsICdtZXRhJywgJ25hdicsICdub2VtYmVkJywgJ25vZnJhbWVzJywgJ25vc2NyaXB0JywgJ29iamVjdCcsICdvbCcsICdwJywgJ3BhcmFtJywgJ3BsYWludGV4dCcsICdwcmUnLCAnc2NyaXB0JywgJ3NlY3Rpb24nLCAnc2VsZWN0JywgJ3NvdXJjZScsICdzdHlsZScsICdzdW1tYXJ5JywgJ3RhYmxlJywgJ3Rib2R5JywgJ3RkJywgJ3RlbXBsYXRlJywgJ3RleHRhcmVhJywgJ3Rmb290JywgJ3RoJywgJ3RoZWFkJywgJ3RpdGxlJywgJ3RyJywgJ3RyYWNrJywgJ3VsJywgJ3dicicsICd4bXAnXTtcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNoYXMtYW4tZWxlbWVudC1pbi1zY29wZVxuICB2YXIgaW5TY29wZVRhZ3MgPSBbJ2FwcGxldCcsICdjYXB0aW9uJywgJ2h0bWwnLCAndGFibGUnLCAndGQnLCAndGgnLCAnbWFycXVlZScsICdvYmplY3QnLCAndGVtcGxhdGUnLFxuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2h0bWwtaW50ZWdyYXRpb24tcG9pbnRcbiAgLy8gVE9ETzogRGlzdGluZ3Vpc2ggYnkgbmFtZXNwYWNlIGhlcmUgLS0gZm9yIDx0aXRsZT4sIGluY2x1ZGluZyBpdCBoZXJlXG4gIC8vIGVycnMgb24gdGhlIHNpZGUgb2YgZmV3ZXIgd2FybmluZ3NcbiAgJ2ZvcmVpZ25PYmplY3QnLCAnZGVzYycsICd0aXRsZSddO1xuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLWJ1dHRvbi1zY29wZVxuICB2YXIgYnV0dG9uU2NvcGVUYWdzID0gaW5TY29wZVRhZ3MuY29uY2F0KFsnYnV0dG9uJ10pO1xuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2dlbmVyYXRlLWltcGxpZWQtZW5kLXRhZ3NcbiAgdmFyIGltcGxpZWRFbmRUYWdzID0gWydkZCcsICdkdCcsICdsaScsICdvcHRpb24nLCAnb3B0Z3JvdXAnLCAncCcsICdycCcsICdydCddO1xuXG4gIHZhciBlbXB0eUFuY2VzdG9ySW5mbyA9IHtcbiAgICBjdXJyZW50OiBudWxsLFxuXG4gICAgZm9ybVRhZzogbnVsbCxcbiAgICBhVGFnSW5TY29wZTogbnVsbCxcbiAgICBidXR0b25UYWdJblNjb3BlOiBudWxsLFxuICAgIG5vYnJUYWdJblNjb3BlOiBudWxsLFxuICAgIHBUYWdJbkJ1dHRvblNjb3BlOiBudWxsLFxuXG4gICAgbGlzdEl0ZW1UYWdBdXRvY2xvc2luZzogbnVsbCxcbiAgICBkbEl0ZW1UYWdBdXRvY2xvc2luZzogbnVsbFxuICB9O1xuXG4gIHZhciB1cGRhdGVkQW5jZXN0b3JJbmZvJDEgPSBmdW5jdGlvbiAob2xkSW5mbywgdGFnLCBpbnN0YW5jZSkge1xuICAgIHZhciBhbmNlc3RvckluZm8gPSBfYXNzaWduKHt9LCBvbGRJbmZvIHx8IGVtcHR5QW5jZXN0b3JJbmZvKTtcbiAgICB2YXIgaW5mbyA9IHsgdGFnOiB0YWcsIGluc3RhbmNlOiBpbnN0YW5jZSB9O1xuXG4gICAgaWYgKGluU2NvcGVUYWdzLmluZGV4T2YodGFnKSAhPT0gLTEpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZSA9IG51bGw7XG4gICAgICBhbmNlc3RvckluZm8uYnV0dG9uVGFnSW5TY29wZSA9IG51bGw7XG4gICAgICBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGUgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoYnV0dG9uU2NvcGVUYWdzLmluZGV4T2YodGFnKSAhPT0gLTEpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gU2VlIHJ1bGVzIGZvciAnbGknLCAnZGQnLCAnZHQnIHN0YXJ0IHRhZ3MgaW5cbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5XG4gICAgaWYgKHNwZWNpYWxUYWdzLmluZGV4T2YodGFnKSAhPT0gLTEgJiYgdGFnICE9PSAnYWRkcmVzcycgJiYgdGFnICE9PSAnZGl2JyAmJiB0YWcgIT09ICdwJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3NpbmcgPSBudWxsO1xuICAgICAgYW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nID0gbnVsbDtcbiAgICB9XG5cbiAgICBhbmNlc3RvckluZm8uY3VycmVudCA9IGluZm87XG5cbiAgICBpZiAodGFnID09PSAnZm9ybScpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5mb3JtVGFnID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2EnKSB7XG4gICAgICBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnYnV0dG9uJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnbm9icicpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5ub2JyVGFnSW5TY29wZSA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdwJykge1xuICAgICAgYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2xpJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3NpbmcgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnZGQnIHx8IHRhZyA9PT0gJ2R0Jykge1xuICAgICAgYW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nID0gaW5mbztcbiAgICB9XG5cbiAgICByZXR1cm4gYW5jZXN0b3JJbmZvO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXJcbiAgICovXG4gIHZhciBpc1RhZ1ZhbGlkV2l0aFBhcmVudCA9IGZ1bmN0aW9uICh0YWcsIHBhcmVudFRhZykge1xuICAgIC8vIEZpcnN0LCBsZXQncyBjaGVjayBpZiB3ZSdyZSBpbiBhbiB1bnVzdWFsIHBhcnNpbmcgbW9kZS4uLlxuICAgIHN3aXRjaCAocGFyZW50VGFnKSB7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5zZWxlY3RcbiAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdvcHRpb24nIHx8IHRhZyA9PT0gJ29wdGdyb3VwJyB8fCB0YWcgPT09ICcjdGV4dCc7XG4gICAgICBjYXNlICdvcHRncm91cCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdvcHRpb24nIHx8IHRhZyA9PT0gJyN0ZXh0JztcbiAgICAgIC8vIFN0cmljdGx5IHNwZWFraW5nLCBzZWVpbmcgYW4gPG9wdGlvbj4gZG9lc24ndCBtZWFuIHdlJ3JlIGluIGEgPHNlbGVjdD5cbiAgICAgIC8vIGJ1dFxuICAgICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJyN0ZXh0JztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRkXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5jYXB0aW9uXG4gICAgICAvLyBObyBzcGVjaWFsIGJlaGF2aW9yIHNpbmNlIHRoZXNlIHJ1bGVzIGZhbGwgYmFjayB0byBcImluIGJvZHlcIiBtb2RlIGZvclxuICAgICAgLy8gYWxsIGV4Y2VwdCBzcGVjaWFsIHRhYmxlIG5vZGVzIHdoaWNoIGNhdXNlIGJhZCBwYXJzaW5nIGJlaGF2aW9yIGFueXdheS5cblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludHJcbiAgICAgIGNhc2UgJ3RyJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ3RoJyB8fCB0YWcgPT09ICd0ZCcgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGJvZHlcbiAgICAgIGNhc2UgJ3Rib2R5JzpcbiAgICAgIGNhc2UgJ3RoZWFkJzpcbiAgICAgIGNhc2UgJ3Rmb290JzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ3RyJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5jb2xncm91cFxuICAgICAgY2FzZSAnY29sZ3JvdXAnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnY29sJyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50YWJsZVxuICAgICAgY2FzZSAndGFibGUnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnY2FwdGlvbicgfHwgdGFnID09PSAnY29sZ3JvdXAnIHx8IHRhZyA9PT0gJ3Rib2R5JyB8fCB0YWcgPT09ICd0Zm9vdCcgfHwgdGFnID09PSAndGhlYWQnIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmhlYWRcbiAgICAgIGNhc2UgJ2hlYWQnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnYmFzZScgfHwgdGFnID09PSAnYmFzZWZvbnQnIHx8IHRhZyA9PT0gJ2Jnc291bmQnIHx8IHRhZyA9PT0gJ2xpbmsnIHx8IHRhZyA9PT0gJ21ldGEnIHx8IHRhZyA9PT0gJ3RpdGxlJyB8fCB0YWcgPT09ICdub3NjcmlwdCcgfHwgdGFnID09PSAnbm9mcmFtZXMnIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NlbWFudGljcy5odG1sI3RoZS1odG1sLWVsZW1lbnRcbiAgICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnaGVhZCcgfHwgdGFnID09PSAnYm9keSc7XG4gICAgICBjYXNlICcjZG9jdW1lbnQnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnaHRtbCc7XG4gICAgfVxuXG4gICAgLy8gUHJvYmFibHkgaW4gdGhlIFwiaW4gYm9keVwiIHBhcnNpbmcgbW9kZSwgc28gd2Ugb3V0bGF3IG9ubHkgdGFnIGNvbWJvc1xuICAgIC8vIHdoZXJlIHRoZSBwYXJzaW5nIHJ1bGVzIGNhdXNlIGltcGxpY2l0IG9wZW5zIG9yIGNsb3NlcyB0byBiZSBhZGRlZC5cbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5XG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgJ2gxJzpcbiAgICAgIGNhc2UgJ2gyJzpcbiAgICAgIGNhc2UgJ2gzJzpcbiAgICAgIGNhc2UgJ2g0JzpcbiAgICAgIGNhc2UgJ2g1JzpcbiAgICAgIGNhc2UgJ2g2JzpcbiAgICAgICAgcmV0dXJuIHBhcmVudFRhZyAhPT0gJ2gxJyAmJiBwYXJlbnRUYWcgIT09ICdoMicgJiYgcGFyZW50VGFnICE9PSAnaDMnICYmIHBhcmVudFRhZyAhPT0gJ2g0JyAmJiBwYXJlbnRUYWcgIT09ICdoNScgJiYgcGFyZW50VGFnICE9PSAnaDYnO1xuXG4gICAgICBjYXNlICdycCc6XG4gICAgICBjYXNlICdydCc6XG4gICAgICAgIHJldHVybiBpbXBsaWVkRW5kVGFncy5pbmRleE9mKHBhcmVudFRhZykgPT09IC0xO1xuXG4gICAgICBjYXNlICdib2R5JzpcbiAgICAgIGNhc2UgJ2NhcHRpb24nOlxuICAgICAgY2FzZSAnY29sJzpcbiAgICAgIGNhc2UgJ2NvbGdyb3VwJzpcbiAgICAgIGNhc2UgJ2ZyYW1lJzpcbiAgICAgIGNhc2UgJ2hlYWQnOlxuICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICBjYXNlICd0Ym9keSc6XG4gICAgICBjYXNlICd0ZCc6XG4gICAgICBjYXNlICd0Zm9vdCc6XG4gICAgICBjYXNlICd0aCc6XG4gICAgICBjYXNlICd0aGVhZCc6XG4gICAgICBjYXNlICd0cic6XG4gICAgICAgIC8vIFRoZXNlIHRhZ3MgYXJlIG9ubHkgdmFsaWQgd2l0aCBhIGZldyBwYXJlbnRzIHRoYXQgaGF2ZSBzcGVjaWFsIGNoaWxkXG4gICAgICAgIC8vIHBhcnNpbmcgcnVsZXMgLS0gaWYgd2UncmUgZG93biBoZXJlLCB0aGVuIG5vbmUgb2YgdGhvc2UgbWF0Y2hlZCBhbmRcbiAgICAgICAgLy8gc28gd2UgYWxsb3cgaXQgb25seSBpZiB3ZSBkb24ndCBrbm93IHdoYXQgdGhlIHBhcmVudCBpcywgYXMgYWxsIG90aGVyXG4gICAgICAgIC8vIGNhc2VzIGFyZSBpbnZhbGlkLlxuICAgICAgICByZXR1cm4gcGFyZW50VGFnID09IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlclxuICAgKi9cbiAgdmFyIGZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWcgPSBmdW5jdGlvbiAodGFnLCBhbmNlc3RvckluZm8pIHtcbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgY2FzZSAnYWRkcmVzcyc6XG4gICAgICBjYXNlICdhcnRpY2xlJzpcbiAgICAgIGNhc2UgJ2FzaWRlJzpcbiAgICAgIGNhc2UgJ2Jsb2NrcXVvdGUnOlxuICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgIGNhc2UgJ2RldGFpbHMnOlxuICAgICAgY2FzZSAnZGlhbG9nJzpcbiAgICAgIGNhc2UgJ2Rpcic6XG4gICAgICBjYXNlICdkaXYnOlxuICAgICAgY2FzZSAnZGwnOlxuICAgICAgY2FzZSAnZmllbGRzZXQnOlxuICAgICAgY2FzZSAnZmlnY2FwdGlvbic6XG4gICAgICBjYXNlICdmaWd1cmUnOlxuICAgICAgY2FzZSAnZm9vdGVyJzpcbiAgICAgIGNhc2UgJ2hlYWRlcic6XG4gICAgICBjYXNlICdoZ3JvdXAnOlxuICAgICAgY2FzZSAnbWFpbic6XG4gICAgICBjYXNlICdtZW51JzpcbiAgICAgIGNhc2UgJ25hdic6XG4gICAgICBjYXNlICdvbCc6XG4gICAgICBjYXNlICdwJzpcbiAgICAgIGNhc2UgJ3NlY3Rpb24nOlxuICAgICAgY2FzZSAnc3VtbWFyeSc6XG4gICAgICBjYXNlICd1bCc6XG4gICAgICBjYXNlICdwcmUnOlxuICAgICAgY2FzZSAnbGlzdGluZyc6XG4gICAgICBjYXNlICd0YWJsZSc6XG4gICAgICBjYXNlICdocic6XG4gICAgICBjYXNlICd4bXAnOlxuICAgICAgY2FzZSAnaDEnOlxuICAgICAgY2FzZSAnaDInOlxuICAgICAgY2FzZSAnaDMnOlxuICAgICAgY2FzZSAnaDQnOlxuICAgICAgY2FzZSAnaDUnOlxuICAgICAgY2FzZSAnaDYnOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlO1xuXG4gICAgICBjYXNlICdmb3JtJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5mb3JtVGFnIHx8IGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZTtcblxuICAgICAgY2FzZSAnbGknOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3Npbmc7XG5cbiAgICAgIGNhc2UgJ2RkJzpcbiAgICAgIGNhc2UgJ2R0JzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZztcblxuICAgICAgY2FzZSAnYnV0dG9uJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlO1xuXG4gICAgICBjYXNlICdhJzpcbiAgICAgICAgLy8gU3BlYyBzYXlzIHNvbWV0aGluZyBhYm91dCBzdG9yaW5nIGEgbGlzdCBvZiBtYXJrZXJzLCBidXQgaXQgc291bmRzXG4gICAgICAgIC8vIGVxdWl2YWxlbnQgdG8gdGhpcyBjaGVjay5cbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZTtcblxuICAgICAgY2FzZSAnbm9icic6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgdmFyIGRpZFdhcm4gPSB7fTtcblxuICB2YWxpZGF0ZURPTU5lc3RpbmcgPSBmdW5jdGlvbiAoY2hpbGRUYWcsIGNoaWxkVGV4dCwgYW5jZXN0b3JJbmZvKSB7XG4gICAgYW5jZXN0b3JJbmZvID0gYW5jZXN0b3JJbmZvIHx8IGVtcHR5QW5jZXN0b3JJbmZvO1xuICAgIHZhciBwYXJlbnRJbmZvID0gYW5jZXN0b3JJbmZvLmN1cnJlbnQ7XG4gICAgdmFyIHBhcmVudFRhZyA9IHBhcmVudEluZm8gJiYgcGFyZW50SW5mby50YWc7XG5cbiAgICBpZiAoY2hpbGRUZXh0ICE9IG51bGwpIHtcbiAgICAgIHdhcm5pbmcoY2hpbGRUYWcgPT0gbnVsbCwgJ3ZhbGlkYXRlRE9NTmVzdGluZzogd2hlbiBjaGlsZFRleHQgaXMgcGFzc2VkLCBjaGlsZFRhZyBzaG91bGQgYmUgbnVsbCcpO1xuICAgICAgY2hpbGRUYWcgPSAnI3RleHQnO1xuICAgIH1cblxuICAgIHZhciBpbnZhbGlkUGFyZW50ID0gaXNUYWdWYWxpZFdpdGhQYXJlbnQoY2hpbGRUYWcsIHBhcmVudFRhZykgPyBudWxsIDogcGFyZW50SW5mbztcbiAgICB2YXIgaW52YWxpZEFuY2VzdG9yID0gaW52YWxpZFBhcmVudCA/IG51bGwgOiBmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnKGNoaWxkVGFnLCBhbmNlc3RvckluZm8pO1xuICAgIHZhciBpbnZhbGlkUGFyZW50T3JBbmNlc3RvciA9IGludmFsaWRQYXJlbnQgfHwgaW52YWxpZEFuY2VzdG9yO1xuICAgIGlmICghaW52YWxpZFBhcmVudE9yQW5jZXN0b3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYW5jZXN0b3JUYWcgPSBpbnZhbGlkUGFyZW50T3JBbmNlc3Rvci50YWc7XG4gICAgdmFyIGFkZGVuZHVtID0gZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQ2KCk7XG5cbiAgICB2YXIgd2FybktleSA9ICEhaW52YWxpZFBhcmVudCArICd8JyArIGNoaWxkVGFnICsgJ3wnICsgYW5jZXN0b3JUYWcgKyAnfCcgKyBhZGRlbmR1bTtcbiAgICBpZiAoZGlkV2Fyblt3YXJuS2V5XSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuW3dhcm5LZXldID0gdHJ1ZTtcblxuICAgIHZhciB0YWdEaXNwbGF5TmFtZSA9IGNoaWxkVGFnO1xuICAgIHZhciB3aGl0ZXNwYWNlSW5mbyA9ICcnO1xuICAgIGlmIChjaGlsZFRhZyA9PT0gJyN0ZXh0Jykge1xuICAgICAgaWYgKC9cXFMvLnRlc3QoY2hpbGRUZXh0KSkge1xuICAgICAgICB0YWdEaXNwbGF5TmFtZSA9ICdUZXh0IG5vZGVzJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhZ0Rpc3BsYXlOYW1lID0gJ1doaXRlc3BhY2UgdGV4dCBub2Rlcyc7XG4gICAgICAgIHdoaXRlc3BhY2VJbmZvID0gXCIgTWFrZSBzdXJlIHlvdSBkb24ndCBoYXZlIGFueSBleHRyYSB3aGl0ZXNwYWNlIGJldHdlZW4gdGFncyBvbiBcIiArICdlYWNoIGxpbmUgb2YgeW91ciBzb3VyY2UgY29kZS4nO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0YWdEaXNwbGF5TmFtZSA9ICc8JyArIGNoaWxkVGFnICsgJz4nO1xuICAgIH1cblxuICAgIGlmIChpbnZhbGlkUGFyZW50KSB7XG4gICAgICB2YXIgaW5mbyA9ICcnO1xuICAgICAgaWYgKGFuY2VzdG9yVGFnID09PSAndGFibGUnICYmIGNoaWxkVGFnID09PSAndHInKSB7XG4gICAgICAgIGluZm8gKz0gJyBBZGQgYSA8dGJvZHk+IHRvIHlvdXIgY29kZSB0byBtYXRjaCB0aGUgRE9NIHRyZWUgZ2VuZXJhdGVkIGJ5ICcgKyAndGhlIGJyb3dzZXIuJztcbiAgICAgIH1cbiAgICAgIHdhcm5pbmcoZmFsc2UsICd2YWxpZGF0ZURPTU5lc3RpbmcoLi4uKTogJXMgY2Fubm90IGFwcGVhciBhcyBhIGNoaWxkIG9mIDwlcz4uJXMlcyVzJywgdGFnRGlzcGxheU5hbWUsIGFuY2VzdG9yVGFnLCB3aGl0ZXNwYWNlSW5mbywgaW5mbywgYWRkZW5kdW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAndmFsaWRhdGVET01OZXN0aW5nKC4uLik6ICVzIGNhbm5vdCBhcHBlYXIgYXMgYSBkZXNjZW5kYW50IG9mICcgKyAnPCVzPi4lcycsIHRhZ0Rpc3BsYXlOYW1lLCBhbmNlc3RvclRhZywgYWRkZW5kdW0pO1xuICAgIH1cbiAgfTtcblxuICAvLyBUT0RPOiB0dXJuIHRoaXMgaW50byBhIG5hbWVkIGV4cG9ydFxuICB2YWxpZGF0ZURPTU5lc3RpbmcudXBkYXRlZEFuY2VzdG9ySW5mbyA9IHVwZGF0ZWRBbmNlc3RvckluZm8kMTtcblxuICAvLyBGb3IgdGVzdGluZ1xuICB2YWxpZGF0ZURPTU5lc3RpbmcuaXNUYWdWYWxpZEluQ29udGV4dCA9IGZ1bmN0aW9uICh0YWcsIGFuY2VzdG9ySW5mbykge1xuICAgIGFuY2VzdG9ySW5mbyA9IGFuY2VzdG9ySW5mbyB8fCBlbXB0eUFuY2VzdG9ySW5mbztcbiAgICB2YXIgcGFyZW50SW5mbyA9IGFuY2VzdG9ySW5mby5jdXJyZW50O1xuICAgIHZhciBwYXJlbnRUYWcgPSBwYXJlbnRJbmZvICYmIHBhcmVudEluZm8udGFnO1xuICAgIHJldHVybiBpc1RhZ1ZhbGlkV2l0aFBhcmVudCh0YWcsIHBhcmVudFRhZykgJiYgIWZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWcodGFnLCBhbmNlc3RvckluZm8pO1xuICB9O1xufVxuXG52YXIgdmFsaWRhdGVET01OZXN0aW5nJDEgPSB2YWxpZGF0ZURPTU5lc3Rpbmc7XG5cbi8vIFRPRE86IGRpcmVjdCBpbXBvcnRzIGxpa2Ugc29tZS1wYWNrYWdlL3NyYy8qIGFyZSBiYWQuIEZpeCBtZS5cbnZhciBjcmVhdGVFbGVtZW50ID0gY3JlYXRlRWxlbWVudCQxO1xudmFyIGNyZWF0ZVRleHROb2RlID0gY3JlYXRlVGV4dE5vZGUkMTtcbnZhciBzZXRJbml0aWFsUHJvcGVydGllcyA9IHNldEluaXRpYWxQcm9wZXJ0aWVzJDE7XG52YXIgZGlmZlByb3BlcnRpZXMgPSBkaWZmUHJvcGVydGllcyQxO1xudmFyIHVwZGF0ZVByb3BlcnRpZXMgPSB1cGRhdGVQcm9wZXJ0aWVzJDE7XG52YXIgZGlmZkh5ZHJhdGVkUHJvcGVydGllcyA9IGRpZmZIeWRyYXRlZFByb3BlcnRpZXMkMTtcbnZhciBkaWZmSHlkcmF0ZWRUZXh0ID0gZGlmZkh5ZHJhdGVkVGV4dCQxO1xudmFyIHdhcm5Gb3JVbm1hdGNoZWRUZXh0ID0gd2FybkZvclVubWF0Y2hlZFRleHQkMTtcbnZhciB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50ID0gd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudCQxO1xudmFyIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZVRleHQgPSB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0JDE7XG52YXIgd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50ID0gd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50JDE7XG52YXIgd2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0ID0gd2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0JDE7XG52YXIgdXBkYXRlZEFuY2VzdG9ySW5mbyA9IHZhbGlkYXRlRE9NTmVzdGluZyQxLnVwZGF0ZWRBbmNlc3RvckluZm87XG52YXIgcHJlY2FjaGVGaWJlck5vZGUgPSBwcmVjYWNoZUZpYmVyTm9kZSQxO1xudmFyIHVwZGF0ZUZpYmVyUHJvcHMgPSB1cGRhdGVGaWJlclByb3BzJDE7XG5cblxue1xuICB2YXIgU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkcgPSAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJztcbiAgaWYgKHR5cGVvZiBNYXAgIT09ICdmdW5jdGlvbicgfHwgTWFwLnByb3RvdHlwZSA9PSBudWxsIHx8IHR5cGVvZiBNYXAucHJvdG90eXBlLmZvckVhY2ggIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIFNldCAhPT0gJ2Z1bmN0aW9uJyB8fCBTZXQucHJvdG90eXBlID09IG51bGwgfHwgdHlwZW9mIFNldC5wcm90b3R5cGUuY2xlYXIgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIFNldC5wcm90b3R5cGUuZm9yRWFjaCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHdhcm5pbmcoZmFsc2UsICdSZWFjdCBkZXBlbmRzIG9uIE1hcCBhbmQgU2V0IGJ1aWx0LWluIHR5cGVzLiBNYWtlIHN1cmUgdGhhdCB5b3UgbG9hZCBhICcgKyAncG9seWZpbGwgaW4gb2xkZXIgYnJvd3NlcnMuIGh0dHA6Ly9mYi5tZS9yZWFjdC1wb2x5ZmlsbHMnKTtcbiAgfVxufVxuXG5pbmplY3Rpb24kMy5pbmplY3RGaWJlckNvbnRyb2xsZWRIb3N0Q29tcG9uZW50KFJlYWN0RE9NRmliZXJDb21wb25lbnQpO1xuXG52YXIgZXZlbnRzRW5hYmxlZCA9IG51bGw7XG52YXIgc2VsZWN0aW9uSW5mb3JtYXRpb24gPSBudWxsO1xuXG4vKipcbiAqIFRydWUgaWYgdGhlIHN1cHBsaWVkIERPTSBub2RlIGlzIGEgdmFsaWQgbm9kZSBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7P0RPTUVsZW1lbnR9IG5vZGUgVGhlIGNhbmRpZGF0ZSBET00gbm9kZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIERPTSBpcyBhIHZhbGlkIERPTSBub2RlLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRDb250YWluZXIobm9kZSkge1xuICByZXR1cm4gISEobm9kZSAmJiAobm9kZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFIHx8IG5vZGUubm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUgfHwgbm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERSB8fCBub2RlLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUgJiYgbm9kZS5ub2RlVmFsdWUgPT09ICcgcmVhY3QtbW91bnQtcG9pbnQtdW5zdGFibGUgJykpO1xufVxuXG5mdW5jdGlvbiBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKSB7XG4gIGlmICghY29udGFpbmVyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5kb2N1bWVudEVsZW1lbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5maXJzdENoaWxkO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZEh5ZHJhdGVEdWVUb0xlZ2FjeUhldXJpc3RpYyhjb250YWluZXIpIHtcbiAgdmFyIHJvb3RFbGVtZW50ID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gIHJldHVybiAhIShyb290RWxlbWVudCAmJiByb290RWxlbWVudC5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFICYmIHJvb3RFbGVtZW50Lmhhc0F0dHJpYnV0ZShST09UX0FUVFJJQlVURV9OQU1FKSk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZEF1dG9Gb2N1c0hvc3RDb21wb25lbnQodHlwZSwgcHJvcHMpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnYnV0dG9uJzpcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICByZXR1cm4gISFwcm9wcy5hdXRvRm9jdXM7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgRE9NUmVuZGVyZXIgPSByZWFjdFJlY29uY2lsZXIoe1xuICBnZXRSb290SG9zdENvbnRleHQ6IGZ1bmN0aW9uIChyb290Q29udGFpbmVySW5zdGFuY2UpIHtcbiAgICB2YXIgdHlwZSA9IHZvaWQgMDtcbiAgICB2YXIgbmFtZXNwYWNlID0gdm9pZCAwO1xuICAgIHZhciBub2RlVHlwZSA9IHJvb3RDb250YWluZXJJbnN0YW5jZS5ub2RlVHlwZTtcbiAgICBzd2l0Y2ggKG5vZGVUeXBlKSB7XG4gICAgICBjYXNlIERPQ1VNRU5UX05PREU6XG4gICAgICBjYXNlIERPQ1VNRU5UX0ZSQUdNRU5UX05PREU6XG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlID0gbm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUgPyAnI2RvY3VtZW50JyA6ICcjZnJhZ21lbnQnO1xuICAgICAgICAgIHZhciByb290ID0gcm9vdENvbnRhaW5lckluc3RhbmNlLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgICBuYW1lc3BhY2UgPSByb290ID8gcm9vdC5uYW1lc3BhY2VVUkkgOiBnZXRDaGlsZE5hbWVzcGFjZShudWxsLCAnJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgY29udGFpbmVyID0gbm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSA/IHJvb3RDb250YWluZXJJbnN0YW5jZS5wYXJlbnROb2RlIDogcm9vdENvbnRhaW5lckluc3RhbmNlO1xuICAgICAgICAgIHZhciBvd25OYW1lc3BhY2UgPSBjb250YWluZXIubmFtZXNwYWNlVVJJIHx8IG51bGw7XG4gICAgICAgICAgdHlwZSA9IGNvbnRhaW5lci50YWdOYW1lO1xuICAgICAgICAgIG5hbWVzcGFjZSA9IGdldENoaWxkTmFtZXNwYWNlKG93bk5hbWVzcGFjZSwgdHlwZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAge1xuICAgICAgdmFyIHZhbGlkYXRlZFRhZyA9IHR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciBfYW5jZXN0b3JJbmZvID0gdXBkYXRlZEFuY2VzdG9ySW5mbyhudWxsLCB2YWxpZGF0ZWRUYWcsIG51bGwpO1xuICAgICAgcmV0dXJuIHsgbmFtZXNwYWNlOiBuYW1lc3BhY2UsIGFuY2VzdG9ySW5mbzogX2FuY2VzdG9ySW5mbyB9O1xuICAgIH1cbiAgICByZXR1cm4gbmFtZXNwYWNlO1xuICB9LFxuICBnZXRDaGlsZEhvc3RDb250ZXh0OiBmdW5jdGlvbiAocGFyZW50SG9zdENvbnRleHQsIHR5cGUpIHtcbiAgICB7XG4gICAgICB2YXIgcGFyZW50SG9zdENvbnRleHREZXYgPSBwYXJlbnRIb3N0Q29udGV4dDtcbiAgICAgIHZhciBfbmFtZXNwYWNlID0gZ2V0Q2hpbGROYW1lc3BhY2UocGFyZW50SG9zdENvbnRleHREZXYubmFtZXNwYWNlLCB0eXBlKTtcbiAgICAgIHZhciBfYW5jZXN0b3JJbmZvMiA9IHVwZGF0ZWRBbmNlc3RvckluZm8ocGFyZW50SG9zdENvbnRleHREZXYuYW5jZXN0b3JJbmZvLCB0eXBlLCBudWxsKTtcbiAgICAgIHJldHVybiB7IG5hbWVzcGFjZTogX25hbWVzcGFjZSwgYW5jZXN0b3JJbmZvOiBfYW5jZXN0b3JJbmZvMiB9O1xuICAgIH1cbiAgICB2YXIgcGFyZW50TmFtZXNwYWNlID0gcGFyZW50SG9zdENvbnRleHQ7XG4gICAgcmV0dXJuIGdldENoaWxkTmFtZXNwYWNlKHBhcmVudE5hbWVzcGFjZSwgdHlwZSk7XG4gIH0sXG4gIGdldFB1YmxpY0luc3RhbmNlOiBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0sXG4gIHByZXBhcmVGb3JDb21taXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBldmVudHNFbmFibGVkID0gaXNFbmFibGVkKCk7XG4gICAgc2VsZWN0aW9uSW5mb3JtYXRpb24gPSBnZXRTZWxlY3Rpb25JbmZvcm1hdGlvbigpO1xuICAgIHNldEVuYWJsZWQoZmFsc2UpO1xuICB9LFxuICByZXNldEFmdGVyQ29tbWl0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmVzdG9yZVNlbGVjdGlvbihzZWxlY3Rpb25JbmZvcm1hdGlvbik7XG4gICAgc2VsZWN0aW9uSW5mb3JtYXRpb24gPSBudWxsO1xuICAgIHNldEVuYWJsZWQoZXZlbnRzRW5hYmxlZCk7XG4gICAgZXZlbnRzRW5hYmxlZCA9IG51bGw7XG4gIH0sXG4gIGNyZWF0ZUluc3RhbmNlOiBmdW5jdGlvbiAodHlwZSwgcHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgICB2YXIgcGFyZW50TmFtZXNwYWNlID0gdm9pZCAwO1xuICAgIHtcbiAgICAgIC8vIFRPRE86IHRha2UgbmFtZXNwYWNlIGludG8gYWNjb3VudCB3aGVuIHZhbGlkYXRpbmcuXG4gICAgICB2YXIgaG9zdENvbnRleHREZXYgPSBob3N0Q29udGV4dDtcbiAgICAgIHZhbGlkYXRlRE9NTmVzdGluZyQxKHR5cGUsIG51bGwsIGhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbyk7XG4gICAgICBpZiAodHlwZW9mIHByb3BzLmNoaWxkcmVuID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgcHJvcHMuY2hpbGRyZW4gPT09ICdudW1iZXInKSB7XG4gICAgICAgIHZhciBzdHJpbmcgPSAnJyArIHByb3BzLmNoaWxkcmVuO1xuICAgICAgICB2YXIgb3duQW5jZXN0b3JJbmZvID0gdXBkYXRlZEFuY2VzdG9ySW5mbyhob3N0Q29udGV4dERldi5hbmNlc3RvckluZm8sIHR5cGUsIG51bGwpO1xuICAgICAgICB2YWxpZGF0ZURPTU5lc3RpbmckMShudWxsLCBzdHJpbmcsIG93bkFuY2VzdG9ySW5mbyk7XG4gICAgICB9XG4gICAgICBwYXJlbnROYW1lc3BhY2UgPSBob3N0Q29udGV4dERldi5uYW1lc3BhY2U7XG4gICAgfVxuICAgIHZhciBkb21FbGVtZW50ID0gY3JlYXRlRWxlbWVudCh0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBwYXJlbnROYW1lc3BhY2UpO1xuICAgIHByZWNhY2hlRmliZXJOb2RlKGludGVybmFsSW5zdGFuY2VIYW5kbGUsIGRvbUVsZW1lbnQpO1xuICAgIHVwZGF0ZUZpYmVyUHJvcHMoZG9tRWxlbWVudCwgcHJvcHMpO1xuICAgIHJldHVybiBkb21FbGVtZW50O1xuICB9LFxuICBhcHBlbmRJbml0aWFsQ2hpbGQ6IGZ1bmN0aW9uIChwYXJlbnRJbnN0YW5jZSwgY2hpbGQpIHtcbiAgICBwYXJlbnRJbnN0YW5jZS5hcHBlbmRDaGlsZChjaGlsZCk7XG4gIH0sXG4gIGZpbmFsaXplSW5pdGlhbENoaWxkcmVuOiBmdW5jdGlvbiAoZG9tRWxlbWVudCwgdHlwZSwgcHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSkge1xuICAgIHNldEluaXRpYWxQcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHR5cGUsIHByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpO1xuICAgIHJldHVybiBzaG91bGRBdXRvRm9jdXNIb3N0Q29tcG9uZW50KHR5cGUsIHByb3BzKTtcbiAgfSxcbiAgcHJlcGFyZVVwZGF0ZTogZnVuY3Rpb24gKGRvbUVsZW1lbnQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCkge1xuICAgIHtcbiAgICAgIHZhciBob3N0Q29udGV4dERldiA9IGhvc3RDb250ZXh0O1xuICAgICAgaWYgKHR5cGVvZiBuZXdQcm9wcy5jaGlsZHJlbiAhPT0gdHlwZW9mIG9sZFByb3BzLmNoaWxkcmVuICYmICh0eXBlb2YgbmV3UHJvcHMuY2hpbGRyZW4gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBuZXdQcm9wcy5jaGlsZHJlbiA9PT0gJ251bWJlcicpKSB7XG4gICAgICAgIHZhciBzdHJpbmcgPSAnJyArIG5ld1Byb3BzLmNoaWxkcmVuO1xuICAgICAgICB2YXIgb3duQW5jZXN0b3JJbmZvID0gdXBkYXRlZEFuY2VzdG9ySW5mbyhob3N0Q29udGV4dERldi5hbmNlc3RvckluZm8sIHR5cGUsIG51bGwpO1xuICAgICAgICB2YWxpZGF0ZURPTU5lc3RpbmckMShudWxsLCBzdHJpbmcsIG93bkFuY2VzdG9ySW5mbyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkaWZmUHJvcGVydGllcyhkb21FbGVtZW50LCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSk7XG4gIH0sXG4gIHNob3VsZFNldFRleHRDb250ZW50OiBmdW5jdGlvbiAodHlwZSwgcHJvcHMpIHtcbiAgICByZXR1cm4gdHlwZSA9PT0gJ3RleHRhcmVhJyB8fCB0eXBlb2YgcHJvcHMuY2hpbGRyZW4gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBwcm9wcy5jaGlsZHJlbiA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09PSAnb2JqZWN0JyAmJiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAhPT0gbnVsbCAmJiB0eXBlb2YgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwuX19odG1sID09PSAnc3RyaW5nJztcbiAgfSxcbiAgc2hvdWxkRGVwcmlvcml0aXplU3VidHJlZTogZnVuY3Rpb24gKHR5cGUsIHByb3BzKSB7XG4gICAgcmV0dXJuICEhcHJvcHMuaGlkZGVuO1xuICB9LFxuICBjcmVhdGVUZXh0SW5zdGFuY2U6IGZ1bmN0aW9uICh0ZXh0LCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0LCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gICAge1xuICAgICAgdmFyIGhvc3RDb250ZXh0RGV2ID0gaG9zdENvbnRleHQ7XG4gICAgICB2YWxpZGF0ZURPTU5lc3RpbmckMShudWxsLCB0ZXh0LCBob3N0Q29udGV4dERldi5hbmNlc3RvckluZm8pO1xuICAgIH1cbiAgICB2YXIgdGV4dE5vZGUgPSBjcmVhdGVUZXh0Tm9kZSh0ZXh0LCByb290Q29udGFpbmVySW5zdGFuY2UpO1xuICAgIHByZWNhY2hlRmliZXJOb2RlKGludGVybmFsSW5zdGFuY2VIYW5kbGUsIHRleHROb2RlKTtcbiAgICByZXR1cm4gdGV4dE5vZGU7XG4gIH0sXG5cblxuICBub3c6IG5vdyxcblxuICBtdXRhdGlvbjoge1xuICAgIGNvbW1pdE1vdW50OiBmdW5jdGlvbiAoZG9tRWxlbWVudCwgdHlwZSwgbmV3UHJvcHMsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgICAgIGRvbUVsZW1lbnQuZm9jdXMoKTtcbiAgICB9LFxuICAgIGNvbW1pdFVwZGF0ZTogZnVuY3Rpb24gKGRvbUVsZW1lbnQsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSkge1xuICAgICAgLy8gVXBkYXRlIHRoZSBwcm9wcyBoYW5kbGUgc28gdGhhdCB3ZSBrbm93IHdoaWNoIHByb3BzIGFyZSB0aGUgb25lcyB3aXRoXG4gICAgICAvLyB3aXRoIGN1cnJlbnQgZXZlbnQgaGFuZGxlcnMuXG4gICAgICB1cGRhdGVGaWJlclByb3BzKGRvbUVsZW1lbnQsIG5ld1Byb3BzKTtcbiAgICAgIC8vIEFwcGx5IHRoZSBkaWZmIHRvIHRoZSBET00gbm9kZS5cbiAgICAgIHVwZGF0ZVByb3BlcnRpZXMoZG9tRWxlbWVudCwgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzKTtcbiAgICB9LFxuICAgIHJlc2V0VGV4dENvbnRlbnQ6IGZ1bmN0aW9uIChkb21FbGVtZW50KSB7XG4gICAgICBkb21FbGVtZW50LnRleHRDb250ZW50ID0gJyc7XG4gICAgfSxcbiAgICBjb21taXRUZXh0VXBkYXRlOiBmdW5jdGlvbiAodGV4dEluc3RhbmNlLCBvbGRUZXh0LCBuZXdUZXh0KSB7XG4gICAgICB0ZXh0SW5zdGFuY2Uubm9kZVZhbHVlID0gbmV3VGV4dDtcbiAgICB9LFxuICAgIGFwcGVuZENoaWxkOiBmdW5jdGlvbiAocGFyZW50SW5zdGFuY2UsIGNoaWxkKSB7XG4gICAgICBwYXJlbnRJbnN0YW5jZS5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgfSxcbiAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyOiBmdW5jdGlvbiAoY29udGFpbmVyLCBjaGlsZCkge1xuICAgICAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFKSB7XG4gICAgICAgIGNvbnRhaW5lci5wYXJlbnROb2RlLmluc2VydEJlZm9yZShjaGlsZCwgY29udGFpbmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBpbnNlcnRCZWZvcmU6IGZ1bmN0aW9uIChwYXJlbnRJbnN0YW5jZSwgY2hpbGQsIGJlZm9yZUNoaWxkKSB7XG4gICAgICBwYXJlbnRJbnN0YW5jZS5pbnNlcnRCZWZvcmUoY2hpbGQsIGJlZm9yZUNoaWxkKTtcbiAgICB9LFxuICAgIGluc2VydEluQ29udGFpbmVyQmVmb3JlOiBmdW5jdGlvbiAoY29udGFpbmVyLCBjaGlsZCwgYmVmb3JlQ2hpbGQpIHtcbiAgICAgIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSkge1xuICAgICAgICBjb250YWluZXIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY2hpbGQsIGJlZm9yZUNoaWxkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRhaW5lci5pbnNlcnRCZWZvcmUoY2hpbGQsIGJlZm9yZUNoaWxkKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbW92ZUNoaWxkOiBmdW5jdGlvbiAocGFyZW50SW5zdGFuY2UsIGNoaWxkKSB7XG4gICAgICBwYXJlbnRJbnN0YW5jZS5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgfSxcbiAgICByZW1vdmVDaGlsZEZyb21Db250YWluZXI6IGZ1bmN0aW9uIChjb250YWluZXIsIGNoaWxkKSB7XG4gICAgICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIHtcbiAgICAgICAgY29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgaHlkcmF0aW9uOiB7XG4gICAgY2FuSHlkcmF0ZUluc3RhbmNlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIHR5cGUsIHByb3BzKSB7XG4gICAgICBpZiAoaW5zdGFuY2Uubm9kZVR5cGUgIT09IEVMRU1FTlRfTk9ERSB8fCB0eXBlLnRvTG93ZXJDYXNlKCkgIT09IGluc3RhbmNlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICAvLyBUaGlzIGhhcyBub3cgYmVlbiByZWZpbmVkIHRvIGFuIGVsZW1lbnQgbm9kZS5cbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9LFxuICAgIGNhbkh5ZHJhdGVUZXh0SW5zdGFuY2U6IGZ1bmN0aW9uIChpbnN0YW5jZSwgdGV4dCkge1xuICAgICAgaWYgKHRleHQgPT09ICcnIHx8IGluc3RhbmNlLm5vZGVUeXBlICE9PSBURVhUX05PREUpIHtcbiAgICAgICAgLy8gRW1wdHkgc3RyaW5ncyBhcmUgbm90IHBhcnNlZCBieSBIVE1MIHNvIHRoZXJlIHdvbid0IGJlIGEgY29ycmVjdCBtYXRjaCBoZXJlLlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIC8vIFRoaXMgaGFzIG5vdyBiZWVuIHJlZmluZWQgdG8gYSB0ZXh0IG5vZGUuXG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfSxcbiAgICBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmc6IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgdmFyIG5vZGUgPSBpbnN0YW5jZS5uZXh0U2libGluZztcbiAgICAgIC8vIFNraXAgbm9uLWh5ZHJhdGFibGUgbm9kZXMuXG4gICAgICB3aGlsZSAobm9kZSAmJiBub2RlLm5vZGVUeXBlICE9PSBFTEVNRU5UX05PREUgJiYgbm9kZS5ub2RlVHlwZSAhPT0gVEVYVF9OT0RFKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSxcbiAgICBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZDogZnVuY3Rpb24gKHBhcmVudEluc3RhbmNlKSB7XG4gICAgICB2YXIgbmV4dCA9IHBhcmVudEluc3RhbmNlLmZpcnN0Q2hpbGQ7XG4gICAgICAvLyBTa2lwIG5vbi1oeWRyYXRhYmxlIG5vZGVzLlxuICAgICAgd2hpbGUgKG5leHQgJiYgbmV4dC5ub2RlVHlwZSAhPT0gRUxFTUVOVF9OT0RFICYmIG5leHQubm9kZVR5cGUgIT09IFRFWFRfTk9ERSkge1xuICAgICAgICBuZXh0ID0gbmV4dC5uZXh0U2libGluZztcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH0sXG4gICAgaHlkcmF0ZUluc3RhbmNlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIHR5cGUsIHByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0LCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gICAgICBwcmVjYWNoZUZpYmVyTm9kZShpbnRlcm5hbEluc3RhbmNlSGFuZGxlLCBpbnN0YW5jZSk7XG4gICAgICAvLyBUT0RPOiBQb3NzaWJseSBkZWZlciB0aGlzIHVudGlsIHRoZSBjb21taXQgcGhhc2Ugd2hlcmUgYWxsIHRoZSBldmVudHNcbiAgICAgIC8vIGdldCBhdHRhY2hlZC5cbiAgICAgIHVwZGF0ZUZpYmVyUHJvcHMoaW5zdGFuY2UsIHByb3BzKTtcbiAgICAgIHZhciBwYXJlbnROYW1lc3BhY2UgPSB2b2lkIDA7XG4gICAgICB7XG4gICAgICAgIHZhciBob3N0Q29udGV4dERldiA9IGhvc3RDb250ZXh0O1xuICAgICAgICBwYXJlbnROYW1lc3BhY2UgPSBob3N0Q29udGV4dERldi5uYW1lc3BhY2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGlmZkh5ZHJhdGVkUHJvcGVydGllcyhpbnN0YW5jZSwgdHlwZSwgcHJvcHMsIHBhcmVudE5hbWVzcGFjZSwgcm9vdENvbnRhaW5lckluc3RhbmNlKTtcbiAgICB9LFxuICAgIGh5ZHJhdGVUZXh0SW5zdGFuY2U6IGZ1bmN0aW9uICh0ZXh0SW5zdGFuY2UsIHRleHQsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgICAgIHByZWNhY2hlRmliZXJOb2RlKGludGVybmFsSW5zdGFuY2VIYW5kbGUsIHRleHRJbnN0YW5jZSk7XG4gICAgICByZXR1cm4gZGlmZkh5ZHJhdGVkVGV4dCh0ZXh0SW5zdGFuY2UsIHRleHQpO1xuICAgIH0sXG4gICAgZGlkTm90TWF0Y2hIeWRyYXRlZENvbnRhaW5lclRleHRJbnN0YW5jZTogZnVuY3Rpb24gKHBhcmVudENvbnRhaW5lciwgdGV4dEluc3RhbmNlLCB0ZXh0KSB7XG4gICAgICB7XG4gICAgICAgIHdhcm5Gb3JVbm1hdGNoZWRUZXh0KHRleHRJbnN0YW5jZSwgdGV4dCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkaWROb3RNYXRjaEh5ZHJhdGVkVGV4dEluc3RhbmNlOiBmdW5jdGlvbiAocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCB0ZXh0SW5zdGFuY2UsIHRleHQpIHtcbiAgICAgIGlmICh0cnVlICYmIHBhcmVudFByb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HXSAhPT0gdHJ1ZSkge1xuICAgICAgICB3YXJuRm9yVW5tYXRjaGVkVGV4dCh0ZXh0SW5zdGFuY2UsIHRleHQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGlkTm90SHlkcmF0ZUNvbnRhaW5lckluc3RhbmNlOiBmdW5jdGlvbiAocGFyZW50Q29udGFpbmVyLCBpbnN0YW5jZSkge1xuICAgICAge1xuICAgICAgICBpZiAoaW5zdGFuY2Uubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50KHBhcmVudENvbnRhaW5lciwgaW5zdGFuY2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZVRleHQocGFyZW50Q29udGFpbmVyLCBpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGRpZE5vdEh5ZHJhdGVJbnN0YW5jZTogZnVuY3Rpb24gKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgaW5zdGFuY2UpIHtcbiAgICAgIGlmICh0cnVlICYmIHBhcmVudFByb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HXSAhPT0gdHJ1ZSkge1xuICAgICAgICBpZiAoaW5zdGFuY2Uubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50KHBhcmVudEluc3RhbmNlLCBpbnN0YW5jZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dChwYXJlbnRJbnN0YW5jZSwgaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lckluc3RhbmNlOiBmdW5jdGlvbiAocGFyZW50Q29udGFpbmVyLCB0eXBlLCBwcm9wcykge1xuICAgICAge1xuICAgICAgICB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQocGFyZW50Q29udGFpbmVyLCB0eXBlLCBwcm9wcyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lclRleHRJbnN0YW5jZTogZnVuY3Rpb24gKHBhcmVudENvbnRhaW5lciwgdGV4dCkge1xuICAgICAge1xuICAgICAgICB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQocGFyZW50Q29udGFpbmVyLCB0ZXh0KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlSW5zdGFuY2U6IGZ1bmN0aW9uIChwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIHR5cGUsIHByb3BzKSB7XG4gICAgICBpZiAodHJ1ZSAmJiBwYXJlbnRQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklOR10gIT09IHRydWUpIHtcbiAgICAgICAgd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50KHBhcmVudEluc3RhbmNlLCB0eXBlLCBwcm9wcyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZTogZnVuY3Rpb24gKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgdGV4dCkge1xuICAgICAgaWYgKHRydWUgJiYgcGFyZW50UHJvcHNbU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkddICE9PSB0cnVlKSB7XG4gICAgICAgIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dChwYXJlbnRJbnN0YW5jZSwgdGV4dCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHNjaGVkdWxlRGVmZXJyZWRDYWxsYmFjazogcklDLFxuICBjYW5jZWxEZWZlcnJlZENhbGxiYWNrOiBjSUMsXG5cbiAgdXNlU3luY1NjaGVkdWxpbmc6ICFlbmFibGVBc3luY1NjaGVkdWxpbmdCeURlZmF1bHRJblJlYWN0RE9NXG59KTtcblxuaW5qZWN0aW9uJDQuaW5qZWN0RmliZXJCYXRjaGVkVXBkYXRlcyhET01SZW5kZXJlci5iYXRjaGVkVXBkYXRlcyk7XG5cbnZhciB3YXJuZWRBYm91dEh5ZHJhdGVBUEkgPSBmYWxzZTtcblxuZnVuY3Rpb24gcmVuZGVyU3VidHJlZUludG9Db250YWluZXIocGFyZW50Q29tcG9uZW50LCBjaGlsZHJlbiwgY29udGFpbmVyLCBmb3JjZUh5ZHJhdGUsIGNhbGxiYWNrKSB7XG4gICFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikgPyBpbnZhcmlhbnQoZmFsc2UsICdUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicpIDogdm9pZCAwO1xuXG4gIHtcbiAgICBpZiAoY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIgJiYgY29udGFpbmVyLm5vZGVUeXBlICE9PSBDT01NRU5UX05PREUpIHtcbiAgICAgIHZhciBob3N0SW5zdGFuY2UgPSBET01SZW5kZXJlci5maW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFscyhjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lci5jdXJyZW50KTtcbiAgICAgIGlmIChob3N0SW5zdGFuY2UpIHtcbiAgICAgICAgd2FybmluZyhob3N0SW5zdGFuY2UucGFyZW50Tm9kZSA9PT0gY29udGFpbmVyLCAncmVuZGVyKC4uLik6IEl0IGxvb2tzIGxpa2UgdGhlIFJlYWN0LXJlbmRlcmVkIGNvbnRlbnQgb2YgdGhpcyAnICsgJ2NvbnRhaW5lciB3YXMgcmVtb3ZlZCB3aXRob3V0IHVzaW5nIFJlYWN0LiBUaGlzIGlzIG5vdCAnICsgJ3N1cHBvcnRlZCBhbmQgd2lsbCBjYXVzZSBlcnJvcnMuIEluc3RlYWQsIGNhbGwgJyArICdSZWFjdERPTS51bm1vdW50Q29tcG9uZW50QXROb2RlIHRvIGVtcHR5IGEgY29udGFpbmVyLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBpc1Jvb3RSZW5kZXJlZEJ5U29tZVJlYWN0ID0gISFjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lcjtcbiAgICB2YXIgcm9vdEVsID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgdmFyIGhhc05vblJvb3RSZWFjdENoaWxkID0gISEocm9vdEVsICYmIGdldEluc3RhbmNlRnJvbU5vZGUkMShyb290RWwpKTtcblxuICAgIHdhcm5pbmcoIWhhc05vblJvb3RSZWFjdENoaWxkIHx8IGlzUm9vdFJlbmRlcmVkQnlTb21lUmVhY3QsICdyZW5kZXIoLi4uKTogUmVwbGFjaW5nIFJlYWN0LXJlbmRlcmVkIGNoaWxkcmVuIHdpdGggYSBuZXcgcm9vdCAnICsgJ2NvbXBvbmVudC4gSWYgeW91IGludGVuZGVkIHRvIHVwZGF0ZSB0aGUgY2hpbGRyZW4gb2YgdGhpcyBub2RlLCAnICsgJ3lvdSBzaG91bGQgaW5zdGVhZCBoYXZlIHRoZSBleGlzdGluZyBjaGlsZHJlbiB1cGRhdGUgdGhlaXIgc3RhdGUgJyArICdhbmQgcmVuZGVyIHRoZSBuZXcgY29tcG9uZW50cyBpbnN0ZWFkIG9mIGNhbGxpbmcgUmVhY3RET00ucmVuZGVyLicpO1xuXG4gICAgd2FybmluZyhjb250YWluZXIubm9kZVR5cGUgIT09IEVMRU1FTlRfTk9ERSB8fCAhY29udGFpbmVyLnRhZ05hbWUgfHwgY29udGFpbmVyLnRhZ05hbWUudG9VcHBlckNhc2UoKSAhPT0gJ0JPRFknLCAncmVuZGVyKCk6IFJlbmRlcmluZyBjb21wb25lbnRzIGRpcmVjdGx5IGludG8gZG9jdW1lbnQuYm9keSBpcyAnICsgJ2Rpc2NvdXJhZ2VkLCBzaW5jZSBpdHMgY2hpbGRyZW4gYXJlIG9mdGVuIG1hbmlwdWxhdGVkIGJ5IHRoaXJkLXBhcnR5ICcgKyAnc2NyaXB0cyBhbmQgYnJvd3NlciBleHRlbnNpb25zLiBUaGlzIG1heSBsZWFkIHRvIHN1YnRsZSAnICsgJ3JlY29uY2lsaWF0aW9uIGlzc3Vlcy4gVHJ5IHJlbmRlcmluZyBpbnRvIGEgY29udGFpbmVyIGVsZW1lbnQgY3JlYXRlZCAnICsgJ2ZvciB5b3VyIGFwcC4nKTtcbiAgfVxuXG4gIHZhciByb290ID0gY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXI7XG4gIGlmICghcm9vdCkge1xuICAgIHZhciBzaG91bGRIeWRyYXRlID0gZm9yY2VIeWRyYXRlIHx8IHNob3VsZEh5ZHJhdGVEdWVUb0xlZ2FjeUhldXJpc3RpYyhjb250YWluZXIpO1xuICAgIC8vIEZpcnN0IGNsZWFyIGFueSBleGlzdGluZyBjb250ZW50LlxuICAgIGlmICghc2hvdWxkSHlkcmF0ZSkge1xuICAgICAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICAgICAgdmFyIHJvb3RTaWJsaW5nID0gdm9pZCAwO1xuICAgICAgd2hpbGUgKHJvb3RTaWJsaW5nID0gY29udGFpbmVyLmxhc3RDaGlsZCkge1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKCF3YXJuZWQgJiYgcm9vdFNpYmxpbmcubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSAmJiByb290U2libGluZy5oYXNBdHRyaWJ1dGUoUk9PVF9BVFRSSUJVVEVfTkFNRSkpIHtcbiAgICAgICAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAncmVuZGVyKCk6IFRhcmdldCBub2RlIGhhcyBtYXJrdXAgcmVuZGVyZWQgYnkgUmVhY3QsIGJ1dCB0aGVyZSAnICsgJ2FyZSB1bnJlbGF0ZWQgbm9kZXMgYXMgd2VsbC4gVGhpcyBpcyBtb3N0IGNvbW1vbmx5IGNhdXNlZCBieSAnICsgJ3doaXRlLXNwYWNlIGluc2VydGVkIGFyb3VuZCBzZXJ2ZXItcmVuZGVyZWQgbWFya3VwLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQocm9vdFNpYmxpbmcpO1xuICAgICAgfVxuICAgIH1cbiAgICB7XG4gICAgICBpZiAoc2hvdWxkSHlkcmF0ZSAmJiAhZm9yY2VIeWRyYXRlICYmICF3YXJuZWRBYm91dEh5ZHJhdGVBUEkpIHtcbiAgICAgICAgd2FybmVkQWJvdXRIeWRyYXRlQVBJID0gdHJ1ZTtcbiAgICAgICAgbG93UHJpb3JpdHlXYXJuaW5nJDEoZmFsc2UsICdyZW5kZXIoKTogQ2FsbGluZyBSZWFjdERPTS5yZW5kZXIoKSB0byBoeWRyYXRlIHNlcnZlci1yZW5kZXJlZCBtYXJrdXAgJyArICd3aWxsIHN0b3Agd29ya2luZyBpbiBSZWFjdCB2MTcuIFJlcGxhY2UgdGhlIFJlYWN0RE9NLnJlbmRlcigpIGNhbGwgJyArICd3aXRoIFJlYWN0RE9NLmh5ZHJhdGUoKSBpZiB5b3Ugd2FudCBSZWFjdCB0byBhdHRhY2ggdG8gdGhlIHNlcnZlciBIVE1MLicpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgbmV3Um9vdCA9IERPTVJlbmRlcmVyLmNyZWF0ZUNvbnRhaW5lcihjb250YWluZXIsIHNob3VsZEh5ZHJhdGUpO1xuICAgIHJvb3QgPSBjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lciA9IG5ld1Jvb3Q7XG4gICAgLy8gSW5pdGlhbCBtb3VudCBzaG91bGQgbm90IGJlIGJhdGNoZWQuXG4gICAgRE9NUmVuZGVyZXIudW5iYXRjaGVkVXBkYXRlcyhmdW5jdGlvbiAoKSB7XG4gICAgICBET01SZW5kZXJlci51cGRhdGVDb250YWluZXIoY2hpbGRyZW4sIG5ld1Jvb3QsIHBhcmVudENvbXBvbmVudCwgY2FsbGJhY2spO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIERPTVJlbmRlcmVyLnVwZGF0ZUNvbnRhaW5lcihjaGlsZHJlbiwgcm9vdCwgcGFyZW50Q29tcG9uZW50LCBjYWxsYmFjayk7XG4gIH1cbiAgcmV0dXJuIERPTVJlbmRlcmVyLmdldFB1YmxpY1Jvb3RJbnN0YW5jZShyb290KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUG9ydGFsKGNoaWxkcmVuLCBjb250YWluZXIpIHtcbiAgdmFyIGtleSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbnVsbDtcblxuICAhaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIpID8gaW52YXJpYW50KGZhbHNlLCAnVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgYSBET00gZWxlbWVudC4nKSA6IHZvaWQgMDtcbiAgLy8gVE9ETzogcGFzcyBSZWFjdERPTSBwb3J0YWwgaW1wbGVtZW50YXRpb24gYXMgdGhpcmQgYXJndW1lbnRcbiAgcmV0dXJuIGNyZWF0ZVBvcnRhbCQxKGNoaWxkcmVuLCBjb250YWluZXIsIG51bGwsIGtleSk7XG59XG5cbmZ1bmN0aW9uIFJlYWN0Um9vdChjb250YWluZXIsIGh5ZHJhdGUpIHtcbiAgdmFyIHJvb3QgPSBET01SZW5kZXJlci5jcmVhdGVDb250YWluZXIoY29udGFpbmVyLCBoeWRyYXRlKTtcbiAgdGhpcy5fcmVhY3RSb290Q29udGFpbmVyID0gcm9vdDtcbn1cblJlYWN0Um9vdC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKGNoaWxkcmVuLCBjYWxsYmFjaykge1xuICB2YXIgcm9vdCA9IHRoaXMuX3JlYWN0Um9vdENvbnRhaW5lcjtcbiAgRE9NUmVuZGVyZXIudXBkYXRlQ29udGFpbmVyKGNoaWxkcmVuLCByb290LCBudWxsLCBjYWxsYmFjayk7XG59O1xuUmVhY3RSb290LnByb3RvdHlwZS51bm1vdW50ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHZhciByb290ID0gdGhpcy5fcmVhY3RSb290Q29udGFpbmVyO1xuICBET01SZW5kZXJlci51cGRhdGVDb250YWluZXIobnVsbCwgcm9vdCwgbnVsbCwgY2FsbGJhY2spO1xufTtcblxudmFyIFJlYWN0RE9NID0ge1xuICBjcmVhdGVQb3J0YWw6IGNyZWF0ZVBvcnRhbCxcblxuICBmaW5kRE9NTm9kZTogZnVuY3Rpb24gKGNvbXBvbmVudE9yRWxlbWVudCkge1xuICAgIHtcbiAgICAgIHZhciBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgICBpZiAob3duZXIgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHdhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gb3duZXIuc3RhdGVOb2RlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlcjtcbiAgICAgICAgd2FybmluZyh3YXJuZWRBYm91dFJlZnNJblJlbmRlciwgJyVzIGlzIGFjY2Vzc2luZyBmaW5kRE9NTm9kZSBpbnNpZGUgaXRzIHJlbmRlcigpLiAnICsgJ3JlbmRlcigpIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLiBJdCBzaG91bGQgJyArICduZXZlciBhY2Nlc3Mgc29tZXRoaW5nIHRoYXQgcmVxdWlyZXMgc3RhbGUgZGF0YSBmcm9tIHRoZSBwcmV2aW91cyAnICsgJ3JlbmRlciwgc3VjaCBhcyByZWZzLiBNb3ZlIHRoaXMgbG9naWMgdG8gY29tcG9uZW50RGlkTW91bnQgYW5kICcgKyAnY29tcG9uZW50RGlkVXBkYXRlIGluc3RlYWQuJywgZ2V0Q29tcG9uZW50TmFtZShvd25lcikgfHwgJ0EgY29tcG9uZW50Jyk7XG4gICAgICAgIG93bmVyLnN0YXRlTm9kZS5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29tcG9uZW50T3JFbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoY29tcG9uZW50T3JFbGVtZW50Lm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgIHJldHVybiBjb21wb25lbnRPckVsZW1lbnQ7XG4gICAgfVxuXG4gICAgdmFyIGluc3QgPSBnZXQoY29tcG9uZW50T3JFbGVtZW50KTtcbiAgICBpZiAoaW5zdCkge1xuICAgICAgcmV0dXJuIERPTVJlbmRlcmVyLmZpbmRIb3N0SW5zdGFuY2UoaW5zdCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjb21wb25lbnRPckVsZW1lbnQucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ0VsZW1lbnQgYXBwZWFycyB0byBiZSBuZWl0aGVyIFJlYWN0Q29tcG9uZW50IG5vciBET01Ob2RlLiBLZXlzOiAlcycsIE9iamVjdC5rZXlzKGNvbXBvbmVudE9yRWxlbWVudCkpO1xuICAgIH1cbiAgfSxcbiAgaHlkcmF0ZTogZnVuY3Rpb24gKGVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgICAvLyBUT0RPOiB0aHJvdyBvciB3YXJuIGlmIHdlIGNvdWxkbid0IGh5ZHJhdGU/XG4gICAgcmV0dXJuIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKG51bGwsIGVsZW1lbnQsIGNvbnRhaW5lciwgdHJ1ZSwgY2FsbGJhY2spO1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIChlbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKG51bGwsIGVsZW1lbnQsIGNvbnRhaW5lciwgZmFsc2UsIGNhbGxiYWNrKTtcbiAgfSxcbiAgdW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXI6IGZ1bmN0aW9uIChwYXJlbnRDb21wb25lbnQsIGVsZW1lbnQsIGNvbnRhaW5lck5vZGUsIGNhbGxiYWNrKSB7XG4gICAgIShwYXJlbnRDb21wb25lbnQgIT0gbnVsbCAmJiBoYXMocGFyZW50Q29tcG9uZW50KSkgPyBpbnZhcmlhbnQoZmFsc2UsICdwYXJlbnRDb21wb25lbnQgbXVzdCBiZSBhIHZhbGlkIFJlYWN0IENvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgIHJldHVybiByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihwYXJlbnRDb21wb25lbnQsIGVsZW1lbnQsIGNvbnRhaW5lck5vZGUsIGZhbHNlLCBjYWxsYmFjayk7XG4gIH0sXG4gIHVubW91bnRDb21wb25lbnRBdE5vZGU6IGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICAhaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIpID8gaW52YXJpYW50KGZhbHNlLCAndW5tb3VudENvbXBvbmVudEF0Tm9kZSguLi4pOiBUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicpIDogdm9pZCAwO1xuXG4gICAgaWYgKGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyKSB7XG4gICAgICB7XG4gICAgICAgIHZhciByb290RWwgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgICAgICAgdmFyIHJlbmRlcmVkQnlEaWZmZXJlbnRSZWFjdCA9IHJvb3RFbCAmJiAhZ2V0SW5zdGFuY2VGcm9tTm9kZSQxKHJvb3RFbCk7XG4gICAgICAgIHdhcm5pbmcoIXJlbmRlcmVkQnlEaWZmZXJlbnRSZWFjdCwgXCJ1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFRoZSBub2RlIHlvdSdyZSBhdHRlbXB0aW5nIHRvIHVubW91bnQgXCIgKyAnd2FzIHJlbmRlcmVkIGJ5IGFub3RoZXIgY29weSBvZiBSZWFjdC4nKTtcbiAgICAgIH1cblxuICAgICAgLy8gVW5tb3VudCBzaG91bGQgbm90IGJlIGJhdGNoZWQuXG4gICAgICBET01SZW5kZXJlci51bmJhdGNoZWRVcGRhdGVzKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVuZGVyU3VidHJlZUludG9Db250YWluZXIobnVsbCwgbnVsbCwgY29udGFpbmVyLCBmYWxzZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIC8vIElmIHlvdSBjYWxsIHVubW91bnRDb21wb25lbnRBdE5vZGUgdHdpY2UgaW4gcXVpY2sgc3VjY2Vzc2lvbiwgeW91J2xsXG4gICAgICAvLyBnZXQgYHRydWVgIHR3aWNlLiBUaGF0J3MgcHJvYmFibHkgZmluZT9cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB7XG4gICAgICAgIHZhciBfcm9vdEVsID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgICAgIHZhciBoYXNOb25Sb290UmVhY3RDaGlsZCA9ICEhKF9yb290RWwgJiYgZ2V0SW5zdGFuY2VGcm9tTm9kZSQxKF9yb290RWwpKTtcblxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgY29udGFpbmVyIGl0c2VsZiBpcyBhIFJlYWN0IHJvb3Qgbm9kZS5cbiAgICAgICAgdmFyIGlzQ29udGFpbmVyUmVhY3RSb290ID0gY29udGFpbmVyLm5vZGVUeXBlID09PSAxICYmIGlzVmFsaWRDb250YWluZXIoY29udGFpbmVyLnBhcmVudE5vZGUpICYmICEhY29udGFpbmVyLnBhcmVudE5vZGUuX3JlYWN0Um9vdENvbnRhaW5lcjtcblxuICAgICAgICB3YXJuaW5nKCFoYXNOb25Sb290UmVhY3RDaGlsZCwgXCJ1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFRoZSBub2RlIHlvdSdyZSBhdHRlbXB0aW5nIHRvIHVubW91bnQgXCIgKyAnd2FzIHJlbmRlcmVkIGJ5IFJlYWN0IGFuZCBpcyBub3QgYSB0b3AtbGV2ZWwgY29udGFpbmVyLiAlcycsIGlzQ29udGFpbmVyUmVhY3RSb290ID8gJ1lvdSBtYXkgaGF2ZSBhY2NpZGVudGFsbHkgcGFzc2VkIGluIGEgUmVhY3Qgcm9vdCBub2RlIGluc3RlYWQgJyArICdvZiBpdHMgY29udGFpbmVyLicgOiAnSW5zdGVhZCwgaGF2ZSB0aGUgcGFyZW50IGNvbXBvbmVudCB1cGRhdGUgaXRzIHN0YXRlIGFuZCAnICsgJ3JlcmVuZGVyIGluIG9yZGVyIHRvIHJlbW92ZSB0aGlzIGNvbXBvbmVudC4nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSxcblxuXG4gIC8vIFRlbXBvcmFyeSBhbGlhcyBzaW5jZSB3ZSBhbHJlYWR5IHNoaXBwZWQgUmVhY3QgMTYgUkMgd2l0aCBpdC5cbiAgLy8gVE9ETzogcmVtb3ZlIGluIFJlYWN0IDE3LlxuICB1bnN0YWJsZV9jcmVhdGVQb3J0YWw6IGNyZWF0ZVBvcnRhbCxcblxuICB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlczogYmF0Y2hlZFVwZGF0ZXMsXG5cbiAgdW5zdGFibGVfZGVmZXJyZWRVcGRhdGVzOiBET01SZW5kZXJlci5kZWZlcnJlZFVwZGF0ZXMsXG5cbiAgZmx1c2hTeW5jOiBET01SZW5kZXJlci5mbHVzaFN5bmMsXG5cbiAgX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ6IHtcbiAgICAvLyBGb3IgVGFwRXZlbnRQbHVnaW4gd2hpY2ggaXMgcG9wdWxhciBpbiBvcGVuIHNvdXJjZVxuICAgIEV2ZW50UGx1Z2luSHViOiBFdmVudFBsdWdpbkh1YixcbiAgICAvLyBVc2VkIGJ5IHRlc3QtdXRpbHNcbiAgICBFdmVudFBsdWdpblJlZ2lzdHJ5OiBFdmVudFBsdWdpblJlZ2lzdHJ5LFxuICAgIEV2ZW50UHJvcGFnYXRvcnM6IEV2ZW50UHJvcGFnYXRvcnMsXG4gICAgUmVhY3RDb250cm9sbGVkQ29tcG9uZW50OiBSZWFjdENvbnRyb2xsZWRDb21wb25lbnQsXG4gICAgUmVhY3RET01Db21wb25lbnRUcmVlOiBSZWFjdERPTUNvbXBvbmVudFRyZWUsXG4gICAgUmVhY3RET01FdmVudExpc3RlbmVyOiBSZWFjdERPTUV2ZW50TGlzdGVuZXJcbiAgfVxufTtcblxuaWYgKGVuYWJsZUNyZWF0ZVJvb3QpIHtcbiAgUmVhY3RET00uY3JlYXRlUm9vdCA9IGZ1bmN0aW9uIGNyZWF0ZVJvb3QoY29udGFpbmVyLCBvcHRpb25zKSB7XG4gICAgdmFyIGh5ZHJhdGUgPSBvcHRpb25zICE9IG51bGwgJiYgb3B0aW9ucy5oeWRyYXRlID09PSB0cnVlO1xuICAgIHJldHVybiBuZXcgUmVhY3RSb290KGNvbnRhaW5lciwgaHlkcmF0ZSk7XG4gIH07XG59XG5cbnZhciBmb3VuZERldlRvb2xzID0gRE9NUmVuZGVyZXIuaW5qZWN0SW50b0RldlRvb2xzKHtcbiAgZmluZEZpYmVyQnlIb3N0SW5zdGFuY2U6IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlLFxuICBidW5kbGVUeXBlOiAxLFxuICB2ZXJzaW9uOiBSZWFjdFZlcnNpb24sXG4gIHJlbmRlcmVyUGFja2FnZU5hbWU6ICdyZWFjdC1kb20nXG59KTtcblxue1xuICBpZiAoIWZvdW5kRGV2VG9vbHMgJiYgRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmIHdpbmRvdy50b3AgPT09IHdpbmRvdy5zZWxmKSB7XG4gICAgLy8gSWYgd2UncmUgaW4gQ2hyb21lIG9yIEZpcmVmb3gsIHByb3ZpZGUgYSBkb3dubG9hZCBsaW5rIGlmIG5vdCBpbnN0YWxsZWQuXG4gICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignQ2hyb21lJykgPiAtMSAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0VkZ2UnKSA9PT0gLTEgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94JykgPiAtMSkge1xuICAgICAgdmFyIHByb3RvY29sID0gd2luZG93LmxvY2F0aW9uLnByb3RvY29sO1xuICAgICAgLy8gRG9uJ3Qgd2FybiBpbiBleG90aWMgY2FzZXMgbGlrZSBjaHJvbWUtZXh0ZW5zaW9uOi8vLlxuICAgICAgaWYgKC9eKGh0dHBzP3xmaWxlKTokLy50ZXN0KHByb3RvY29sKSkge1xuICAgICAgICBjb25zb2xlLmluZm8oJyVjRG93bmxvYWQgdGhlIFJlYWN0IERldlRvb2xzICcgKyAnZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1kZXZ0b29scycgKyAocHJvdG9jb2wgPT09ICdmaWxlOicgPyAnXFxuWW91IG1pZ2h0IG5lZWQgdG8gdXNlIGEgbG9jYWwgSFRUUCBzZXJ2ZXIgKGluc3RlYWQgb2YgZmlsZTovLyk6ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1kZXZ0b29scy1mYXEnIDogJycpLCAnZm9udC13ZWlnaHQ6Ym9sZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5cblxudmFyIFJlYWN0RE9NJDIgPSBPYmplY3QuZnJlZXplKHtcblx0ZGVmYXVsdDogUmVhY3RET01cbn0pO1xuXG52YXIgUmVhY3RET00kMyA9ICggUmVhY3RET00kMiAmJiBSZWFjdERPTSApIHx8IFJlYWN0RE9NJDI7XG5cbi8vIFRPRE86IGRlY2lkZSBvbiB0aGUgdG9wLWxldmVsIGV4cG9ydCBmb3JtLlxuLy8gVGhpcyBpcyBoYWNreSBidXQgbWFrZXMgaXQgd29yayB3aXRoIGJvdGggUm9sbHVwIGFuZCBKZXN0LlxudmFyIHJlYWN0RG9tID0gUmVhY3RET00kM1snZGVmYXVsdCddID8gUmVhY3RET00kM1snZGVmYXVsdCddIDogUmVhY3RET00kMztcblxubW9kdWxlLmV4cG9ydHMgPSByZWFjdERvbTtcbiAgfSkoKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9janMvcmVhY3QtZG9tLmRldmVsb3BtZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///29\n");

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\n\n\n\nvar hyphenate = __webpack_require__(31);\n\nvar msPattern = /^ms-/;\n\n/**\n * Hyphenates a camelcased CSS property name, for example:\n *\n *   > hyphenateStyleName('backgroundColor')\n *   < \"background-color\"\n *   > hyphenateStyleName('MozTransition')\n *   < \"-moz-transition\"\n *   > hyphenateStyleName('msTransition')\n *   < \"-ms-transition\"\n *\n * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix\n * is converted to `-ms-`.\n *\n * @param {string} string\n * @return {string}\n */\nfunction hyphenateStyleName(string) {\n  return hyphenate(string).replace(msPattern, '-ms-');\n}\n\nmodule.exports = hyphenateStyleName;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaHlwaGVuYXRlU3R5bGVOYW1lLmpzPzk4YmQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGh5cGhlbmF0ZSA9IHJlcXVpcmUoJy4vaHlwaGVuYXRlJyk7XG5cbnZhciBtc1BhdHRlcm4gPSAvXm1zLS87XG5cbi8qKlxuICogSHlwaGVuYXRlcyBhIGNhbWVsY2FzZWQgQ1NTIHByb3BlcnR5IG5hbWUsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ2JhY2tncm91bmRDb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kLWNvbG9yXCJcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ01velRyYW5zaXRpb24nKVxuICogICA8IFwiLW1vei10cmFuc2l0aW9uXCJcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ21zVHJhbnNpdGlvbicpXG4gKiAgIDwgXCItbXMtdHJhbnNpdGlvblwiXG4gKlxuICogQXMgTW9kZXJuaXpyIHN1Z2dlc3RzIChodHRwOi8vbW9kZXJuaXpyLmNvbS9kb2NzLyNwcmVmaXhlZCksIGFuIGBtc2AgcHJlZml4XG4gKiBpcyBjb252ZXJ0ZWQgdG8gYC1tcy1gLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gaHlwaGVuYXRlU3R5bGVOYW1lKHN0cmluZykge1xuICByZXR1cm4gaHlwaGVuYXRlKHN0cmluZykucmVwbGFjZShtc1BhdHRlcm4sICctbXMtJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaHlwaGVuYXRlU3R5bGVOYW1lO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2h5cGhlbmF0ZVN0eWxlTmFtZS5qc1xuLy8gbW9kdWxlIGlkID0gMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///30\n");

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\n\nvar _uppercasePattern = /([A-Z])/g;\n\n/**\n * Hyphenates a camelcased string, for example:\n *\n *   > hyphenate('backgroundColor')\n *   < \"background-color\"\n *\n * For CSS style names, use `hyphenateStyleName` instead which works properly\n * with all vendor prefixes, including `ms`.\n *\n * @param {string} string\n * @return {string}\n */\nfunction hyphenate(string) {\n  return string.replace(_uppercasePattern, '-$1').toLowerCase();\n}\n\nmodule.exports = hyphenate;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaHlwaGVuYXRlLmpzPzAwZjAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIF91cHBlcmNhc2VQYXR0ZXJuID0gLyhbQS1aXSkvZztcblxuLyoqXG4gKiBIeXBoZW5hdGVzIGEgY2FtZWxjYXNlZCBzdHJpbmcsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBoeXBoZW5hdGUoJ2JhY2tncm91bmRDb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kLWNvbG9yXCJcbiAqXG4gKiBGb3IgQ1NTIHN0eWxlIG5hbWVzLCB1c2UgYGh5cGhlbmF0ZVN0eWxlTmFtZWAgaW5zdGVhZCB3aGljaCB3b3JrcyBwcm9wZXJseVxuICogd2l0aCBhbGwgdmVuZG9yIHByZWZpeGVzLCBpbmNsdWRpbmcgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGh5cGhlbmF0ZShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKF91cHBlcmNhc2VQYXR0ZXJuLCAnLSQxJykudG9Mb3dlckNhc2UoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoeXBoZW5hdGU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaHlwaGVuYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///31\n");

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\n\n\n\nvar camelize = __webpack_require__(33);\n\nvar msPattern = /^-ms-/;\n\n/**\n * Camelcases a hyphenated CSS property name, for example:\n *\n *   > camelizeStyleName('background-color')\n *   < \"backgroundColor\"\n *   > camelizeStyleName('-moz-transition')\n *   < \"MozTransition\"\n *   > camelizeStyleName('-ms-transition')\n *   < \"msTransition\"\n *\n * As Andi Smith suggests\n * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix\n * is converted to lowercase `ms`.\n *\n * @param {string} string\n * @return {string}\n */\nfunction camelizeStyleName(string) {\n  return camelize(string.replace(msPattern, 'ms-'));\n}\n\nmodule.exports = camelizeStyleName;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvY2FtZWxpemVTdHlsZU5hbWUuanM/ZmU1NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FtZWxpemUgPSByZXF1aXJlKCcuL2NhbWVsaXplJyk7XG5cbnZhciBtc1BhdHRlcm4gPSAvXi1tcy0vO1xuXG4vKipcbiAqIENhbWVsY2FzZXMgYSBoeXBoZW5hdGVkIENTUyBwcm9wZXJ0eSBuYW1lLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gY2FtZWxpemVTdHlsZU5hbWUoJ2JhY2tncm91bmQtY29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZENvbG9yXCJcbiAqICAgPiBjYW1lbGl6ZVN0eWxlTmFtZSgnLW1vei10cmFuc2l0aW9uJylcbiAqICAgPCBcIk1velRyYW5zaXRpb25cIlxuICogICA+IGNhbWVsaXplU3R5bGVOYW1lKCctbXMtdHJhbnNpdGlvbicpXG4gKiAgIDwgXCJtc1RyYW5zaXRpb25cIlxuICpcbiAqIEFzIEFuZGkgU21pdGggc3VnZ2VzdHNcbiAqIChodHRwOi8vd3d3LmFuZGlzbWl0aC5jb20vYmxvZy8yMDEyLzAyL21vZGVybml6ci1wcmVmaXhlZC8pLCBhbiBgLW1zYCBwcmVmaXhcbiAqIGlzIGNvbnZlcnRlZCB0byBsb3dlcmNhc2UgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGNhbWVsaXplU3R5bGVOYW1lKHN0cmluZykge1xuICByZXR1cm4gY2FtZWxpemUoc3RyaW5nLnJlcGxhY2UobXNQYXR0ZXJuLCAnbXMtJykpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhbWVsaXplU3R5bGVOYW1lO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2NhbWVsaXplU3R5bGVOYW1lLmpzXG4vLyBtb2R1bGUgaWQgPSAzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///32\n");

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\n\nvar _hyphenPattern = /-(.)/g;\n\n/**\n * Camelcases a hyphenated string, for example:\n *\n *   > camelize('background-color')\n *   < \"backgroundColor\"\n *\n * @param {string} string\n * @return {string}\n */\nfunction camelize(string) {\n  return string.replace(_hyphenPattern, function (_, character) {\n    return character.toUpperCase();\n  });\n}\n\nmodule.exports = camelize;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvY2FtZWxpemUuanM/MGZlMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBfaHlwaGVuUGF0dGVybiA9IC8tKC4pL2c7XG5cbi8qKlxuICogQ2FtZWxjYXNlcyBhIGh5cGhlbmF0ZWQgc3RyaW5nLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gY2FtZWxpemUoJ2JhY2tncm91bmQtY29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZENvbG9yXCJcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGNhbWVsaXplKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoX2h5cGhlblBhdHRlcm4sIGZ1bmN0aW9uIChfLCBjaGFyYWN0ZXIpIHtcbiAgICByZXR1cm4gY2hhcmFjdGVyLnRvVXBwZXJDYXNlKCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhbWVsaXplO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2NhbWVsaXplLmpzXG4vLyBtb2R1bGUgaWQgPSAzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///33\n");

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _react = __webpack_require__(1);\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _AddOption = __webpack_require__(35);\n\nvar _AddOption2 = _interopRequireDefault(_AddOption);\n\nvar _Options = __webpack_require__(36);\n\nvar _Options2 = _interopRequireDefault(_Options);\n\nvar _Header = __webpack_require__(38);\n\nvar _Header2 = _interopRequireDefault(_Header);\n\nvar _Action = __webpack_require__(39);\n\nvar _Action2 = _interopRequireDefault(_Action);\n\nvar _OptionModal = __webpack_require__(40);\n\nvar _OptionModal2 = _interopRequireDefault(_OptionModal);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar IndecisionApp = function (_React$Component) {\n    _inherits(IndecisionApp, _React$Component);\n\n    function IndecisionApp() {\n        var _ref;\n\n        var _temp, _this, _ret;\n\n        _classCallCheck(this, IndecisionApp);\n\n        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n        }\n\n        return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = IndecisionApp.__proto__ || Object.getPrototypeOf(IndecisionApp)).call.apply(_ref, [this].concat(args))), _this), _this.state = {\n            options: [],\n            selectedOption: undefined\n        }, _this.handleDeleteOptions = function () {\n            _this.setState(function () {\n                return { options: [] };\n            });\n        }, _this.handleDeleteOption = function (option) {\n            //console.log(option)\n            // deleting individual options with filter \n            // in filter !== if they are not equal then its an item we dont want to remove\n            _this.setState(function (prevState) {\n                return {\n                    options: prevState.options.filter(function (el) {\n                        return option !== el;\n                    })\n                };\n            });\n        }, _this.handlePick = function () {\n            var randomNum = Math.floor(Math.random() * _this.state.options.length);\n            var option = _this.state.options[randomNum];\n            _this.setState(function () {\n                return {\n                    selectedOption: option\n                };\n            });\n        }, _this.handleDeleteModal = function () {\n            _this.setState(function () {\n                return { selectedOption: undefined };\n            });\n        }, _this.handleAddOption = function (option) {\n            // validation\n            // if empty string -> !option \n            if (!option) {\n                return 'Enter valid value to add item';\n                // below we checking if option already exists\n                // indexOf > -1 means we found a match\n            } else if (_this.state.options.indexOf(option) > -1) {\n                return 'This option already exists';\n            }\n\n            // we never want to manipulate the state\n            // prevState.options.push(option) - that is why we dont use push\n            // adding new options to the options array using concat()\n            _this.setState(function (prevState) {\n                return { options: prevState.options.concat(option) };\n            });\n        }, _temp), _possibleConstructorReturn(_this, _ret);\n    }\n\n    _createClass(IndecisionApp, [{\n        key: 'componentDidMount',\n        value: function componentDidMount() {\n            // catch data if is unvalid\n            try {\n                var json = localStorage.getItem('options');\n                var options = JSON.parse(json);\n\n                // if localstorage is empty it returns null and JSON.parse will return null too - so we dont want to setState to null - that is why we do conditional\n                if (options) {\n                    // returning options obj since is the same as the var above\n                    this.setState(function () {\n                        return { options: options };\n                    });\n                }\n            } catch (e) {\n                // Do nothing at all\n            }\n        }\n\n        // saving data\n\n    }, {\n        key: 'componentDidUpdate',\n        value: function componentDidUpdate(prevProps, prevState) {\n            // checking if options array change\n            if (prevState.options.length !== this.state.options.length) {\n                var json = JSON.stringify(this.state.options);\n                localStorage.setItem('options', json);\n            }\n        }\n    }, {\n        key: 'componentWillUnmount',\n        value: function componentWillUnmount() {\n            console.log('componentWillUnmount');\n        }\n    }, {\n        key: 'render',\n        value: function render() {\n            var subtitle = 'Put your life in the hands of a computer';\n            return _react2.default.createElement(\n                'div',\n                null,\n                _react2.default.createElement(_Header2.default, { subtitle: subtitle }),\n                _react2.default.createElement(\n                    'div',\n                    { className: 'container' },\n                    _react2.default.createElement(_Action2.default, { hasOptions: this.state.options.length > 0,\n                        handlePick: this.handlePick }),\n                    _react2.default.createElement(\n                        'div',\n                        { className: 'widget' },\n                        _react2.default.createElement(_Options2.default, { options: this.state.options,\n                            handleDeleteOptions: this.handleDeleteOptions,\n                            handleDeleteOption: this.handleDeleteOption\n                        }),\n                        _react2.default.createElement(_AddOption2.default, { handleAddOption: this.handleAddOption })\n                    )\n                ),\n                _react2.default.createElement(_OptionModal2.default, { selectedOption: this.state.selectedOption, handleDeleteModal: this.handleDeleteModal })\n            );\n        }\n    }]);\n\n    return IndecisionApp;\n}(_react2.default.Component);\n\nexports.default = IndecisionApp;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2NvbXBvbmVudHMvSW5kZWNpc2lvbkFwcC5qcz8xZDA4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgQWRkT3B0aW9uIGZyb20gJy4vQWRkT3B0aW9uJ1xuaW1wb3J0IE9wdGlvbnMgZnJvbSAnLi9PcHRpb25zJ1xuaW1wb3J0IEhlYWRlciBmcm9tICcuL0hlYWRlcidcbmltcG9ydCBBY3Rpb24gZnJvbSAnLi9BY3Rpb24nXG5pbXBvcnQgT3B0aW9uTW9kYWwgZnJvbSAnLi9PcHRpb25Nb2RhbCdcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5kZWNpc2lvbkFwcCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgc3RhdGUgPSB7XG4gICAgICAgIG9wdGlvbnM6IFtdLFxuICAgICAgICBzZWxlY3RlZE9wdGlvbjogdW5kZWZpbmVkXG4gICAgfVxuXG4gIGhhbmRsZURlbGV0ZU9wdGlvbnMgPSAoKSA9PiB7XG4gICAgICB0aGlzLnNldFN0YXRlKCgpID0+ICh7b3B0aW9uczogW119KSk7XG4gIH1cblxuICBoYW5kbGVEZWxldGVPcHRpb24gPSAob3B0aW9uKSA9PiB7XG4gICAgICAvL2NvbnNvbGUubG9nKG9wdGlvbilcbiAgICAgIC8vIGRlbGV0aW5nIGluZGl2aWR1YWwgb3B0aW9ucyB3aXRoIGZpbHRlciBcbiAgICAgIC8vIGluIGZpbHRlciAhPT0gaWYgdGhleSBhcmUgbm90IGVxdWFsIHRoZW4gaXRzIGFuIGl0ZW0gd2UgZG9udCB3YW50IHRvIHJlbW92ZVxuICAgICAgdGhpcy5zZXRTdGF0ZSgocHJldlN0YXRlKSA9PiAoe1xuICAgICAgICAgIG9wdGlvbnM6IHByZXZTdGF0ZS5vcHRpb25zLmZpbHRlcihlbCA9PiBvcHRpb24gIT09IGVsKVxuICAgICAgfSkpXG4gIH1cblxuICBoYW5kbGVQaWNrID0gKCkgPT4ge1xuICAgICAgY29uc3QgcmFuZG9tTnVtID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogdGhpcy5zdGF0ZS5vcHRpb25zLmxlbmd0aCk7XG4gICAgICBjb25zdCBvcHRpb24gPSB0aGlzLnN0YXRlLm9wdGlvbnNbcmFuZG9tTnVtXVxuICAgICAgdGhpcy5zZXRTdGF0ZSgoKSA9PiAoe1xuICAgICAgICAgIHNlbGVjdGVkT3B0aW9uOiBvcHRpb25cbiAgICAgIH0pKTtcbiAgfTtcblxuICBoYW5kbGVEZWxldGVNb2RhbCA9ICgpID0+IHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoKCkgPT4gKHtzZWxlY3RlZE9wdGlvbjogdW5kZWZpbmVkfSkpXG4gIH1cbiBcbiAgaGFuZGxlQWRkT3B0aW9uID0gKG9wdGlvbikgPT4ge1xuICAgICAgLy8gdmFsaWRhdGlvblxuICAgICAgLy8gaWYgZW1wdHkgc3RyaW5nIC0+ICFvcHRpb24gXG4gICAgICBpZighb3B0aW9uKXtcbiAgICAgICAgICByZXR1cm4gJ0VudGVyIHZhbGlkIHZhbHVlIHRvIGFkZCBpdGVtJztcbiAgICAgICAgICAvLyBiZWxvdyB3ZSBjaGVja2luZyBpZiBvcHRpb24gYWxyZWFkeSBleGlzdHNcbiAgICAgICAgICAvLyBpbmRleE9mID4gLTEgbWVhbnMgd2UgZm91bmQgYSBtYXRjaFxuICAgICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlLm9wdGlvbnMuaW5kZXhPZihvcHRpb24pID4gLTEpe1xuICAgICAgICAgIHJldHVybiAnVGhpcyBvcHRpb24gYWxyZWFkeSBleGlzdHMnO1xuICAgICAgfVxuXG4gICAgICAvLyB3ZSBuZXZlciB3YW50IHRvIG1hbmlwdWxhdGUgdGhlIHN0YXRlXG4gICAgICAvLyBwcmV2U3RhdGUub3B0aW9ucy5wdXNoKG9wdGlvbikgLSB0aGF0IGlzIHdoeSB3ZSBkb250IHVzZSBwdXNoXG4gICAgICAvLyBhZGRpbmcgbmV3IG9wdGlvbnMgdG8gdGhlIG9wdGlvbnMgYXJyYXkgdXNpbmcgY29uY2F0KClcbiAgICAgIHRoaXMuc2V0U3RhdGUoKHByZXZTdGF0ZSkgPT4gKHtvcHRpb25zOiBwcmV2U3RhdGUub3B0aW9ucy5jb25jYXQob3B0aW9uKX0pKSAgIFxuICB9IFxuICBcbiAgY29tcG9uZW50RGlkTW91bnQoKXtcbiAgICAvLyBjYXRjaCBkYXRhIGlmIGlzIHVudmFsaWRcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBqc29uID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ29wdGlvbnMnKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IEpTT04ucGFyc2UoanNvbik7XG5cbiAgICAgICAgLy8gaWYgbG9jYWxzdG9yYWdlIGlzIGVtcHR5IGl0IHJldHVybnMgbnVsbCBhbmQgSlNPTi5wYXJzZSB3aWxsIHJldHVybiBudWxsIHRvbyAtIHNvIHdlIGRvbnQgd2FudCB0byBzZXRTdGF0ZSB0byBudWxsIC0gdGhhdCBpcyB3aHkgd2UgZG8gY29uZGl0aW9uYWxcbiAgICAgICAgaWYob3B0aW9ucyl7XG4gICAgICAgICAgICAvLyByZXR1cm5pbmcgb3B0aW9ucyBvYmogc2luY2UgaXMgdGhlIHNhbWUgYXMgdGhlIHZhciBhYm92ZVxuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSgoKSA9PiAoe29wdGlvbnN9KSk7XG4gICB9XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICAgIC8vIERvIG5vdGhpbmcgYXQgYWxsXG4gICAgfVxufVxuXG4vLyBzYXZpbmcgZGF0YVxuY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlKXtcbiAgICAvLyBjaGVja2luZyBpZiBvcHRpb25zIGFycmF5IGNoYW5nZVxuICAgIGlmKHByZXZTdGF0ZS5vcHRpb25zLmxlbmd0aCAhPT0gdGhpcy5zdGF0ZS5vcHRpb25zLmxlbmd0aCl7XG4gICAgICAgIGNvbnN0IGpzb24gPSBKU09OLnN0cmluZ2lmeSh0aGlzLnN0YXRlLm9wdGlvbnMpO1xuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnb3B0aW9ucycsIGpzb24pXG4gICAgfVxuXG59XG5jb21wb25lbnRXaWxsVW5tb3VudCgpe1xuICAgIGNvbnNvbGUubG9nKCdjb21wb25lbnRXaWxsVW5tb3VudCcpXG59XG5cbiAgcmVuZGVyKCl7XG4gICAgICBjb25zdCBzdWJ0aXRsZSA9ICdQdXQgeW91ciBsaWZlIGluIHRoZSBoYW5kcyBvZiBhIGNvbXB1dGVyJztcbiAgICAgIHJldHVybiAoXG4gICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgPEhlYWRlciBzdWJ0aXRsZT17c3VidGl0bGV9Lz5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb250YWluZXJcIj5cbiAgICAgICAgICAgICAgICA8QWN0aW9uIGhhc09wdGlvbnM9e3RoaXMuc3RhdGUub3B0aW9ucy5sZW5ndGggPiAwfSBcbiAgICAgICAgICAgICAgICBoYW5kbGVQaWNrPXt0aGlzLmhhbmRsZVBpY2t9IC8+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3aWRnZXRcIj5cbiAgICAgICAgICAgICAgICAgICAgPE9wdGlvbnMgb3B0aW9ucz17dGhpcy5zdGF0ZS5vcHRpb25zfVxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVEZWxldGVPcHRpb25zPXt0aGlzLmhhbmRsZURlbGV0ZU9wdGlvbnN9XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZURlbGV0ZU9wdGlvbj17dGhpcy5oYW5kbGVEZWxldGVPcHRpb259XG4gICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgIDxBZGRPcHRpb24gaGFuZGxlQWRkT3B0aW9uPXt0aGlzLmhhbmRsZUFkZE9wdGlvbn0gLz5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDxPcHRpb25Nb2RhbCBzZWxlY3RlZE9wdGlvbj17dGhpcy5zdGF0ZS5zZWxlY3RlZE9wdGlvbn0gaGFuZGxlRGVsZXRlTW9kYWw9e3RoaXMuaGFuZGxlRGVsZXRlTW9kYWx9IC8+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICApXG4gIH1cbn1cblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9jb21wb25lbnRzL0luZGVjaXNpb25BcHAuanMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7Ozs7Ozs7Ozs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQU1BO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQURBO0FBQUE7QUFHQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBR0E7QUFHQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7Ozs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFMQTtBQUhBO0FBV0E7QUFiQTtBQWdCQTs7OztBQWhHQTtBQUNBO0FBREEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///34\n");

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _react = __webpack_require__(1);\n\nvar _react2 = _interopRequireDefault(_react);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar AddOption = function (_React$Component) {\n    _inherits(AddOption, _React$Component);\n\n    function AddOption() {\n        var _ref;\n\n        var _temp, _this, _ret;\n\n        _classCallCheck(this, AddOption);\n\n        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n        }\n\n        return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = AddOption.__proto__ || Object.getPrototypeOf(AddOption)).call.apply(_ref, [this].concat(args))), _this), _this.state = {\n            error: undefined\n        }, _this.handleAddOption = function (e) {\n            e.preventDefault();\n            console.log('testing');\n            var option = e.target.elements.option.value.trim();\n            var error = _this.props.handleAddOption(option);\n\n            // the error message is specific to this form, so it's the only place it needs to live - that is why we set the state in this child component \n            // in ES6 if the obj property has the same name as the variable we can just use as below\n            // error: error - will be the same as shorthand syntax below\n            _this.setState(function () {\n                return { error: error };\n            });\n\n            // clearing the input if there is no error\n            if (!error) {\n                e.target.elements.option.value = '';\n            }\n        }, _temp), _possibleConstructorReturn(_this, _ret);\n    }\n\n    _createClass(AddOption, [{\n        key: 'render',\n        value: function render() {\n            return _react2.default.createElement(\n                'div',\n                null,\n                this.state.error && _react2.default.createElement(\n                    'p',\n                    { className: 'add-option-error' },\n                    this.state.error\n                ),\n                _react2.default.createElement(\n                    'form',\n                    { className: 'add-option', onSubmit: this.handleAddOption },\n                    _react2.default.createElement('input', { className: 'add-option__input', type: 'text', name: 'option' }),\n                    _react2.default.createElement(\n                        'button',\n                        { className: 'button' },\n                        'Add option'\n                    )\n                )\n            );\n        }\n    }]);\n\n    return AddOption;\n}(_react2.default.Component);\n\nexports.default = AddOption;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2NvbXBvbmVudHMvQWRkT3B0aW9uLmpzPzk4YmYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBZGRPcHRpb24gZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIHN0YXRlID0ge1xuICAgICAgICBlcnJvcjogdW5kZWZpbmVkXG4gICAgfVxuICBcbiAgaGFuZGxlQWRkT3B0aW9uID0gKGUpID0+IHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGNvbnNvbGUubG9nKCd0ZXN0aW5nJyk7XG4gICAgICBjb25zdCBvcHRpb24gPSBlLnRhcmdldC5lbGVtZW50cy5vcHRpb24udmFsdWUudHJpbSgpO1xuICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLnByb3BzLmhhbmRsZUFkZE9wdGlvbihvcHRpb24pO1xuICAgICAgXG4gICAgICAvLyB0aGUgZXJyb3IgbWVzc2FnZSBpcyBzcGVjaWZpYyB0byB0aGlzIGZvcm0sIHNvIGl0J3MgdGhlIG9ubHkgcGxhY2UgaXQgbmVlZHMgdG8gbGl2ZSAtIHRoYXQgaXMgd2h5IHdlIHNldCB0aGUgc3RhdGUgaW4gdGhpcyBjaGlsZCBjb21wb25lbnQgXG4gICAgICAvLyBpbiBFUzYgaWYgdGhlIG9iaiBwcm9wZXJ0eSBoYXMgdGhlIHNhbWUgbmFtZSBhcyB0aGUgdmFyaWFibGUgd2UgY2FuIGp1c3QgdXNlIGFzIGJlbG93XG4gICAgICAvLyBlcnJvcjogZXJyb3IgLSB3aWxsIGJlIHRoZSBzYW1lIGFzIHNob3J0aGFuZCBzeW50YXggYmVsb3dcbiAgICAgIHRoaXMuc2V0U3RhdGUoKCkgPT4gKHsgZXJyb3IgfSkpICAgICAgICBcbiAgICAgIFxuICAgICAgLy8gY2xlYXJpbmcgdGhlIGlucHV0IGlmIHRoZXJlIGlzIG5vIGVycm9yXG4gICAgICBpZighZXJyb3Ipe1xuICAgICAgICAgIGUudGFyZ2V0LmVsZW1lbnRzLm9wdGlvbi52YWx1ZSA9ICcnO1xuICAgICAgfVxuICB9ICAgXG4gIHJlbmRlcigpe1xuICAgICAgcmV0dXJuIChcbiAgICAgIDxkaXY+XG4gICAgICB7LyogY29uZGl0aW9uYWwgcmVuZGVyaW5nIGJlbG93IHJlbmRlcnMgdGhlIGVycm9yIG1zZyAqL31cbiAgICAgICAgICB7dGhpcy5zdGF0ZS5lcnJvciAmJiA8cCBjbGFzc05hbWU9XCJhZGQtb3B0aW9uLWVycm9yXCI+e3RoaXMuc3RhdGUuZXJyb3J9PC9wPn1cbiAgICAgICAgICA8Zm9ybSBjbGFzc05hbWU9XCJhZGQtb3B0aW9uXCIgb25TdWJtaXQ9e3RoaXMuaGFuZGxlQWRkT3B0aW9ufT5cbiAgICAgICAgICAgICAgPGlucHV0IGNsYXNzTmFtZT1cImFkZC1vcHRpb25fX2lucHV0XCIgdHlwZT1cInRleHRcIiBuYW1lPVwib3B0aW9uXCIgLz5cbiAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9XCJidXR0b25cIj5BZGQgb3B0aW9uPC9idXR0b24+XG4gICAgICAgICAgPC9mb3JtPlxuICAgICAgPC9kaXY+XG4gICAgICApXG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvY29tcG9uZW50cy9BZGRPcHRpb24uanMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTs7Ozs7Ozs7Ozs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7QUFDQTtBQUNBO0FBREE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUZBO0FBSEE7QUFTQTs7OztBQWhDQTtBQUNBO0FBREEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///35\n");

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _react = __webpack_require__(1);\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _Option = __webpack_require__(37);\n\nvar _Option2 = _interopRequireDefault(_Option);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar Options = function Options(props) {\n    return _react2.default.createElement(\n        'div',\n        null,\n        _react2.default.createElement(\n            'div',\n            { className: 'widget-header' },\n            _react2.default.createElement(\n                'h3',\n                { className: 'widget-header__title' },\n                'Your Options'\n            ),\n            _react2.default.createElement(\n                'button',\n                {\n                    className: 'button button--link',\n                    onClick: props.handleDeleteOptions\n                },\n                'Remove All'\n            )\n        ),\n        props.options.length === 0 && _react2.default.createElement(\n            'p',\n            { className: 'widget-header__message' },\n            'Please add an option to get started!'\n        ),\n        props.options.map(function (el, i) {\n            return _react2.default.createElement(_Option2.default, { key: el,\n                optionText: el,\n                count: i + 1,\n                handleDeleteOption: props.handleDeleteOption\n            });\n        })\n    );\n};\n\nexports.default = Options;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2NvbXBvbmVudHMvT3B0aW9ucy5qcz8yOTI3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgT3B0aW9uIGZyb20gJy4vT3B0aW9uJ1xuXG5jb25zdCBPcHRpb25zID0gKHByb3BzKSA9PiAoXG5cbiAgICA8ZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIndpZGdldC1oZWFkZXJcIj5cbiAgICAgICAgICAgIDxoMyBjbGFzc05hbWU9XCJ3aWRnZXQtaGVhZGVyX190aXRsZVwiPllvdXIgT3B0aW9uczwvaDM+XG4gICAgICAgICAgICA8YnV0dG9uIFxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJidXR0b24gYnV0dG9uLS1saW5rXCJcbiAgICAgICAgICAgICAgb25DbGljaz17cHJvcHMuaGFuZGxlRGVsZXRlT3B0aW9uc31cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICBSZW1vdmUgQWxsXG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPC9kaXY+XG4gICAgXG4gICAgICAgIHsvKiBpZiBvcHRpb25zIGFycmF5IGlzIGVtcHR5IHNob3cgbXNnICovfVxuICAgICAgICB7cHJvcHMub3B0aW9ucy5sZW5ndGggPT09IDAgJiYgPHAgY2xhc3NOYW1lPVwid2lkZ2V0LWhlYWRlcl9fbWVzc2FnZVwiPlBsZWFzZSBhZGQgYW4gb3B0aW9uIHRvIGdldCBzdGFydGVkITwvcD59XG4gICAgICAgIHtcbiAgICAgICAgICAgIHByb3BzLm9wdGlvbnMubWFwKChlbCwgaSkgPT4gKFxuICAgICAgICAgICAgPE9wdGlvbiBrZXk9e2VsfVxuICAgICAgICAgICAgb3B0aW9uVGV4dD17ZWx9XG4gICAgICAgICAgICBjb3VudD17aSArIDF9XG4gICAgICAgICAgICBoYW5kbGVEZWxldGVPcHRpb249e3Byb3BzLmhhbmRsZURlbGV0ZU9wdGlvbn1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgICApKVxuICAgICAgICB9XG4gICAgPC9kaXY+XG4pXG5cbmV4cG9ydCBkZWZhdWx0IE9wdGlvbnM7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9jb21wb25lbnRzL09wdGlvbnMuanMiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7Ozs7O0FBQ0E7QUFBQTtBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUZBO0FBQUE7QUFBQTtBQUZBO0FBV0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFIQTtBQURBO0FBZEE7QUFGQTtBQUNBO0FBMEJBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///36\n");

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _react = __webpack_require__(1);\n\nvar _react2 = _interopRequireDefault(_react);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar Option = function Option(props) {\n    return _react2.default.createElement(\n        \"div\",\n        { className: \"option\" },\n        _react2.default.createElement(\n            \"p\",\n            { className: \"option__text\" },\n            props.count,\n            \". \",\n            props.optionText\n        ),\n        _react2.default.createElement(\n            \"button\",\n            {\n                className: \"button button--link\"\n                // passing an inline func thats gonna get called with the e argument when the button gets clicked and we are going to called the handleDeleteOption with the correct data - explicitly pass optionText\n                , onClick: function onClick(e) {\n                    props.handleDeleteOption(props.optionText);\n                }\n            },\n            \"remove\"\n        )\n    );\n};\n\nexports.default = Option;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2NvbXBvbmVudHMvT3B0aW9uLmpzPzMyYmEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuY29uc3QgT3B0aW9uID0gKHByb3BzKSA9PiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJvcHRpb25cIj5cbiAgICAgICAgPHAgY2xhc3NOYW1lPVwib3B0aW9uX190ZXh0XCI+e3Byb3BzLmNvdW50fS4ge3Byb3BzLm9wdGlvblRleHR9PC9wPlxuICAgICAgICA8YnV0dG9uIFxuICAgICAgICAgICAgY2xhc3NOYW1lPVwiYnV0dG9uIGJ1dHRvbi0tbGlua1wiXG4gICAgICAgIC8vIHBhc3NpbmcgYW4gaW5saW5lIGZ1bmMgdGhhdHMgZ29ubmEgZ2V0IGNhbGxlZCB3aXRoIHRoZSBlIGFyZ3VtZW50IHdoZW4gdGhlIGJ1dHRvbiBnZXRzIGNsaWNrZWQgYW5kIHdlIGFyZSBnb2luZyB0byBjYWxsZWQgdGhlIGhhbmRsZURlbGV0ZU9wdGlvbiB3aXRoIHRoZSBjb3JyZWN0IGRhdGEgLSBleHBsaWNpdGx5IHBhc3Mgb3B0aW9uVGV4dFxuICAgICAgICAgICAgb25DbGljaz17KGUpID0+IHtcbiAgICAgICAgICAgICAgICBwcm9wcy5oYW5kbGVEZWxldGVPcHRpb24ocHJvcHMub3B0aW9uVGV4dCk7XG4gICAgICAgICAgICB9fVxuICAgICAgICA+XG4gICAgICAgIHJlbW92ZVxuICAgICAgICA8L2J1dHRvbj5cbiAgICA8L2Rpdj5cbilcblxuZXhwb3J0IGRlZmF1bHQgT3B0aW9uO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvY29tcG9uZW50cy9PcHRpb24uanMiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7Ozs7O0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFMQTtBQUFBO0FBQUE7QUFGQTtBQURBO0FBQ0E7QUFjQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///37\n");

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _react = __webpack_require__(1);\n\nvar _react2 = _interopRequireDefault(_react);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar Header = function Header(props) {\n  return _react2.default.createElement(\n    \"div\",\n    { className: \"header\" },\n    _react2.default.createElement(\n      \"div\",\n      { className: \"container\" },\n      _react2.default.createElement(\n        \"div\",\n        { className: \"header__title\" },\n        _react2.default.createElement(\n          \"svg\",\n          { x: \"0px\", y: \"0px\", viewBox: \"0 0 49.4 12.3\" },\n          _react2.default.createElement(\n            \"g\",\n            null,\n            _react2.default.createElement(\"path\", { fill: \"#FFFFFF\", d: \"M2,5.7C1.2,5.3,0.2,4.3,1,2.9c1-1.8,3.8-1.1,6-2.9l0.6,1.1L1.4,12.1H0.1l6-10.4C4.7,2.3,2.6,2.4,2,3.4 c-0.6,1,0.5,1.5,0.5,1.5L2,5.7z\" }),\n            _react2.default.createElement(\"path\", { fill: \"#FFFFFF\", d: \"M11.9,6.4c0.2,0.1,0.4,0.3,0.5,0.4c-1,1.2-2.2,2.3-3.2,2.3c-1,0-1.4-0.9-0.9-1.8l1.6-2.8 c0.5-0.9-0.3-1.2-2.2,1.2L5.8,9.1H4.5l3.5-6h1.2L8.8,3.9c0.6-0.6,1.2-0.9,1.7-0.9c0.7,0,1.2,0.7,0.7,1.6L9.4,7.7 C9.1,8.2,9.2,8.4,9.5,8.4C10.1,8.4,10.9,7.6,11.9,6.4L11.9,6.4z\" }),\n            _react2.default.createElement(\"path\", { fill: \"#FFFFFF\", d: \"M17.8,6.4c0.2,0.1,0.4,0.3,0.5,0.4c-1,1.2-2.2,2.3-3.2,2.3c-0.6,0-1-0.3-1.1-0.8c-0.6,0.5-1.2,0.8-1.7,0.8 c-1,0-1.4-0.9-0.9-1.8l1.8-3c0.5-0.9,1.5-1.4,2.1-1.4c0.5,0,0.9,0.3,1.1,0.6l1.8-3.2h1.2l-4.2,7.3c-0.3,0.5-0.1,0.7,0.1,0.7 C15.9,8.4,16.8,7.6,17.8,6.4L17.8,6.4z M12.4,7.7c-0.3,0.5-0.1,0.7,0.1,0.7c0.5,0,1.3-0.6,2.1-1.8L15.6,5h0 c0.6-1.1-0.7-1.4-1.4-0.3L12.4,7.7z\" }),\n            _react2.default.createElement(\"path\", { fill: \"#FFFFFF\", d: \"M18.9,6.7l-0.1,0.2c-0.6,1-0.1,1.5,0.6,1.5c0.9,0,2-0.8,2.9-1.9l0.1-0.1c0.2,0.1,0.4,0.3,0.5,0.4 c-1,1.2-2.4,2.3-3.9,2.3c-1.5,0-2.1-1.2-1.4-2.6L19,4.4c0.5-0.9,1.3-1.4,2.3-1.4c1,0,1.7,0.9,1,2l-0.2,0.3 C21.2,6.9,19.7,7,18.9,6.7z M19.3,6.1c0.5,0.2,1.3,0.2,1.9-0.8L21.3,5c0.7-1.3-0.5-1.5-1.2-0.3L19.3,6.1z\" }),\n            _react2.default.createElement(\"path\", { fill: \"#FFFFFF\", d: \"M23.4,6.9c-0.6,1-0.1,1.5,0.6,1.5c0.9,0,2-0.8,2.9-1.9l0.1-0.1c0.2,0.1,0.4,0.3,0.5,0.4 c-1,1.2-2.4,2.3-3.9,2.3c-1.5,0-2.1-1.2-1.4-2.6l1.3-2.2C24.2,3.5,25,2.9,26,2.9c1,0,1.7,0.9,1,2l-0.2,0.3h-1L26,5 c0.7-1.3-0.5-1.5-1.2-0.3L23.4,6.9z\" }),\n            _react2.default.createElement(\"path\", { fill: \"#FFFFFF\", d: \"M30.2,6.4c0.2,0.1,0.4,0.3,0.5,0.4c-1,1.2-2.2,2.3-3.2,2.3c-1,0-1.4-0.9-0.9-1.8l2.5-4.3h1.2l-2.7,4.7 c-0.3,0.5-0.1,0.7,0.1,0.7C28.3,8.4,29.2,7.6,30.2,6.4L30.2,6.4z M30.5,1c0.4,0,0.7,0.3,0.7,0.7s-0.3,0.7-0.7,0.7 c-0.4,0-0.7-0.3-0.7-0.7S30,1,30.5,1z\" }),\n            _react2.default.createElement(\"path\", { fill: \"#FFFFFF\", d: \"M29.6,8.2l0.8-0.4c0,0,0.2,0.5,0.6,0.5c1.2,0,0.9-2.3,1.4-3.6c-0.4,0.6-1.1,1.5-1.8,2.3 c-0.2-0.1-0.4-0.3-0.5-0.4c1.1-1.3,2.3-3,2.8-3.7l0.9,0.5c-0.8,1.6-0.7,3.4-1.1,4.6c0.5-0.3,1-0.8,1.5-1.4l0.1-0.1 c0.2,0,0.4,0.2,0.5,0.4C33.9,8,32.7,9,31.4,9.1c0,0,0,0,0,0c-0.1,0-0.2,0-0.3,0C29.9,9.2,29.6,8.2,29.6,8.2z\" }),\n            _react2.default.createElement(\"path\", { fill: \"#FFFFFF\", d: \"M37.5,6.4c0.2,0.1,0.4,0.3,0.5,0.4c-1,1.2-2.2,2.3-3.2,2.3c-1,0-1.4-0.9-0.9-1.8l2.5-4.3h1.2l-2.7,4.7 c-0.3,0.5-0.1,0.7,0.1,0.7C35.6,8.4,36.5,7.6,37.5,6.4L37.5,6.4z M37.8,1c0.4,0,0.7,0.3,0.7,0.7s-0.3,0.7-0.7,0.7 c-0.4,0-0.7-0.3-0.7-0.7S37.3,1,37.8,1z\" }),\n            _react2.default.createElement(\"path\", { fill: \"#FFFFFF\", d: \"M40.5,8.1c-1.7,2.1-4.7,1.1-3.1-1.6L38,5.6l0.6-1.1C39.3,3.3,40,2.9,41,2.9c1.2,0,1.9,1.2,1.1,2.5l-1.2,2 c0.6,0,1.3-0.3,1.9-0.9l0.1-0.1c0.2,0.1,0.4,0.3,0.5,0.4c-0.6,0.8-1.8,1.2-2.6,1.2H40.5z M40.2,6.5L40.2,6.5l1-1.6 c0.8-1.3-0.4-1.9-1.3-0.4l-0.6,1l-0.9,1.6c-0.7,1.3,0.7,1.5,1.3,0.5l0,0c-0.1-0.1-0.1-0.3-0.1-0.4C39.5,6.9,39.8,6.5,40.2,6.5z\" }),\n            _react2.default.createElement(\"path\", { fill: \"#FFFFFF\", d: \"M48.8,6.4c0.2,0.1,0.4,0.3,0.5,0.4c-1,1.2-2.2,2.3-3.2,2.3c-1,0-1.4-0.9-0.9-1.8l1.6-2.8 c0.5-0.9-0.3-1.2-2.2,1.2l-1.9,3.3h-1.3l3.5-6h1.2l-0.5,0.8c0.6-0.6,1.2-0.9,1.7-0.9c0.7,0,1.2,0.7,0.7,1.6l-1.8,3.2 c-0.3,0.5-0.1,0.7,0.1,0.7C46.9,8.4,47.8,7.6,48.8,6.4L48.8,6.4z\" })\n          )\n        )\n      ),\n      props.subtitle && _react2.default.createElement(\n        \"h2\",\n        { className: \"header__subtitle\" },\n        props.subtitle\n      )\n    )\n  );\n};\n\nHeader.defaultProps = {\n  title: 'Indecision'\n};\n\nexports.default = Header;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2NvbXBvbmVudHMvSGVhZGVyLmpzPzZmN2EiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuXG5jb25zdCBIZWFkZXIgPSAocHJvcHMpID0+IChcbiAgPGRpdiBjbGFzc05hbWU9XCJoZWFkZXJcIj5cbiAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRhaW5lclwiPlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJoZWFkZXJfX3RpdGxlXCI+XG4gICAgICAgIDxzdmcgeD1cIjBweFwiIHk9XCIwcHhcIiB2aWV3Qm94PVwiMCAwIDQ5LjQgMTIuM1wiPlxuICAgICAgICAgIDxnPlxuICAgICAgICAgICAgPHBhdGggZmlsbD1cIiNGRkZGRkZcIiBkPVwiTTIsNS43QzEuMiw1LjMsMC4yLDQuMywxLDIuOWMxLTEuOCwzLjgtMS4xLDYtMi45bDAuNiwxLjFMMS40LDEyLjFIMC4xbDYtMTAuNEM0LjcsMi4zLDIuNiwyLjQsMiwzLjRcbiAgICAgICAgICAgICAgYy0wLjYsMSwwLjUsMS41LDAuNSwxLjVMMiw1Ljd6XCIvPlxuICAgICAgICAgICAgPHBhdGggZmlsbD1cIiNGRkZGRkZcIiBkPVwiTTExLjksNi40YzAuMiwwLjEsMC40LDAuMywwLjUsMC40Yy0xLDEuMi0yLjIsMi4zLTMuMiwyLjNjLTEsMC0xLjQtMC45LTAuOS0xLjhsMS42LTIuOFxuICAgICAgICAgICAgICBjMC41LTAuOS0wLjMtMS4yLTIuMiwxLjJMNS44LDkuMUg0LjVsMy41LTZoMS4yTDguOCwzLjljMC42LTAuNiwxLjItMC45LDEuNy0wLjljMC43LDAsMS4yLDAuNywwLjcsMS42TDkuNCw3LjdcbiAgICAgICAgICAgICAgQzkuMSw4LjIsOS4yLDguNCw5LjUsOC40QzEwLjEsOC40LDEwLjksNy42LDExLjksNi40TDExLjksNi40elwiLz5cbiAgICAgICAgICAgIDxwYXRoIGZpbGw9XCIjRkZGRkZGXCIgZD1cIk0xNy44LDYuNGMwLjIsMC4xLDAuNCwwLjMsMC41LDAuNGMtMSwxLjItMi4yLDIuMy0zLjIsMi4zYy0wLjYsMC0xLTAuMy0xLjEtMC44Yy0wLjYsMC41LTEuMiwwLjgtMS43LDAuOFxuICAgICAgICAgICAgICBjLTEsMC0xLjQtMC45LTAuOS0xLjhsMS44LTNjMC41LTAuOSwxLjUtMS40LDIuMS0xLjRjMC41LDAsMC45LDAuMywxLjEsMC42bDEuOC0zLjJoMS4ybC00LjIsNy4zYy0wLjMsMC41LTAuMSwwLjcsMC4xLDAuN1xuICAgICAgICAgICAgICBDMTUuOSw4LjQsMTYuOCw3LjYsMTcuOCw2LjRMMTcuOCw2LjR6IE0xMi40LDcuN2MtMC4zLDAuNS0wLjEsMC43LDAuMSwwLjdjMC41LDAsMS4zLTAuNiwyLjEtMS44TDE1LjYsNWgwXG4gICAgICAgICAgICAgIGMwLjYtMS4xLTAuNy0xLjQtMS40LTAuM0wxMi40LDcuN3pcIi8+XG4gICAgICAgICAgICA8cGF0aCBmaWxsPVwiI0ZGRkZGRlwiIGQ9XCJNMTguOSw2LjdsLTAuMSwwLjJjLTAuNiwxLTAuMSwxLjUsMC42LDEuNWMwLjksMCwyLTAuOCwyLjktMS45bDAuMS0wLjFjMC4yLDAuMSwwLjQsMC4zLDAuNSwwLjRcbiAgICAgICAgICAgICAgYy0xLDEuMi0yLjQsMi4zLTMuOSwyLjNjLTEuNSwwLTIuMS0xLjItMS40LTIuNkwxOSw0LjRjMC41LTAuOSwxLjMtMS40LDIuMy0xLjRjMSwwLDEuNywwLjksMSwybC0wLjIsMC4zXG4gICAgICAgICAgICAgIEMyMS4yLDYuOSwxOS43LDcsMTguOSw2Ljd6IE0xOS4zLDYuMWMwLjUsMC4yLDEuMywwLjIsMS45LTAuOEwyMS4zLDVjMC43LTEuMy0wLjUtMS41LTEuMi0wLjNMMTkuMyw2LjF6XCIvPlxuICAgICAgICAgICAgPHBhdGggZmlsbD1cIiNGRkZGRkZcIiBkPVwiTTIzLjQsNi45Yy0wLjYsMS0wLjEsMS41LDAuNiwxLjVjMC45LDAsMi0wLjgsMi45LTEuOWwwLjEtMC4xYzAuMiwwLjEsMC40LDAuMywwLjUsMC40XG4gICAgICAgICAgICAgIGMtMSwxLjItMi40LDIuMy0zLjksMi4zYy0xLjUsMC0yLjEtMS4yLTEuNC0yLjZsMS4zLTIuMkMyNC4yLDMuNSwyNSwyLjksMjYsMi45YzEsMCwxLjcsMC45LDEsMmwtMC4yLDAuM2gtMUwyNiw1XG4gICAgICAgICAgICAgIGMwLjctMS4zLTAuNS0xLjUtMS4yLTAuM0wyMy40LDYuOXpcIi8+XG4gICAgICAgICAgICA8cGF0aCBmaWxsPVwiI0ZGRkZGRlwiIGQ9XCJNMzAuMiw2LjRjMC4yLDAuMSwwLjQsMC4zLDAuNSwwLjRjLTEsMS4yLTIuMiwyLjMtMy4yLDIuM2MtMSwwLTEuNC0wLjktMC45LTEuOGwyLjUtNC4zaDEuMmwtMi43LDQuN1xuICAgICAgICAgICAgICBjLTAuMywwLjUtMC4xLDAuNywwLjEsMC43QzI4LjMsOC40LDI5LjIsNy42LDMwLjIsNi40TDMwLjIsNi40eiBNMzAuNSwxYzAuNCwwLDAuNywwLjMsMC43LDAuN3MtMC4zLDAuNy0wLjcsMC43XG4gICAgICAgICAgICAgIGMtMC40LDAtMC43LTAuMy0wLjctMC43UzMwLDEsMzAuNSwxelwiLz5cbiAgICAgICAgICAgIDxwYXRoIGZpbGw9XCIjRkZGRkZGXCIgZD1cIk0yOS42LDguMmwwLjgtMC40YzAsMCwwLjIsMC41LDAuNiwwLjVjMS4yLDAsMC45LTIuMywxLjQtMy42Yy0wLjQsMC42LTEuMSwxLjUtMS44LDIuM1xuICAgICAgICAgICAgICBjLTAuMi0wLjEtMC40LTAuMy0wLjUtMC40YzEuMS0xLjMsMi4zLTMsMi44LTMuN2wwLjksMC41Yy0wLjgsMS42LTAuNywzLjQtMS4xLDQuNmMwLjUtMC4zLDEtMC44LDEuNS0xLjRsMC4xLTAuMVxuICAgICAgICAgICAgICBjMC4yLDAsMC40LDAuMiwwLjUsMC40QzMzLjksOCwzMi43LDksMzEuNCw5LjFjMCwwLDAsMCwwLDBjLTAuMSwwLTAuMiwwLTAuMywwQzI5LjksOS4yLDI5LjYsOC4yLDI5LjYsOC4yelwiLz5cbiAgICAgICAgICAgIDxwYXRoIGZpbGw9XCIjRkZGRkZGXCIgZD1cIk0zNy41LDYuNGMwLjIsMC4xLDAuNCwwLjMsMC41LDAuNGMtMSwxLjItMi4yLDIuMy0zLjIsMi4zYy0xLDAtMS40LTAuOS0wLjktMS44bDIuNS00LjNoMS4ybC0yLjcsNC43XG4gICAgICAgICAgICAgIGMtMC4zLDAuNS0wLjEsMC43LDAuMSwwLjdDMzUuNiw4LjQsMzYuNSw3LjYsMzcuNSw2LjRMMzcuNSw2LjR6IE0zNy44LDFjMC40LDAsMC43LDAuMywwLjcsMC43cy0wLjMsMC43LTAuNywwLjdcbiAgICAgICAgICAgICAgYy0wLjQsMC0wLjctMC4zLTAuNy0wLjdTMzcuMywxLDM3LjgsMXpcIi8+XG4gICAgICAgICAgICA8cGF0aCBmaWxsPVwiI0ZGRkZGRlwiIGQ9XCJNNDAuNSw4LjFjLTEuNywyLjEtNC43LDEuMS0zLjEtMS42TDM4LDUuNmwwLjYtMS4xQzM5LjMsMy4zLDQwLDIuOSw0MSwyLjljMS4yLDAsMS45LDEuMiwxLjEsMi41bC0xLjIsMlxuICAgICAgICAgICAgICBjMC42LDAsMS4zLTAuMywxLjktMC45bDAuMS0wLjFjMC4yLDAuMSwwLjQsMC4zLDAuNSwwLjRjLTAuNiwwLjgtMS44LDEuMi0yLjYsMS4ySDQwLjV6IE00MC4yLDYuNUw0MC4yLDYuNWwxLTEuNlxuICAgICAgICAgICAgICBjMC44LTEuMy0wLjQtMS45LTEuMy0wLjRsLTAuNiwxbC0wLjksMS42Yy0wLjcsMS4zLDAuNywxLjUsMS4zLDAuNWwwLDBjLTAuMS0wLjEtMC4xLTAuMy0wLjEtMC40QzM5LjUsNi45LDM5LjgsNi41LDQwLjIsNi41elwiLz5cbiAgICAgICAgICAgIDxwYXRoIGZpbGw9XCIjRkZGRkZGXCIgZD1cIk00OC44LDYuNGMwLjIsMC4xLDAuNCwwLjMsMC41LDAuNGMtMSwxLjItMi4yLDIuMy0zLjIsMi4zYy0xLDAtMS40LTAuOS0wLjktMS44bDEuNi0yLjhcbiAgICAgICAgICAgICAgYzAuNS0wLjktMC4zLTEuMi0yLjIsMS4ybC0xLjksMy4zaC0xLjNsMy41LTZoMS4ybC0wLjUsMC44YzAuNi0wLjYsMS4yLTAuOSwxLjctMC45YzAuNywwLDEuMiwwLjcsMC43LDEuNmwtMS44LDMuMlxuICAgICAgICAgICAgICBjLTAuMywwLjUtMC4xLDAuNywwLjEsMC43QzQ2LjksOC40LDQ3LjgsNy42LDQ4LjgsNi40TDQ4LjgsNi40elwiLz5cbiAgICAgICAgICA8L2c+XG4gICAgICAgIDwvc3ZnPlxuICAgICAgPC9kaXY+XG4gICAgICB7cHJvcHMuc3VidGl0bGUgJiYgPGgyIGNsYXNzTmFtZT1cImhlYWRlcl9fc3VidGl0bGVcIj57cHJvcHMuc3VidGl0bGV9PC9oMj59XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuXG4pXG5cbkhlYWRlci5kZWZhdWx0UHJvcHMgPSB7XG4gIHRpdGxlOiAnSW5kZWNpc2lvbidcbn1cblxuZXhwb3J0IGRlZmF1bHQgSGVhZGVyO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvY29tcG9uZW50cy9IZWFkZXIuanMiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7Ozs7O0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBR0E7QUFJQTtBQUdBO0FBR0E7QUFHQTtBQUdBO0FBR0E7QUFHQTtBQTVCQTtBQURBO0FBREE7QUFvQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQXJDQTtBQURBO0FBREE7QUFDQTtBQTRDQTtBQUNBO0FBREE7QUFDQTtBQUdBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///38\n");

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _react = __webpack_require__(1);\n\nvar _react2 = _interopRequireDefault(_react);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar Action = function Action(props) {\n    return _react2.default.createElement(\n        \"div\",\n        null,\n        _react2.default.createElement(\n            \"button\",\n            { className: \"big-button\", onClick: props.handlePick, disabled: !props.hasOptions },\n            \"What should I do?\"\n        )\n    );\n};\n\nexports.default = Action;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2NvbXBvbmVudHMvQWN0aW9uLmpzP2VlMmYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuY29uc3QgQWN0aW9uID0gKHByb3BzKSA9PiAoXG4gICAgPGRpdj5cbiAgICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9XCJiaWctYnV0dG9uXCIgb25DbGljaz17cHJvcHMuaGFuZGxlUGlja30gZGlzYWJsZWQ9eyFwcm9wcy5oYXNPcHRpb25zfT5XaGF0IHNob3VsZCBJIGRvPzwvYnV0dG9uPlxuICAgIDwvZGl2PlxuICBcbilcblxuZXhwb3J0IGRlZmF1bHQgQWN0aW9uO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvY29tcG9uZW50cy9BY3Rpb24uanMiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7Ozs7O0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBREE7QUFEQTtBQUNBO0FBTUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///39\n");

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _react = __webpack_require__(1);\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _reactModal = __webpack_require__(41);\n\nvar _reactModal2 = _interopRequireDefault(_reactModal);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar OptionModal = function OptionModal(props) {\n  return _react2.default.createElement(\n    _reactModal2.default,\n    {\n      isOpen: !!props.selectedOption,\n      onRequestClose: props.handleDeleteModal,\n      ariaHideApp: false,\n      contentLabel: 'Selected Option',\n      closeTimeoutMS: 200,\n      className: 'modal'\n    },\n    _react2.default.createElement(\n      'h3',\n      { className: 'modal__title' },\n      'Selected Option'\n    ),\n    props.selectedOption && _react2.default.createElement(\n      'p',\n      { className: 'modal__body' },\n      props.selectedOption\n    ),\n    _react2.default.createElement(\n      'button',\n      { className: 'button', onClick: props.handleDeleteModal },\n      'Okay'\n    )\n  );\n};\n\nexports.default = OptionModal;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2NvbXBvbmVudHMvT3B0aW9uTW9kYWwuanM/ZjE2ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IE1vZGFsIGZyb20gJ3JlYWN0LW1vZGFsJztcblxuY29uc3QgT3B0aW9uTW9kYWwgPSAocHJvcHMpID0+IChcbiAgPE1vZGFsXG4gICAgaXNPcGVuPXshIXByb3BzLnNlbGVjdGVkT3B0aW9ufVxuICAgIG9uUmVxdWVzdENsb3NlPXtwcm9wcy5oYW5kbGVEZWxldGVNb2RhbH1cbiAgICBhcmlhSGlkZUFwcD17ZmFsc2V9XG4gICAgY29udGVudExhYmVsPVwiU2VsZWN0ZWQgT3B0aW9uXCJcbiAgICBjbG9zZVRpbWVvdXRNUz17MjAwfVxuICAgIGNsYXNzTmFtZT1cIm1vZGFsXCJcbiAgPlxuICAgIDxoMyBjbGFzc05hbWU9XCJtb2RhbF9fdGl0bGVcIj5TZWxlY3RlZCBPcHRpb248L2gzPlxuICAgIHsgcHJvcHMuc2VsZWN0ZWRPcHRpb24gJiYgPHAgY2xhc3NOYW1lPVwibW9kYWxfX2JvZHlcIj57cHJvcHMuc2VsZWN0ZWRPcHRpb259PC9wPiB9XG4gICAgPGJ1dHRvbiBjbGFzc05hbWU9XCJidXR0b25cIiBvbkNsaWNrPXtwcm9wcy5oYW5kbGVEZWxldGVNb2RhbH0+T2theTwvYnV0dG9uPlxuICA8L01vZGFsPlxuKVxuXG5leHBvcnQgZGVmYXVsdCBPcHRpb25Nb2RhbDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2NvbXBvbmVudHMvT3B0aW9uTW9kYWwuanMiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7Ozs7O0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVZBO0FBREE7QUFDQTtBQWNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///40\n");

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Modal = __webpack_require__(42);\n\nvar _Modal2 = _interopRequireDefault(_Modal);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = _Modal2.default;\nmodule.exports = exports[\"default\"];//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtbW9kYWwvbGliL2luZGV4LmpzP2IxNmQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfTW9kYWwgPSByZXF1aXJlKFwiLi9jb21wb25lbnRzL01vZGFsXCIpO1xuXG52YXIgX01vZGFsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01vZGFsKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gX01vZGFsMi5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1tb2RhbC9saWIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///41\n");

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.bodyOpenClassName = exports.portalClassName = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _react = __webpack_require__(1);\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _reactDom = __webpack_require__(9);\n\nvar _reactDom2 = _interopRequireDefault(_reactDom);\n\nvar _propTypes = __webpack_require__(16);\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _ModalPortal = __webpack_require__(45);\n\nvar _ModalPortal2 = _interopRequireDefault(_ModalPortal);\n\nvar _ariaAppHider = __webpack_require__(18);\n\nvar ariaAppHider = _interopRequireWildcard(_ariaAppHider);\n\nvar _safeHTMLElement = __webpack_require__(20);\n\nvar _safeHTMLElement2 = _interopRequireDefault(_safeHTMLElement);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar portalClassName = exports.portalClassName = \"ReactModalPortal\";\nvar bodyOpenClassName = exports.bodyOpenClassName = \"ReactModal__Body--open\";\n\nvar isReact16 = _reactDom2.default.createPortal !== undefined;\nvar createPortal = isReact16 ? _reactDom2.default.createPortal : _reactDom2.default.unstable_renderSubtreeIntoContainer;\n\nfunction getParentElement(parentSelector) {\n  return parentSelector();\n}\n\nvar Modal = function (_Component) {\n  _inherits(Modal, _Component);\n\n  function Modal() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, Modal);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Modal.__proto__ || Object.getPrototypeOf(Modal)).call.apply(_ref, [this].concat(args))), _this), _this.removePortal = function () {\n      !isReact16 && _reactDom2.default.unmountComponentAtNode(_this.node);\n      var parent = getParentElement(_this.props.parentSelector);\n      parent.removeChild(_this.node);\n    }, _this.portalRef = function (ref) {\n      _this.portal = ref;\n    }, _this.renderPortal = function (props) {\n      var portal = createPortal(_this, _react2.default.createElement(_ModalPortal2.default, _extends({ defaultStyles: Modal.defaultStyles }, props)), _this.node);\n      _this.portalRef(portal);\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  _createClass(Modal, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      if (!_safeHTMLElement.canUseDOM) return;\n\n      if (!isReact16) {\n        this.node = document.createElement(\"div\");\n      }\n      this.node.className = this.props.portalClassName;\n\n      var parent = getParentElement(this.props.parentSelector);\n      parent.appendChild(this.node);\n\n      !isReact16 && this.renderPortal(this.props);\n    }\n  }, {\n    key: \"componentWillReceiveProps\",\n    value: function componentWillReceiveProps(newProps) {\n      if (!_safeHTMLElement.canUseDOM) return;\n      var isOpen = newProps.isOpen;\n      // Stop unnecessary renders if modal is remaining closed\n\n      if (!this.props.isOpen && !isOpen) return;\n\n      var currentParent = getParentElement(this.props.parentSelector);\n      var newParent = getParentElement(newProps.parentSelector);\n\n      if (newParent !== currentParent) {\n        currentParent.removeChild(this.node);\n        newParent.appendChild(this.node);\n      }\n\n      !isReact16 && this.renderPortal(newProps);\n    }\n  }, {\n    key: \"componentWillUpdate\",\n    value: function componentWillUpdate(newProps) {\n      if (!_safeHTMLElement.canUseDOM) return;\n      if (newProps.portalClassName !== this.props.portalClassName) {\n        this.node.className = newProps.portalClassName;\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (!_safeHTMLElement.canUseDOM || !this.node || !this.portal) return;\n\n      var state = this.portal.state;\n      var now = Date.now();\n      var closesAt = state.isOpen && this.props.closeTimeoutMS && (state.closesAt || now + this.props.closeTimeoutMS);\n\n      if (closesAt) {\n        if (!state.beforeClose) {\n          this.portal.closeWithTimeout();\n        }\n\n        setTimeout(this.removePortal, closesAt - now);\n      } else {\n        this.removePortal();\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      if (!_safeHTMLElement.canUseDOM || !isReact16) {\n        return null;\n      }\n\n      if (!this.node && isReact16) {\n        this.node = document.createElement(\"div\");\n      }\n\n      return createPortal(_react2.default.createElement(_ModalPortal2.default, _extends({\n        ref: this.portalRef,\n        defaultStyles: Modal.defaultStyles\n      }, this.props)), this.node);\n    }\n  }], [{\n    key: \"setAppElement\",\n    value: function setAppElement(element) {\n      ariaAppHider.setElement(element);\n    }\n\n    /* eslint-disable react/no-unused-prop-types */\n\n    /* eslint-enable react/no-unused-prop-types */\n\n  }]);\n\n  return Modal;\n}(_react.Component);\n\nModal.propTypes = {\n  isOpen: _propTypes2.default.bool.isRequired,\n  style: _propTypes2.default.shape({\n    content: _propTypes2.default.object,\n    overlay: _propTypes2.default.object\n  }),\n  portalClassName: _propTypes2.default.string,\n  bodyOpenClassName: _propTypes2.default.string,\n  className: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.shape({\n    base: _propTypes2.default.string.isRequired,\n    afterOpen: _propTypes2.default.string.isRequired,\n    beforeClose: _propTypes2.default.string.isRequired\n  })]),\n  overlayClassName: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.shape({\n    base: _propTypes2.default.string.isRequired,\n    afterOpen: _propTypes2.default.string.isRequired,\n    beforeClose: _propTypes2.default.string.isRequired\n  })]),\n  appElement: _propTypes2.default.instanceOf(_safeHTMLElement2.default),\n  onAfterOpen: _propTypes2.default.func,\n  onRequestClose: _propTypes2.default.func,\n  closeTimeoutMS: _propTypes2.default.number,\n  ariaHideApp: _propTypes2.default.bool,\n  shouldFocusAfterRender: _propTypes2.default.bool,\n  shouldCloseOnOverlayClick: _propTypes2.default.bool,\n  shouldReturnFocusAfterClose: _propTypes2.default.bool,\n  parentSelector: _propTypes2.default.func,\n  aria: _propTypes2.default.object,\n  role: _propTypes2.default.string,\n  contentLabel: _propTypes2.default.string,\n  shouldCloseOnEsc: _propTypes2.default.bool\n};\nModal.defaultProps = {\n  isOpen: false,\n  portalClassName: portalClassName,\n  bodyOpenClassName: bodyOpenClassName,\n  ariaHideApp: true,\n  closeTimeoutMS: 0,\n  shouldFocusAfterRender: true,\n  shouldCloseOnEsc: true,\n  shouldCloseOnOverlayClick: true,\n  shouldReturnFocusAfterClose: true,\n  parentSelector: function parentSelector() {\n    return document.body;\n  }\n};\nModal.defaultStyles = {\n  overlay: {\n    position: \"fixed\",\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0,\n    backgroundColor: \"rgba(255, 255, 255, 0.75)\"\n  },\n  content: {\n    position: \"absolute\",\n    top: \"40px\",\n    left: \"40px\",\n    right: \"40px\",\n    bottom: \"40px\",\n    border: \"1px solid #ccc\",\n    background: \"#fff\",\n    overflow: \"auto\",\n    WebkitOverflowScrolling: \"touch\",\n    borderRadius: \"4px\",\n    outline: \"none\",\n    padding: \"20px\"\n  }\n};\nexports.default = Modal;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtbW9kYWwvbGliL2NvbXBvbmVudHMvTW9kYWwuanM/YTdiOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuYm9keU9wZW5DbGFzc05hbWUgPSBleHBvcnRzLnBvcnRhbENsYXNzTmFtZSA9IHVuZGVmaW5lZDtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfcmVhY3REb20gPSByZXF1aXJlKFwicmVhY3QtZG9tXCIpO1xuXG52YXIgX3JlYWN0RG9tMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0RG9tKTtcblxudmFyIF9wcm9wVHlwZXMgPSByZXF1aXJlKFwicHJvcC10eXBlc1wiKTtcblxudmFyIF9wcm9wVHlwZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcHJvcFR5cGVzKTtcblxudmFyIF9Nb2RhbFBvcnRhbCA9IHJlcXVpcmUoXCIuL01vZGFsUG9ydGFsXCIpO1xuXG52YXIgX01vZGFsUG9ydGFsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01vZGFsUG9ydGFsKTtcblxudmFyIF9hcmlhQXBwSGlkZXIgPSByZXF1aXJlKFwiLi4vaGVscGVycy9hcmlhQXBwSGlkZXJcIik7XG5cbnZhciBhcmlhQXBwSGlkZXIgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfYXJpYUFwcEhpZGVyKTtcblxudmFyIF9zYWZlSFRNTEVsZW1lbnQgPSByZXF1aXJlKFwiLi4vaGVscGVycy9zYWZlSFRNTEVsZW1lbnRcIik7XG5cbnZhciBfc2FmZUhUTUxFbGVtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NhZmVIVE1MRWxlbWVudCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIHBvcnRhbENsYXNzTmFtZSA9IGV4cG9ydHMucG9ydGFsQ2xhc3NOYW1lID0gXCJSZWFjdE1vZGFsUG9ydGFsXCI7XG52YXIgYm9keU9wZW5DbGFzc05hbWUgPSBleHBvcnRzLmJvZHlPcGVuQ2xhc3NOYW1lID0gXCJSZWFjdE1vZGFsX19Cb2R5LS1vcGVuXCI7XG5cbnZhciBpc1JlYWN0MTYgPSBfcmVhY3REb20yLmRlZmF1bHQuY3JlYXRlUG9ydGFsICE9PSB1bmRlZmluZWQ7XG52YXIgY3JlYXRlUG9ydGFsID0gaXNSZWFjdDE2ID8gX3JlYWN0RG9tMi5kZWZhdWx0LmNyZWF0ZVBvcnRhbCA6IF9yZWFjdERvbTIuZGVmYXVsdC51bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjtcblxuZnVuY3Rpb24gZ2V0UGFyZW50RWxlbWVudChwYXJlbnRTZWxlY3Rvcikge1xuICByZXR1cm4gcGFyZW50U2VsZWN0b3IoKTtcbn1cblxudmFyIE1vZGFsID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgX2luaGVyaXRzKE1vZGFsLCBfQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBNb2RhbCgpIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTW9kYWwpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoX3JlZiA9IE1vZGFsLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTW9kYWwpKS5jYWxsLmFwcGx5KF9yZWYsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy5yZW1vdmVQb3J0YWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAhaXNSZWFjdDE2ICYmIF9yZWFjdERvbTIuZGVmYXVsdC51bm1vdW50Q29tcG9uZW50QXROb2RlKF90aGlzLm5vZGUpO1xuICAgICAgdmFyIHBhcmVudCA9IGdldFBhcmVudEVsZW1lbnQoX3RoaXMucHJvcHMucGFyZW50U2VsZWN0b3IpO1xuICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKF90aGlzLm5vZGUpO1xuICAgIH0sIF90aGlzLnBvcnRhbFJlZiA9IGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgIF90aGlzLnBvcnRhbCA9IHJlZjtcbiAgICB9LCBfdGhpcy5yZW5kZXJQb3J0YWwgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICAgIHZhciBwb3J0YWwgPSBjcmVhdGVQb3J0YWwoX3RoaXMsIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9Nb2RhbFBvcnRhbDIuZGVmYXVsdCwgX2V4dGVuZHMoeyBkZWZhdWx0U3R5bGVzOiBNb2RhbC5kZWZhdWx0U3R5bGVzIH0sIHByb3BzKSksIF90aGlzLm5vZGUpO1xuICAgICAgX3RoaXMucG9ydGFsUmVmKHBvcnRhbCk7XG4gICAgfSwgX3RlbXApLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTW9kYWwsIFt7XG4gICAga2V5OiBcImNvbXBvbmVudERpZE1vdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgaWYgKCFfc2FmZUhUTUxFbGVtZW50LmNhblVzZURPTSkgcmV0dXJuO1xuXG4gICAgICBpZiAoIWlzUmVhY3QxNikge1xuICAgICAgICB0aGlzLm5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5ub2RlLmNsYXNzTmFtZSA9IHRoaXMucHJvcHMucG9ydGFsQ2xhc3NOYW1lO1xuXG4gICAgICB2YXIgcGFyZW50ID0gZ2V0UGFyZW50RWxlbWVudCh0aGlzLnByb3BzLnBhcmVudFNlbGVjdG9yKTtcbiAgICAgIHBhcmVudC5hcHBlbmRDaGlsZCh0aGlzLm5vZGUpO1xuXG4gICAgICAhaXNSZWFjdDE2ICYmIHRoaXMucmVuZGVyUG9ydGFsKHRoaXMucHJvcHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV3UHJvcHMpIHtcbiAgICAgIGlmICghX3NhZmVIVE1MRWxlbWVudC5jYW5Vc2VET00pIHJldHVybjtcbiAgICAgIHZhciBpc09wZW4gPSBuZXdQcm9wcy5pc09wZW47XG4gICAgICAvLyBTdG9wIHVubmVjZXNzYXJ5IHJlbmRlcnMgaWYgbW9kYWwgaXMgcmVtYWluaW5nIGNsb3NlZFxuXG4gICAgICBpZiAoIXRoaXMucHJvcHMuaXNPcGVuICYmICFpc09wZW4pIHJldHVybjtcblxuICAgICAgdmFyIGN1cnJlbnRQYXJlbnQgPSBnZXRQYXJlbnRFbGVtZW50KHRoaXMucHJvcHMucGFyZW50U2VsZWN0b3IpO1xuICAgICAgdmFyIG5ld1BhcmVudCA9IGdldFBhcmVudEVsZW1lbnQobmV3UHJvcHMucGFyZW50U2VsZWN0b3IpO1xuXG4gICAgICBpZiAobmV3UGFyZW50ICE9PSBjdXJyZW50UGFyZW50KSB7XG4gICAgICAgIGN1cnJlbnRQYXJlbnQucmVtb3ZlQ2hpbGQodGhpcy5ub2RlKTtcbiAgICAgICAgbmV3UGFyZW50LmFwcGVuZENoaWxkKHRoaXMubm9kZSk7XG4gICAgICB9XG5cbiAgICAgICFpc1JlYWN0MTYgJiYgdGhpcy5yZW5kZXJQb3J0YWwobmV3UHJvcHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wb25lbnRXaWxsVXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVcGRhdGUobmV3UHJvcHMpIHtcbiAgICAgIGlmICghX3NhZmVIVE1MRWxlbWVudC5jYW5Vc2VET00pIHJldHVybjtcbiAgICAgIGlmIChuZXdQcm9wcy5wb3J0YWxDbGFzc05hbWUgIT09IHRoaXMucHJvcHMucG9ydGFsQ2xhc3NOYW1lKSB7XG4gICAgICAgIHRoaXMubm9kZS5jbGFzc05hbWUgPSBuZXdQcm9wcy5wb3J0YWxDbGFzc05hbWU7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXBvbmVudFdpbGxVbm1vdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgaWYgKCFfc2FmZUhUTUxFbGVtZW50LmNhblVzZURPTSB8fCAhdGhpcy5ub2RlIHx8ICF0aGlzLnBvcnRhbCkgcmV0dXJuO1xuXG4gICAgICB2YXIgc3RhdGUgPSB0aGlzLnBvcnRhbC5zdGF0ZTtcbiAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgdmFyIGNsb3Nlc0F0ID0gc3RhdGUuaXNPcGVuICYmIHRoaXMucHJvcHMuY2xvc2VUaW1lb3V0TVMgJiYgKHN0YXRlLmNsb3Nlc0F0IHx8IG5vdyArIHRoaXMucHJvcHMuY2xvc2VUaW1lb3V0TVMpO1xuXG4gICAgICBpZiAoY2xvc2VzQXQpIHtcbiAgICAgICAgaWYgKCFzdGF0ZS5iZWZvcmVDbG9zZSkge1xuICAgICAgICAgIHRoaXMucG9ydGFsLmNsb3NlV2l0aFRpbWVvdXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldFRpbWVvdXQodGhpcy5yZW1vdmVQb3J0YWwsIGNsb3Nlc0F0IC0gbm93KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVtb3ZlUG9ydGFsKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICBpZiAoIV9zYWZlSFRNTEVsZW1lbnQuY2FuVXNlRE9NIHx8ICFpc1JlYWN0MTYpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5ub2RlICYmIGlzUmVhY3QxNikge1xuICAgICAgICB0aGlzLm5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY3JlYXRlUG9ydGFsKF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9Nb2RhbFBvcnRhbDIuZGVmYXVsdCwgX2V4dGVuZHMoe1xuICAgICAgICByZWY6IHRoaXMucG9ydGFsUmVmLFxuICAgICAgICBkZWZhdWx0U3R5bGVzOiBNb2RhbC5kZWZhdWx0U3R5bGVzXG4gICAgICB9LCB0aGlzLnByb3BzKSksIHRoaXMubm9kZSk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwic2V0QXBwRWxlbWVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRBcHBFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgIGFyaWFBcHBIaWRlci5zZXRFbGVtZW50KGVsZW1lbnQpO1xuICAgIH1cblxuICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0L25vLXVudXNlZC1wcm9wLXR5cGVzICovXG5cbiAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0L25vLXVudXNlZC1wcm9wLXR5cGVzICovXG5cbiAgfV0pO1xuXG4gIHJldHVybiBNb2RhbDtcbn0oX3JlYWN0LkNvbXBvbmVudCk7XG5cbk1vZGFsLnByb3BUeXBlcyA9IHtcbiAgaXNPcGVuOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmJvb2wuaXNSZXF1aXJlZCxcbiAgc3R5bGU6IF9wcm9wVHlwZXMyLmRlZmF1bHQuc2hhcGUoe1xuICAgIGNvbnRlbnQ6IF9wcm9wVHlwZXMyLmRlZmF1bHQub2JqZWN0LFxuICAgIG92ZXJsYXk6IF9wcm9wVHlwZXMyLmRlZmF1bHQub2JqZWN0XG4gIH0pLFxuICBwb3J0YWxDbGFzc05hbWU6IF9wcm9wVHlwZXMyLmRlZmF1bHQuc3RyaW5nLFxuICBib2R5T3BlbkNsYXNzTmFtZTogX3Byb3BUeXBlczIuZGVmYXVsdC5zdHJpbmcsXG4gIGNsYXNzTmFtZTogX3Byb3BUeXBlczIuZGVmYXVsdC5vbmVPZlR5cGUoW19wcm9wVHlwZXMyLmRlZmF1bHQuc3RyaW5nLCBfcHJvcFR5cGVzMi5kZWZhdWx0LnNoYXBlKHtcbiAgICBiYXNlOiBfcHJvcFR5cGVzMi5kZWZhdWx0LnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIGFmdGVyT3BlbjogX3Byb3BUeXBlczIuZGVmYXVsdC5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICBiZWZvcmVDbG9zZTogX3Byb3BUeXBlczIuZGVmYXVsdC5zdHJpbmcuaXNSZXF1aXJlZFxuICB9KV0pLFxuICBvdmVybGF5Q2xhc3NOYW1lOiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9uZU9mVHlwZShbX3Byb3BUeXBlczIuZGVmYXVsdC5zdHJpbmcsIF9wcm9wVHlwZXMyLmRlZmF1bHQuc2hhcGUoe1xuICAgIGJhc2U6IF9wcm9wVHlwZXMyLmRlZmF1bHQuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgYWZ0ZXJPcGVuOiBfcHJvcFR5cGVzMi5kZWZhdWx0LnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIGJlZm9yZUNsb3NlOiBfcHJvcFR5cGVzMi5kZWZhdWx0LnN0cmluZy5pc1JlcXVpcmVkXG4gIH0pXSksXG4gIGFwcEVsZW1lbnQ6IF9wcm9wVHlwZXMyLmRlZmF1bHQuaW5zdGFuY2VPZihfc2FmZUhUTUxFbGVtZW50Mi5kZWZhdWx0KSxcbiAgb25BZnRlck9wZW46IF9wcm9wVHlwZXMyLmRlZmF1bHQuZnVuYyxcbiAgb25SZXF1ZXN0Q2xvc2U6IF9wcm9wVHlwZXMyLmRlZmF1bHQuZnVuYyxcbiAgY2xvc2VUaW1lb3V0TVM6IF9wcm9wVHlwZXMyLmRlZmF1bHQubnVtYmVyLFxuICBhcmlhSGlkZUFwcDogX3Byb3BUeXBlczIuZGVmYXVsdC5ib29sLFxuICBzaG91bGRGb2N1c0FmdGVyUmVuZGVyOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmJvb2wsXG4gIHNob3VsZENsb3NlT25PdmVybGF5Q2xpY2s6IF9wcm9wVHlwZXMyLmRlZmF1bHQuYm9vbCxcbiAgc2hvdWxkUmV0dXJuRm9jdXNBZnRlckNsb3NlOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmJvb2wsXG4gIHBhcmVudFNlbGVjdG9yOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmZ1bmMsXG4gIGFyaWE6IF9wcm9wVHlwZXMyLmRlZmF1bHQub2JqZWN0LFxuICByb2xlOiBfcHJvcFR5cGVzMi5kZWZhdWx0LnN0cmluZyxcbiAgY29udGVudExhYmVsOiBfcHJvcFR5cGVzMi5kZWZhdWx0LnN0cmluZyxcbiAgc2hvdWxkQ2xvc2VPbkVzYzogX3Byb3BUeXBlczIuZGVmYXVsdC5ib29sXG59O1xuTW9kYWwuZGVmYXVsdFByb3BzID0ge1xuICBpc09wZW46IGZhbHNlLFxuICBwb3J0YWxDbGFzc05hbWU6IHBvcnRhbENsYXNzTmFtZSxcbiAgYm9keU9wZW5DbGFzc05hbWU6IGJvZHlPcGVuQ2xhc3NOYW1lLFxuICBhcmlhSGlkZUFwcDogdHJ1ZSxcbiAgY2xvc2VUaW1lb3V0TVM6IDAsXG4gIHNob3VsZEZvY3VzQWZ0ZXJSZW5kZXI6IHRydWUsXG4gIHNob3VsZENsb3NlT25Fc2M6IHRydWUsXG4gIHNob3VsZENsb3NlT25PdmVybGF5Q2xpY2s6IHRydWUsXG4gIHNob3VsZFJldHVybkZvY3VzQWZ0ZXJDbG9zZTogdHJ1ZSxcbiAgcGFyZW50U2VsZWN0b3I6IGZ1bmN0aW9uIHBhcmVudFNlbGVjdG9yKCkge1xuICAgIHJldHVybiBkb2N1bWVudC5ib2R5O1xuICB9XG59O1xuTW9kYWwuZGVmYXVsdFN0eWxlcyA9IHtcbiAgb3ZlcmxheToge1xuICAgIHBvc2l0aW9uOiBcImZpeGVkXCIsXG4gICAgdG9wOiAwLFxuICAgIGxlZnQ6IDAsXG4gICAgcmlnaHQ6IDAsXG4gICAgYm90dG9tOiAwLFxuICAgIGJhY2tncm91bmRDb2xvcjogXCJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNzUpXCJcbiAgfSxcbiAgY29udGVudDoge1xuICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgdG9wOiBcIjQwcHhcIixcbiAgICBsZWZ0OiBcIjQwcHhcIixcbiAgICByaWdodDogXCI0MHB4XCIsXG4gICAgYm90dG9tOiBcIjQwcHhcIixcbiAgICBib3JkZXI6IFwiMXB4IHNvbGlkICNjY2NcIixcbiAgICBiYWNrZ3JvdW5kOiBcIiNmZmZcIixcbiAgICBvdmVyZmxvdzogXCJhdXRvXCIsXG4gICAgV2Via2l0T3ZlcmZsb3dTY3JvbGxpbmc6IFwidG91Y2hcIixcbiAgICBib3JkZXJSYWRpdXM6IFwiNHB4XCIsXG4gICAgb3V0bGluZTogXCJub25lXCIsXG4gICAgcGFkZGluZzogXCIyMHB4XCJcbiAgfVxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IE1vZGFsO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LW1vZGFsL2xpYi9jb21wb25lbnRzL01vZGFsLmpzXG4vLyBtb2R1bGUgaWQgPSA0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///42\n");

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar emptyFunction = __webpack_require__(2);\nvar invariant = __webpack_require__(4);\nvar warning = __webpack_require__(6);\nvar assign = __webpack_require__(3);\n\nvar ReactPropTypesSecret = __webpack_require__(8);\nvar checkPropTypes = __webpack_require__(7);\n\nmodule.exports = function(isValidElement, throwOnDirectAccess) {\n  /* global Symbol */\n  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.\n\n  /**\n   * Returns the iterator method function contained on the iterable object.\n   *\n   * Be sure to invoke the function with the iterable as context:\n   *\n   *     var iteratorFn = getIteratorFn(myIterable);\n   *     if (iteratorFn) {\n   *       var iterator = iteratorFn.call(myIterable);\n   *       ...\n   *     }\n   *\n   * @param {?object} maybeIterable\n   * @return {?function}\n   */\n  function getIteratorFn(maybeIterable) {\n    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);\n    if (typeof iteratorFn === 'function') {\n      return iteratorFn;\n    }\n  }\n\n  /**\n   * Collection of methods that allow declaration and validation of props that are\n   * supplied to React components. Example usage:\n   *\n   *   var Props = require('ReactPropTypes');\n   *   var MyArticle = React.createClass({\n   *     propTypes: {\n   *       // An optional string prop named \"description\".\n   *       description: Props.string,\n   *\n   *       // A required enum prop named \"category\".\n   *       category: Props.oneOf(['News','Photos']).isRequired,\n   *\n   *       // A prop named \"dialog\" that requires an instance of Dialog.\n   *       dialog: Props.instanceOf(Dialog).isRequired\n   *     },\n   *     render: function() { ... }\n   *   });\n   *\n   * A more formal specification of how these methods are used:\n   *\n   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)\n   *   decl := ReactPropTypes.{type}(.isRequired)?\n   *\n   * Each and every declaration produces a function with the same signature. This\n   * allows the creation of custom validation functions. For example:\n   *\n   *  var MyLink = React.createClass({\n   *    propTypes: {\n   *      // An optional string or URI prop named \"href\".\n   *      href: function(props, propName, componentName) {\n   *        var propValue = props[propName];\n   *        if (propValue != null && typeof propValue !== 'string' &&\n   *            !(propValue instanceof URI)) {\n   *          return new Error(\n   *            'Expected a string or an URI for ' + propName + ' in ' +\n   *            componentName\n   *          );\n   *        }\n   *      }\n   *    },\n   *    render: function() {...}\n   *  });\n   *\n   * @internal\n   */\n\n  var ANONYMOUS = '<<anonymous>>';\n\n  // Important!\n  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.\n  var ReactPropTypes = {\n    array: createPrimitiveTypeChecker('array'),\n    bool: createPrimitiveTypeChecker('boolean'),\n    func: createPrimitiveTypeChecker('function'),\n    number: createPrimitiveTypeChecker('number'),\n    object: createPrimitiveTypeChecker('object'),\n    string: createPrimitiveTypeChecker('string'),\n    symbol: createPrimitiveTypeChecker('symbol'),\n\n    any: createAnyTypeChecker(),\n    arrayOf: createArrayOfTypeChecker,\n    element: createElementTypeChecker(),\n    instanceOf: createInstanceTypeChecker,\n    node: createNodeChecker(),\n    objectOf: createObjectOfTypeChecker,\n    oneOf: createEnumTypeChecker,\n    oneOfType: createUnionTypeChecker,\n    shape: createShapeTypeChecker,\n    exact: createStrictShapeTypeChecker,\n  };\n\n  /**\n   * inlined Object.is polyfill to avoid requiring consumers ship their own\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n   */\n  /*eslint-disable no-self-compare*/\n  function is(x, y) {\n    // SameValue algorithm\n    if (x === y) {\n      // Steps 1-5, 7-10\n      // Steps 6.b-6.e: +0 != -0\n      return x !== 0 || 1 / x === 1 / y;\n    } else {\n      // Step 6.a: NaN == NaN\n      return x !== x && y !== y;\n    }\n  }\n  /*eslint-enable no-self-compare*/\n\n  /**\n   * We use an Error-like object for backward compatibility as people may call\n   * PropTypes directly and inspect their output. However, we don't use real\n   * Errors anymore. We don't inspect their stack anyway, and creating them\n   * is prohibitively expensive if they are created too often, such as what\n   * happens in oneOfType() for any type before the one that matched.\n   */\n  function PropTypeError(message) {\n    this.message = message;\n    this.stack = '';\n  }\n  // Make `instanceof Error` still work for returned errors.\n  PropTypeError.prototype = Error.prototype;\n\n  function createChainableTypeChecker(validate) {\n    if (process.env.NODE_ENV !== 'production') {\n      var manualPropTypeCallCache = {};\n      var manualPropTypeWarningCount = 0;\n    }\n    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {\n      componentName = componentName || ANONYMOUS;\n      propFullName = propFullName || propName;\n\n      if (secret !== ReactPropTypesSecret) {\n        if (throwOnDirectAccess) {\n          // New behavior only for users of `prop-types` package\n          invariant(\n            false,\n            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +\n            'Use `PropTypes.checkPropTypes()` to call them. ' +\n            'Read more at http://fb.me/use-check-prop-types'\n          );\n        } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {\n          // Old behavior for people using React.PropTypes\n          var cacheKey = componentName + ':' + propName;\n          if (\n            !manualPropTypeCallCache[cacheKey] &&\n            // Avoid spamming the console because they are often not actionable except for lib authors\n            manualPropTypeWarningCount < 3\n          ) {\n            warning(\n              false,\n              'You are manually calling a React.PropTypes validation ' +\n              'function for the `%s` prop on `%s`. This is deprecated ' +\n              'and will throw in the standalone `prop-types` package. ' +\n              'You may be seeing this warning due to a third-party PropTypes ' +\n              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.',\n              propFullName,\n              componentName\n            );\n            manualPropTypeCallCache[cacheKey] = true;\n            manualPropTypeWarningCount++;\n          }\n        }\n      }\n      if (props[propName] == null) {\n        if (isRequired) {\n          if (props[propName] === null) {\n            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));\n          }\n          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));\n        }\n        return null;\n      } else {\n        return validate(props, propName, componentName, location, propFullName);\n      }\n    }\n\n    var chainedCheckType = checkType.bind(null, false);\n    chainedCheckType.isRequired = checkType.bind(null, true);\n\n    return chainedCheckType;\n  }\n\n  function createPrimitiveTypeChecker(expectedType) {\n    function validate(props, propName, componentName, location, propFullName, secret) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== expectedType) {\n        // `propValue` being instance of, say, date/regexp, pass the 'object'\n        // check, but we can offer a more precise error message here rather than\n        // 'of type `object`'.\n        var preciseType = getPreciseType(propValue);\n\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createAnyTypeChecker() {\n    return createChainableTypeChecker(emptyFunction.thatReturnsNull);\n  }\n\n  function createArrayOfTypeChecker(typeChecker) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (typeof typeChecker !== 'function') {\n        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');\n      }\n      var propValue = props[propName];\n      if (!Array.isArray(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));\n      }\n      for (var i = 0; i < propValue.length; i++) {\n        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);\n        if (error instanceof Error) {\n          return error;\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createElementTypeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      if (!isValidElement(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createInstanceTypeChecker(expectedClass) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (!(props[propName] instanceof expectedClass)) {\n        var expectedClassName = expectedClass.name || ANONYMOUS;\n        var actualClassName = getClassName(props[propName]);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createEnumTypeChecker(expectedValues) {\n    if (!Array.isArray(expectedValues)) {\n      process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;\n      return emptyFunction.thatReturnsNull;\n    }\n\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      for (var i = 0; i < expectedValues.length; i++) {\n        if (is(propValue, expectedValues[i])) {\n          return null;\n        }\n      }\n\n      var valuesString = JSON.stringify(expectedValues);\n      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createObjectOfTypeChecker(typeChecker) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (typeof typeChecker !== 'function') {\n        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');\n      }\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));\n      }\n      for (var key in propValue) {\n        if (propValue.hasOwnProperty(key)) {\n          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n          if (error instanceof Error) {\n            return error;\n          }\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createUnionTypeChecker(arrayOfTypeCheckers) {\n    if (!Array.isArray(arrayOfTypeCheckers)) {\n      process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;\n      return emptyFunction.thatReturnsNull;\n    }\n\n    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n      var checker = arrayOfTypeCheckers[i];\n      if (typeof checker !== 'function') {\n        warning(\n          false,\n          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +\n          'received %s at index %s.',\n          getPostfixForTypeWarning(checker),\n          i\n        );\n        return emptyFunction.thatReturnsNull;\n      }\n    }\n\n    function validate(props, propName, componentName, location, propFullName) {\n      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n        var checker = arrayOfTypeCheckers[i];\n        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {\n          return null;\n        }\n      }\n\n      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createNodeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (!isNode(props[propName])) {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createShapeTypeChecker(shapeTypes) {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n      }\n      for (var key in shapeTypes) {\n        var checker = shapeTypes[key];\n        if (!checker) {\n          continue;\n        }\n        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n        if (error) {\n          return error;\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createStrictShapeTypeChecker(shapeTypes) {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n      }\n      // We need to check all keys in case some are required but missing from\n      // props.\n      var allKeys = assign({}, props[propName], shapeTypes);\n      for (var key in allKeys) {\n        var checker = shapeTypes[key];\n        if (!checker) {\n          return new PropTypeError(\n            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +\n            '\\nBad object: ' + JSON.stringify(props[propName], null, '  ') +\n            '\\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')\n          );\n        }\n        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n        if (error) {\n          return error;\n        }\n      }\n      return null;\n    }\n\n    return createChainableTypeChecker(validate);\n  }\n\n  function isNode(propValue) {\n    switch (typeof propValue) {\n      case 'number':\n      case 'string':\n      case 'undefined':\n        return true;\n      case 'boolean':\n        return !propValue;\n      case 'object':\n        if (Array.isArray(propValue)) {\n          return propValue.every(isNode);\n        }\n        if (propValue === null || isValidElement(propValue)) {\n          return true;\n        }\n\n        var iteratorFn = getIteratorFn(propValue);\n        if (iteratorFn) {\n          var iterator = iteratorFn.call(propValue);\n          var step;\n          if (iteratorFn !== propValue.entries) {\n            while (!(step = iterator.next()).done) {\n              if (!isNode(step.value)) {\n                return false;\n              }\n            }\n          } else {\n            // Iterator will provide entry [k,v] tuples rather than values.\n            while (!(step = iterator.next()).done) {\n              var entry = step.value;\n              if (entry) {\n                if (!isNode(entry[1])) {\n                  return false;\n                }\n              }\n            }\n          }\n        } else {\n          return false;\n        }\n\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  function isSymbol(propType, propValue) {\n    // Native Symbol.\n    if (propType === 'symbol') {\n      return true;\n    }\n\n    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\n    if (propValue['@@toStringTag'] === 'Symbol') {\n      return true;\n    }\n\n    // Fallback for non-spec compliant Symbols which are polyfilled.\n    if (typeof Symbol === 'function' && propValue instanceof Symbol) {\n      return true;\n    }\n\n    return false;\n  }\n\n  // Equivalent of `typeof` but with special handling for array and regexp.\n  function getPropType(propValue) {\n    var propType = typeof propValue;\n    if (Array.isArray(propValue)) {\n      return 'array';\n    }\n    if (propValue instanceof RegExp) {\n      // Old webkits (at least until Android 4.0) return 'function' rather than\n      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\n      // passes PropTypes.object.\n      return 'object';\n    }\n    if (isSymbol(propType, propValue)) {\n      return 'symbol';\n    }\n    return propType;\n  }\n\n  // This handles more types than `getPropType`. Only used for error messages.\n  // See `createPrimitiveTypeChecker`.\n  function getPreciseType(propValue) {\n    if (typeof propValue === 'undefined' || propValue === null) {\n      return '' + propValue;\n    }\n    var propType = getPropType(propValue);\n    if (propType === 'object') {\n      if (propValue instanceof Date) {\n        return 'date';\n      } else if (propValue instanceof RegExp) {\n        return 'regexp';\n      }\n    }\n    return propType;\n  }\n\n  // Returns a string that is postfixed to a warning about an invalid type.\n  // For example, \"undefined\" or \"of type array\"\n  function getPostfixForTypeWarning(value) {\n    var type = getPreciseType(value);\n    switch (type) {\n      case 'array':\n      case 'object':\n        return 'an ' + type;\n      case 'boolean':\n      case 'date':\n      case 'regexp':\n        return 'a ' + type;\n      default:\n        return type;\n    }\n  }\n\n  // Returns class name of the object, if any.\n  function getClassName(propValue) {\n    if (!propValue.constructor || !propValue.constructor.name) {\n      return ANONYMOUS;\n    }\n    return propValue.constructor.name;\n  }\n\n  ReactPropTypes.checkPropTypes = checkPropTypes;\n  ReactPropTypes.PropTypes = ReactPropTypes;\n\n  return ReactPropTypes;\n};\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qcz8yNmQ5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcbnZhciBjaGVja1Byb3BUeXBlcyA9IHJlcXVpcmUoJy4vY2hlY2tQcm9wVHlwZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpc1ZhbGlkRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAvKiBnbG9iYWwgU3ltYm9sICovXG4gIHZhciBJVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbiAgdmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InOyAvLyBCZWZvcmUgU3ltYm9sIHNwZWMuXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGl0ZXJhdG9yIG1ldGhvZCBmdW5jdGlvbiBjb250YWluZWQgb24gdGhlIGl0ZXJhYmxlIG9iamVjdC5cbiAgICpcbiAgICogQmUgc3VyZSB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGl0ZXJhYmxlIGFzIGNvbnRleHQ6XG4gICAqXG4gICAqICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obXlJdGVyYWJsZSk7XG4gICAqICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgKiAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobXlJdGVyYWJsZSk7XG4gICAqICAgICAgIC4uLlxuICAgKiAgICAgfVxuICAgKlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG1heWJlSXRlcmFibGVcbiAgICogQHJldHVybiB7P2Z1bmN0aW9ufVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBtYXliZUl0ZXJhYmxlICYmIChJVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtJVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBpdGVyYXRvckZuO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb2xsZWN0aW9uIG9mIG1ldGhvZHMgdGhhdCBhbGxvdyBkZWNsYXJhdGlvbiBhbmQgdmFsaWRhdGlvbiBvZiBwcm9wcyB0aGF0IGFyZVxuICAgKiBzdXBwbGllZCB0byBSZWFjdCBjb21wb25lbnRzLiBFeGFtcGxlIHVzYWdlOlxuICAgKlxuICAgKiAgIHZhciBQcm9wcyA9IHJlcXVpcmUoJ1JlYWN0UHJvcFR5cGVzJyk7XG4gICAqICAgdmFyIE15QXJ0aWNsZSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgcHJvcCBuYW1lZCBcImRlc2NyaXB0aW9uXCIuXG4gICAqICAgICAgIGRlc2NyaXB0aW9uOiBQcm9wcy5zdHJpbmcsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcmVxdWlyZWQgZW51bSBwcm9wIG5hbWVkIFwiY2F0ZWdvcnlcIi5cbiAgICogICAgICAgY2F0ZWdvcnk6IFByb3BzLm9uZU9mKFsnTmV3cycsJ1Bob3RvcyddKS5pc1JlcXVpcmVkLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHByb3AgbmFtZWQgXCJkaWFsb2dcIiB0aGF0IHJlcXVpcmVzIGFuIGluc3RhbmNlIG9mIERpYWxvZy5cbiAgICogICAgICAgZGlhbG9nOiBQcm9wcy5pbnN0YW5jZU9mKERpYWxvZykuaXNSZXF1aXJlZFxuICAgKiAgICAgfSxcbiAgICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7IC4uLiB9XG4gICAqICAgfSk7XG4gICAqXG4gICAqIEEgbW9yZSBmb3JtYWwgc3BlY2lmaWNhdGlvbiBvZiBob3cgdGhlc2UgbWV0aG9kcyBhcmUgdXNlZDpcbiAgICpcbiAgICogICB0eXBlIDo9IGFycmF5fGJvb2x8ZnVuY3xvYmplY3R8bnVtYmVyfHN0cmluZ3xvbmVPZihbLi4uXSl8aW5zdGFuY2VPZiguLi4pXG4gICAqICAgZGVjbCA6PSBSZWFjdFByb3BUeXBlcy57dHlwZX0oLmlzUmVxdWlyZWQpP1xuICAgKlxuICAgKiBFYWNoIGFuZCBldmVyeSBkZWNsYXJhdGlvbiBwcm9kdWNlcyBhIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgc2lnbmF0dXJlLiBUaGlzXG4gICAqIGFsbG93cyB0aGUgY3JlYXRpb24gb2YgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb25zLiBGb3IgZXhhbXBsZTpcbiAgICpcbiAgICogIHZhciBNeUxpbmsgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBvciBVUkkgcHJvcCBuYW1lZCBcImhyZWZcIi5cbiAgICogICAgICBocmVmOiBmdW5jdGlvbihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICogICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAqICAgICAgICBpZiAocHJvcFZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHByb3BWYWx1ZSAhPT0gJ3N0cmluZycgJiZcbiAgICogICAgICAgICAgICAhKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFVSSSkpIHtcbiAgICogICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICogICAgICAgICAgICAnRXhwZWN0ZWQgYSBzdHJpbmcgb3IgYW4gVVJJIGZvciAnICsgcHJvcE5hbWUgKyAnIGluICcgK1xuICAgKiAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICogICAgICAgICAgKTtcbiAgICogICAgICAgIH1cbiAgICogICAgICB9XG4gICAqICAgIH0sXG4gICAqICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7Li4ufVxuICAgKiAgfSk7XG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuICB2YXIgQU5PTllNT1VTID0gJzw8YW5vbnltb3VzPj4nO1xuXG4gIC8vIEltcG9ydGFudCFcbiAgLy8gS2VlcCB0aGlzIGxpc3QgaW4gc3luYyB3aXRoIHByb2R1Y3Rpb24gdmVyc2lvbiBpbiBgLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanNgLlxuICB2YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gICAgYXJyYXk6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdhcnJheScpLFxuICAgIGJvb2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdib29sZWFuJyksXG4gICAgZnVuYzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Z1bmN0aW9uJyksXG4gICAgbnVtYmVyOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignbnVtYmVyJyksXG4gICAgb2JqZWN0OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignb2JqZWN0JyksXG4gICAgc3RyaW5nOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3RyaW5nJyksXG4gICAgc3ltYm9sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3ltYm9sJyksXG5cbiAgICBhbnk6IGNyZWF0ZUFueVR5cGVDaGVja2VyKCksXG4gICAgYXJyYXlPZjogY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyLFxuICAgIGVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpLFxuICAgIGluc3RhbmNlT2Y6IGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIsXG4gICAgbm9kZTogY3JlYXRlTm9kZUNoZWNrZXIoKSxcbiAgICBvYmplY3RPZjogY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcixcbiAgICBvbmVPZjogY3JlYXRlRW51bVR5cGVDaGVja2VyLFxuICAgIG9uZU9mVHlwZTogY3JlYXRlVW5pb25UeXBlQ2hlY2tlcixcbiAgICBzaGFwZTogY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcixcbiAgICBleGFjdDogY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcixcbiAgfTtcblxuICAvKipcbiAgICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAgICovXG4gIC8qZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlKi9cbiAgZnVuY3Rpb24gaXMoeCwgeSkge1xuICAgIC8vIFNhbWVWYWx1ZSBhbGdvcml0aG1cbiAgICBpZiAoeCA9PT0geSkge1xuICAgICAgLy8gU3RlcHMgMS01LCA3LTEwXG4gICAgICAvLyBTdGVwcyA2LmItNi5lOiArMCAhPSAtMFxuICAgICAgcmV0dXJuIHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgICB9XG4gIH1cbiAgLyplc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSovXG5cbiAgLyoqXG4gICAqIFdlIHVzZSBhbiBFcnJvci1saWtlIG9iamVjdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBhcyBwZW9wbGUgbWF5IGNhbGxcbiAgICogUHJvcFR5cGVzIGRpcmVjdGx5IGFuZCBpbnNwZWN0IHRoZWlyIG91dHB1dC4gSG93ZXZlciwgd2UgZG9uJ3QgdXNlIHJlYWxcbiAgICogRXJyb3JzIGFueW1vcmUuIFdlIGRvbid0IGluc3BlY3QgdGhlaXIgc3RhY2sgYW55d2F5LCBhbmQgY3JlYXRpbmcgdGhlbVxuICAgKiBpcyBwcm9oaWJpdGl2ZWx5IGV4cGVuc2l2ZSBpZiB0aGV5IGFyZSBjcmVhdGVkIHRvbyBvZnRlbiwgc3VjaCBhcyB3aGF0XG4gICAqIGhhcHBlbnMgaW4gb25lT2ZUeXBlKCkgZm9yIGFueSB0eXBlIGJlZm9yZSB0aGUgb25lIHRoYXQgbWF0Y2hlZC5cbiAgICovXG4gIGZ1bmN0aW9uIFByb3BUeXBlRXJyb3IobWVzc2FnZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5zdGFjayA9ICcnO1xuICB9XG4gIC8vIE1ha2UgYGluc3RhbmNlb2YgRXJyb3JgIHN0aWxsIHdvcmsgZm9yIHJldHVybmVkIGVycm9ycy5cbiAgUHJvcFR5cGVFcnJvci5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlID0ge307XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPSAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja1R5cGUoaXNSZXF1aXJlZCwgcHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICAgIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnROYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgIHByb3BGdWxsTmFtZSA9IHByb3BGdWxsTmFtZSB8fCBwcm9wTmFtZTtcblxuICAgICAgaWYgKHNlY3JldCAhPT0gUmVhY3RQcm9wVHlwZXNTZWNyZXQpIHtcbiAgICAgICAgaWYgKHRocm93T25EaXJlY3RBY2Nlc3MpIHtcbiAgICAgICAgICAvLyBOZXcgYmVoYXZpb3Igb25seSBmb3IgdXNlcnMgb2YgYHByb3AtdHlwZXNgIHBhY2thZ2VcbiAgICAgICAgICBpbnZhcmlhbnQoXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICdVc2UgYFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpYCB0byBjYWxsIHRoZW0uICcgK1xuICAgICAgICAgICAgJ1JlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXMnXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIC8vIE9sZCBiZWhhdmlvciBmb3IgcGVvcGxlIHVzaW5nIFJlYWN0LlByb3BUeXBlc1xuICAgICAgICAgIHZhciBjYWNoZUtleSA9IGNvbXBvbmVudE5hbWUgKyAnOicgKyBwcm9wTmFtZTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldICYmXG4gICAgICAgICAgICAvLyBBdm9pZCBzcGFtbWluZyB0aGUgY29uc29sZSBiZWNhdXNlIHRoZXkgYXJlIG9mdGVuIG5vdCBhY3Rpb25hYmxlIGV4Y2VwdCBmb3IgbGliIGF1dGhvcnNcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50IDwgM1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgd2FybmluZyhcbiAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICdZb3UgYXJlIG1hbnVhbGx5IGNhbGxpbmcgYSBSZWFjdC5Qcm9wVHlwZXMgdmFsaWRhdGlvbiAnICtcbiAgICAgICAgICAgICAgJ2Z1bmN0aW9uIGZvciB0aGUgYCVzYCBwcm9wIG9uIGAlc2AuIFRoaXMgaXMgZGVwcmVjYXRlZCAnICtcbiAgICAgICAgICAgICAgJ2FuZCB3aWxsIHRocm93IGluIHRoZSBzdGFuZGFsb25lIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICAgJ1lvdSBtYXkgYmUgc2VlaW5nIHRoaXMgd2FybmluZyBkdWUgdG8gYSB0aGlyZC1wYXJ0eSBQcm9wVHlwZXMgJyArXG4gICAgICAgICAgICAgICdsaWJyYXJ5LiBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWRvbnQtY2FsbC1wcm9wdHlwZXMgJyArICdmb3IgZGV0YWlscy4nLFxuICAgICAgICAgICAgICBwcm9wRnVsbE5hbWUsXG4gICAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gPSB0cnVlO1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNSZXF1aXJlZCkge1xuICAgICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignVGhlICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgJyArICgnaW4gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYG51bGxgLicpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCBpbiAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgdW5kZWZpbmVkYC4nKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2hhaW5lZENoZWNrVHlwZSA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIGZhbHNlKTtcbiAgICBjaGFpbmVkQ2hlY2tUeXBlLmlzUmVxdWlyZWQgPSBjaGVja1R5cGUuYmluZChudWxsLCB0cnVlKTtcblxuICAgIHJldHVybiBjaGFpbmVkQ2hlY2tUeXBlO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoZXhwZWN0ZWRUeXBlKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSBleHBlY3RlZFR5cGUpIHtcbiAgICAgICAgLy8gYHByb3BWYWx1ZWAgYmVpbmcgaW5zdGFuY2Ugb2YsIHNheSwgZGF0ZS9yZWdleHAsIHBhc3MgdGhlICdvYmplY3QnXG4gICAgICAgIC8vIGNoZWNrLCBidXQgd2UgY2FuIG9mZmVyIGEgbW9yZSBwcmVjaXNlIGVycm9yIG1lc3NhZ2UgaGVyZSByYXRoZXIgdGhhblxuICAgICAgICAvLyAnb2YgdHlwZSBgb2JqZWN0YCcuXG4gICAgICAgIHZhciBwcmVjaXNlVHlwZSA9IGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJlY2lzZVR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2AnICsgZXhwZWN0ZWRUeXBlICsgJ2AuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpIHtcbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIoZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIGFycmF5T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gYXJyYXkuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBpLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJ1snICsgaSArICddJywgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIoZXhwZWN0ZWRDbGFzcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCEocHJvcHNbcHJvcE5hbWVdIGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykpIHtcbiAgICAgICAgdmFyIGV4cGVjdGVkQ2xhc3NOYW1lID0gZXhwZWN0ZWRDbGFzcy5uYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgICAgdmFyIGFjdHVhbENsYXNzTmFtZSA9IGdldENsYXNzTmFtZShwcm9wc1twcm9wTmFtZV0pO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBhY3R1YWxDbGFzc05hbWUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2luc3RhbmNlIG9mIGAnICsgZXhwZWN0ZWRDbGFzc05hbWUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVudW1UeXBlQ2hlY2tlcihleHBlY3RlZFZhbHVlcykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFZhbHVlcykpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJykgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaXMocHJvcFZhbHVlLCBleHBlY3RlZFZhbHVlc1tpXSkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWVzU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZXhwZWN0ZWRWYWx1ZXMpO1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB2YWx1ZSBgJyArIHByb3BWYWx1ZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBvbmUgb2YgJyArIHZhbHVlc1N0cmluZyArICcuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBvYmplY3RPZi4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBvYmplY3QuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHByb3BWYWx1ZSkge1xuICAgICAgICBpZiAocHJvcFZhbHVlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIoYXJyYXlPZlR5cGVDaGVja2Vycykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheU9mVHlwZUNoZWNrZXJzKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZSwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJykgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICBpZiAodHlwZW9mIGNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2FybmluZyhcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUuIEV4cGVjdGVkIGFuIGFycmF5IG9mIGNoZWNrIGZ1bmN0aW9ucywgYnV0ICcgK1xuICAgICAgICAgICdyZWNlaXZlZCAlcyBhdCBpbmRleCAlcy4nLFxuICAgICAgICAgIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyhjaGVja2VyKSxcbiAgICAgICAgICBpXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICAgIGlmIChjaGVja2VyKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU5vZGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCFpc05vZGUocHJvcHNbcHJvcE5hbWVdKSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIFJlYWN0Tm9kZS4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBzaGFwZVR5cGVzKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgICBpZiAoIWNoZWNrZXIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGFsbCBrZXlzIGluIGNhc2Ugc29tZSBhcmUgcmVxdWlyZWQgYnV0IG1pc3NpbmcgZnJvbVxuICAgICAgLy8gcHJvcHMuXG4gICAgICB2YXIgYWxsS2V5cyA9IGFzc2lnbih7fSwgcHJvcHNbcHJvcE5hbWVdLCBzaGFwZVR5cGVzKTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBhbGxLZXlzKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgICBpZiAoIWNoZWNrZXIpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoXG4gICAgICAgICAgICAnSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Aga2V5IGAnICsga2V5ICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJyArXG4gICAgICAgICAgICAnXFxuQmFkIG9iamVjdDogJyArIEpTT04uc3RyaW5naWZ5KHByb3BzW3Byb3BOYW1lXSwgbnVsbCwgJyAgJykgK1xuICAgICAgICAgICAgJ1xcblZhbGlkIGtleXM6ICcgKyAgSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmtleXMoc2hhcGVUeXBlcyksIG51bGwsICcgICcpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTm9kZShwcm9wVmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiBwcm9wVmFsdWUpIHtcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgcmV0dXJuICFwcm9wVmFsdWU7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BWYWx1ZS5ldmVyeShpc05vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wVmFsdWUgPT09IG51bGwgfHwgaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKHByb3BWYWx1ZSk7XG4gICAgICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKHByb3BWYWx1ZSk7XG4gICAgICAgICAgdmFyIHN0ZXA7XG4gICAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IHByb3BWYWx1ZS5lbnRyaWVzKSB7XG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIGlmICghaXNOb2RlKHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEl0ZXJhdG9yIHdpbGwgcHJvdmlkZSBlbnRyeSBbayx2XSB0dXBsZXMgcmF0aGVyIHRoYW4gdmFsdWVzLlxuICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTm9kZShlbnRyeVsxXSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkge1xuICAgIC8vIE5hdGl2ZSBTeW1ib2wuXG4gICAgaWYgKHByb3BUeXBlID09PSAnc3ltYm9sJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXSA9PT0gJ1N5bWJvbCdcbiAgICBpZiAocHJvcFZhbHVlWydAQHRvU3RyaW5nVGFnJ10gPT09ICdTeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBGYWxsYmFjayBmb3Igbm9uLXNwZWMgY29tcGxpYW50IFN5bWJvbHMgd2hpY2ggYXJlIHBvbHlmaWxsZWQuXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgcHJvcFZhbHVlIGluc3RhbmNlb2YgU3ltYm9sKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBFcXVpdmFsZW50IG9mIGB0eXBlb2ZgIGJ1dCB3aXRoIHNwZWNpYWwgaGFuZGxpbmcgZm9yIGFycmF5IGFuZCByZWdleHAuXG4gIGZ1bmN0aW9uIGdldFByb3BUeXBlKHByb3BWYWx1ZSkge1xuICAgIHZhciBwcm9wVHlwZSA9IHR5cGVvZiBwcm9wVmFsdWU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgfVxuICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIC8vIE9sZCB3ZWJraXRzIChhdCBsZWFzdCB1bnRpbCBBbmRyb2lkIDQuMCkgcmV0dXJuICdmdW5jdGlvbicgcmF0aGVyIHRoYW5cbiAgICAgIC8vICdvYmplY3QnIGZvciB0eXBlb2YgYSBSZWdFeHAuIFdlJ2xsIG5vcm1hbGl6ZSB0aGlzIGhlcmUgc28gdGhhdCAvYmxhL1xuICAgICAgLy8gcGFzc2VzIFByb3BUeXBlcy5vYmplY3QuXG4gICAgICByZXR1cm4gJ29iamVjdCc7XG4gICAgfVxuICAgIGlmIChpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdzeW1ib2wnO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBUaGlzIGhhbmRsZXMgbW9yZSB0eXBlcyB0aGFuIGBnZXRQcm9wVHlwZWAuIE9ubHkgdXNlZCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gIC8vIFNlZSBgY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXJgLlxuICBmdW5jdGlvbiBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHByb3BWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcFZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gJycgKyBwcm9wVmFsdWU7XG4gICAgfVxuICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgaWYgKHByb3BUeXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuICdkYXRlJztcbiAgICAgIH0gZWxzZSBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIHJldHVybiAncmVnZXhwJztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByb3BUeXBlO1xuICB9XG5cbiAgLy8gUmV0dXJucyBhIHN0cmluZyB0aGF0IGlzIHBvc3RmaXhlZCB0byBhIHdhcm5pbmcgYWJvdXQgYW4gaW52YWxpZCB0eXBlLlxuICAvLyBGb3IgZXhhbXBsZSwgXCJ1bmRlZmluZWRcIiBvciBcIm9mIHR5cGUgYXJyYXlcIlxuICBmdW5jdGlvbiBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcodmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IGdldFByZWNpc2VUeXBlKHZhbHVlKTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHJldHVybiAnYW4gJyArIHR5cGU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgY2FzZSAncmVnZXhwJzpcbiAgICAgICAgcmV0dXJuICdhICcgKyB0eXBlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICB9XG5cbiAgLy8gUmV0dXJucyBjbGFzcyBuYW1lIG9mIHRoZSBvYmplY3QsIGlmIGFueS5cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKHByb3BWYWx1ZSkge1xuICAgIGlmICghcHJvcFZhbHVlLmNvbnN0cnVjdG9yIHx8ICFwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZSkge1xuICAgICAgcmV0dXJuIEFOT05ZTU9VUztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICB9XG5cbiAgUmVhY3RQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBjaGVja1Byb3BUeXBlcztcbiAgUmVhY3RQcm9wVHlwZXMuUHJvcFR5cGVzID0gUmVhY3RQcm9wVHlwZXM7XG5cbiAgcmV0dXJuIFJlYWN0UHJvcFR5cGVzO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanNcbi8vIG1vZHVsZSBpZCA9IDQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///43\n");

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar emptyFunction = __webpack_require__(2);\nvar invariant = __webpack_require__(4);\nvar ReactPropTypesSecret = __webpack_require__(8);\n\nmodule.exports = function() {\n  function shim(props, propName, componentName, location, propFullName, secret) {\n    if (secret === ReactPropTypesSecret) {\n      // It is still safe when called from React.\n      return;\n    }\n    invariant(\n      false,\n      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +\n      'Use PropTypes.checkPropTypes() to call them. ' +\n      'Read more at http://fb.me/use-check-prop-types'\n    );\n  };\n  shim.isRequired = shim;\n  function getShim() {\n    return shim;\n  };\n  // Important!\n  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.\n  var ReactPropTypes = {\n    array: shim,\n    bool: shim,\n    func: shim,\n    number: shim,\n    object: shim,\n    string: shim,\n    symbol: shim,\n\n    any: shim,\n    arrayOf: getShim,\n    element: shim,\n    instanceOf: getShim,\n    node: shim,\n    objectOf: getShim,\n    oneOf: getShim,\n    oneOfType: getShim,\n    shape: getShim,\n    exact: getShim\n  };\n\n  ReactPropTypes.checkPropTypes = emptyFunction;\n  ReactPropTypes.PropTypes = ReactPropTypes;\n\n  return ReactPropTypes;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanM/NDM4NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBzaGltKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgaWYgKHNlY3JldCA9PT0gUmVhY3RQcm9wVHlwZXNTZWNyZXQpIHtcbiAgICAgIC8vIEl0IGlzIHN0aWxsIHNhZmUgd2hlbiBjYWxsZWQgZnJvbSBSZWFjdC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaW52YXJpYW50KFxuICAgICAgZmFsc2UsXG4gICAgICAnQ2FsbGluZyBQcm9wVHlwZXMgdmFsaWRhdG9ycyBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAnVXNlIFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpIHRvIGNhbGwgdGhlbS4gJyArXG4gICAgICAnUmVhZCBtb3JlIGF0IGh0dHA6Ly9mYi5tZS91c2UtY2hlY2stcHJvcC10eXBlcydcbiAgICApO1xuICB9O1xuICBzaGltLmlzUmVxdWlyZWQgPSBzaGltO1xuICBmdW5jdGlvbiBnZXRTaGltKCkge1xuICAgIHJldHVybiBzaGltO1xuICB9O1xuICAvLyBJbXBvcnRhbnQhXG4gIC8vIEtlZXAgdGhpcyBsaXN0IGluIHN5bmMgd2l0aCBwcm9kdWN0aW9uIHZlcnNpb24gaW4gYC4vZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanNgLlxuICB2YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gICAgYXJyYXk6IHNoaW0sXG4gICAgYm9vbDogc2hpbSxcbiAgICBmdW5jOiBzaGltLFxuICAgIG51bWJlcjogc2hpbSxcbiAgICBvYmplY3Q6IHNoaW0sXG4gICAgc3RyaW5nOiBzaGltLFxuICAgIHN5bWJvbDogc2hpbSxcblxuICAgIGFueTogc2hpbSxcbiAgICBhcnJheU9mOiBnZXRTaGltLFxuICAgIGVsZW1lbnQ6IHNoaW0sXG4gICAgaW5zdGFuY2VPZjogZ2V0U2hpbSxcbiAgICBub2RlOiBzaGltLFxuICAgIG9iamVjdE9mOiBnZXRTaGltLFxuICAgIG9uZU9mOiBnZXRTaGltLFxuICAgIG9uZU9mVHlwZTogZ2V0U2hpbSxcbiAgICBzaGFwZTogZ2V0U2hpbSxcbiAgICBleGFjdDogZ2V0U2hpbVxuICB9O1xuXG4gIFJlYWN0UHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzID0gZW1wdHlGdW5jdGlvbjtcbiAgUmVhY3RQcm9wVHlwZXMuUHJvcFR5cGVzID0gUmVhY3RQcm9wVHlwZXM7XG5cbiAgcmV0dXJuIFJlYWN0UHJvcFR5cGVzO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zLmpzXG4vLyBtb2R1bGUgaWQgPSA0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///44\n");

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _react = __webpack_require__(1);\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = __webpack_require__(16);\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _focusManager = __webpack_require__(46);\n\nvar focusManager = _interopRequireWildcard(_focusManager);\n\nvar _scopeTab = __webpack_require__(47);\n\nvar _scopeTab2 = _interopRequireDefault(_scopeTab);\n\nvar _ariaAppHider = __webpack_require__(18);\n\nvar ariaAppHider = _interopRequireWildcard(_ariaAppHider);\n\nvar _refCount = __webpack_require__(19);\n\nvar refCount = _interopRequireWildcard(_refCount);\n\nvar _bodyClassList = __webpack_require__(49);\n\nvar bodyClassList = _interopRequireWildcard(_bodyClassList);\n\nvar _safeHTMLElement = __webpack_require__(20);\n\nvar _safeHTMLElement2 = _interopRequireDefault(_safeHTMLElement);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// so that our CSS is statically analyzable\nvar CLASS_NAMES = {\n  overlay: \"ReactModal__Overlay\",\n  content: \"ReactModal__Content\"\n};\n\nvar TAB_KEY = 9;\nvar ESC_KEY = 27;\n\nvar ModalPortal = function (_Component) {\n  _inherits(ModalPortal, _Component);\n\n  function ModalPortal(props) {\n    _classCallCheck(this, ModalPortal);\n\n    var _this = _possibleConstructorReturn(this, (ModalPortal.__proto__ || Object.getPrototypeOf(ModalPortal)).call(this, props));\n\n    _this.setFocusAfterRender = function (focus) {\n      _this.focusAfterRender = _this.props.shouldFocusAfterRender && focus;\n    };\n\n    _this.setOverlayRef = function (overlay) {\n      _this.overlay = overlay;\n    };\n\n    _this.setContentRef = function (content) {\n      _this.content = content;\n    };\n\n    _this.afterClose = function () {\n      var _this$props = _this.props,\n          appElement = _this$props.appElement,\n          ariaHideApp = _this$props.ariaHideApp;\n\n      // Remove body class\n\n      bodyClassList.remove(_this.props.bodyOpenClassName);\n\n      // Reset aria-hidden attribute if all modals have been removed\n      if (ariaHideApp && refCount.totalCount() < 1) {\n        ariaAppHider.show(appElement);\n      }\n\n      if (_this.props.shouldFocusAfterRender) {\n        if (_this.props.shouldReturnFocusAfterClose) {\n          focusManager.returnFocus();\n          focusManager.teardownScopedFocus();\n        } else {\n          focusManager.popWithoutFocus();\n        }\n      }\n    };\n\n    _this.open = function () {\n      _this.beforeOpen();\n      if (_this.state.afterOpen && _this.state.beforeClose) {\n        clearTimeout(_this.closeTimer);\n        _this.setState({ beforeClose: false });\n      } else {\n        if (_this.props.shouldFocusAfterRender) {\n          focusManager.setupScopedFocus(_this.node);\n          focusManager.markForFocusLater();\n        }\n\n        _this.setState({ isOpen: true }, function () {\n          _this.setState({ afterOpen: true });\n\n          if (_this.props.isOpen && _this.props.onAfterOpen) {\n            _this.props.onAfterOpen();\n          }\n        });\n      }\n    };\n\n    _this.close = function () {\n      if (_this.props.closeTimeoutMS > 0) {\n        _this.closeWithTimeout();\n      } else {\n        _this.closeWithoutTimeout();\n      }\n    };\n\n    _this.focusContent = function () {\n      return _this.content && !_this.contentHasFocus() && _this.content.focus();\n    };\n\n    _this.closeWithTimeout = function () {\n      var closesAt = Date.now() + _this.props.closeTimeoutMS;\n      _this.setState({ beforeClose: true, closesAt: closesAt }, function () {\n        _this.closeTimer = setTimeout(_this.closeWithoutTimeout, _this.state.closesAt - Date.now());\n      });\n    };\n\n    _this.closeWithoutTimeout = function () {\n      _this.setState({\n        beforeClose: false,\n        isOpen: false,\n        afterOpen: false,\n        closesAt: null\n      }, _this.afterClose);\n    };\n\n    _this.handleKeyDown = function (event) {\n      if (event.keyCode === TAB_KEY) {\n        (0, _scopeTab2.default)(_this.content, event);\n      }\n\n      if (_this.props.shouldCloseOnEsc && event.keyCode === ESC_KEY) {\n        event.stopPropagation();\n        _this.requestClose(event);\n      }\n    };\n\n    _this.handleOverlayOnClick = function (event) {\n      if (_this.shouldClose === null) {\n        _this.shouldClose = true;\n      }\n\n      if (_this.shouldClose && _this.props.shouldCloseOnOverlayClick) {\n        if (_this.ownerHandlesClose()) {\n          _this.requestClose(event);\n        } else {\n          _this.focusContent();\n        }\n      }\n      _this.shouldClose = null;\n      _this.moveFromContentToOverlay = null;\n    };\n\n    _this.handleOverlayOnMouseUp = function () {\n      if (_this.moveFromContentToOverlay === null) {\n        _this.shouldClose = false;\n      }\n      if (_this.props.shouldCloseOnOverlayClick) {\n        _this.shouldClose = true;\n      }\n    };\n\n    _this.handleContentOnMouseUp = function () {\n      _this.shouldClose = false;\n    };\n\n    _this.handleOverlayOnMouseDown = function (event) {\n      if (!_this.props.shouldCloseOnOverlayClick && event.target == _this.overlay) {\n        event.preventDefault();\n      }\n      _this.moveFromContentToOverlay = false;\n    };\n\n    _this.handleContentOnClick = function () {\n      _this.shouldClose = false;\n    };\n\n    _this.handleContentOnMouseDown = function () {\n      _this.shouldClose = false;\n      _this.moveFromContentToOverlay = false;\n    };\n\n    _this.requestClose = function (event) {\n      return _this.ownerHandlesClose() && _this.props.onRequestClose(event);\n    };\n\n    _this.ownerHandlesClose = function () {\n      return _this.props.onRequestClose;\n    };\n\n    _this.shouldBeClosed = function () {\n      return !_this.state.isOpen && !_this.state.beforeClose;\n    };\n\n    _this.contentHasFocus = function () {\n      return document.activeElement === _this.content || _this.content.contains(document.activeElement);\n    };\n\n    _this.buildClassName = function (which, additional) {\n      var classNames = (typeof additional === \"undefined\" ? \"undefined\" : _typeof(additional)) === \"object\" ? additional : {\n        base: CLASS_NAMES[which],\n        afterOpen: CLASS_NAMES[which] + \"--after-open\",\n        beforeClose: CLASS_NAMES[which] + \"--before-close\"\n      };\n      var className = classNames.base;\n      if (_this.state.afterOpen) {\n        className = className + \" \" + classNames.afterOpen;\n      }\n      if (_this.state.beforeClose) {\n        className = className + \" \" + classNames.beforeClose;\n      }\n      return typeof additional === \"string\" && additional ? className + \" \" + additional : className;\n    };\n\n    _this.ariaAttributes = function (items) {\n      return Object.keys(items).reduce(function (acc, name) {\n        acc[\"aria-\" + name] = items[name];\n        return acc;\n      }, {});\n    };\n\n    _this.state = {\n      afterOpen: false,\n      beforeClose: false\n    };\n\n    _this.shouldClose = null;\n    _this.moveFromContentToOverlay = null;\n    return _this;\n  }\n\n  _createClass(ModalPortal, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      // Focus needs to be set when mounting and already open\n      if (this.props.isOpen) {\n        this.setFocusAfterRender(true);\n        this.open();\n      }\n    }\n  }, {\n    key: \"componentWillReceiveProps\",\n    value: function componentWillReceiveProps(newProps) {\n      if (process.env.NODE_ENV !== \"production\") {\n        if (newProps.bodyOpenClassName !== this.props.bodyOpenClassName) {\n          // eslint-disable-next-line no-console\n          console.warn('React-Modal: \"bodyOpenClassName\" prop has been modified. ' + \"This may cause unexpected behavior when multiple modals are open.\");\n        }\n      }\n      // Focus only needs to be set once when the modal is being opened\n      if (!this.props.isOpen && newProps.isOpen) {\n        this.setFocusAfterRender(true);\n        this.open();\n      } else if (this.props.isOpen && !newProps.isOpen) {\n        this.close();\n      }\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {\n      if (this.focusAfterRender) {\n        this.focusContent();\n        this.setFocusAfterRender(false);\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.afterClose();\n      clearTimeout(this.closeTimer);\n    }\n  }, {\n    key: \"beforeOpen\",\n    value: function beforeOpen() {\n      var _props = this.props,\n          appElement = _props.appElement,\n          ariaHideApp = _props.ariaHideApp,\n          bodyOpenClassName = _props.bodyOpenClassName;\n      // Add body class\n\n      bodyClassList.add(bodyOpenClassName);\n      // Add aria-hidden to appElement\n      if (ariaHideApp) {\n        ariaAppHider.hide(appElement);\n      }\n    }\n\n    // Don't steal focus from inner elements\n\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _props2 = this.props,\n          className = _props2.className,\n          overlayClassName = _props2.overlayClassName,\n          defaultStyles = _props2.defaultStyles;\n\n      var contentStyles = className ? {} : defaultStyles.content;\n      var overlayStyles = overlayClassName ? {} : defaultStyles.overlay;\n\n      return this.shouldBeClosed() ? null : _react2.default.createElement(\n        \"div\",\n        {\n          ref: this.setOverlayRef,\n          className: this.buildClassName(\"overlay\", overlayClassName),\n          style: _extends({}, overlayStyles, this.props.style.overlay),\n          onClick: this.handleOverlayOnClick,\n          onMouseDown: this.handleOverlayOnMouseDown,\n          onMouseUp: this.handleOverlayOnMouseUp,\n          \"aria-modal\": \"true\"\n        },\n        _react2.default.createElement(\n          \"div\",\n          _extends({\n            ref: this.setContentRef,\n            style: _extends({}, contentStyles, this.props.style.content),\n            className: this.buildClassName(\"content\", className),\n            tabIndex: \"-1\",\n            onKeyDown: this.handleKeyDown,\n            onMouseDown: this.handleContentOnMouseDown,\n            onMouseUp: this.handleContentOnMouseUp,\n            onClick: this.handleContentOnClick,\n            role: this.props.role,\n            \"aria-label\": this.props.contentLabel\n          }, this.ariaAttributes(this.props.aria || {})),\n          this.props.children\n        )\n      );\n    }\n  }]);\n\n  return ModalPortal;\n}(_react.Component);\n\nModalPortal.defaultProps = {\n  style: {\n    overlay: {},\n    content: {}\n  }\n};\nModalPortal.propTypes = {\n  isOpen: _propTypes2.default.bool.isRequired,\n  defaultStyles: _propTypes2.default.shape({\n    content: _propTypes2.default.object,\n    overlay: _propTypes2.default.object\n  }),\n  style: _propTypes2.default.shape({\n    content: _propTypes2.default.object,\n    overlay: _propTypes2.default.object\n  }),\n  className: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.object]),\n  overlayClassName: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.object]),\n  bodyOpenClassName: _propTypes2.default.string,\n  ariaHideApp: _propTypes2.default.bool,\n  appElement: _propTypes2.default.instanceOf(_safeHTMLElement2.default),\n  onAfterOpen: _propTypes2.default.func,\n  onRequestClose: _propTypes2.default.func,\n  closeTimeoutMS: _propTypes2.default.number,\n  shouldFocusAfterRender: _propTypes2.default.bool,\n  shouldCloseOnOverlayClick: _propTypes2.default.bool,\n  shouldReturnFocusAfterClose: _propTypes2.default.bool,\n  role: _propTypes2.default.string,\n  contentLabel: _propTypes2.default.string,\n  aria: _propTypes2.default.object,\n  children: _propTypes2.default.node,\n  shouldCloseOnEsc: _propTypes2.default.bool\n};\nexports.default = ModalPortal;\nmodule.exports = exports[\"default\"];\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtbW9kYWwvbGliL2NvbXBvbmVudHMvTW9kYWxQb3J0YWwuanM/MTdmMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9wcm9wVHlwZXMgPSByZXF1aXJlKFwicHJvcC10eXBlc1wiKTtcblxudmFyIF9wcm9wVHlwZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcHJvcFR5cGVzKTtcblxudmFyIF9mb2N1c01hbmFnZXIgPSByZXF1aXJlKFwiLi4vaGVscGVycy9mb2N1c01hbmFnZXJcIik7XG5cbnZhciBmb2N1c01hbmFnZXIgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfZm9jdXNNYW5hZ2VyKTtcblxudmFyIF9zY29wZVRhYiA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL3Njb3BlVGFiXCIpO1xuXG52YXIgX3Njb3BlVGFiMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Njb3BlVGFiKTtcblxudmFyIF9hcmlhQXBwSGlkZXIgPSByZXF1aXJlKFwiLi4vaGVscGVycy9hcmlhQXBwSGlkZXJcIik7XG5cbnZhciBhcmlhQXBwSGlkZXIgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfYXJpYUFwcEhpZGVyKTtcblxudmFyIF9yZWZDb3VudCA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL3JlZkNvdW50XCIpO1xuXG52YXIgcmVmQ291bnQgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfcmVmQ291bnQpO1xuXG52YXIgX2JvZHlDbGFzc0xpc3QgPSByZXF1aXJlKFwiLi4vaGVscGVycy9ib2R5Q2xhc3NMaXN0XCIpO1xuXG52YXIgYm9keUNsYXNzTGlzdCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9ib2R5Q2xhc3NMaXN0KTtcblxudmFyIF9zYWZlSFRNTEVsZW1lbnQgPSByZXF1aXJlKFwiLi4vaGVscGVycy9zYWZlSFRNTEVsZW1lbnRcIik7XG5cbnZhciBfc2FmZUhUTUxFbGVtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NhZmVIVE1MRWxlbWVudCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLy8gc28gdGhhdCBvdXIgQ1NTIGlzIHN0YXRpY2FsbHkgYW5hbHl6YWJsZVxudmFyIENMQVNTX05BTUVTID0ge1xuICBvdmVybGF5OiBcIlJlYWN0TW9kYWxfX092ZXJsYXlcIixcbiAgY29udGVudDogXCJSZWFjdE1vZGFsX19Db250ZW50XCJcbn07XG5cbnZhciBUQUJfS0VZID0gOTtcbnZhciBFU0NfS0VZID0gMjc7XG5cbnZhciBNb2RhbFBvcnRhbCA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhNb2RhbFBvcnRhbCwgX0NvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gTW9kYWxQb3J0YWwocHJvcHMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTW9kYWxQb3J0YWwpO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKE1vZGFsUG9ydGFsLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTW9kYWxQb3J0YWwpKS5jYWxsKHRoaXMsIHByb3BzKSk7XG5cbiAgICBfdGhpcy5zZXRGb2N1c0FmdGVyUmVuZGVyID0gZnVuY3Rpb24gKGZvY3VzKSB7XG4gICAgICBfdGhpcy5mb2N1c0FmdGVyUmVuZGVyID0gX3RoaXMucHJvcHMuc2hvdWxkRm9jdXNBZnRlclJlbmRlciAmJiBmb2N1cztcbiAgICB9O1xuXG4gICAgX3RoaXMuc2V0T3ZlcmxheVJlZiA9IGZ1bmN0aW9uIChvdmVybGF5KSB7XG4gICAgICBfdGhpcy5vdmVybGF5ID0gb3ZlcmxheTtcbiAgICB9O1xuXG4gICAgX3RoaXMuc2V0Q29udGVudFJlZiA9IGZ1bmN0aW9uIChjb250ZW50KSB7XG4gICAgICBfdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICB9O1xuXG4gICAgX3RoaXMuYWZ0ZXJDbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wcyA9IF90aGlzLnByb3BzLFxuICAgICAgICAgIGFwcEVsZW1lbnQgPSBfdGhpcyRwcm9wcy5hcHBFbGVtZW50LFxuICAgICAgICAgIGFyaWFIaWRlQXBwID0gX3RoaXMkcHJvcHMuYXJpYUhpZGVBcHA7XG5cbiAgICAgIC8vIFJlbW92ZSBib2R5IGNsYXNzXG5cbiAgICAgIGJvZHlDbGFzc0xpc3QucmVtb3ZlKF90aGlzLnByb3BzLmJvZHlPcGVuQ2xhc3NOYW1lKTtcblxuICAgICAgLy8gUmVzZXQgYXJpYS1oaWRkZW4gYXR0cmlidXRlIGlmIGFsbCBtb2RhbHMgaGF2ZSBiZWVuIHJlbW92ZWRcbiAgICAgIGlmIChhcmlhSGlkZUFwcCAmJiByZWZDb3VudC50b3RhbENvdW50KCkgPCAxKSB7XG4gICAgICAgIGFyaWFBcHBIaWRlci5zaG93KGFwcEVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoX3RoaXMucHJvcHMuc2hvdWxkRm9jdXNBZnRlclJlbmRlcikge1xuICAgICAgICBpZiAoX3RoaXMucHJvcHMuc2hvdWxkUmV0dXJuRm9jdXNBZnRlckNsb3NlKSB7XG4gICAgICAgICAgZm9jdXNNYW5hZ2VyLnJldHVybkZvY3VzKCk7XG4gICAgICAgICAgZm9jdXNNYW5hZ2VyLnRlYXJkb3duU2NvcGVkRm9jdXMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb2N1c01hbmFnZXIucG9wV2l0aG91dEZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLmJlZm9yZU9wZW4oKTtcbiAgICAgIGlmIChfdGhpcy5zdGF0ZS5hZnRlck9wZW4gJiYgX3RoaXMuc3RhdGUuYmVmb3JlQ2xvc2UpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLmNsb3NlVGltZXIpO1xuICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IGJlZm9yZUNsb3NlOiBmYWxzZSB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChfdGhpcy5wcm9wcy5zaG91bGRGb2N1c0FmdGVyUmVuZGVyKSB7XG4gICAgICAgICAgZm9jdXNNYW5hZ2VyLnNldHVwU2NvcGVkRm9jdXMoX3RoaXMubm9kZSk7XG4gICAgICAgICAgZm9jdXNNYW5hZ2VyLm1hcmtGb3JGb2N1c0xhdGVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IGlzT3BlbjogdHJ1ZSB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBhZnRlck9wZW46IHRydWUgfSk7XG5cbiAgICAgICAgICBpZiAoX3RoaXMucHJvcHMuaXNPcGVuICYmIF90aGlzLnByb3BzLm9uQWZ0ZXJPcGVuKSB7XG4gICAgICAgICAgICBfdGhpcy5wcm9wcy5vbkFmdGVyT3BlbigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKF90aGlzLnByb3BzLmNsb3NlVGltZW91dE1TID4gMCkge1xuICAgICAgICBfdGhpcy5jbG9zZVdpdGhUaW1lb3V0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdGhpcy5jbG9zZVdpdGhvdXRUaW1lb3V0KCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLmZvY3VzQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdGhpcy5jb250ZW50ICYmICFfdGhpcy5jb250ZW50SGFzRm9jdXMoKSAmJiBfdGhpcy5jb250ZW50LmZvY3VzKCk7XG4gICAgfTtcblxuICAgIF90aGlzLmNsb3NlV2l0aFRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY2xvc2VzQXQgPSBEYXRlLm5vdygpICsgX3RoaXMucHJvcHMuY2xvc2VUaW1lb3V0TVM7XG4gICAgICBfdGhpcy5zZXRTdGF0ZSh7IGJlZm9yZUNsb3NlOiB0cnVlLCBjbG9zZXNBdDogY2xvc2VzQXQgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5jbG9zZVRpbWVyID0gc2V0VGltZW91dChfdGhpcy5jbG9zZVdpdGhvdXRUaW1lb3V0LCBfdGhpcy5zdGF0ZS5jbG9zZXNBdCAtIERhdGUubm93KCkpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIF90aGlzLmNsb3NlV2l0aG91dFRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGJlZm9yZUNsb3NlOiBmYWxzZSxcbiAgICAgICAgaXNPcGVuOiBmYWxzZSxcbiAgICAgICAgYWZ0ZXJPcGVuOiBmYWxzZSxcbiAgICAgICAgY2xvc2VzQXQ6IG51bGxcbiAgICAgIH0sIF90aGlzLmFmdGVyQ2xvc2UpO1xuICAgIH07XG5cbiAgICBfdGhpcy5oYW5kbGVLZXlEb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gVEFCX0tFWSkge1xuICAgICAgICAoMCwgX3Njb3BlVGFiMi5kZWZhdWx0KShfdGhpcy5jb250ZW50LCBldmVudCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChfdGhpcy5wcm9wcy5zaG91bGRDbG9zZU9uRXNjICYmIGV2ZW50LmtleUNvZGUgPT09IEVTQ19LRVkpIHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIF90aGlzLnJlcXVlc3RDbG9zZShldmVudCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLmhhbmRsZU92ZXJsYXlPbkNsaWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAoX3RoaXMuc2hvdWxkQ2xvc2UgPT09IG51bGwpIHtcbiAgICAgICAgX3RoaXMuc2hvdWxkQ2xvc2UgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoX3RoaXMuc2hvdWxkQ2xvc2UgJiYgX3RoaXMucHJvcHMuc2hvdWxkQ2xvc2VPbk92ZXJsYXlDbGljaykge1xuICAgICAgICBpZiAoX3RoaXMub3duZXJIYW5kbGVzQ2xvc2UoKSkge1xuICAgICAgICAgIF90aGlzLnJlcXVlc3RDbG9zZShldmVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3RoaXMuZm9jdXNDb250ZW50KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIF90aGlzLnNob3VsZENsb3NlID0gbnVsbDtcbiAgICAgIF90aGlzLm1vdmVGcm9tQ29udGVudFRvT3ZlcmxheSA9IG51bGw7XG4gICAgfTtcblxuICAgIF90aGlzLmhhbmRsZU92ZXJsYXlPbk1vdXNlVXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoX3RoaXMubW92ZUZyb21Db250ZW50VG9PdmVybGF5ID09PSBudWxsKSB7XG4gICAgICAgIF90aGlzLnNob3VsZENsb3NlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoX3RoaXMucHJvcHMuc2hvdWxkQ2xvc2VPbk92ZXJsYXlDbGljaykge1xuICAgICAgICBfdGhpcy5zaG91bGRDbG9zZSA9IHRydWU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLmhhbmRsZUNvbnRlbnRPbk1vdXNlVXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5zaG91bGRDbG9zZSA9IGZhbHNlO1xuICAgIH07XG5cbiAgICBfdGhpcy5oYW5kbGVPdmVybGF5T25Nb3VzZURvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmICghX3RoaXMucHJvcHMuc2hvdWxkQ2xvc2VPbk92ZXJsYXlDbGljayAmJiBldmVudC50YXJnZXQgPT0gX3RoaXMub3ZlcmxheSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgICAgX3RoaXMubW92ZUZyb21Db250ZW50VG9PdmVybGF5ID0gZmFsc2U7XG4gICAgfTtcblxuICAgIF90aGlzLmhhbmRsZUNvbnRlbnRPbkNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuc2hvdWxkQ2xvc2UgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgX3RoaXMuaGFuZGxlQ29udGVudE9uTW91c2VEb3duID0gZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuc2hvdWxkQ2xvc2UgPSBmYWxzZTtcbiAgICAgIF90aGlzLm1vdmVGcm9tQ29udGVudFRvT3ZlcmxheSA9IGZhbHNlO1xuICAgIH07XG5cbiAgICBfdGhpcy5yZXF1ZXN0Q2xvc2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHJldHVybiBfdGhpcy5vd25lckhhbmRsZXNDbG9zZSgpICYmIF90aGlzLnByb3BzLm9uUmVxdWVzdENsb3NlKGV2ZW50KTtcbiAgICB9O1xuXG4gICAgX3RoaXMub3duZXJIYW5kbGVzQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMucHJvcHMub25SZXF1ZXN0Q2xvc2U7XG4gICAgfTtcblxuICAgIF90aGlzLnNob3VsZEJlQ2xvc2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICFfdGhpcy5zdGF0ZS5pc09wZW4gJiYgIV90aGlzLnN0YXRlLmJlZm9yZUNsb3NlO1xuICAgIH07XG5cbiAgICBfdGhpcy5jb250ZW50SGFzRm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gX3RoaXMuY29udGVudCB8fCBfdGhpcy5jb250ZW50LmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpO1xuICAgIH07XG5cbiAgICBfdGhpcy5idWlsZENsYXNzTmFtZSA9IGZ1bmN0aW9uICh3aGljaCwgYWRkaXRpb25hbCkge1xuICAgICAgdmFyIGNsYXNzTmFtZXMgPSAodHlwZW9mIGFkZGl0aW9uYWwgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihhZGRpdGlvbmFsKSkgPT09IFwib2JqZWN0XCIgPyBhZGRpdGlvbmFsIDoge1xuICAgICAgICBiYXNlOiBDTEFTU19OQU1FU1t3aGljaF0sXG4gICAgICAgIGFmdGVyT3BlbjogQ0xBU1NfTkFNRVNbd2hpY2hdICsgXCItLWFmdGVyLW9wZW5cIixcbiAgICAgICAgYmVmb3JlQ2xvc2U6IENMQVNTX05BTUVTW3doaWNoXSArIFwiLS1iZWZvcmUtY2xvc2VcIlxuICAgICAgfTtcbiAgICAgIHZhciBjbGFzc05hbWUgPSBjbGFzc05hbWVzLmJhc2U7XG4gICAgICBpZiAoX3RoaXMuc3RhdGUuYWZ0ZXJPcGVuKSB7XG4gICAgICAgIGNsYXNzTmFtZSA9IGNsYXNzTmFtZSArIFwiIFwiICsgY2xhc3NOYW1lcy5hZnRlck9wZW47XG4gICAgICB9XG4gICAgICBpZiAoX3RoaXMuc3RhdGUuYmVmb3JlQ2xvc2UpIHtcbiAgICAgICAgY2xhc3NOYW1lID0gY2xhc3NOYW1lICsgXCIgXCIgKyBjbGFzc05hbWVzLmJlZm9yZUNsb3NlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHR5cGVvZiBhZGRpdGlvbmFsID09PSBcInN0cmluZ1wiICYmIGFkZGl0aW9uYWwgPyBjbGFzc05hbWUgKyBcIiBcIiArIGFkZGl0aW9uYWwgOiBjbGFzc05hbWU7XG4gICAgfTtcblxuICAgIF90aGlzLmFyaWFBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKGl0ZW1zKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXMoaXRlbXMpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBuYW1lKSB7XG4gICAgICAgIGFjY1tcImFyaWEtXCIgKyBuYW1lXSA9IGl0ZW1zW25hbWVdO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfSwge30pO1xuICAgIH07XG5cbiAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGFmdGVyT3BlbjogZmFsc2UsXG4gICAgICBiZWZvcmVDbG9zZTogZmFsc2VcbiAgICB9O1xuXG4gICAgX3RoaXMuc2hvdWxkQ2xvc2UgPSBudWxsO1xuICAgIF90aGlzLm1vdmVGcm9tQ29udGVudFRvT3ZlcmxheSA9IG51bGw7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE1vZGFsUG9ydGFsLCBbe1xuICAgIGtleTogXCJjb21wb25lbnREaWRNb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgIC8vIEZvY3VzIG5lZWRzIHRvIGJlIHNldCB3aGVuIG1vdW50aW5nIGFuZCBhbHJlYWR5IG9wZW5cbiAgICAgIGlmICh0aGlzLnByb3BzLmlzT3Blbikge1xuICAgICAgICB0aGlzLnNldEZvY3VzQWZ0ZXJSZW5kZXIodHJ1ZSk7XG4gICAgICAgIHRoaXMub3BlbigpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV3UHJvcHMpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgaWYgKG5ld1Byb3BzLmJvZHlPcGVuQ2xhc3NOYW1lICE9PSB0aGlzLnByb3BzLmJvZHlPcGVuQ2xhc3NOYW1lKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1JlYWN0LU1vZGFsOiBcImJvZHlPcGVuQ2xhc3NOYW1lXCIgcHJvcCBoYXMgYmVlbiBtb2RpZmllZC4gJyArIFwiVGhpcyBtYXkgY2F1c2UgdW5leHBlY3RlZCBiZWhhdmlvciB3aGVuIG11bHRpcGxlIG1vZGFscyBhcmUgb3Blbi5cIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEZvY3VzIG9ubHkgbmVlZHMgdG8gYmUgc2V0IG9uY2Ugd2hlbiB0aGUgbW9kYWwgaXMgYmVpbmcgb3BlbmVkXG4gICAgICBpZiAoIXRoaXMucHJvcHMuaXNPcGVuICYmIG5ld1Byb3BzLmlzT3Blbikge1xuICAgICAgICB0aGlzLnNldEZvY3VzQWZ0ZXJSZW5kZXIodHJ1ZSk7XG4gICAgICAgIHRoaXMub3BlbigpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnByb3BzLmlzT3BlbiAmJiAhbmV3UHJvcHMuaXNPcGVuKSB7XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcG9uZW50RGlkVXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgIGlmICh0aGlzLmZvY3VzQWZ0ZXJSZW5kZXIpIHtcbiAgICAgICAgdGhpcy5mb2N1c0NvbnRlbnQoKTtcbiAgICAgICAgdGhpcy5zZXRGb2N1c0FmdGVyUmVuZGVyKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcG9uZW50V2lsbFVubW91bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICB0aGlzLmFmdGVyQ2xvc2UoKTtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNsb3NlVGltZXIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJiZWZvcmVPcGVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJlZm9yZU9wZW4oKSB7XG4gICAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBhcHBFbGVtZW50ID0gX3Byb3BzLmFwcEVsZW1lbnQsXG4gICAgICAgICAgYXJpYUhpZGVBcHAgPSBfcHJvcHMuYXJpYUhpZGVBcHAsXG4gICAgICAgICAgYm9keU9wZW5DbGFzc05hbWUgPSBfcHJvcHMuYm9keU9wZW5DbGFzc05hbWU7XG4gICAgICAvLyBBZGQgYm9keSBjbGFzc1xuXG4gICAgICBib2R5Q2xhc3NMaXN0LmFkZChib2R5T3BlbkNsYXNzTmFtZSk7XG4gICAgICAvLyBBZGQgYXJpYS1oaWRkZW4gdG8gYXBwRWxlbWVudFxuICAgICAgaWYgKGFyaWFIaWRlQXBwKSB7XG4gICAgICAgIGFyaWFBcHBIaWRlci5oaWRlKGFwcEVsZW1lbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERvbid0IHN0ZWFsIGZvY3VzIGZyb20gaW5uZXIgZWxlbWVudHNcblxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX3Byb3BzMiA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgY2xhc3NOYW1lID0gX3Byb3BzMi5jbGFzc05hbWUsXG4gICAgICAgICAgb3ZlcmxheUNsYXNzTmFtZSA9IF9wcm9wczIub3ZlcmxheUNsYXNzTmFtZSxcbiAgICAgICAgICBkZWZhdWx0U3R5bGVzID0gX3Byb3BzMi5kZWZhdWx0U3R5bGVzO1xuXG4gICAgICB2YXIgY29udGVudFN0eWxlcyA9IGNsYXNzTmFtZSA/IHt9IDogZGVmYXVsdFN0eWxlcy5jb250ZW50O1xuICAgICAgdmFyIG92ZXJsYXlTdHlsZXMgPSBvdmVybGF5Q2xhc3NOYW1lID8ge30gOiBkZWZhdWx0U3R5bGVzLm92ZXJsYXk7XG5cbiAgICAgIHJldHVybiB0aGlzLnNob3VsZEJlQ2xvc2VkKCkgPyBudWxsIDogX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIFwiZGl2XCIsXG4gICAgICAgIHtcbiAgICAgICAgICByZWY6IHRoaXMuc2V0T3ZlcmxheVJlZixcbiAgICAgICAgICBjbGFzc05hbWU6IHRoaXMuYnVpbGRDbGFzc05hbWUoXCJvdmVybGF5XCIsIG92ZXJsYXlDbGFzc05hbWUpLFxuICAgICAgICAgIHN0eWxlOiBfZXh0ZW5kcyh7fSwgb3ZlcmxheVN0eWxlcywgdGhpcy5wcm9wcy5zdHlsZS5vdmVybGF5KSxcbiAgICAgICAgICBvbkNsaWNrOiB0aGlzLmhhbmRsZU92ZXJsYXlPbkNsaWNrLFxuICAgICAgICAgIG9uTW91c2VEb3duOiB0aGlzLmhhbmRsZU92ZXJsYXlPbk1vdXNlRG93bixcbiAgICAgICAgICBvbk1vdXNlVXA6IHRoaXMuaGFuZGxlT3ZlcmxheU9uTW91c2VVcCxcbiAgICAgICAgICBcImFyaWEtbW9kYWxcIjogXCJ0cnVlXCJcbiAgICAgICAgfSxcbiAgICAgICAgX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICBfZXh0ZW5kcyh7XG4gICAgICAgICAgICByZWY6IHRoaXMuc2V0Q29udGVudFJlZixcbiAgICAgICAgICAgIHN0eWxlOiBfZXh0ZW5kcyh7fSwgY29udGVudFN0eWxlcywgdGhpcy5wcm9wcy5zdHlsZS5jb250ZW50KSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogdGhpcy5idWlsZENsYXNzTmFtZShcImNvbnRlbnRcIiwgY2xhc3NOYW1lKSxcbiAgICAgICAgICAgIHRhYkluZGV4OiBcIi0xXCIsXG4gICAgICAgICAgICBvbktleURvd246IHRoaXMuaGFuZGxlS2V5RG93bixcbiAgICAgICAgICAgIG9uTW91c2VEb3duOiB0aGlzLmhhbmRsZUNvbnRlbnRPbk1vdXNlRG93bixcbiAgICAgICAgICAgIG9uTW91c2VVcDogdGhpcy5oYW5kbGVDb250ZW50T25Nb3VzZVVwLFxuICAgICAgICAgICAgb25DbGljazogdGhpcy5oYW5kbGVDb250ZW50T25DbGljayxcbiAgICAgICAgICAgIHJvbGU6IHRoaXMucHJvcHMucm9sZSxcbiAgICAgICAgICAgIFwiYXJpYS1sYWJlbFwiOiB0aGlzLnByb3BzLmNvbnRlbnRMYWJlbFxuICAgICAgICAgIH0sIHRoaXMuYXJpYUF0dHJpYnV0ZXModGhpcy5wcm9wcy5hcmlhIHx8IHt9KSksXG4gICAgICAgICAgdGhpcy5wcm9wcy5jaGlsZHJlblxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNb2RhbFBvcnRhbDtcbn0oX3JlYWN0LkNvbXBvbmVudCk7XG5cbk1vZGFsUG9ydGFsLmRlZmF1bHRQcm9wcyA9IHtcbiAgc3R5bGU6IHtcbiAgICBvdmVybGF5OiB7fSxcbiAgICBjb250ZW50OiB7fVxuICB9XG59O1xuTW9kYWxQb3J0YWwucHJvcFR5cGVzID0ge1xuICBpc09wZW46IF9wcm9wVHlwZXMyLmRlZmF1bHQuYm9vbC5pc1JlcXVpcmVkLFxuICBkZWZhdWx0U3R5bGVzOiBfcHJvcFR5cGVzMi5kZWZhdWx0LnNoYXBlKHtcbiAgICBjb250ZW50OiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9iamVjdCxcbiAgICBvdmVybGF5OiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9iamVjdFxuICB9KSxcbiAgc3R5bGU6IF9wcm9wVHlwZXMyLmRlZmF1bHQuc2hhcGUoe1xuICAgIGNvbnRlbnQ6IF9wcm9wVHlwZXMyLmRlZmF1bHQub2JqZWN0LFxuICAgIG92ZXJsYXk6IF9wcm9wVHlwZXMyLmRlZmF1bHQub2JqZWN0XG4gIH0pLFxuICBjbGFzc05hbWU6IF9wcm9wVHlwZXMyLmRlZmF1bHQub25lT2ZUeXBlKFtfcHJvcFR5cGVzMi5kZWZhdWx0LnN0cmluZywgX3Byb3BUeXBlczIuZGVmYXVsdC5vYmplY3RdKSxcbiAgb3ZlcmxheUNsYXNzTmFtZTogX3Byb3BUeXBlczIuZGVmYXVsdC5vbmVPZlR5cGUoW19wcm9wVHlwZXMyLmRlZmF1bHQuc3RyaW5nLCBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9iamVjdF0pLFxuICBib2R5T3BlbkNsYXNzTmFtZTogX3Byb3BUeXBlczIuZGVmYXVsdC5zdHJpbmcsXG4gIGFyaWFIaWRlQXBwOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmJvb2wsXG4gIGFwcEVsZW1lbnQ6IF9wcm9wVHlwZXMyLmRlZmF1bHQuaW5zdGFuY2VPZihfc2FmZUhUTUxFbGVtZW50Mi5kZWZhdWx0KSxcbiAgb25BZnRlck9wZW46IF9wcm9wVHlwZXMyLmRlZmF1bHQuZnVuYyxcbiAgb25SZXF1ZXN0Q2xvc2U6IF9wcm9wVHlwZXMyLmRlZmF1bHQuZnVuYyxcbiAgY2xvc2VUaW1lb3V0TVM6IF9wcm9wVHlwZXMyLmRlZmF1bHQubnVtYmVyLFxuICBzaG91bGRGb2N1c0FmdGVyUmVuZGVyOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmJvb2wsXG4gIHNob3VsZENsb3NlT25PdmVybGF5Q2xpY2s6IF9wcm9wVHlwZXMyLmRlZmF1bHQuYm9vbCxcbiAgc2hvdWxkUmV0dXJuRm9jdXNBZnRlckNsb3NlOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmJvb2wsXG4gIHJvbGU6IF9wcm9wVHlwZXMyLmRlZmF1bHQuc3RyaW5nLFxuICBjb250ZW50TGFiZWw6IF9wcm9wVHlwZXMyLmRlZmF1bHQuc3RyaW5nLFxuICBhcmlhOiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9iamVjdCxcbiAgY2hpbGRyZW46IF9wcm9wVHlwZXMyLmRlZmF1bHQubm9kZSxcbiAgc2hvdWxkQ2xvc2VPbkVzYzogX3Byb3BUeXBlczIuZGVmYXVsdC5ib29sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gTW9kYWxQb3J0YWw7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LW1vZGFsL2xpYi9jb21wb25lbnRzL01vZGFsUG9ydGFsLmpzXG4vLyBtb2R1bGUgaWQgPSA0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///45\n");

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.handleBlur = handleBlur;\nexports.handleFocus = handleFocus;\nexports.markForFocusLater = markForFocusLater;\nexports.returnFocus = returnFocus;\nexports.popWithoutFocus = popWithoutFocus;\nexports.setupScopedFocus = setupScopedFocus;\nexports.teardownScopedFocus = teardownScopedFocus;\n\nvar _tabbable = __webpack_require__(17);\n\nvar _tabbable2 = _interopRequireDefault(_tabbable);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar focusLaterElements = [];\nvar modalElement = null;\nvar needToFocus = false;\n\nfunction handleBlur() {\n  needToFocus = true;\n}\n\nfunction handleFocus() {\n  if (needToFocus) {\n    needToFocus = false;\n    if (!modalElement) {\n      return;\n    }\n    // need to see how jQuery shims document.on('focusin') so we don't need the\n    // setTimeout, firefox doesn't support focusin, if it did, we could focus\n    // the element outside of a setTimeout. Side-effect of this implementation\n    // is that the document.body gets focus, and then we focus our element right\n    // after, seems fine.\n    setTimeout(function () {\n      if (modalElement.contains(document.activeElement)) {\n        return;\n      }\n      var el = (0, _tabbable2.default)(modalElement)[0] || modalElement;\n      el.focus();\n    }, 0);\n  }\n}\n\nfunction markForFocusLater() {\n  focusLaterElements.push(document.activeElement);\n}\n\n/* eslint-disable no-console */\nfunction returnFocus() {\n  var toFocus = null;\n  try {\n    if (focusLaterElements.length !== 0) {\n      toFocus = focusLaterElements.pop();\n      toFocus.focus();\n    }\n    return;\n  } catch (e) {\n    console.warn([\"You tried to return focus to\", toFocus, \"but it is not in the DOM anymore\"].join(\" \"));\n  }\n}\n/* eslint-enable no-console */\n\nfunction popWithoutFocus() {\n  focusLaterElements.length > 0 && focusLaterElements.pop();\n}\n\nfunction setupScopedFocus(element) {\n  modalElement = element;\n\n  if (window.addEventListener) {\n    window.addEventListener(\"blur\", handleBlur, false);\n    document.addEventListener(\"focus\", handleFocus, true);\n  } else {\n    window.attachEvent(\"onBlur\", handleBlur);\n    document.attachEvent(\"onFocus\", handleFocus);\n  }\n}\n\nfunction teardownScopedFocus() {\n  modalElement = null;\n\n  if (window.addEventListener) {\n    window.removeEventListener(\"blur\", handleBlur);\n    document.removeEventListener(\"focus\", handleFocus);\n  } else {\n    window.detachEvent(\"onBlur\", handleBlur);\n    document.detachEvent(\"onFocus\", handleFocus);\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtbW9kYWwvbGliL2hlbHBlcnMvZm9jdXNNYW5hZ2VyLmpzPzllNzEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmhhbmRsZUJsdXIgPSBoYW5kbGVCbHVyO1xuZXhwb3J0cy5oYW5kbGVGb2N1cyA9IGhhbmRsZUZvY3VzO1xuZXhwb3J0cy5tYXJrRm9yRm9jdXNMYXRlciA9IG1hcmtGb3JGb2N1c0xhdGVyO1xuZXhwb3J0cy5yZXR1cm5Gb2N1cyA9IHJldHVybkZvY3VzO1xuZXhwb3J0cy5wb3BXaXRob3V0Rm9jdXMgPSBwb3BXaXRob3V0Rm9jdXM7XG5leHBvcnRzLnNldHVwU2NvcGVkRm9jdXMgPSBzZXR1cFNjb3BlZEZvY3VzO1xuZXhwb3J0cy50ZWFyZG93blNjb3BlZEZvY3VzID0gdGVhcmRvd25TY29wZWRGb2N1cztcblxudmFyIF90YWJiYWJsZSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL3RhYmJhYmxlXCIpO1xuXG52YXIgX3RhYmJhYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RhYmJhYmxlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGZvY3VzTGF0ZXJFbGVtZW50cyA9IFtdO1xudmFyIG1vZGFsRWxlbWVudCA9IG51bGw7XG52YXIgbmVlZFRvRm9jdXMgPSBmYWxzZTtcblxuZnVuY3Rpb24gaGFuZGxlQmx1cigpIHtcbiAgbmVlZFRvRm9jdXMgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVGb2N1cygpIHtcbiAgaWYgKG5lZWRUb0ZvY3VzKSB7XG4gICAgbmVlZFRvRm9jdXMgPSBmYWxzZTtcbiAgICBpZiAoIW1vZGFsRWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBuZWVkIHRvIHNlZSBob3cgalF1ZXJ5IHNoaW1zIGRvY3VtZW50Lm9uKCdmb2N1c2luJykgc28gd2UgZG9uJ3QgbmVlZCB0aGVcbiAgICAvLyBzZXRUaW1lb3V0LCBmaXJlZm94IGRvZXNuJ3Qgc3VwcG9ydCBmb2N1c2luLCBpZiBpdCBkaWQsIHdlIGNvdWxkIGZvY3VzXG4gICAgLy8gdGhlIGVsZW1lbnQgb3V0c2lkZSBvZiBhIHNldFRpbWVvdXQuIFNpZGUtZWZmZWN0IG9mIHRoaXMgaW1wbGVtZW50YXRpb25cbiAgICAvLyBpcyB0aGF0IHRoZSBkb2N1bWVudC5ib2R5IGdldHMgZm9jdXMsIGFuZCB0aGVuIHdlIGZvY3VzIG91ciBlbGVtZW50IHJpZ2h0XG4gICAgLy8gYWZ0ZXIsIHNlZW1zIGZpbmUuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAobW9kYWxFbGVtZW50LmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBlbCA9ICgwLCBfdGFiYmFibGUyLmRlZmF1bHQpKG1vZGFsRWxlbWVudClbMF0gfHwgbW9kYWxFbGVtZW50O1xuICAgICAgZWwuZm9jdXMoKTtcbiAgICB9LCAwKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrRm9yRm9jdXNMYXRlcigpIHtcbiAgZm9jdXNMYXRlckVsZW1lbnRzLnB1c2goZG9jdW1lbnQuYWN0aXZlRWxlbWVudCk7XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbmZ1bmN0aW9uIHJldHVybkZvY3VzKCkge1xuICB2YXIgdG9Gb2N1cyA9IG51bGw7XG4gIHRyeSB7XG4gICAgaWYgKGZvY3VzTGF0ZXJFbGVtZW50cy5sZW5ndGggIT09IDApIHtcbiAgICAgIHRvRm9jdXMgPSBmb2N1c0xhdGVyRWxlbWVudHMucG9wKCk7XG4gICAgICB0b0ZvY3VzLmZvY3VzKCk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUud2FybihbXCJZb3UgdHJpZWQgdG8gcmV0dXJuIGZvY3VzIHRvXCIsIHRvRm9jdXMsIFwiYnV0IGl0IGlzIG5vdCBpbiB0aGUgRE9NIGFueW1vcmVcIl0uam9pbihcIiBcIikpO1xuICB9XG59XG4vKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cblxuZnVuY3Rpb24gcG9wV2l0aG91dEZvY3VzKCkge1xuICBmb2N1c0xhdGVyRWxlbWVudHMubGVuZ3RoID4gMCAmJiBmb2N1c0xhdGVyRWxlbWVudHMucG9wKCk7XG59XG5cbmZ1bmN0aW9uIHNldHVwU2NvcGVkRm9jdXMoZWxlbWVudCkge1xuICBtb2RhbEVsZW1lbnQgPSBlbGVtZW50O1xuXG4gIGlmICh3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBoYW5kbGVCbHVyLCBmYWxzZSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIGhhbmRsZUZvY3VzLCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICB3aW5kb3cuYXR0YWNoRXZlbnQoXCJvbkJsdXJcIiwgaGFuZGxlQmx1cik7XG4gICAgZG9jdW1lbnQuYXR0YWNoRXZlbnQoXCJvbkZvY3VzXCIsIGhhbmRsZUZvY3VzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0ZWFyZG93blNjb3BlZEZvY3VzKCkge1xuICBtb2RhbEVsZW1lbnQgPSBudWxsO1xuXG4gIGlmICh3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmx1clwiLCBoYW5kbGVCbHVyKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgaGFuZGxlRm9jdXMpO1xuICB9IGVsc2Uge1xuICAgIHdpbmRvdy5kZXRhY2hFdmVudChcIm9uQmx1clwiLCBoYW5kbGVCbHVyKTtcbiAgICBkb2N1bWVudC5kZXRhY2hFdmVudChcIm9uRm9jdXNcIiwgaGFuZGxlRm9jdXMpO1xuICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtbW9kYWwvbGliL2hlbHBlcnMvZm9jdXNNYW5hZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///46\n");

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = scopeTab;\n\nvar _tabbable = __webpack_require__(17);\n\nvar _tabbable2 = _interopRequireDefault(_tabbable);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction scopeTab(node, event) {\n  var tabbable = (0, _tabbable2.default)(node);\n\n  if (!tabbable.length) {\n    // Do nothing, since there are no elements that can receive focus.\n    event.preventDefault();\n    return;\n  }\n\n  var shiftKey = event.shiftKey;\n  var head = tabbable[0];\n  var tail = tabbable[tabbable.length - 1];\n\n  // proceed with default browser behavior\n  if (node === document.activeElement) {\n    return;\n  }\n\n  var target;\n  if (tail === document.activeElement && !shiftKey) {\n    target = head;\n  }\n\n  if (head === document.activeElement && shiftKey) {\n    target = tail;\n  }\n\n  if (target) {\n    event.preventDefault();\n    target.focus();\n    return;\n  }\n\n  // Safari radio issue.\n  //\n  // Safari does not move the focus to the radio button,\n  // so we need to force it to really walk through all elements.\n  //\n  // This is very error prune, since we are trying to guess\n  // if it is a safari browser from the first occurence between\n  // chrome or safari.\n  //\n  // The chrome user agent contains the first ocurrence\n  // as the 'chrome/version' and later the 'safari/version'.\n  var checkSafari = /(\\bChrome\\b|\\bSafari\\b)\\//.exec(navigator.userAgent);\n  var isSafariDesktop = checkSafari != null && checkSafari[1] != \"Chrome\" && /\\biPod\\b|\\biPad\\b/g.exec(navigator.userAgent) == null;\n\n  // If we are not in safari desktop, let the browser control\n  // the focus\n  if (!isSafariDesktop) return;\n\n  var x = tabbable.indexOf(document.activeElement);\n\n  if (x > -1) {\n    x += shiftKey ? -1 : 1;\n  }\n\n  event.preventDefault();\n\n  tabbable[x].focus();\n}\nmodule.exports = exports[\"default\"];//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtbW9kYWwvbGliL2hlbHBlcnMvc2NvcGVUYWIuanM/NzhiNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHNjb3BlVGFiO1xuXG52YXIgX3RhYmJhYmxlID0gcmVxdWlyZShcIi4vdGFiYmFibGVcIik7XG5cbnZhciBfdGFiYmFibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGFiYmFibGUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBzY29wZVRhYihub2RlLCBldmVudCkge1xuICB2YXIgdGFiYmFibGUgPSAoMCwgX3RhYmJhYmxlMi5kZWZhdWx0KShub2RlKTtcblxuICBpZiAoIXRhYmJhYmxlLmxlbmd0aCkge1xuICAgIC8vIERvIG5vdGhpbmcsIHNpbmNlIHRoZXJlIGFyZSBubyBlbGVtZW50cyB0aGF0IGNhbiByZWNlaXZlIGZvY3VzLlxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHNoaWZ0S2V5ID0gZXZlbnQuc2hpZnRLZXk7XG4gIHZhciBoZWFkID0gdGFiYmFibGVbMF07XG4gIHZhciB0YWlsID0gdGFiYmFibGVbdGFiYmFibGUubGVuZ3RoIC0gMV07XG5cbiAgLy8gcHJvY2VlZCB3aXRoIGRlZmF1bHQgYnJvd3NlciBiZWhhdmlvclxuICBpZiAobm9kZSA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciB0YXJnZXQ7XG4gIGlmICh0YWlsID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmICFzaGlmdEtleSkge1xuICAgIHRhcmdldCA9IGhlYWQ7XG4gIH1cblxuICBpZiAoaGVhZCA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiBzaGlmdEtleSkge1xuICAgIHRhcmdldCA9IHRhaWw7XG4gIH1cblxuICBpZiAodGFyZ2V0KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB0YXJnZXQuZm9jdXMoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBTYWZhcmkgcmFkaW8gaXNzdWUuXG4gIC8vXG4gIC8vIFNhZmFyaSBkb2VzIG5vdCBtb3ZlIHRoZSBmb2N1cyB0byB0aGUgcmFkaW8gYnV0dG9uLFxuICAvLyBzbyB3ZSBuZWVkIHRvIGZvcmNlIGl0IHRvIHJlYWxseSB3YWxrIHRocm91Z2ggYWxsIGVsZW1lbnRzLlxuICAvL1xuICAvLyBUaGlzIGlzIHZlcnkgZXJyb3IgcHJ1bmUsIHNpbmNlIHdlIGFyZSB0cnlpbmcgdG8gZ3Vlc3NcbiAgLy8gaWYgaXQgaXMgYSBzYWZhcmkgYnJvd3NlciBmcm9tIHRoZSBmaXJzdCBvY2N1cmVuY2UgYmV0d2VlblxuICAvLyBjaHJvbWUgb3Igc2FmYXJpLlxuICAvL1xuICAvLyBUaGUgY2hyb21lIHVzZXIgYWdlbnQgY29udGFpbnMgdGhlIGZpcnN0IG9jdXJyZW5jZVxuICAvLyBhcyB0aGUgJ2Nocm9tZS92ZXJzaW9uJyBhbmQgbGF0ZXIgdGhlICdzYWZhcmkvdmVyc2lvbicuXG4gIHZhciBjaGVja1NhZmFyaSA9IC8oXFxiQ2hyb21lXFxifFxcYlNhZmFyaVxcYilcXC8vLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIHZhciBpc1NhZmFyaURlc2t0b3AgPSBjaGVja1NhZmFyaSAhPSBudWxsICYmIGNoZWNrU2FmYXJpWzFdICE9IFwiQ2hyb21lXCIgJiYgL1xcYmlQb2RcXGJ8XFxiaVBhZFxcYi9nLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudCkgPT0gbnVsbDtcblxuICAvLyBJZiB3ZSBhcmUgbm90IGluIHNhZmFyaSBkZXNrdG9wLCBsZXQgdGhlIGJyb3dzZXIgY29udHJvbFxuICAvLyB0aGUgZm9jdXNcbiAgaWYgKCFpc1NhZmFyaURlc2t0b3ApIHJldHVybjtcblxuICB2YXIgeCA9IHRhYmJhYmxlLmluZGV4T2YoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCk7XG5cbiAgaWYgKHggPiAtMSkge1xuICAgIHggKz0gc2hpZnRLZXkgPyAtMSA6IDE7XG4gIH1cblxuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gIHRhYmJhYmxlW3hdLmZvY3VzKCk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LW1vZGFsL2xpYi9oZWxwZXJzL3Njb3BlVGFiLmpzXG4vLyBtb2R1bGUgaWQgPSA0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///47\n");

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2014-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n\n\n/**\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar warning = function() {};\n\nif (process.env.NODE_ENV !== 'production') {\n  warning = function(condition, format, args) {\n    var len = arguments.length;\n    args = new Array(len > 2 ? len - 2 : 0);\n    for (var key = 2; key < len; key++) {\n      args[key - 2] = arguments[key];\n    }\n    if (format === undefined) {\n      throw new Error(\n        '`warning(condition, format, ...args)` requires a warning ' +\n        'message argument'\n      );\n    }\n\n    if (format.length < 10 || (/^[s\\W]*$/).test(format)) {\n      throw new Error(\n        'The warning format should be able to uniquely identify this ' +\n        'warning. Please, use a more descriptive format than: ' + format\n      );\n    }\n\n    if (!condition) {\n      var argIndex = 0;\n      var message = 'Warning: ' +\n        format.replace(/%s/g, function() {\n          return args[argIndex++];\n        });\n      if (typeof console !== 'undefined') {\n        console.error(message);\n      }\n      try {\n        // This error was thrown as a convenience so that you can use this stack\n        // to find the callsite that caused this warning to fire.\n        throw new Error(message);\n      } catch(x) {}\n    }\n  };\n}\n\nmodule.exports = warning;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd2FybmluZy9icm93c2VyLmpzPzFhZjAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xuXG52YXIgd2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHdhcm5pbmcgPSBmdW5jdGlvbihjb25kaXRpb24sIGZvcm1hdCwgYXJncykge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuID4gMiA/IGxlbiAtIDIgOiAwKTtcbiAgICBmb3IgKHZhciBrZXkgPSAyOyBrZXkgPCBsZW47IGtleSsrKSB7XG4gICAgICBhcmdzW2tleSAtIDJdID0gYXJndW1lbnRzW2tleV07XG4gICAgfVxuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArXG4gICAgICAgICdtZXNzYWdlIGFyZ3VtZW50J1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoZm9ybWF0Lmxlbmd0aCA8IDEwIHx8ICgvXltzXFxXXSokLykudGVzdChmb3JtYXQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdUaGUgd2FybmluZyBmb3JtYXQgc2hvdWxkIGJlIGFibGUgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyAnICtcbiAgICAgICAgJ3dhcm5pbmcuIFBsZWFzZSwgdXNlIGEgbW9yZSBkZXNjcmlwdGl2ZSBmb3JtYXQgdGhhbjogJyArIGZvcm1hdFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgK1xuICAgICAgICBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICAgIH0pO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICB9IGNhdGNoKHgpIHt9XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdhcm5pbmc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy93YXJuaW5nL2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///48\n");

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.add = add;\nexports.remove = remove;\n\nvar _refCount = __webpack_require__(19);\n\nvar refCount = _interopRequireWildcard(_refCount);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction add(bodyClass) {\n  // Increment class(es) on refCount tracker and add class(es) to body\n  bodyClass.split(\" \").map(refCount.add).forEach(function (className) {\n    return document.body.classList.add(className);\n  });\n}\n\nfunction remove(bodyClass) {\n  var classListMap = refCount.get();\n  // Decrement class(es) from the refCount tracker\n  // and remove unused class(es) from body\n  bodyClass.split(\" \").map(refCount.remove).filter(function (className) {\n    return classListMap[className] === 0;\n  }).forEach(function (className) {\n    return document.body.classList.remove(className);\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtbW9kYWwvbGliL2hlbHBlcnMvYm9keUNsYXNzTGlzdC5qcz81NDMzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5hZGQgPSBhZGQ7XG5leHBvcnRzLnJlbW92ZSA9IHJlbW92ZTtcblxudmFyIF9yZWZDb3VudCA9IHJlcXVpcmUoXCIuL3JlZkNvdW50XCIpO1xuXG52YXIgcmVmQ291bnQgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfcmVmQ291bnQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBhZGQoYm9keUNsYXNzKSB7XG4gIC8vIEluY3JlbWVudCBjbGFzcyhlcykgb24gcmVmQ291bnQgdHJhY2tlciBhbmQgYWRkIGNsYXNzKGVzKSB0byBib2R5XG4gIGJvZHlDbGFzcy5zcGxpdChcIiBcIikubWFwKHJlZkNvdW50LmFkZCkuZm9yRWFjaChmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlKGJvZHlDbGFzcykge1xuICB2YXIgY2xhc3NMaXN0TWFwID0gcmVmQ291bnQuZ2V0KCk7XG4gIC8vIERlY3JlbWVudCBjbGFzcyhlcykgZnJvbSB0aGUgcmVmQ291bnQgdHJhY2tlclxuICAvLyBhbmQgcmVtb3ZlIHVudXNlZCBjbGFzcyhlcykgZnJvbSBib2R5XG4gIGJvZHlDbGFzcy5zcGxpdChcIiBcIikubWFwKHJlZkNvdW50LnJlbW92ZSkuZmlsdGVyKGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcbiAgICByZXR1cm4gY2xhc3NMaXN0TWFwW2NsYXNzTmFtZV0gPT09IDA7XG4gIH0pLmZvckVhY2goZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuICAgIHJldHVybiBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcbiAgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtbW9kYWwvbGliL2hlbHBlcnMvYm9keUNsYXNzTGlzdC5qc1xuLy8gbW9kdWxlIGlkID0gNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///49\n");

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*!\n  Copyright (c) 2015 Jed Watson.\n  Based on code that is Copyright 2013-2015, Facebook, Inc.\n  All rights reserved.\n*/\n/* global define */\n\n(function () {\n\t'use strict';\n\n\tvar canUseDOM = !!(\n\t\ttypeof window !== 'undefined' &&\n\t\twindow.document &&\n\t\twindow.document.createElement\n\t);\n\n\tvar ExecutionEnvironment = {\n\n\t\tcanUseDOM: canUseDOM,\n\n\t\tcanUseWorkers: typeof Worker !== 'undefined',\n\n\t\tcanUseEventListeners:\n\t\t\tcanUseDOM && !!(window.addEventListener || window.attachEvent),\n\n\t\tcanUseViewport: canUseDOM && !!window.screen\n\n\t};\n\n\tif (true) {\n\t\t!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n\t\t\treturn ExecutionEnvironment;\n\t\t}).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else if (typeof module !== 'undefined' && module.exports) {\n\t\tmodule.exports = ExecutionEnvironment;\n\t} else {\n\t\twindow.ExecutionEnvironment = ExecutionEnvironment;\n\t}\n\n}());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXhlbnYvaW5kZXguanM/YmI4OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAgQ29weXJpZ2h0IChjKSAyMDE1IEplZCBXYXRzb24uXG4gIEJhc2VkIG9uIGNvZGUgdGhhdCBpcyBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKi9cbi8qIGdsb2JhbCBkZWZpbmUgKi9cblxuKGZ1bmN0aW9uICgpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBjYW5Vc2VET00gPSAhIShcblx0XHR0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuXHRcdHdpbmRvdy5kb2N1bWVudCAmJlxuXHRcdHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50XG5cdCk7XG5cblx0dmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0ge1xuXG5cdFx0Y2FuVXNlRE9NOiBjYW5Vc2VET00sXG5cblx0XHRjYW5Vc2VXb3JrZXJzOiB0eXBlb2YgV29ya2VyICE9PSAndW5kZWZpbmVkJyxcblxuXHRcdGNhblVzZUV2ZW50TGlzdGVuZXJzOlxuXHRcdFx0Y2FuVXNlRE9NICYmICEhKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyIHx8IHdpbmRvdy5hdHRhY2hFdmVudCksXG5cblx0XHRjYW5Vc2VWaWV3cG9ydDogY2FuVXNlRE9NICYmICEhd2luZG93LnNjcmVlblxuXG5cdH07XG5cblx0aWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT09ICdvYmplY3QnICYmIGRlZmluZS5hbWQpIHtcblx0XHRkZWZpbmUoZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIEV4ZWN1dGlvbkVudmlyb25tZW50O1xuXHRcdH0pO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBFeGVjdXRpb25FbnZpcm9ubWVudDtcblx0fSBlbHNlIHtcblx0XHR3aW5kb3cuRXhlY3V0aW9uRW52aXJvbm1lbnQgPSBFeGVjdXRpb25FbnZpcm9ubWVudDtcblx0fVxuXG59KCkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZXhlbnYvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///50\n");

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(52);\nif(typeof content === 'string') content = [[module.i, content, '']];\n// Prepare cssTransformation\nvar transform;\n\nvar options = {\"hmr\":true}\noptions.transform = transform\n// add the styles to the DOM\nvar update = __webpack_require__(22)(content, options);\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(false) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!../css-loader/index.js!../sass-loader/lib/loader.js!./normalize.css\", function() {\n\t\t\tvar newContent = require(\"!!../css-loader/index.js!../sass-loader/lib/loader.js!./normalize.css\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbm9ybWFsaXplLmNzcy9ub3JtYWxpemUuY3NzPzdjNTQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEuL25vcm1hbGl6ZS5jc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIFByZXBhcmUgY3NzVHJhbnNmb3JtYXRpb25cbnZhciB0cmFuc2Zvcm07XG5cbnZhciBvcHRpb25zID0ge1wiaG1yXCI6dHJ1ZX1cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vY3NzLWxvYWRlci9pbmRleC5qcyEuLi9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4vbm9ybWFsaXplLmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vY3NzLWxvYWRlci9pbmRleC5qcyEuLi9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4vbm9ybWFsaXplLmNzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbm9ybWFsaXplLmNzcy9ub3JtYWxpemUuY3NzXG4vLyBtb2R1bGUgaWQgPSA1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///51\n");

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(21)(false);\n// imports\n\n\n// module\nexports.push([module.i, \"/*! normalize.css v7.0.0 | MIT License | github.com/necolas/normalize.css */\\n/* Document\\n   ========================================================================== */\\n/**\\n * 1. Correct the line height in all browsers.\\n * 2. Prevent adjustments of font size after orientation changes in\\n *    IE on Windows Phone and in iOS.\\n */\\nhtml {\\n  line-height: 1.15;\\n  /* 1 */\\n  -ms-text-size-adjust: 100%;\\n  /* 2 */\\n  -webkit-text-size-adjust: 100%;\\n  /* 2 */ }\\n\\n/* Sections\\n   ========================================================================== */\\n/**\\n * Remove the margin in all browsers (opinionated).\\n */\\nbody {\\n  margin: 0; }\\n\\n/**\\n * Add the correct display in IE 9-.\\n */\\narticle,\\naside,\\nfooter,\\nheader,\\nnav,\\nsection {\\n  display: block; }\\n\\n/**\\n * Correct the font size and margin on `h1` elements within `section` and\\n * `article` contexts in Chrome, Firefox, and Safari.\\n */\\nh1 {\\n  font-size: 2em;\\n  margin: 0.67em 0; }\\n\\n/* Grouping content\\n   ========================================================================== */\\n/**\\n * Add the correct display in IE 9-.\\n * 1. Add the correct display in IE.\\n */\\nfigcaption,\\nfigure,\\nmain {\\n  /* 1 */\\n  display: block; }\\n\\n/**\\n * Add the correct margin in IE 8.\\n */\\nfigure {\\n  margin: 1em 40px; }\\n\\n/**\\n * 1. Add the correct box sizing in Firefox.\\n * 2. Show the overflow in Edge and IE.\\n */\\nhr {\\n  box-sizing: content-box;\\n  /* 1 */\\n  height: 0;\\n  /* 1 */\\n  overflow: visible;\\n  /* 2 */ }\\n\\n/**\\n * 1. Correct the inheritance and scaling of font size in all browsers.\\n * 2. Correct the odd `em` font sizing in all browsers.\\n */\\npre {\\n  font-family: monospace, monospace;\\n  /* 1 */\\n  font-size: 1em;\\n  /* 2 */ }\\n\\n/* Text-level semantics\\n   ========================================================================== */\\n/**\\n * 1. Remove the gray background on active links in IE 10.\\n * 2. Remove gaps in links underline in iOS 8+ and Safari 8+.\\n */\\na {\\n  background-color: transparent;\\n  /* 1 */\\n  -webkit-text-decoration-skip: objects;\\n  /* 2 */ }\\n\\n/**\\n * 1. Remove the bottom border in Chrome 57- and Firefox 39-.\\n * 2. Add the correct text decoration in Chrome, Edge, IE, Opera, and Safari.\\n */\\nabbr[title] {\\n  border-bottom: none;\\n  /* 1 */\\n  text-decoration: underline;\\n  /* 2 */\\n  text-decoration: underline dotted;\\n  /* 2 */ }\\n\\n/**\\n * Prevent the duplicate application of `bolder` by the next rule in Safari 6.\\n */\\nb,\\nstrong {\\n  font-weight: inherit; }\\n\\n/**\\n * Add the correct font weight in Chrome, Edge, and Safari.\\n */\\nb,\\nstrong {\\n  font-weight: bolder; }\\n\\n/**\\n * 1. Correct the inheritance and scaling of font size in all browsers.\\n * 2. Correct the odd `em` font sizing in all browsers.\\n */\\ncode,\\nkbd,\\nsamp {\\n  font-family: monospace, monospace;\\n  /* 1 */\\n  font-size: 1em;\\n  /* 2 */ }\\n\\n/**\\n * Add the correct font style in Android 4.3-.\\n */\\ndfn {\\n  font-style: italic; }\\n\\n/**\\n * Add the correct background and color in IE 9-.\\n */\\nmark {\\n  background-color: #ff0;\\n  color: #000; }\\n\\n/**\\n * Add the correct font size in all browsers.\\n */\\nsmall {\\n  font-size: 80%; }\\n\\n/**\\n * Prevent `sub` and `sup` elements from affecting the line height in\\n * all browsers.\\n */\\nsub,\\nsup {\\n  font-size: 75%;\\n  line-height: 0;\\n  position: relative;\\n  vertical-align: baseline; }\\n\\nsub {\\n  bottom: -0.25em; }\\n\\nsup {\\n  top: -0.5em; }\\n\\n/* Embedded content\\n   ========================================================================== */\\n/**\\n * Add the correct display in IE 9-.\\n */\\naudio,\\nvideo {\\n  display: inline-block; }\\n\\n/**\\n * Add the correct display in iOS 4-7.\\n */\\naudio:not([controls]) {\\n  display: none;\\n  height: 0; }\\n\\n/**\\n * Remove the border on images inside links in IE 10-.\\n */\\nimg {\\n  border-style: none; }\\n\\n/**\\n * Hide the overflow in IE.\\n */\\nsvg:not(:root) {\\n  overflow: hidden; }\\n\\n/* Forms\\n   ========================================================================== */\\n/**\\n * 1. Change the font styles in all browsers (opinionated).\\n * 2. Remove the margin in Firefox and Safari.\\n */\\nbutton,\\ninput,\\noptgroup,\\nselect,\\ntextarea {\\n  font-family: sans-serif;\\n  /* 1 */\\n  font-size: 100%;\\n  /* 1 */\\n  line-height: 1.15;\\n  /* 1 */\\n  margin: 0;\\n  /* 2 */ }\\n\\n/**\\n * Show the overflow in IE.\\n * 1. Show the overflow in Edge.\\n */\\nbutton,\\ninput {\\n  /* 1 */\\n  overflow: visible; }\\n\\n/**\\n * Remove the inheritance of text transform in Edge, Firefox, and IE.\\n * 1. Remove the inheritance of text transform in Firefox.\\n */\\nbutton,\\nselect {\\n  /* 1 */\\n  text-transform: none; }\\n\\n/**\\n * 1. Prevent a WebKit bug where (2) destroys native `audio` and `video`\\n *    controls in Android 4.\\n * 2. Correct the inability to style clickable types in iOS and Safari.\\n */\\nbutton,\\nhtml [type=\\\"button\\\"],\\n[type=\\\"reset\\\"],\\n[type=\\\"submit\\\"] {\\n  -webkit-appearance: button;\\n  /* 2 */ }\\n\\n/**\\n * Remove the inner border and padding in Firefox.\\n */\\nbutton::-moz-focus-inner,\\n[type=\\\"button\\\"]::-moz-focus-inner,\\n[type=\\\"reset\\\"]::-moz-focus-inner,\\n[type=\\\"submit\\\"]::-moz-focus-inner {\\n  border-style: none;\\n  padding: 0; }\\n\\n/**\\n * Restore the focus styles unset by the previous rule.\\n */\\nbutton:-moz-focusring,\\n[type=\\\"button\\\"]:-moz-focusring,\\n[type=\\\"reset\\\"]:-moz-focusring,\\n[type=\\\"submit\\\"]:-moz-focusring {\\n  outline: 1px dotted ButtonText; }\\n\\n/**\\n * Correct the padding in Firefox.\\n */\\nfieldset {\\n  padding: 0.35em 0.75em 0.625em; }\\n\\n/**\\n * 1. Correct the text wrapping in Edge and IE.\\n * 2. Correct the color inheritance from `fieldset` elements in IE.\\n * 3. Remove the padding so developers are not caught out when they zero out\\n *    `fieldset` elements in all browsers.\\n */\\nlegend {\\n  box-sizing: border-box;\\n  /* 1 */\\n  color: inherit;\\n  /* 2 */\\n  display: table;\\n  /* 1 */\\n  max-width: 100%;\\n  /* 1 */\\n  padding: 0;\\n  /* 3 */\\n  white-space: normal;\\n  /* 1 */ }\\n\\n/**\\n * 1. Add the correct display in IE 9-.\\n * 2. Add the correct vertical alignment in Chrome, Firefox, and Opera.\\n */\\nprogress {\\n  display: inline-block;\\n  /* 1 */\\n  vertical-align: baseline;\\n  /* 2 */ }\\n\\n/**\\n * Remove the default vertical scrollbar in IE.\\n */\\ntextarea {\\n  overflow: auto; }\\n\\n/**\\n * 1. Add the correct box sizing in IE 10-.\\n * 2. Remove the padding in IE 10-.\\n */\\n[type=\\\"checkbox\\\"],\\n[type=\\\"radio\\\"] {\\n  box-sizing: border-box;\\n  /* 1 */\\n  padding: 0;\\n  /* 2 */ }\\n\\n/**\\n * Correct the cursor style of increment and decrement buttons in Chrome.\\n */\\n[type=\\\"number\\\"]::-webkit-inner-spin-button,\\n[type=\\\"number\\\"]::-webkit-outer-spin-button {\\n  height: auto; }\\n\\n/**\\n * 1. Correct the odd appearance in Chrome and Safari.\\n * 2. Correct the outline style in Safari.\\n */\\n[type=\\\"search\\\"] {\\n  -webkit-appearance: textfield;\\n  /* 1 */\\n  outline-offset: -2px;\\n  /* 2 */ }\\n\\n/**\\n * Remove the inner padding and cancel buttons in Chrome and Safari on macOS.\\n */\\n[type=\\\"search\\\"]::-webkit-search-cancel-button,\\n[type=\\\"search\\\"]::-webkit-search-decoration {\\n  -webkit-appearance: none; }\\n\\n/**\\n * 1. Correct the inability to style clickable types in iOS and Safari.\\n * 2. Change font properties to `inherit` in Safari.\\n */\\n::-webkit-file-upload-button {\\n  -webkit-appearance: button;\\n  /* 1 */\\n  font: inherit;\\n  /* 2 */ }\\n\\n/* Interactive\\n   ========================================================================== */\\n/*\\n * Add the correct display in IE 9-.\\n * 1. Add the correct display in Edge, IE, and Firefox.\\n */\\ndetails,\\nmenu {\\n  display: block; }\\n\\n/*\\n * Add the correct display in all browsers.\\n */\\nsummary {\\n  display: list-item; }\\n\\n/* Scripting\\n   ========================================================================== */\\n/**\\n * Add the correct display in IE 9-.\\n */\\ncanvas {\\n  display: inline-block; }\\n\\n/**\\n * Add the correct display in IE.\\n */\\ntemplate {\\n  display: none; }\\n\\n/* Hidden\\n   ========================================================================== */\\n/**\\n * Add the correct display in IE 10-.\\n */\\n[hidden] {\\n  display: none; }\\n\", \"\"]);\n\n// exports\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbm9ybWFsaXplLmNzcy9ub3JtYWxpemUuY3NzPzBmMTIiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi8qISBub3JtYWxpemUuY3NzIHY3LjAuMCB8IE1JVCBMaWNlbnNlIHwgZ2l0aHViLmNvbS9uZWNvbGFzL25vcm1hbGl6ZS5jc3MgKi9cXG4vKiBEb2N1bWVudFxcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuLyoqXFxuICogMS4gQ29ycmVjdCB0aGUgbGluZSBoZWlnaHQgaW4gYWxsIGJyb3dzZXJzLlxcbiAqIDIuIFByZXZlbnQgYWRqdXN0bWVudHMgb2YgZm9udCBzaXplIGFmdGVyIG9yaWVudGF0aW9uIGNoYW5nZXMgaW5cXG4gKiAgICBJRSBvbiBXaW5kb3dzIFBob25lIGFuZCBpbiBpT1MuXFxuICovXFxuaHRtbCB7XFxuICBsaW5lLWhlaWdodDogMS4xNTtcXG4gIC8qIDEgKi9cXG4gIC1tcy10ZXh0LXNpemUtYWRqdXN0OiAxMDAlO1xcbiAgLyogMiAqL1xcbiAgLXdlYmtpdC10ZXh0LXNpemUtYWRqdXN0OiAxMDAlO1xcbiAgLyogMiAqLyB9XFxuXFxuLyogU2VjdGlvbnNcXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcbi8qKlxcbiAqIFJlbW92ZSB0aGUgbWFyZ2luIGluIGFsbCBicm93c2VycyAob3BpbmlvbmF0ZWQpLlxcbiAqL1xcbmJvZHkge1xcbiAgbWFyZ2luOiAwOyB9XFxuXFxuLyoqXFxuICogQWRkIHRoZSBjb3JyZWN0IGRpc3BsYXkgaW4gSUUgOS0uXFxuICovXFxuYXJ0aWNsZSxcXG5hc2lkZSxcXG5mb290ZXIsXFxuaGVhZGVyLFxcbm5hdixcXG5zZWN0aW9uIHtcXG4gIGRpc3BsYXk6IGJsb2NrOyB9XFxuXFxuLyoqXFxuICogQ29ycmVjdCB0aGUgZm9udCBzaXplIGFuZCBtYXJnaW4gb24gYGgxYCBlbGVtZW50cyB3aXRoaW4gYHNlY3Rpb25gIGFuZFxcbiAqIGBhcnRpY2xlYCBjb250ZXh0cyBpbiBDaHJvbWUsIEZpcmVmb3gsIGFuZCBTYWZhcmkuXFxuICovXFxuaDEge1xcbiAgZm9udC1zaXplOiAyZW07XFxuICBtYXJnaW46IDAuNjdlbSAwOyB9XFxuXFxuLyogR3JvdXBpbmcgY29udGVudFxcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuLyoqXFxuICogQWRkIHRoZSBjb3JyZWN0IGRpc3BsYXkgaW4gSUUgOS0uXFxuICogMS4gQWRkIHRoZSBjb3JyZWN0IGRpc3BsYXkgaW4gSUUuXFxuICovXFxuZmlnY2FwdGlvbixcXG5maWd1cmUsXFxubWFpbiB7XFxuICAvKiAxICovXFxuICBkaXNwbGF5OiBibG9jazsgfVxcblxcbi8qKlxcbiAqIEFkZCB0aGUgY29ycmVjdCBtYXJnaW4gaW4gSUUgOC5cXG4gKi9cXG5maWd1cmUge1xcbiAgbWFyZ2luOiAxZW0gNDBweDsgfVxcblxcbi8qKlxcbiAqIDEuIEFkZCB0aGUgY29ycmVjdCBib3ggc2l6aW5nIGluIEZpcmVmb3guXFxuICogMi4gU2hvdyB0aGUgb3ZlcmZsb3cgaW4gRWRnZSBhbmQgSUUuXFxuICovXFxuaHIge1xcbiAgYm94LXNpemluZzogY29udGVudC1ib3g7XFxuICAvKiAxICovXFxuICBoZWlnaHQ6IDA7XFxuICAvKiAxICovXFxuICBvdmVyZmxvdzogdmlzaWJsZTtcXG4gIC8qIDIgKi8gfVxcblxcbi8qKlxcbiAqIDEuIENvcnJlY3QgdGhlIGluaGVyaXRhbmNlIGFuZCBzY2FsaW5nIG9mIGZvbnQgc2l6ZSBpbiBhbGwgYnJvd3NlcnMuXFxuICogMi4gQ29ycmVjdCB0aGUgb2RkIGBlbWAgZm9udCBzaXppbmcgaW4gYWxsIGJyb3dzZXJzLlxcbiAqL1xcbnByZSB7XFxuICBmb250LWZhbWlseTogbW9ub3NwYWNlLCBtb25vc3BhY2U7XFxuICAvKiAxICovXFxuICBmb250LXNpemU6IDFlbTtcXG4gIC8qIDIgKi8gfVxcblxcbi8qIFRleHQtbGV2ZWwgc2VtYW50aWNzXFxuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG4vKipcXG4gKiAxLiBSZW1vdmUgdGhlIGdyYXkgYmFja2dyb3VuZCBvbiBhY3RpdmUgbGlua3MgaW4gSUUgMTAuXFxuICogMi4gUmVtb3ZlIGdhcHMgaW4gbGlua3MgdW5kZXJsaW5lIGluIGlPUyA4KyBhbmQgU2FmYXJpIDgrLlxcbiAqL1xcbmEge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAvKiAxICovXFxuICAtd2Via2l0LXRleHQtZGVjb3JhdGlvbi1za2lwOiBvYmplY3RzO1xcbiAgLyogMiAqLyB9XFxuXFxuLyoqXFxuICogMS4gUmVtb3ZlIHRoZSBib3R0b20gYm9yZGVyIGluIENocm9tZSA1Ny0gYW5kIEZpcmVmb3ggMzktLlxcbiAqIDIuIEFkZCB0aGUgY29ycmVjdCB0ZXh0IGRlY29yYXRpb24gaW4gQ2hyb21lLCBFZGdlLCBJRSwgT3BlcmEsIGFuZCBTYWZhcmkuXFxuICovXFxuYWJiclt0aXRsZV0ge1xcbiAgYm9yZGVyLWJvdHRvbTogbm9uZTtcXG4gIC8qIDEgKi9cXG4gIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xcbiAgLyogMiAqL1xcbiAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmUgZG90dGVkO1xcbiAgLyogMiAqLyB9XFxuXFxuLyoqXFxuICogUHJldmVudCB0aGUgZHVwbGljYXRlIGFwcGxpY2F0aW9uIG9mIGBib2xkZXJgIGJ5IHRoZSBuZXh0IHJ1bGUgaW4gU2FmYXJpIDYuXFxuICovXFxuYixcXG5zdHJvbmcge1xcbiAgZm9udC13ZWlnaHQ6IGluaGVyaXQ7IH1cXG5cXG4vKipcXG4gKiBBZGQgdGhlIGNvcnJlY3QgZm9udCB3ZWlnaHQgaW4gQ2hyb21lLCBFZGdlLCBhbmQgU2FmYXJpLlxcbiAqL1xcbmIsXFxuc3Ryb25nIHtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkZXI7IH1cXG5cXG4vKipcXG4gKiAxLiBDb3JyZWN0IHRoZSBpbmhlcml0YW5jZSBhbmQgc2NhbGluZyBvZiBmb250IHNpemUgaW4gYWxsIGJyb3dzZXJzLlxcbiAqIDIuIENvcnJlY3QgdGhlIG9kZCBgZW1gIGZvbnQgc2l6aW5nIGluIGFsbCBicm93c2Vycy5cXG4gKi9cXG5jb2RlLFxcbmtiZCxcXG5zYW1wIHtcXG4gIGZvbnQtZmFtaWx5OiBtb25vc3BhY2UsIG1vbm9zcGFjZTtcXG4gIC8qIDEgKi9cXG4gIGZvbnQtc2l6ZTogMWVtO1xcbiAgLyogMiAqLyB9XFxuXFxuLyoqXFxuICogQWRkIHRoZSBjb3JyZWN0IGZvbnQgc3R5bGUgaW4gQW5kcm9pZCA0LjMtLlxcbiAqL1xcbmRmbiB7XFxuICBmb250LXN0eWxlOiBpdGFsaWM7IH1cXG5cXG4vKipcXG4gKiBBZGQgdGhlIGNvcnJlY3QgYmFja2dyb3VuZCBhbmQgY29sb3IgaW4gSUUgOS0uXFxuICovXFxubWFyayB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmYwO1xcbiAgY29sb3I6ICMwMDA7IH1cXG5cXG4vKipcXG4gKiBBZGQgdGhlIGNvcnJlY3QgZm9udCBzaXplIGluIGFsbCBicm93c2Vycy5cXG4gKi9cXG5zbWFsbCB7XFxuICBmb250LXNpemU6IDgwJTsgfVxcblxcbi8qKlxcbiAqIFByZXZlbnQgYHN1YmAgYW5kIGBzdXBgIGVsZW1lbnRzIGZyb20gYWZmZWN0aW5nIHRoZSBsaW5lIGhlaWdodCBpblxcbiAqIGFsbCBicm93c2Vycy5cXG4gKi9cXG5zdWIsXFxuc3VwIHtcXG4gIGZvbnQtc2l6ZTogNzUlO1xcbiAgbGluZS1oZWlnaHQ6IDA7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICB2ZXJ0aWNhbC1hbGlnbjogYmFzZWxpbmU7IH1cXG5cXG5zdWIge1xcbiAgYm90dG9tOiAtMC4yNWVtOyB9XFxuXFxuc3VwIHtcXG4gIHRvcDogLTAuNWVtOyB9XFxuXFxuLyogRW1iZWRkZWQgY29udGVudFxcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuLyoqXFxuICogQWRkIHRoZSBjb3JyZWN0IGRpc3BsYXkgaW4gSUUgOS0uXFxuICovXFxuYXVkaW8sXFxudmlkZW8ge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrOyB9XFxuXFxuLyoqXFxuICogQWRkIHRoZSBjb3JyZWN0IGRpc3BsYXkgaW4gaU9TIDQtNy5cXG4gKi9cXG5hdWRpbzpub3QoW2NvbnRyb2xzXSkge1xcbiAgZGlzcGxheTogbm9uZTtcXG4gIGhlaWdodDogMDsgfVxcblxcbi8qKlxcbiAqIFJlbW92ZSB0aGUgYm9yZGVyIG9uIGltYWdlcyBpbnNpZGUgbGlua3MgaW4gSUUgMTAtLlxcbiAqL1xcbmltZyB7XFxuICBib3JkZXItc3R5bGU6IG5vbmU7IH1cXG5cXG4vKipcXG4gKiBIaWRlIHRoZSBvdmVyZmxvdyBpbiBJRS5cXG4gKi9cXG5zdmc6bm90KDpyb290KSB7XFxuICBvdmVyZmxvdzogaGlkZGVuOyB9XFxuXFxuLyogRm9ybXNcXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcbi8qKlxcbiAqIDEuIENoYW5nZSB0aGUgZm9udCBzdHlsZXMgaW4gYWxsIGJyb3dzZXJzIChvcGluaW9uYXRlZCkuXFxuICogMi4gUmVtb3ZlIHRoZSBtYXJnaW4gaW4gRmlyZWZveCBhbmQgU2FmYXJpLlxcbiAqL1xcbmJ1dHRvbixcXG5pbnB1dCxcXG5vcHRncm91cCxcXG5zZWxlY3QsXFxudGV4dGFyZWEge1xcbiAgZm9udC1mYW1pbHk6IHNhbnMtc2VyaWY7XFxuICAvKiAxICovXFxuICBmb250LXNpemU6IDEwMCU7XFxuICAvKiAxICovXFxuICBsaW5lLWhlaWdodDogMS4xNTtcXG4gIC8qIDEgKi9cXG4gIG1hcmdpbjogMDtcXG4gIC8qIDIgKi8gfVxcblxcbi8qKlxcbiAqIFNob3cgdGhlIG92ZXJmbG93IGluIElFLlxcbiAqIDEuIFNob3cgdGhlIG92ZXJmbG93IGluIEVkZ2UuXFxuICovXFxuYnV0dG9uLFxcbmlucHV0IHtcXG4gIC8qIDEgKi9cXG4gIG92ZXJmbG93OiB2aXNpYmxlOyB9XFxuXFxuLyoqXFxuICogUmVtb3ZlIHRoZSBpbmhlcml0YW5jZSBvZiB0ZXh0IHRyYW5zZm9ybSBpbiBFZGdlLCBGaXJlZm94LCBhbmQgSUUuXFxuICogMS4gUmVtb3ZlIHRoZSBpbmhlcml0YW5jZSBvZiB0ZXh0IHRyYW5zZm9ybSBpbiBGaXJlZm94LlxcbiAqL1xcbmJ1dHRvbixcXG5zZWxlY3Qge1xcbiAgLyogMSAqL1xcbiAgdGV4dC10cmFuc2Zvcm06IG5vbmU7IH1cXG5cXG4vKipcXG4gKiAxLiBQcmV2ZW50IGEgV2ViS2l0IGJ1ZyB3aGVyZSAoMikgZGVzdHJveXMgbmF0aXZlIGBhdWRpb2AgYW5kIGB2aWRlb2BcXG4gKiAgICBjb250cm9scyBpbiBBbmRyb2lkIDQuXFxuICogMi4gQ29ycmVjdCB0aGUgaW5hYmlsaXR5IHRvIHN0eWxlIGNsaWNrYWJsZSB0eXBlcyBpbiBpT1MgYW5kIFNhZmFyaS5cXG4gKi9cXG5idXR0b24sXFxuaHRtbCBbdHlwZT1cXFwiYnV0dG9uXFxcIl0sXFxuW3R5cGU9XFxcInJlc2V0XFxcIl0sXFxuW3R5cGU9XFxcInN1Ym1pdFxcXCJdIHtcXG4gIC13ZWJraXQtYXBwZWFyYW5jZTogYnV0dG9uO1xcbiAgLyogMiAqLyB9XFxuXFxuLyoqXFxuICogUmVtb3ZlIHRoZSBpbm5lciBib3JkZXIgYW5kIHBhZGRpbmcgaW4gRmlyZWZveC5cXG4gKi9cXG5idXR0b246Oi1tb3otZm9jdXMtaW5uZXIsXFxuW3R5cGU9XFxcImJ1dHRvblxcXCJdOjotbW96LWZvY3VzLWlubmVyLFxcblt0eXBlPVxcXCJyZXNldFxcXCJdOjotbW96LWZvY3VzLWlubmVyLFxcblt0eXBlPVxcXCJzdWJtaXRcXFwiXTo6LW1vei1mb2N1cy1pbm5lciB7XFxuICBib3JkZXItc3R5bGU6IG5vbmU7XFxuICBwYWRkaW5nOiAwOyB9XFxuXFxuLyoqXFxuICogUmVzdG9yZSB0aGUgZm9jdXMgc3R5bGVzIHVuc2V0IGJ5IHRoZSBwcmV2aW91cyBydWxlLlxcbiAqL1xcbmJ1dHRvbjotbW96LWZvY3VzcmluZyxcXG5bdHlwZT1cXFwiYnV0dG9uXFxcIl06LW1vei1mb2N1c3JpbmcsXFxuW3R5cGU9XFxcInJlc2V0XFxcIl06LW1vei1mb2N1c3JpbmcsXFxuW3R5cGU9XFxcInN1Ym1pdFxcXCJdOi1tb3otZm9jdXNyaW5nIHtcXG4gIG91dGxpbmU6IDFweCBkb3R0ZWQgQnV0dG9uVGV4dDsgfVxcblxcbi8qKlxcbiAqIENvcnJlY3QgdGhlIHBhZGRpbmcgaW4gRmlyZWZveC5cXG4gKi9cXG5maWVsZHNldCB7XFxuICBwYWRkaW5nOiAwLjM1ZW0gMC43NWVtIDAuNjI1ZW07IH1cXG5cXG4vKipcXG4gKiAxLiBDb3JyZWN0IHRoZSB0ZXh0IHdyYXBwaW5nIGluIEVkZ2UgYW5kIElFLlxcbiAqIDIuIENvcnJlY3QgdGhlIGNvbG9yIGluaGVyaXRhbmNlIGZyb20gYGZpZWxkc2V0YCBlbGVtZW50cyBpbiBJRS5cXG4gKiAzLiBSZW1vdmUgdGhlIHBhZGRpbmcgc28gZGV2ZWxvcGVycyBhcmUgbm90IGNhdWdodCBvdXQgd2hlbiB0aGV5IHplcm8gb3V0XFxuICogICAgYGZpZWxkc2V0YCBlbGVtZW50cyBpbiBhbGwgYnJvd3NlcnMuXFxuICovXFxubGVnZW5kIHtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICAvKiAxICovXFxuICBjb2xvcjogaW5oZXJpdDtcXG4gIC8qIDIgKi9cXG4gIGRpc3BsYXk6IHRhYmxlO1xcbiAgLyogMSAqL1xcbiAgbWF4LXdpZHRoOiAxMDAlO1xcbiAgLyogMSAqL1xcbiAgcGFkZGluZzogMDtcXG4gIC8qIDMgKi9cXG4gIHdoaXRlLXNwYWNlOiBub3JtYWw7XFxuICAvKiAxICovIH1cXG5cXG4vKipcXG4gKiAxLiBBZGQgdGhlIGNvcnJlY3QgZGlzcGxheSBpbiBJRSA5LS5cXG4gKiAyLiBBZGQgdGhlIGNvcnJlY3QgdmVydGljYWwgYWxpZ25tZW50IGluIENocm9tZSwgRmlyZWZveCwgYW5kIE9wZXJhLlxcbiAqL1xcbnByb2dyZXNzIHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIC8qIDEgKi9cXG4gIHZlcnRpY2FsLWFsaWduOiBiYXNlbGluZTtcXG4gIC8qIDIgKi8gfVxcblxcbi8qKlxcbiAqIFJlbW92ZSB0aGUgZGVmYXVsdCB2ZXJ0aWNhbCBzY3JvbGxiYXIgaW4gSUUuXFxuICovXFxudGV4dGFyZWEge1xcbiAgb3ZlcmZsb3c6IGF1dG87IH1cXG5cXG4vKipcXG4gKiAxLiBBZGQgdGhlIGNvcnJlY3QgYm94IHNpemluZyBpbiBJRSAxMC0uXFxuICogMi4gUmVtb3ZlIHRoZSBwYWRkaW5nIGluIElFIDEwLS5cXG4gKi9cXG5bdHlwZT1cXFwiY2hlY2tib3hcXFwiXSxcXG5bdHlwZT1cXFwicmFkaW9cXFwiXSB7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgLyogMSAqL1xcbiAgcGFkZGluZzogMDtcXG4gIC8qIDIgKi8gfVxcblxcbi8qKlxcbiAqIENvcnJlY3QgdGhlIGN1cnNvciBzdHlsZSBvZiBpbmNyZW1lbnQgYW5kIGRlY3JlbWVudCBidXR0b25zIGluIENocm9tZS5cXG4gKi9cXG5bdHlwZT1cXFwibnVtYmVyXFxcIl06Oi13ZWJraXQtaW5uZXItc3Bpbi1idXR0b24sXFxuW3R5cGU9XFxcIm51bWJlclxcXCJdOjotd2Via2l0LW91dGVyLXNwaW4tYnV0dG9uIHtcXG4gIGhlaWdodDogYXV0bzsgfVxcblxcbi8qKlxcbiAqIDEuIENvcnJlY3QgdGhlIG9kZCBhcHBlYXJhbmNlIGluIENocm9tZSBhbmQgU2FmYXJpLlxcbiAqIDIuIENvcnJlY3QgdGhlIG91dGxpbmUgc3R5bGUgaW4gU2FmYXJpLlxcbiAqL1xcblt0eXBlPVxcXCJzZWFyY2hcXFwiXSB7XFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IHRleHRmaWVsZDtcXG4gIC8qIDEgKi9cXG4gIG91dGxpbmUtb2Zmc2V0OiAtMnB4O1xcbiAgLyogMiAqLyB9XFxuXFxuLyoqXFxuICogUmVtb3ZlIHRoZSBpbm5lciBwYWRkaW5nIGFuZCBjYW5jZWwgYnV0dG9ucyBpbiBDaHJvbWUgYW5kIFNhZmFyaSBvbiBtYWNPUy5cXG4gKi9cXG5bdHlwZT1cXFwic2VhcmNoXFxcIl06Oi13ZWJraXQtc2VhcmNoLWNhbmNlbC1idXR0b24sXFxuW3R5cGU9XFxcInNlYXJjaFxcXCJdOjotd2Via2l0LXNlYXJjaC1kZWNvcmF0aW9uIHtcXG4gIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTsgfVxcblxcbi8qKlxcbiAqIDEuIENvcnJlY3QgdGhlIGluYWJpbGl0eSB0byBzdHlsZSBjbGlja2FibGUgdHlwZXMgaW4gaU9TIGFuZCBTYWZhcmkuXFxuICogMi4gQ2hhbmdlIGZvbnQgcHJvcGVydGllcyB0byBgaW5oZXJpdGAgaW4gU2FmYXJpLlxcbiAqL1xcbjo6LXdlYmtpdC1maWxlLXVwbG9hZC1idXR0b24ge1xcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBidXR0b247XFxuICAvKiAxICovXFxuICBmb250OiBpbmhlcml0O1xcbiAgLyogMiAqLyB9XFxuXFxuLyogSW50ZXJhY3RpdmVcXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcbi8qXFxuICogQWRkIHRoZSBjb3JyZWN0IGRpc3BsYXkgaW4gSUUgOS0uXFxuICogMS4gQWRkIHRoZSBjb3JyZWN0IGRpc3BsYXkgaW4gRWRnZSwgSUUsIGFuZCBGaXJlZm94LlxcbiAqL1xcbmRldGFpbHMsXFxubWVudSB7XFxuICBkaXNwbGF5OiBibG9jazsgfVxcblxcbi8qXFxuICogQWRkIHRoZSBjb3JyZWN0IGRpc3BsYXkgaW4gYWxsIGJyb3dzZXJzLlxcbiAqL1xcbnN1bW1hcnkge1xcbiAgZGlzcGxheTogbGlzdC1pdGVtOyB9XFxuXFxuLyogU2NyaXB0aW5nXFxuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG4vKipcXG4gKiBBZGQgdGhlIGNvcnJlY3QgZGlzcGxheSBpbiBJRSA5LS5cXG4gKi9cXG5jYW52YXMge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrOyB9XFxuXFxuLyoqXFxuICogQWRkIHRoZSBjb3JyZWN0IGRpc3BsYXkgaW4gSUUuXFxuICovXFxudGVtcGxhdGUge1xcbiAgZGlzcGxheTogbm9uZTsgfVxcblxcbi8qIEhpZGRlblxcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuLyoqXFxuICogQWRkIHRoZSBjb3JyZWN0IGRpc3BsYXkgaW4gSUUgMTAtLlxcbiAqL1xcbltoaWRkZW5dIHtcXG4gIGRpc3BsYXk6IG5vbmU7IH1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyIS4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9ub2RlX21vZHVsZXMvbm9ybWFsaXplLmNzcy9ub3JtYWxpemUuY3NzXG4vLyBtb2R1bGUgaWQgPSA1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///52\n");

/***/ }),
/* 53 */
/***/ (function(module, exports) {

eval("\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzPzk4OTMiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIFdoZW4gc291cmNlIG1hcHMgYXJlIGVuYWJsZWQsIGBzdHlsZS1sb2FkZXJgIHVzZXMgYSBsaW5rIGVsZW1lbnQgd2l0aCBhIGRhdGEtdXJpIHRvXG4gKiBlbWJlZCB0aGUgY3NzIG9uIHRoZSBwYWdlLiBUaGlzIGJyZWFrcyBhbGwgcmVsYXRpdmUgdXJscyBiZWNhdXNlIG5vdyB0aGV5IGFyZSByZWxhdGl2ZSB0byBhXG4gKiBidW5kbGUgaW5zdGVhZCBvZiB0aGUgY3VycmVudCBwYWdlLlxuICpcbiAqIE9uZSBzb2x1dGlvbiBpcyB0byBvbmx5IHVzZSBmdWxsIHVybHMsIGJ1dCB0aGF0IG1heSBiZSBpbXBvc3NpYmxlLlxuICpcbiAqIEluc3RlYWQsIHRoaXMgZnVuY3Rpb24gXCJmaXhlc1wiIHRoZSByZWxhdGl2ZSB1cmxzIHRvIGJlIGFic29sdXRlIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBwYWdlIGxvY2F0aW9uLlxuICpcbiAqIEEgcnVkaW1lbnRhcnkgdGVzdCBzdWl0ZSBpcyBsb2NhdGVkIGF0IGB0ZXN0L2ZpeFVybHMuanNgIGFuZCBjYW4gYmUgcnVuIHZpYSB0aGUgYG5wbSB0ZXN0YCBjb21tYW5kLlxuICpcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3MpIHtcbiAgLy8gZ2V0IGN1cnJlbnQgbG9jYXRpb25cbiAgdmFyIGxvY2F0aW9uID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cubG9jYXRpb247XG5cbiAgaWYgKCFsb2NhdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImZpeFVybHMgcmVxdWlyZXMgd2luZG93LmxvY2F0aW9uXCIpO1xuICB9XG5cblx0Ly8gYmxhbmsgb3IgbnVsbD9cblx0aWYgKCFjc3MgfHwgdHlwZW9mIGNzcyAhPT0gXCJzdHJpbmdcIikge1xuXHQgIHJldHVybiBjc3M7XG4gIH1cblxuICB2YXIgYmFzZVVybCA9IGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICsgbG9jYXRpb24uaG9zdDtcbiAgdmFyIGN1cnJlbnREaXIgPSBiYXNlVXJsICsgbG9jYXRpb24ucGF0aG5hbWUucmVwbGFjZSgvXFwvW15cXC9dKiQvLCBcIi9cIik7XG5cblx0Ly8gY29udmVydCBlYWNoIHVybCguLi4pXG5cdC8qXG5cdFRoaXMgcmVndWxhciBleHByZXNzaW9uIGlzIGp1c3QgYSB3YXkgdG8gcmVjdXJzaXZlbHkgbWF0Y2ggYnJhY2tldHMgd2l0aGluXG5cdGEgc3RyaW5nLlxuXG5cdCAvdXJsXFxzKlxcKCAgPSBNYXRjaCBvbiB0aGUgd29yZCBcInVybFwiIHdpdGggYW55IHdoaXRlc3BhY2UgYWZ0ZXIgaXQgYW5kIHRoZW4gYSBwYXJlbnNcblx0ICAgKCAgPSBTdGFydCBhIGNhcHR1cmluZyBncm91cFxuXHQgICAgICg/OiAgPSBTdGFydCBhIG5vbi1jYXB0dXJpbmcgZ3JvdXBcblx0ICAgICAgICAgW14pKF0gID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICg/OiAgPSBTdGFydCBhbm90aGVyIG5vbi1jYXB0dXJpbmcgZ3JvdXBzXG5cdCAgICAgICAgICAgICAgICAgW14pKF0rICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgICAgICBbXikoXSogID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgXFwpICA9IE1hdGNoIGEgZW5kIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICApICA9IEVuZCBHcm91cFxuICAgICAgICAgICAgICAqXFwpID0gTWF0Y2ggYW55dGhpbmcgYW5kIHRoZW4gYSBjbG9zZSBwYXJlbnNcbiAgICAgICAgICApICA9IENsb3NlIG5vbi1jYXB0dXJpbmcgZ3JvdXBcbiAgICAgICAgICAqICA9IE1hdGNoIGFueXRoaW5nXG4gICAgICAgKSAgPSBDbG9zZSBjYXB0dXJpbmcgZ3JvdXBcblx0IFxcKSAgPSBNYXRjaCBhIGNsb3NlIHBhcmVuc1xuXG5cdCAvZ2kgID0gR2V0IGFsbCBtYXRjaGVzLCBub3QgdGhlIGZpcnN0LiAgQmUgY2FzZSBpbnNlbnNpdGl2ZS5cblx0ICovXG5cdHZhciBmaXhlZENzcyA9IGNzcy5yZXBsYWNlKC91cmxcXHMqXFwoKCg/OlteKShdfFxcKCg/OlteKShdK3xcXChbXikoXSpcXCkpKlxcKSkqKVxcKS9naSwgZnVuY3Rpb24oZnVsbE1hdGNoLCBvcmlnVXJsKSB7XG5cdFx0Ly8gc3RyaXAgcXVvdGVzIChpZiB0aGV5IGV4aXN0KVxuXHRcdHZhciB1bnF1b3RlZE9yaWdVcmwgPSBvcmlnVXJsXG5cdFx0XHQudHJpbSgpXG5cdFx0XHQucmVwbGFjZSgvXlwiKC4qKVwiJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KVxuXHRcdFx0LnJlcGxhY2UoL14nKC4qKSckLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pO1xuXG5cdFx0Ly8gYWxyZWFkeSBhIGZ1bGwgdXJsPyBubyBjaGFuZ2Vcblx0XHRpZiAoL14oI3xkYXRhOnxodHRwOlxcL1xcL3xodHRwczpcXC9cXC98ZmlsZTpcXC9cXC9cXC8pL2kudGVzdCh1bnF1b3RlZE9yaWdVcmwpKSB7XG5cdFx0ICByZXR1cm4gZnVsbE1hdGNoO1xuXHRcdH1cblxuXHRcdC8vIGNvbnZlcnQgdGhlIHVybCB0byBhIGZ1bGwgdXJsXG5cdFx0dmFyIG5ld1VybDtcblxuXHRcdGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi8vXCIpID09PSAwKSB7XG5cdFx0ICBcdC8vVE9ETzogc2hvdWxkIHdlIGFkZCBwcm90b2NvbD9cblx0XHRcdG5ld1VybCA9IHVucXVvdGVkT3JpZ1VybDtcblx0XHR9IGVsc2UgaWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiL1wiKSA9PT0gMCkge1xuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIGJhc2UgdXJsXG5cdFx0XHRuZXdVcmwgPSBiYXNlVXJsICsgdW5xdW90ZWRPcmlnVXJsOyAvLyBhbHJlYWR5IHN0YXJ0cyB3aXRoICcvJ1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byBjdXJyZW50IGRpcmVjdG9yeVxuXHRcdFx0bmV3VXJsID0gY3VycmVudERpciArIHVucXVvdGVkT3JpZ1VybC5yZXBsYWNlKC9eXFwuXFwvLywgXCJcIik7IC8vIFN0cmlwIGxlYWRpbmcgJy4vJ1xuXHRcdH1cblxuXHRcdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgdXJsKC4uLilcblx0XHRyZXR1cm4gXCJ1cmwoXCIgKyBKU09OLnN0cmluZ2lmeShuZXdVcmwpICsgXCIpXCI7XG5cdH0pO1xuXG5cdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgY3NzXG5cdHJldHVybiBmaXhlZENzcztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL3VybHMuanNcbi8vIG1vZHVsZSBpZCA9IDUzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///53\n");

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(55);\nif(typeof content === 'string') content = [[module.i, content, '']];\n// Prepare cssTransformation\nvar transform;\n\nvar options = {\"hmr\":true}\noptions.transform = transform\n// add the styles to the DOM\nvar update = __webpack_require__(22)(content, options);\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(false) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!../../node_modules/css-loader/index.js!../../node_modules/sass-loader/lib/loader.js!./styles.scss\", function() {\n\t\t\tvar newContent = require(\"!!../../node_modules/css-loader/index.js!../../node_modules/sass-loader/lib/loader.js!./styles.scss\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc3R5bGVzL3N0eWxlcy5zY3NzP2UzMDQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4vc3R5bGVzLnNjc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIFByZXBhcmUgY3NzVHJhbnNmb3JtYXRpb25cbnZhciB0cmFuc2Zvcm07XG5cbnZhciBvcHRpb25zID0ge1wiaG1yXCI6dHJ1ZX1cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4vc3R5bGVzLnNjc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4vc3R5bGVzLnNjc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3N0eWxlcy9zdHlsZXMuc2Nzc1xuLy8gbW9kdWxlIGlkID0gNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///54\n");

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

eval("var escape = __webpack_require__(56);\nexports = module.exports = __webpack_require__(21)(false);\n// imports\n\n\n// module\nexports.push([module.i, \"@font-face {\\n  font-family: 'Circular Std Book';\\n  font-style: normal;\\n  font-weight: normal;\\n  src: local(\\\"Circular Std Book\\\"), url(\" + escape(__webpack_require__(57)) + \") format(\\\"woff\\\"); }\\n\\n@font-face {\\n  font-family: 'Circular Std Book Italic';\\n  font-style: normal;\\n  font-weight: normal;\\n  src: local(\\\"Circular Std Book Italic\\\"), url(\" + escape(__webpack_require__(58)) + \") format(\\\"woff\\\"); }\\n\\n@font-face {\\n  font-family: 'Circular Std Medium';\\n  font-style: normal;\\n  font-weight: normal;\\n  src: local(\\\"Circular Std Medium\\\"), url(\" + escape(__webpack_require__(59)) + \") format(\\\"woff\\\"); }\\n\\n@font-face {\\n  font-family: 'Circular Std Medium Italic';\\n  font-style: normal;\\n  font-weight: normal;\\n  src: local(\\\"Circular Std Medium Italic\\\"), url(\" + escape(__webpack_require__(60)) + \") format(\\\"woff\\\"); }\\n\\n@font-face {\\n  font-family: 'Circular Std Black';\\n  font-style: normal;\\n  font-weight: normal;\\n  src: local(\\\"Circular Std Black\\\"), url(\" + escape(__webpack_require__(61)) + \") format(\\\"woff\\\"); }\\n\\n@font-face {\\n  font-family: 'Circular Std Black Italic';\\n  font-style: normal;\\n  font-weight: normal;\\n  src: local(\\\"Circular Std Black Italic\\\"), url(\" + escape(__webpack_require__(62)) + \") format(\\\"woff\\\"); }\\n\\n@font-face {\\n  font-family: 'Circular Std Bold';\\n  font-style: normal;\\n  font-weight: normal;\\n  src: local(\\\"Circular Std Bold\\\"), url(\" + escape(__webpack_require__(63)) + \") format(\\\"woff\\\"); }\\n\\n@font-face {\\n  font-family: 'Circular Std Bold Italic';\\n  font-style: normal;\\n  font-weight: normal;\\n  src: local(\\\"Circular Std Bold Italic\\\"), url(\" + escape(__webpack_require__(64)) + \") format(\\\"woff\\\"); }\\n\\n* {\\n  -webkit-font-smoothing: antialiased; }\\n\\n*:focus {\\n  outline: none; }\\n\\n*,\\n*:before,\\n*:after {\\n  box-sizing: inherit; }\\n\\nhtml {\\n  box-sizing: border-box;\\n  font-family: \\\"Circular Std Book\\\", -apple-system, BlinkMacSystemFont, \\\"Segoe UI\\\", Roboto, Helvetica, Arial, sans-serif, \\\"Apple Color Emoji\\\", \\\"Segoe UI Emoji\\\", \\\"Segoe UI Symbol\\\";\\n  font-size: 62.5%; }\\n\\nbody {\\n  background: #29343d;\\n  font-size: 2rem; }\\n  @media (max-width: 30em) {\\n    body {\\n      font-size: 1.5rem; } }\\n\\nh1 {\\n  font-size: 2.2rem; }\\n\\nbutton {\\n  cursor: pointer;\\n  font-family: \\\"Circular Std Book\\\"; }\\n\\nbutton:disabled {\\n  cursor: default; }\\n\\n.add-option-error {\\n  color: #a5afd7;\\n  font-style: italic;\\n  margin: 2rem 0 0 0;\\n  padding: 0 2rem; }\\n\\n.add-option {\\n  display: flex;\\n  flex-direction: column;\\n  padding: 2rem; }\\n\\n.add-option__input {\\n  background: #29343d;\\n  border: none;\\n  color: #a5afd7;\\n  border-bottom: 0.3rem solid #151a1f;\\n  flex-grow: 1;\\n  margin: 0 0 1.2rem 0;\\n  padding: 1.2rem; }\\n\\n@media (min-width: 45rem) {\\n  .add-option {\\n    flex-direction: row; }\\n  .add-option__input {\\n    margin: 0 1.2rem 0 0; } }\\n\\n.container {\\n  max-width: 60rem;\\n  margin: 0 auto;\\n  padding: 0 2rem; }\\n\\n.header {\\n  color: white;\\n  margin-bottom: 2rem;\\n  padding: 2rem 0;\\n  text-align: center; }\\n  @media (max-width: 30em) {\\n    .header {\\n      padding: 0 0 2rem 0; } }\\n\\n.header__title {\\n  width: 50%;\\n  margin: 0 auto;\\n  margin-top: 5rem; }\\n\\n.header__subtitle {\\n  color: #a5afd7;\\n  font-size: 2rem;\\n  font-weight: 500;\\n  letter-spacing: 2px;\\n  margin: 0; }\\n  @media (max-width: 30em) {\\n    .header__subtitle {\\n      font-size: 1.4rem;\\n      letter-spacing: 1px; } }\\n\\n@media (min-width: 45rem) {\\n  .header {\\n    margin-bottom: 4.8rem; } }\\n\\n.big-button {\\n  background: #8357c5;\\n  border: none;\\n  border-bottom: 0.6rem solid #693cad;\\n  color: white;\\n  font-weight: bold;\\n  font-size: 5.2rem;\\n  width: 100%;\\n  margin-bottom: 2rem;\\n  padding: 2.4rem; }\\n  @media (max-width: 30em) {\\n    .big-button {\\n      font-size: 2.7rem;\\n      padding: 2rem; } }\\n\\n.big-button:disabled {\\n  opacity: .5; }\\n\\n@media (min-width: 45rem) {\\n  .big-button {\\n    margin-bottom: 4.8rem; } }\\n\\n.button {\\n  background: #8357c5;\\n  border: none;\\n  border-bottom: 0.3rem solid #693cad;\\n  color: white;\\n  font-weight: 500;\\n  padding: 1.2rem; }\\n  .button--link {\\n    background: none;\\n    border: none;\\n    color: #a5afd7;\\n    padding: 0; }\\n    .button--link:active {\\n      background: none;\\n      transform: none;\\n      box-shadow: none; }\\n\\nbutton:active {\\n  background-color: #693cad;\\n  transform: translateY(4px);\\n  box-shadow: 0 2px #522f87; }\\n\\n.widget {\\n  background: #464b5e;\\n  margin-bottom: 4.8rem; }\\n\\n.widget-header {\\n  background: #3c4251;\\n  color: #a5afd7;\\n  display: flex;\\n  justify-content: space-between;\\n  padding: 2rem; }\\n\\n.widget-header__title {\\n  margin: 0; }\\n\\n.widget-header__message {\\n  color: #a5afd7;\\n  margin: 0;\\n  text-align: center;\\n  padding: 5.2rem;\\n  border-bottom: 1px solid #9f7dd2; }\\n\\n.option {\\n  border-bottom: 1px solid #5c627b;\\n  display: flex;\\n  justify-content: space-between;\\n  padding: 5.2rem 2rem; }\\n\\n.option__text {\\n  color: white;\\n  font-weight: 500;\\n  font-size: 2rem;\\n  margin: 0;\\n  word-break: break-all; }\\n\\n.ReactModalPortal > div {\\n  opacity: 0; }\\n\\n.ReactModalPortal .ReactModal__Overlay {\\n  align-items: center;\\n  display: flex;\\n  justify-content: center;\\n  transition: opacity 200ms ease-in-out; }\\n\\n.ReactModalPortal .ReactModal__Overlay--after-open {\\n  opacity: 1; }\\n\\n.ReactModalPortal .ReactModal__Overlay--before-close {\\n  opacity: 0; }\\n\\n.modal {\\n  background: #464b5e;\\n  color: white;\\n  max-width: 30rem;\\n  outline: none;\\n  padding: 5.2rem;\\n  text-align: center; }\\n\\n.modal__title {\\n  margin: 0 0 2rem 0; }\\n\\n.modal__body {\\n  font-size: 2rem;\\n  font-weight: 300;\\n  margin: 0 0 5.2rem 0;\\n  word-break: break-all; }\\n\", \"\"]);\n\n// exports\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc3R5bGVzL3N0eWxlcy5zY3NzP2M3NDMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGVzY2FwZSA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvdXJsL2VzY2FwZS5qc1wiKTtcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoZmFsc2UpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiQGZvbnQtZmFjZSB7XFxuICBmb250LWZhbWlseTogJ0NpcmN1bGFyIFN0ZCBCb29rJztcXG4gIGZvbnQtc3R5bGU6IG5vcm1hbDtcXG4gIGZvbnQtd2VpZ2h0OiBub3JtYWw7XFxuICBzcmM6IGxvY2FsKFxcXCJDaXJjdWxhciBTdGQgQm9va1xcXCIpLCB1cmwoXCIgKyBlc2NhcGUocmVxdWlyZShcIi4vQ2lyY3VsYXJTdGQtQm9vay53b2ZmXCIpKSArIFwiKSBmb3JtYXQoXFxcIndvZmZcXFwiKTsgfVxcblxcbkBmb250LWZhY2Uge1xcbiAgZm9udC1mYW1pbHk6ICdDaXJjdWxhciBTdGQgQm9vayBJdGFsaWMnO1xcbiAgZm9udC1zdHlsZTogbm9ybWFsO1xcbiAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcXG4gIHNyYzogbG9jYWwoXFxcIkNpcmN1bGFyIFN0ZCBCb29rIEl0YWxpY1xcXCIpLCB1cmwoXCIgKyBlc2NhcGUocmVxdWlyZShcIi4vQ2lyY3VsYXJTdGQtQm9va0l0YWxpYy53b2ZmXCIpKSArIFwiKSBmb3JtYXQoXFxcIndvZmZcXFwiKTsgfVxcblxcbkBmb250LWZhY2Uge1xcbiAgZm9udC1mYW1pbHk6ICdDaXJjdWxhciBTdGQgTWVkaXVtJztcXG4gIGZvbnQtc3R5bGU6IG5vcm1hbDtcXG4gIGZvbnQtd2VpZ2h0OiBub3JtYWw7XFxuICBzcmM6IGxvY2FsKFxcXCJDaXJjdWxhciBTdGQgTWVkaXVtXFxcIiksIHVybChcIiArIGVzY2FwZShyZXF1aXJlKFwiLi9DaXJjdWxhclN0ZC1NZWRpdW0ud29mZlwiKSkgKyBcIikgZm9ybWF0KFxcXCJ3b2ZmXFxcIik7IH1cXG5cXG5AZm9udC1mYWNlIHtcXG4gIGZvbnQtZmFtaWx5OiAnQ2lyY3VsYXIgU3RkIE1lZGl1bSBJdGFsaWMnO1xcbiAgZm9udC1zdHlsZTogbm9ybWFsO1xcbiAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcXG4gIHNyYzogbG9jYWwoXFxcIkNpcmN1bGFyIFN0ZCBNZWRpdW0gSXRhbGljXFxcIiksIHVybChcIiArIGVzY2FwZShyZXF1aXJlKFwiLi9DaXJjdWxhclN0ZC1NZWRpdW1JdGFsaWMud29mZlwiKSkgKyBcIikgZm9ybWF0KFxcXCJ3b2ZmXFxcIik7IH1cXG5cXG5AZm9udC1mYWNlIHtcXG4gIGZvbnQtZmFtaWx5OiAnQ2lyY3VsYXIgU3RkIEJsYWNrJztcXG4gIGZvbnQtc3R5bGU6IG5vcm1hbDtcXG4gIGZvbnQtd2VpZ2h0OiBub3JtYWw7XFxuICBzcmM6IGxvY2FsKFxcXCJDaXJjdWxhciBTdGQgQmxhY2tcXFwiKSwgdXJsKFwiICsgZXNjYXBlKHJlcXVpcmUoXCIuL0NpcmN1bGFyU3RkLUJsYWNrLndvZmZcIikpICsgXCIpIGZvcm1hdChcXFwid29mZlxcXCIpOyB9XFxuXFxuQGZvbnQtZmFjZSB7XFxuICBmb250LWZhbWlseTogJ0NpcmN1bGFyIFN0ZCBCbGFjayBJdGFsaWMnO1xcbiAgZm9udC1zdHlsZTogbm9ybWFsO1xcbiAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcXG4gIHNyYzogbG9jYWwoXFxcIkNpcmN1bGFyIFN0ZCBCbGFjayBJdGFsaWNcXFwiKSwgdXJsKFwiICsgZXNjYXBlKHJlcXVpcmUoXCIuL0NpcmN1bGFyU3RkLUJsYWNrSXRhbGljLndvZmZcIikpICsgXCIpIGZvcm1hdChcXFwid29mZlxcXCIpOyB9XFxuXFxuQGZvbnQtZmFjZSB7XFxuICBmb250LWZhbWlseTogJ0NpcmN1bGFyIFN0ZCBCb2xkJztcXG4gIGZvbnQtc3R5bGU6IG5vcm1hbDtcXG4gIGZvbnQtd2VpZ2h0OiBub3JtYWw7XFxuICBzcmM6IGxvY2FsKFxcXCJDaXJjdWxhciBTdGQgQm9sZFxcXCIpLCB1cmwoXCIgKyBlc2NhcGUocmVxdWlyZShcIi4vQ2lyY3VsYXJTdGQtQm9sZC53b2ZmXCIpKSArIFwiKSBmb3JtYXQoXFxcIndvZmZcXFwiKTsgfVxcblxcbkBmb250LWZhY2Uge1xcbiAgZm9udC1mYW1pbHk6ICdDaXJjdWxhciBTdGQgQm9sZCBJdGFsaWMnO1xcbiAgZm9udC1zdHlsZTogbm9ybWFsO1xcbiAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcXG4gIHNyYzogbG9jYWwoXFxcIkNpcmN1bGFyIFN0ZCBCb2xkIEl0YWxpY1xcXCIpLCB1cmwoXCIgKyBlc2NhcGUocmVxdWlyZShcIi4vQ2lyY3VsYXJTdGQtQm9sZEl0YWxpYy53b2ZmXCIpKSArIFwiKSBmb3JtYXQoXFxcIndvZmZcXFwiKTsgfVxcblxcbioge1xcbiAgLXdlYmtpdC1mb250LXNtb290aGluZzogYW50aWFsaWFzZWQ7IH1cXG5cXG4qOmZvY3VzIHtcXG4gIG91dGxpbmU6IG5vbmU7IH1cXG5cXG4qLFxcbio6YmVmb3JlLFxcbio6YWZ0ZXIge1xcbiAgYm94LXNpemluZzogaW5oZXJpdDsgfVxcblxcbmh0bWwge1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIGZvbnQtZmFtaWx5OiBcXFwiQ2lyY3VsYXIgU3RkIEJvb2tcXFwiLCAtYXBwbGUtc3lzdGVtLCBCbGlua01hY1N5c3RlbUZvbnQsIFxcXCJTZWdvZSBVSVxcXCIsIFJvYm90bywgSGVsdmV0aWNhLCBBcmlhbCwgc2Fucy1zZXJpZiwgXFxcIkFwcGxlIENvbG9yIEVtb2ppXFxcIiwgXFxcIlNlZ29lIFVJIEVtb2ppXFxcIiwgXFxcIlNlZ29lIFVJIFN5bWJvbFxcXCI7XFxuICBmb250LXNpemU6IDYyLjUlOyB9XFxuXFxuYm9keSB7XFxuICBiYWNrZ3JvdW5kOiAjMjkzNDNkO1xcbiAgZm9udC1zaXplOiAycmVtOyB9XFxuICBAbWVkaWEgKG1heC13aWR0aDogMzBlbSkge1xcbiAgICBib2R5IHtcXG4gICAgICBmb250LXNpemU6IDEuNXJlbTsgfSB9XFxuXFxuaDEge1xcbiAgZm9udC1zaXplOiAyLjJyZW07IH1cXG5cXG5idXR0b24ge1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgZm9udC1mYW1pbHk6IFxcXCJDaXJjdWxhciBTdGQgQm9va1xcXCI7IH1cXG5cXG5idXR0b246ZGlzYWJsZWQge1xcbiAgY3Vyc29yOiBkZWZhdWx0OyB9XFxuXFxuLmFkZC1vcHRpb24tZXJyb3Ige1xcbiAgY29sb3I6ICNhNWFmZDc7XFxuICBmb250LXN0eWxlOiBpdGFsaWM7XFxuICBtYXJnaW46IDJyZW0gMCAwIDA7XFxuICBwYWRkaW5nOiAwIDJyZW07IH1cXG5cXG4uYWRkLW9wdGlvbiB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gIHBhZGRpbmc6IDJyZW07IH1cXG5cXG4uYWRkLW9wdGlvbl9faW5wdXQge1xcbiAgYmFja2dyb3VuZDogIzI5MzQzZDtcXG4gIGJvcmRlcjogbm9uZTtcXG4gIGNvbG9yOiAjYTVhZmQ3O1xcbiAgYm9yZGVyLWJvdHRvbTogMC4zcmVtIHNvbGlkICMxNTFhMWY7XFxuICBmbGV4LWdyb3c6IDE7XFxuICBtYXJnaW46IDAgMCAxLjJyZW0gMDtcXG4gIHBhZGRpbmc6IDEuMnJlbTsgfVxcblxcbkBtZWRpYSAobWluLXdpZHRoOiA0NXJlbSkge1xcbiAgLmFkZC1vcHRpb24ge1xcbiAgICBmbGV4LWRpcmVjdGlvbjogcm93OyB9XFxuICAuYWRkLW9wdGlvbl9faW5wdXQge1xcbiAgICBtYXJnaW46IDAgMS4ycmVtIDAgMDsgfSB9XFxuXFxuLmNvbnRhaW5lciB7XFxuICBtYXgtd2lkdGg6IDYwcmVtO1xcbiAgbWFyZ2luOiAwIGF1dG87XFxuICBwYWRkaW5nOiAwIDJyZW07IH1cXG5cXG4uaGVhZGVyIHtcXG4gIGNvbG9yOiB3aGl0ZTtcXG4gIG1hcmdpbi1ib3R0b206IDJyZW07XFxuICBwYWRkaW5nOiAycmVtIDA7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7IH1cXG4gIEBtZWRpYSAobWF4LXdpZHRoOiAzMGVtKSB7XFxuICAgIC5oZWFkZXIge1xcbiAgICAgIHBhZGRpbmc6IDAgMCAycmVtIDA7IH0gfVxcblxcbi5oZWFkZXJfX3RpdGxlIHtcXG4gIHdpZHRoOiA1MCU7XFxuICBtYXJnaW46IDAgYXV0bztcXG4gIG1hcmdpbi10b3A6IDVyZW07IH1cXG5cXG4uaGVhZGVyX19zdWJ0aXRsZSB7XFxuICBjb2xvcjogI2E1YWZkNztcXG4gIGZvbnQtc2l6ZTogMnJlbTtcXG4gIGZvbnQtd2VpZ2h0OiA1MDA7XFxuICBsZXR0ZXItc3BhY2luZzogMnB4O1xcbiAgbWFyZ2luOiAwOyB9XFxuICBAbWVkaWEgKG1heC13aWR0aDogMzBlbSkge1xcbiAgICAuaGVhZGVyX19zdWJ0aXRsZSB7XFxuICAgICAgZm9udC1zaXplOiAxLjRyZW07XFxuICAgICAgbGV0dGVyLXNwYWNpbmc6IDFweDsgfSB9XFxuXFxuQG1lZGlhIChtaW4td2lkdGg6IDQ1cmVtKSB7XFxuICAuaGVhZGVyIHtcXG4gICAgbWFyZ2luLWJvdHRvbTogNC44cmVtOyB9IH1cXG5cXG4uYmlnLWJ1dHRvbiB7XFxuICBiYWNrZ3JvdW5kOiAjODM1N2M1O1xcbiAgYm9yZGVyOiBub25lO1xcbiAgYm9yZGVyLWJvdHRvbTogMC42cmVtIHNvbGlkICM2OTNjYWQ7XFxuICBjb2xvcjogd2hpdGU7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG4gIGZvbnQtc2l6ZTogNS4ycmVtO1xcbiAgd2lkdGg6IDEwMCU7XFxuICBtYXJnaW4tYm90dG9tOiAycmVtO1xcbiAgcGFkZGluZzogMi40cmVtOyB9XFxuICBAbWVkaWEgKG1heC13aWR0aDogMzBlbSkge1xcbiAgICAuYmlnLWJ1dHRvbiB7XFxuICAgICAgZm9udC1zaXplOiAyLjdyZW07XFxuICAgICAgcGFkZGluZzogMnJlbTsgfSB9XFxuXFxuLmJpZy1idXR0b246ZGlzYWJsZWQge1xcbiAgb3BhY2l0eTogLjU7IH1cXG5cXG5AbWVkaWEgKG1pbi13aWR0aDogNDVyZW0pIHtcXG4gIC5iaWctYnV0dG9uIHtcXG4gICAgbWFyZ2luLWJvdHRvbTogNC44cmVtOyB9IH1cXG5cXG4uYnV0dG9uIHtcXG4gIGJhY2tncm91bmQ6ICM4MzU3YzU7XFxuICBib3JkZXI6IG5vbmU7XFxuICBib3JkZXItYm90dG9tOiAwLjNyZW0gc29saWQgIzY5M2NhZDtcXG4gIGNvbG9yOiB3aGl0ZTtcXG4gIGZvbnQtd2VpZ2h0OiA1MDA7XFxuICBwYWRkaW5nOiAxLjJyZW07IH1cXG4gIC5idXR0b24tLWxpbmsge1xcbiAgICBiYWNrZ3JvdW5kOiBub25lO1xcbiAgICBib3JkZXI6IG5vbmU7XFxuICAgIGNvbG9yOiAjYTVhZmQ3O1xcbiAgICBwYWRkaW5nOiAwOyB9XFxuICAgIC5idXR0b24tLWxpbms6YWN0aXZlIHtcXG4gICAgICBiYWNrZ3JvdW5kOiBub25lO1xcbiAgICAgIHRyYW5zZm9ybTogbm9uZTtcXG4gICAgICBib3gtc2hhZG93OiBub25lOyB9XFxuXFxuYnV0dG9uOmFjdGl2ZSB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjNjkzY2FkO1xcbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDRweCk7XFxuICBib3gtc2hhZG93OiAwIDJweCAjNTIyZjg3OyB9XFxuXFxuLndpZGdldCB7XFxuICBiYWNrZ3JvdW5kOiAjNDY0YjVlO1xcbiAgbWFyZ2luLWJvdHRvbTogNC44cmVtOyB9XFxuXFxuLndpZGdldC1oZWFkZXIge1xcbiAgYmFja2dyb3VuZDogIzNjNDI1MTtcXG4gIGNvbG9yOiAjYTVhZmQ3O1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG4gIHBhZGRpbmc6IDJyZW07IH1cXG5cXG4ud2lkZ2V0LWhlYWRlcl9fdGl0bGUge1xcbiAgbWFyZ2luOiAwOyB9XFxuXFxuLndpZGdldC1oZWFkZXJfX21lc3NhZ2Uge1xcbiAgY29sb3I6ICNhNWFmZDc7XFxuICBtYXJnaW46IDA7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICBwYWRkaW5nOiA1LjJyZW07XFxuICBib3JkZXItYm90dG9tOiAxcHggc29saWQgIzlmN2RkMjsgfVxcblxcbi5vcHRpb24ge1xcbiAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICM1YzYyN2I7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcbiAgcGFkZGluZzogNS4ycmVtIDJyZW07IH1cXG5cXG4ub3B0aW9uX190ZXh0IHtcXG4gIGNvbG9yOiB3aGl0ZTtcXG4gIGZvbnQtd2VpZ2h0OiA1MDA7XFxuICBmb250LXNpemU6IDJyZW07XFxuICBtYXJnaW46IDA7XFxuICB3b3JkLWJyZWFrOiBicmVhay1hbGw7IH1cXG5cXG4uUmVhY3RNb2RhbFBvcnRhbCA+IGRpdiB7XFxuICBvcGFjaXR5OiAwOyB9XFxuXFxuLlJlYWN0TW9kYWxQb3J0YWwgLlJlYWN0TW9kYWxfX092ZXJsYXkge1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gIHRyYW5zaXRpb246IG9wYWNpdHkgMjAwbXMgZWFzZS1pbi1vdXQ7IH1cXG5cXG4uUmVhY3RNb2RhbFBvcnRhbCAuUmVhY3RNb2RhbF9fT3ZlcmxheS0tYWZ0ZXItb3BlbiB7XFxuICBvcGFjaXR5OiAxOyB9XFxuXFxuLlJlYWN0TW9kYWxQb3J0YWwgLlJlYWN0TW9kYWxfX092ZXJsYXktLWJlZm9yZS1jbG9zZSB7XFxuICBvcGFjaXR5OiAwOyB9XFxuXFxuLm1vZGFsIHtcXG4gIGJhY2tncm91bmQ6ICM0NjRiNWU7XFxuICBjb2xvcjogd2hpdGU7XFxuICBtYXgtd2lkdGg6IDMwcmVtO1xcbiAgb3V0bGluZTogbm9uZTtcXG4gIHBhZGRpbmc6IDUuMnJlbTtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjsgfVxcblxcbi5tb2RhbF9fdGl0bGUge1xcbiAgbWFyZ2luOiAwIDAgMnJlbSAwOyB9XFxuXFxuLm1vZGFsX19ib2R5IHtcXG4gIGZvbnQtc2l6ZTogMnJlbTtcXG4gIGZvbnQtd2VpZ2h0OiAzMDA7XFxuICBtYXJnaW46IDAgMCA1LjJyZW0gMDtcXG4gIHdvcmQtYnJlYWs6IGJyZWFrLWFsbDsgfVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIhLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEuL3NyYy9zdHlsZXMvc3R5bGVzLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///55\n");

/***/ }),
/* 56 */
/***/ (function(module, exports) {

eval("module.exports = function escape(url) {\n    if (typeof url !== 'string') {\n        return url\n    }\n    // If url is already wrapped in quotes, remove them\n    if (/^['\"].*['\"]$/.test(url)) {\n        url = url.slice(1, -1);\n    }\n    // Should url be wrapped?\n    // See https://drafts.csswg.org/css-values-3/#urls\n    if (/[\"'() \\t\\n]/.test(url)) {\n        return '\"' + url.replace(/\"/g, '\\\\\"').replace(/\\n/g, '\\\\n') + '\"'\n    }\n\n    return url\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvdXJsL2VzY2FwZS5qcz85MzExIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZXNjYXBlKHVybCkge1xuICAgIGlmICh0eXBlb2YgdXJsICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdXJsXG4gICAgfVxuICAgIC8vIElmIHVybCBpcyBhbHJlYWR5IHdyYXBwZWQgaW4gcXVvdGVzLCByZW1vdmUgdGhlbVxuICAgIGlmICgvXlsnXCJdLipbJ1wiXSQvLnRlc3QodXJsKSkge1xuICAgICAgICB1cmwgPSB1cmwuc2xpY2UoMSwgLTEpO1xuICAgIH1cbiAgICAvLyBTaG91bGQgdXJsIGJlIHdyYXBwZWQ/XG4gICAgLy8gU2VlIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3MtdmFsdWVzLTMvI3VybHNcbiAgICBpZiAoL1tcIicoKSBcXHRcXG5dLy50ZXN0KHVybCkpIHtcbiAgICAgICAgcmV0dXJuICdcIicgKyB1cmwucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpLnJlcGxhY2UoL1xcbi9nLCAnXFxcXG4nKSArICdcIidcbiAgICB9XG5cbiAgICByZXR1cm4gdXJsXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi91cmwvZXNjYXBlLmpzXG4vLyBtb2R1bGUgaWQgPSA1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///56\n");

/***/ }),
/* 57 */
/***/ (function(module, exports) {

eval("module.exports = \"data:application/font-woff;base64,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\"//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc3R5bGVzL0NpcmN1bGFyU3RkLUJvb2sud29mZj83NTQ4Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmFwcGxpY2F0aW9uL2ZvbnQtd29mZjtiYXNlNjQsZDA5R1JrOVVWRThBQUk4RUFBd0FBQUFCREN3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJEUmtZZ0FBQU1vQUFBVjkwQUFHWkZWZWV2MEVSVFNVY0FBR1NBQUFBQUNBQUFBQWdBQUFBQ1IxQlBVd0FBWklnQUFDUzNBQUNGSklsQWplUkhVMVZDQUFDSlFBQUFCY0VBQUFzZ3lzSFEyRTlUTHpJQUFBRjRBQUFBV3dBQUFHQlBPVTl4WTIxaGNBQUFCYXdBQUFMb0FBQUVYaHdVM05ab1pXRmtBQUFCSEFBQUFEUUFBQUEyLzlFc1hXaG9aV0VBQUFGUUFBQUFJQUFBQUNRSmlRYW1hRzEwZUFBQUNKUUFBQVA0QUFBSFlPdFlWVWx0WVhod0FBQUJjQUFBQUFZQUFBQUdBZGhRQUc1aGJXVUFBQUhVQUFBRDJBQUFDQ1h6ZXNHcGNHOXpkQUFBREl3QUFBQVRBQUFBSVA5b0FGQjRBV05nWkdBQVlpZXh5VnlUNC9sdHZqSXdNNzlnQUlLelBkVm1FRHBYKy8rbC94S3M1NW4zQWJuc0RFd2dVUUJPb1F5WmVBRmpZR1JnWUg3Njd3c0RBeHZiLzB2L0w3T2VCNHFnQU1ZYkFMbW5DRGtBQUZBQUFkZ0FBSGdCWTJCaFVtWTh4TUFLcEx1WUloZ1lHTHdoTkdNY1F3Q2pJZ01ERXpjYkN4TWpJeE1qVXdNRGczNEF3NU5xb0JvT0JpRHc4UXZ4WndBSy92dlByUG5ma2VFRTgxTkdIZ1dnUnBBYzQwT21vMEJLZ1lFYkFJbVpEendBZUFHVmxNMXVXMFVVeDM5TzBxUWZTV2tYclVCSWNDaHNJSzNqcEt4U2hOU2t0QnV6YWFzdUs0M3ZIZHVqakdldTVzNk42NG9IZ0NkZ3gyT3dZY0ViSUZZOEN4c0U0OUhJV0UyRWhHZnptL1A1dnpObkROenIvVVFQOHUrcjNyZUZlK3p5WmVFTnRoZ1UzdVJqZml5OHhlMVZ6QlUrNEp2QzI5emlzOEk3Zk1KM2hhK3l2Y3E5eG52Y0tYd2owWitGZC9sMHhYdTlKeHUvRkw3SndlYnZoZStzOWIzTFRsYlYyN29Hdk5rNExkempIbjhVM2tqWk80VTMrYnIzYStFdGhKOExYK0dvOTJIaDdUWDdEaWU5SHdwZlpYZVZlNDJQZUYzNEJsLzAvaXE4eTlNVjcyMTh2L2wzNFp1ODN2Njg4QzNlWDJtN25hcitWdmpPbXVhN1M4M1A5YVN6S3ZBY3pZUU9peUlNVlJlMGV5c25vWE5PaDFNVHFtWFFpMWcvT1BIK3JPeURKSU1zRGE5MGFJMTNjdGdmREE0ZnlhZ3p0cGJCWUhERUVFVkhRT040aTNDU3VFdnMwS3pxaW1sRlNReXExak1WenNTUFpXaWNqdjVZMWx2bDNzZHlORGg4eUNtR1FFVVJ6QXNpTlE4NHdhZDFkc0V2SlVJb0VkTVltK09EZy9sODNyZTVWNy95czRPWFU3My9STGRtNG5Sb2VZVW0wR0x3T0lSRCtnelNPdVFSd29nT2c4MUZCM2tkUGRNcFQwVmRpM0ZacDR3Vzh0UzdPRlNqOUFWZGJYeGZUbjJ6Q0dZeWpTbG83S1hScmpadTByOUVzcUZGRWd1UmdLSkdNOHUrTXdUUEdHR0l3YUdKZUk2UmkxVXVITTB5NmloL3hVT214TFNhWkR0SWE1NVhIN3RXczArRlo1YThMNW1pMmVjSk9wL0pCRmZPNXhtNnNDS2lxYk4ydDlaSEdMRkFlSnBQTXVheEdCVnRIVFZtMlNtcjl6UXNDTG4rbEZncWpmR0ptdHluenBZSi9hR2FqenNyWGF1WEV4T25Xc2JleFZaOHlKdGFSU1ZWc2lqamRDMXpFNmZHcmNKa2JLeHVSYitwYkZjbm1QbmFqQmZwSXU1TDBLcHQ5V3hreTg2cFdhWTIrcEJBdkpPbVM5N0tMa1NkSzJQVnlHcHBkVGpYb1YwbTFLYU5adFRGSEsxY25YeldKdTdMWTdlUXp0bDNoSnRXNHFMeGs2Q2FxYW1rOWVNNFYwRW55ZGJLU0VzVGZLdXJMdXE2bjZZcGlLcHJFNDEzeXVZUkNqTzEzS1V1ZXUvNjVYTTkvQmVYNDdnL05KVjJiWktVYjJMT09NK0wwTkdpVjdNVm1lYmR1TnhhbXoxaHpWT2pFcXRFVllsUlpYWnFoRGttUnliTHhXcVpEQmFkNjJyZVVHSHBxSXRsaGs5c0dMTW9OMzRmSWFCUnRGbm5qQkgySFo5RE1WdXp0VVE4b1Zpa3ZPU0dydVF1ZXk0UUZPZW9yRWRsajg2NW1zQjVtZkxTZ1JxVHF4cEdkTVMxMmdwSFhmTHNTbGtmNFRFdWQrbHcyUDgrOFdYMVRBc2FQQk1DaWliYks0UTJSMGJtS0FLNm5MTE50VVo1M3hEd3VXcEZWOTVqdjd5OWtGWFdhUmxpK1Y5VDJMVlhGcGloS0w3eUxabzlydit2LzRyaFpkYlY2OS9QL2dxTm95V2YwaitOTHEzSGVBSE56dXR2azFVQWdQSG52Ty9zc0JOd2RGTTI2empuc0xjRkJoVlVGT2FWT21Xb1V3ZnpocmVpRUlTaWdoZ0VBMWptRGZER0JQR0tBY1JMRVJVRUx3Z2FYZEtTSVY0UVRZUzZucVB6YnZTYmlRbnBYcHZHOUIvd2kwL3lmUDhCN3IrSEVRQk9CeTRDQ0ZQaFRBQldreUpBRUJqSWNud3hUc1RGTkRGRExCYkx4UlBPUHFmSDZYWFh1V2wzci91UkhDQ3JaSTJzbHcxU3k0Z2NLNXRsWExiSWRqbGZMcEdyNURZVlVscEYxQngxaDFxcm5sRnB0VXRsdGFNRGVyQWVvbXQxdlc3UVRicFZKL1FzblduTWVKdThuZDRuM3VlUldEUVVyWTJ1dE03UmluN2Y5NkZra1d3c1dpYUpxU0pSdEN3cldySkZ5emRsUzJYUkVwSkRaVmpLa21WaTJYS1hUSlV0Q1RWUHJWSHJpNWJ0WlV0MTBWSlh0c3dzV1RaNmIzbjd5NWFVNVNnbGkvRC84dnY4YnIvTDcvUVgrclA5ZHIvTmIrNnY3QThVL2k3RUM3RkN1RkJuRDltRGRyL2RaN00yWTd2dGJydkRiclZwdThIZWE1ZmFSYmJEL0dtczZUVmJ6R2JUYVZKbWdVbWE2V2FZQ1pzYUV6TFZacENweXZ2NXZ2eUJmRTkrN3JmSlhGZHVSUzZadXpVWFBCSTU0aDNlbzFvQ2s1MDJCUCtmQWs0UVFQQ2ZWUzRWSEVPQVNnWndMRUdxT0k2QkRHSXd4MVBORUVMVVVNc0puTWhRNnFqbkpNS2NUQVBEa0NnMHcybkVJMEtVRVl4a0ZFMk1aZ3d4VG1FczR6aVYwemlkOFp6Qm1VeGdJczJjeGRtY3c3bWN4L2xNSXM0RnRIQWhGekdaVnFad01aZHdLVzFjeHVWY1FUdFRtVVlIVjNJVlYzTU4xektkNjdpZUc3aVJtMGd3QTNpUWgxakZ3NnpsYVY3Z1JUYXpoWmQ1aVZkSTh4cGIyY2Jydk1rYmJHY0hPM21iWGJ6RGU3ekxYdmJ3QVIveUkzY3lrMW5NNFdjV3M0bjVKSVhESXVhSzBhemtXVEdTaFdLTWlER2J1NFVTaldJNGg4VW81ckZVdUx6Sys2emdGbTRYSXpnZ21vVG1OcGJ4Q3pmVHlRTThSWVlzdmVUNW5qNE1sdDFpUEIvVHd4OENmdU4zMFNxbThCTkwrSTRmK0pYN2VZVDdlSlRWUE00YXVuaU1KMWtQck9ONU52QWMzWHpLVnl6Z0N3N3lKZmZ3TllmNDdCOVFld0lZZUFHZGxGMklsR1VVeDMvbnZETldhMll1NDhlZ2pycXZPODJXNzZxdnVXLzV5YnE2bVFaTmhheU9FWVJncklGQ1VoUjJrOUJ0SUVxMVlWRlNoR0dHQzRIZUZFWVhwUlRyRmtSQldKczNVV3dFSWFIdFR2OW5IVDlaQ2JyNDhUL3ZjNTV6ZHVmOG4rZnhsQ29BRjRTd2pKbzlSOFdIU1AweDBtZ3htWitnbXkrcFdEdVp3STRUZTZhNFRMZjFrdGgwYVQvNGRsSjdrcUpQVWI2TlZsOGxuUy9Xc3NSK0llK0xTSHlkK3JTdzBkckVrSEtQMEJuVVJvbWpaY3Fmb01scjFIeFk4WUIwbmJoTGpPaDdpSnJOVUR5TmdoK1V6cWNXOVVzdlNsdVUzOVRRcDZtcGI5bXI2dlVXVmQ5SFUvUTdrNzFYM3p2RTh5UTJWNzM2UVpyMzJ5aDZpY2wySnkwK2tWUzFWVyttNGcrSkVtM1dROEhYa0lSWk1jSnlSdXQvK2lURm8xU2pMZHFiaWhYYUcrckM3OXRGMVQ0bnRtMnE2OUR2UEsrL1gxVC8zMmhTL3lZYnBLSTVKVGFCbWpUdnk0Z0pzNS9LZzE0aURUUHhiaGFJWXRqaks5bGtleWhIUzFWemhEWDJIU1d0SldIMlkyczl4TGFib21lYTVjdXN0SU9zc0daaVgwN1ZuMUV1K0ZObXJyV1Myam02VkYrSWJpZUxKb3BIeVRUN1FwajdlT1NjZlBBaStIQXROcVAramJ3SWVrNDYwYitsK2JJUE54Sm1HVFI0Y1IzQmk2cjZaWW8xOS9HSWRraFZIM3k0RmticVp4bWhLaDJTUnBwaDVZb1BONUtSQlExZVhJZThDSjRGWlVTNmtIdzREN2tYU2FMREJEL0x3Y2NyWnliNDluTjl5RjRpSHFOSDdDRG1LRVZybGY3S1BIdUJPZkkvOWxjaG1rVXk1c0ZUMHUwZ0h3RHd2WFRtSG1ZalAxRGhKeUhrMjFYMnF0OEhxcm1iN3VoZGFyazVaRmFnSkFwUmwzb3ZBSHVmUkh0VzJDZmlnRGdrM2hGdmlMZEZ5QzBrYlp5SG0rN3pZM1RhYThUUlZrcmgvN1VMWkpHVDVRclNZUkVMYVg0UzJZUUppZ2ZJdkM1ZUVZUGlyUFltd3NGT1VwRzIyTWw2WGI1bFViNCtHTlQvMFR3NzY2UFJMYVErUU94LzE4OUg2OWtVdGF0TzU4KzMwUjdtNVIrRnMwRGlVOG5zQUlSejYzM0UwVHdTNnlEdjkxOTZMN3drUk1pSDh4LzFzWE9NZFJEd0JhcFpyZlZBeUoraTZIOVJEUEYvMGs2Y3UwLzZNYW52cCtDUGk1cm0vcm9RQU9QT2RzLy85NEFVeHU3MU1KdnRhN3JzRC9HVnZwOFFaeFIvci9WcGJMRTJ1dTBvbTduSVpqK3N0YkFlN25PbysxRTZsL1cyVDdxV3pJNUxEekRUdHpMVDNxVFZEa243NlBKRklHNFZGZEVzN2hXZmlpOUVpK2dWUzBWSnRJcUtLSXQ1SWhFenhXbHhTbXdRaXh1NlduUTA5dDNoN1ZTbHM4UXFrWWtsalZvYVRCSDNpTFdpSkJhSkRRRnJJeE5ZNzZWM1d1VERleW55bHVsYjcxL0lTUXMyU3V3N3lYTEw2Yng4Ujd4TzRnOVF1Um0yZ2FxL3AvMW4xT05EaXB3bTVqTnhoS0k4YjNoOTFYc3JNOTA2S05vVW1uVlhabHRQaUpsaCt4VUhkak9iWTJGTlBLczU3MnIwMUx2d0wrNFpMTWg0QVdOZ1pnQ0QvNmtNQVF4WUFBQW9DQUc0QUhnQmpmeDNXQk5ORnpjQWJ3aTdpN082S25HNU5YRTNLSXFLbFNJQ1lrR3g5NEtLcUVnSHBVZ0xGdXk5OTk0UVJVVXBpcjFpeHdJV0ZGQXBpb2k5M3NXemNlTDlmTE9Kei91ODczZDlmM3hYa2psVHo4eWNtWjNNbWZPYlZWSFdWcFJLcFdyWU95b2hKRGs2S0dGVVVtajdYbkZ4VTVWSUY3a0JaZVN0akx4YUZxengyTHJxOHJyV0UzR3FTRkgwZzU4amFVSWI1OVMvVE1pNFFsdmlhaDBhVW44VGJoUkQxYU1hVVRxcU9kV0c2a1Ixb1R5cG5sUS9haWpsUjAyZ1FxZ3BWRHcxblpwTExhRldVNXVvblZRNmxVa2RvODVRbDZtYlZDSDFtQ3FqcXFnYTZnUDFuWktwLzZnWVZUMVZJNVZPMVZ6VlJ0VkoxVVhWWGRWSE5WVGxwd3BVUmFyaVZBYlZiTlVpMVVyVkJ0VjJWWnJxa0NwSGRVcDFSWFZUVmFncVVWV29hbFFmVkgrcWZsclJWdldzN0t5YVc3V3g2bVRsYWRYRHFxL1ZFS3ZSVnVPdEpsdEZXTVZhSlZ1bFdpMjBXbUcxM21xYjFWNnJnMWJaVmlldExsaGRzN3BqOWRDcXpLcktxdGJxaTlVUHEzL1ZOdXFHYXEyNnVicWQybDNkUTkxZlBWdzlUaDJzbnFwT1VxZXFsNmpYcWJlcjk2c3oxYm5xVStvTDZxdnFBbldSK3JINm1mcUZ1bGI5VWYxZERlcGYxbXJyT3RiMXJRVnJuWFV6NjFiVzdhMWRyVDJ0ZTFqM3N4NXRQZEU2d2pyVzJtQTkxM3FKOVNyckRkWTdyUGRaSDdiT3NUNXRmZG42cG5XUjlUUHJsOWJ2clArME50TFdkSDFhb1BWME85cUQ3azBQcHYzb1FEcUtUcUhuMEV2b1RmUmUraWg5bnI1Tmw5R3Y2RDhaTmRPUXNXYzZNajdNRUdZeUU4K2tNa3VaN1V3V2s4ZWNaYTR6OTVrcTVqMERySXBsV1lFVjJYWnNaN1luTzRBZHpJNWd4N0QrN0FSMktqdWJYY3l1WTdleis5Z2M5alI3bWIzTFBtS2ZzZS9ZdjIyc2JZUU9zY25SMGNteFVaMDZkZkkxRTU5T0ZtSU91ZlQyVklpcnA1dVorRmhDdlhwUGl5SWVsMDZkdWxpSWg0WDBNaE0zRnpQcDdHd21YVHBaaUp1RmRMWVFkd3ZwWWlFZUZ1SnBKaDZkTE1UWlFsd3N4TlZDM0N5a3M0VzRXMGdYQy9Hd0VNOCt5UWx4aXRmWjJYVllURmhFa05udjNzbENuQzNFeFVKY0xjVE5RanBiaUx1RmRMRVFEd3Z4dEpEZUZ1SnJJWDBzcEc5UVFrSmNTblJZZUpMWmt6ek5UQktpSWlJdEVhRnhLYkhtbko3dUZ0TEZRandzeE1MYXgwSjZkYklRWnd0eHNSQlhDN0cwczdjN3FTQXBLaWc2TkNvODNEY3NPaWxvV2tKY2FISklVbUp5VEV4UVVsU2N1VElYNTg0VzRwa1FGQm9WRWhRZEZSc2VGUnVWTkNNcU5pa3NJaUVvT21nYUtUWTlMRDQ1S0RvMkxzbE1vOE1TRTgyZWlJU3dvS1N3QkxNL05DNkpjSTFVbUxuMTdod2VSWEtGQnNkTjcrOUNSc3cxS1NFcUtDSjVtcExZdVpkcmROek1zTmlJc0JDeUNrV0g5WGYyNk94cWJyaTdpMWxRWFp4ZExhU3ptWmpIbVJCbkMzR3hFRmNMY2JPUTN6bmRMYVNMaFNoaTYwT21xMFVtblMwaHBYamZYdVpJUWx3dHhFMGhmZnIyblJtV0VFZm1lVXhDWEd5WW1TYWx4RmxvWkVLWUpTWThMam5CNG9reVdHSVNvNlpiYUpnaExOYnNDMU5HMU95TGpmck55TXc1TkRZdWhuQTJVOExaUXMyY0ZaL0MyZUlobk0wZXd0bEN6WndWbjRXejRsTTRXeEtuQllXRWRRaFBDQW9KNmhDWEVCb2JiSFpEekc2bzJRMHp1K0ZtTjhMc1JwcmRLTE03eGV4T05idlJaamZHN01hYTNUaXpPODNzeHB2ZEJMT2JhSGFUekc2eTJUV1kzUlN6Tzkzc3pqQzdNODJ1cFpWSjRVUVd3V0ZFWkJHeEpCQWFGMDMrZzRobldsaENTQmpoUm56UnlZbUVoTVNSR1dwSmlJb0xKUjVGZm9RUTZSR1h5STY0WnNrUmFwWWJJVVJxaEJDWkVkY3NNVUxOOGlMVUxDMkZiWFJjckRrNUp1cS9mbVV1RTJLZXdvVCtudEhFOTd0RmlTUkVub2tJSlNZNUlTRXNObVFHOGM0SXMvQUpTWXF5Y0ltTGlBb3hQeUMvT3hFVEZXdnVTVXh5ZEZMVXRHaWxUR2lVSVNwVWFRYkpuUkNsbFBxOU52NGZuNGVseTBtUmNjbUpRYkZLdjVVMWlwRC9jdnUvbmtVUyt1L2orTHNYLzE5ZCtHOXdXaEJwdExMb2RBZ0pTZ3d6aDVRbHh4S01uREV0a25SRjhRYVRLVFExTE1tUzgzOWhKZS8vSXNMK24rU3cveVdHVFErSkRvcFJWakJ6TUNKWmVmNWo0djdIN3ZlZnhmK1Qrai9tcExGaGlZb3MvdytIc05qUW9NUklpemZHNHYxZE1wR01SclRDOS8rTitSK3ZmaDBTRXpzNUJ5bXVTeEJad2d4aEZtOVFTSExTYjYreTlDVEhFTEZOdDRTVG9xSkRmeWVGUmhIWkpVWWxXa0lKaExYWmw2QzRya0V4Wkh6TVkwTkNic3AwSkxSelFsaEVWS0lpY25PMGUwaFFBcGtVUWRGSnlqUW10WktaWlBFbUpTZkVoZ2VHazI5Z2xPSkVtMm4wLzZreDF2STM4TjlnY3NqdkdITWZTUEQvU29rSkNpR1ZFSSs1VTRUK3IwZEtJTWlTR0p3UVppa1lsMlJwQnZFclBTTEUzR05DeVlJZEVaU1FIQk1kbEt5ay9wKzJFMzl5YkNoNU1QL1hoLy91R3UzSnR0SGV2RzI4cUd3QTYxSzJWRjlxQkRXTDJrNVZVRzlVZWxXb2Fxc3FtMnpOSHFsZXFkNnAvbEhKVnJaV29sVkhxd2xXYzZ4QWJhMlcxQzdxWHVyUjZtbnF4OWJ1MXNPdFoxa3ZzdDV1bldGdG91dlJUZWtZc3JYWlRXZlFSK2gvR002OHBmRmdmSmxJSm9ac1pzNHpkNWdTbG1lYnNFM1oxbVFMMDV2dHg0YXdFZXhNODlabEM3dUxUV2V6eU5ibEdudUhmY3krWi8reW9Xd2EyT2hzZXRzTXRnbXdDYlZaWWJQSjVyaE5pVTJOemZjNkRldTQxUEd0TTZLT2Y1M0FPbEYxa3V0c3FKTmQ1MUtkNjNXcTZyeXQ4NjNPRDFRUHRVQWRrQnZ5UWYzUVVEUVNoYUY0TkJQTlJSdlJkclFmblViWDBHMzBBRDFCYjVETVVSek5jWnpBNmJtT1hEZHVNQmZBaFhKVHVUZ3VtWnZCTGVVMmM5dTVnMXdXZDV3N3paM25ibkhGWERsWHczM2xqTngvNnRKMUc5VFYxWFdzNjF5M2MxM3Z1ajNyRHF3N3V1N0V1aEYxNCt2T3FydTQ3dHE2Vyt2dXJIdWdibmJkMDNYejY5NnFlN2Z1dzdvbGRaL1hyYXI3Q3VxZkVadWhibmJOUks2OTJBNUpYT1NhR2F2blNtK1o1VnVYSGppbGhjWHMrMUdWdUlXRHg2Q084NlZhQTMxOS9iR1RSYm9uUjBJbnpGeVlHcnRVaisyaUVkZE9iR1VYaXBLUXI4aEJNemc5VDN4NWRxem9OYVNnZWk3YXVuVWV3dld3cWdWdWk3c0EzUjRFc0g1Ni8rVkJpWU9tc0V6NGN2M0JhRlQ2UllKczNHKzh1R25wc2ROYXVXbUhmaXduek4yYnRTaExCK3FLVXBDQTdabnY0ekZvVEk5dTF3SktqeDNiZldDWHZ2ZkNjZEdEZEFiRDJrMHBldWdEUGtMd2xLU0lpS25wSjA4ZVRjL056VW9LbG5nblVmTnBtS2o1T3dZSkU3WmRuZlJZOXk3L1p2RVQvM00rMCtJV3BzelFwMWZUMEtFSVQyYkc0MkgzRXVtZE85TzJITlFkUDJ3SURvMUxEbzJJMjVlelFNOEwxelk5TENyYTFNZlBiMEhmQVFNV1BMd3FkYk1MMkRRaEkwS0szcGN6N2JidWRzN0JJL3YwR2JtYnpsL1FYbGh3SVQ1WE9wSWNlWENvYm1na1diMzE4UkVMQWdLMHZCQ1p2T2R3UnRxZTNOeTA2Zkd4eWRNajlkak5PakJwYitiaC9XbW5UKzgzeEpLLzhVRDlJT3QzK2VkdjV5WmtUOTZwNS81aGNFNCt3alFodi95REVYYVIyMGVMbk5BWDRTRzRRVHZjbUh3YWZJQWhFb2NEd1IxM2hVa1FDQjdRRlFLNUtSbnhXVmtaR1ZsWmVlS1UrUGdwRWljL3Myc3Jjbkt6Q2VLdVpkbWVDRjhuc20yTElPK2gwTFZQQVZpRCtsRkJlZm1qWVZpTnJmc002NnJuVW15emthYlFBV2s2Y2JMUFZLUloxMWtjaDlzUXorVE9JcjgzZk9xV0tOMm84VEdqdy9SWEp0Q1pHVWQzWk9uMnBpMmVsNlkvSDA5cjBsSnlqczdQMHQyOG5IbmxtSjd6eGZVWWJIWGNNQkNzSTN6Ylh3dCs5S20wemJXVFBoOUFuWnRTaU5WaE5KZjZFcVpWUW5pRjdka3ZucFdlbjJIUlo4OHZtamVRSmRzSWZWZU5PM1ZYZS9QOHVTZFB6azhjTVhoY1VOOFZFcjVtclhudk52N0M3VHVYTGxaWFh4by9aT2o0QURlOXV6VzBxYTc4NjduZnJiNzc5Sm9QQmZ2T0ZUelMvdE8rQkRmQURkcjdOT3Q5ZnNTdFpFbnpaOThrdnhIZVdvZHFUMmdqOFNIb3pSUmtxM25aVWRRMDVtVHZSQVJ4VDBWTjFValJHTmtCTDhYSlpZem1TeWZFdjljY21EY2NhVUxuTlJlSnp3VnBkQlEzV3ZTd2N5bnBXNzFjN096VDExWGloRWNWajd5ZUl3ZlEwL2FNQTliVC9OUUY4MUxtekYrL2NZNDBleE85ZGJwaDh6VGQ2TW1SUHZyVXh5d0hDNFhBYlNIN29xUmVQVzROZjFKR0oyV2ZuSDFHZC9MRTFyUXMvYVBldDI3MUxhWVBaTzA0YzA1N2Z0YnBoQnpwMFpOaHQzcjcwSHVuaEcwSjBRV0Z6RW1PMHZkOE5teDRhWGM2S1dwMjBDUnRsZDNUbTFjZlA3N3UxNzNiS0wvZXZVZGNmU2J4d3FwRkt4Y3Yxb2JPaVlnMlNCT2o2UkdoZ2FPN2FscytidzMyME9FKzBHOTNMOSs1ZEx2a3RKVmVPMitOWWFaMmNOaEF0NjZoMTI3bDdjbk5UcGZPWk5LM1R1eS9WS1RkdG5MemlxMVNHalFYY21NUFIwVEV4RVpFWk1iazVoN096Q1ZWNEVzRHdKOVppWkhqRER4ZXFtUjJ3NGh2VlRuN2JYaWdFa1ZJZnFmNUJIdU5VNFZ3MGN2Ri9mVmg5SlF0T3Iwakt4eEpQUkU0RERFZ1NWTVJLeTRRSHhqQXNRUGk4Qjh3Q3NpUDdzRGdKbmdVa0IvTndYemNGeHJqdmhNUW1jSjU4bG5oNmF4Qlg3Q2JEdi9Sb2hWV04zczg0RnV5L2xzeVhaeWFFemhPT3lSZ1hCdjdVVStlTDVMYXg5Q08yeXF3RmZUUVFkdjNYOEhxeTRBU2pETDB6ZExwWWR1aTh5NXJpMjdrbDM4NTNXZmNSc0pXNWNzdUNvK0lHYi9DWm13MVhzNXlielhCUFZ1S21nMDluWkdtM2p3dUJ4b0tvemRlZDRmR091QnVWRHdvbm5qRmJZKysyeTQ2Zk9PTXRNUGFyS05ITHBUdEhaMndWcW82UXArZUgxeU5HK3ZhZCsvajJlL3N1TkpaK3NvWjlJa0YrNUppdEZHeE1XUDZoWjI0dEZqaS9pSHpMT0U5a1UzT0dqRk1oQVNUL1h0V1UyR01iRSttWEVJWnEvbFVkSHBubHNTdlI0cGdYRVd1RjRKWmRoMUVyajh5OWVaa1YySEY1aFdiTjJsTFR0eDZXWGxpOUhEL3VJbERReVZNOWNGV3ZrRmV5NXMxa2NlL3dkWE1waE5aQjQvdGgwYVZqVXZPWDNqd1VndFUxemRZajV0N3RzYnFoU3NYckZvZzhjSGlJTHRwQmtQY3RKUzBnd2YzN2p0NEtDMTVtc1RuN3RoN05FdDdaOVRwN3QxSFRSNHlaZS9VM0ZTSnd5MWFZaFYyeEsyK1l4VzA0S0FSdUpHUExRZXFjalFLUWJMSi9oMTNmRnI2bFBtTGxpMWZKcTA2bVhudXpHYWI4K3lveGQzSFlhUWRtUjJYZCt6UXdTeUpTMEVwSWdkWGhmVzc5cTdkcTd2M0lNSjlZTUJvbDI1RHJsWXYxYmROcHB1dGY5a0duTWlRdmZnQ0ttalMvRjQ3UFF5QkhuU05hYkF6M0dYeEtPeEw4MEwvaFl5bTVieEJTTk5rM2dqazEzZTFmanR1S1BqTkNKM2NUY2ZoR0ppM0I2a2V3VEZmTkJmeTcwUHlBOVg5VWdnb1U4TVMyVW9ZTXlHdnBPVDg4U3Y1NThOOGZDYUVqdFhET2V1V3ZYbzRPRHpwOGYxYlNkbGZmL21VT1pMbFBuWk53dXA1MGh0bUJlZVArSnRDeXVwcEpGakxMT2R3OUVKVSsxVnplNDJ5THQ3N1d2RHVqbTNCTXFUNUFFRWNXVWc0WWMzR0xhczM2dzd0bkQwaktXbCtZbFI4MnJhNSt2QkpkT0xlRTJUVkZubmh6cmdMUTRlUERSZ3lORC9nMXUzTEYyNUxuUENNNlF5T05FWU05MnBPVlo5SDhQNVJueXFPUEM0Ukl1Zm1POEplejVuc1A4bjJuUENPYVFrY2ZVdmtZOUtUTWpQM3AyZG1KdTZQaVVsS2pKRzRTVWpGYlVRdDdYb2pYb0Q2dUpqR3l4aE9BR3ZNMFZDWGdUcWtYRWZHZlpEWFBaby9IcE1aRmg0VEV5YnhXUFdnQzFoZkwwaS9sQ0Z4aFdCNzc4NWRWVUVWaU0vVThJNHpxb1FvRVpyWlJZbGN1cEI4OU1Hc1N6cUkvUWVhd3dJSXdRM2ZZQTM1V0R0akxYWUE2eDVnWFhQakJEY1dyVSt4QmRVbnJyRGdEalFxVkJXVWdWaWxmc1lkVEgwZVpKQmR5N216OEVQQVFlQ0pQU0dJZkx6QVRMRVhlT0VnOHZIRWhFcmN4Q2xUQWlkSFpaMlR1TTNJMUFsNkNYSW4zSkord2VLQ3Y2RGdMK0l4ZGNLT05MLzNWdGVzeGd1aXAwMGNPdGNHQ3RocmN3OU8zaHhSa2RWNHhwMHg5MXR1c2FudTRjcHlSYkN5U0ZYd0RKeElseVRPQU12ekg2U29vT2xUTlVSeDRMV3lWdjVQaW1xbHRkR0p3VWZ6VVhQbU1yWVd3TSswbGpacEdGNjJFN3BESDZ5dEJDMzBmWXI3UWxOUDNKVEZmZkFtd1ZzZThKemxnN0tpVHAvT3pqNTFPaXA3OHVRcFVaTkpCWThMWVRxcFlQbFRkUUVuM0ZsNzRmWnpIWmRta0pOVHVIT3BWZUJZQnZXclNKdVdGS3JnSUdsUlh3NTg4RWdCTnJLVE02NUhsdWlnV1JXb3dRSHN1NE1hazBlc1VpRGRENmJic1ZDSTIyUHlJMTY1RXdUUmZJM2dLcnZXNEU3eWpYWElSTE04M0VyZEszSkdWa2lMR2JkanVBNlB3QzJ4aUJmaktTQjBoZ2FnNGFwTEg3NnU2Zm13TS9kOG1PSHM4OVVwdHR5R05RL0ZGZHhMdkkrRlhYQ2ZyalRWYzRkdExONkY3OU5uRUpRTDNqQU0rMWVDUHd4L2pvZkRXRTg4bHVXTkdpRWM2WThqTDg0ZzI2YW91Q1A3a3FaT1RVNktqazVNUDhvWjA2YVFTU2duZHpBbHM1elFXK1RnaS9EVUZOS2RsVVB3V09HNUtjU2I1ZkdwOTNDVC9UR3lDck5jeFdERCtmSTFwQ1c0TCs3TFZlYU1uckJWL3pLWGZwSXlvQnczMG1HeE9RZTU1SW5oQk54VTdrSkRCc04zd3J3V2MwL2JnWFdLMUo1dEN4VUNoM1d3b2xJRkQySEZibEdveFB2UElOc1RIeUhyTFZjclg2L2xXTnpnN2hDb0kyMHJuY1A0SkI1OW91ZllKL3VQbHBqRHVNNWdzb1BTY3diSUwxS0JrWVB1YTBVU3NDRU5xaEd3dlJ3TjlqVkVQRFpsckxJV2M2Q3B3QnBvNDRuYllJMFhFU2kwRVNEVEZPSXAxMWNFdy81MXAvUXZmZnZ0OU9pNGNmMGtUa3BjSHBzWXBRdGhyeGJrUEwzS3VZS2RLUnJidVhJRkJua1JFZHRCWkV0cVFxU21YLzRzeDk0UE9UTm9xM1J2NjRrejk3VWMyLzlFNEwyNTBxQzVJWUg5dFZ4OHhoUU9PK0RXcGZDdEdyNlhFdkhlUGtpRW5QSW1VT1Erd1o3UEhJREEvWGd4NzFVMitkbHEwc2hrZzQ2UHk0c2huVlRENUVKWHVzdGxrVlB0UitxelowUU9ENGcxMVpPK01VZmdJL2Z4eHVQcW1xdTkyMG84RTRHNzBsd1Z0Q0JGUHVGdUJ1anpBdDVVY1k4Tlg1K0R6ZE12SkJZY0JTakdqaC9BVWVGL3VnYVcxcWhxdVVDeGxtUEF6UlJOYzFoZ2xCMWN4Z3RvWFdQTFJmcXNrajd2b3N1WGNtazcwQnU1SStGUVpJQ0pWVENCK0M0L2gzNVBvU254emFxR3hjK2dXNjJLVy9rS2hsWkRiRFdaQ3BOS1lTcGJHbktMOCsvaDIvZnlTNGxmdlViaTNzRnc4bW53aGlzaXoxS0hZdCtYUktMMlJLTDJycHdBUHNUanczQnNTZjdCbXhLL2g0aVd3Zk5xQkNLZTVIZEV5aTJxT0ZYdFo0NyttK0ZVcXFVcVNzVlFrUlJWcHd1VlNsRzlSTlZ5aXBwc1JVVlFWQ2hGcFZGVU9FVXRwS2dqRkxXU0lwWUdhaXVsV2tGUkdSUTFqNkwyVWRRdWlqcEFFWHNETlp1aXRsRlVJa1VsVU5SaWl0cENVV3NwWXBXZzlsREVJa0h0cDRqcVN1VlExRkVWTVUxUTJSU1ZTMUdFejNHS09rVlJlVmJVT1lvNmJVWHRvS2p6RkxGYlVCZFVWRDVGWGFLb3d4UXhhbEEzS09xcUZiRm1VTHNwYWpORjNhT28yeXFxaUtMdVVzVEFRYTJqcVBzVVZVeFJENnlvVW9wNmJFVWRvb2pSZ3lxbnFLY3FvaTVUenlscUwwVnRwS2hxaXFxeW9sNVJ4RVJDTENMVWVvcGFSVkViS0dvTlJRd24xQldLcXFTb1d5cnFOVVdGVWRRY2lscEdxVWl2NTZ1b1JSUzFsQ0ltRm1KalVhMWlxRGlLSWxMeW9TZ2Jpa3FtcUNpS1NxRW9BMFZOVTFGSkZEVkRSVTFWcVVoMUlaUnFrNFpvN0tyRHphaURsT3B1TXlwR3BmcTBXdlZVVWVrZEtFZGl6V2xIRGFTQ3FDeVZwMnE4Q3F4WXE2NVc4VllaVnJuRVJ2TFc2cnZhU2oxZHZZRllRWTRSKzhjOW9vTTBJWmFPRHRhKzF2T3RsMXB2SkRhTmYra2MraVFqTUQyWlNVd1VzNXg1eHpaZ3Rld1FkanE3bXIzQ0ZyR2xOc2htbU0xS201MDJaMjBLYlQ3VWtlcU1xaE5jSjZiTzRqcWJpQ0plWE9kbG5ROTEvb05Hb0dXb0VKV2lMNXdmdDVqYnhOM20vcTVicDI1dzNaUzY4K3J1cmZ0WHZUYjFQT3ZOcUxlaTNzRjY1WHhEL2cvZWdlL0ZEK2VuOGVmNVMvd0QvbnQ5bC9yZDZ3K29QN24rendaMUcweG9NS2xCZUFORGcra044aHRjYlZEV29MckJod1ovTi9pM0lkV3dVME9YaGlNYUJqU2MyRENzNGZxRzF4cCt0YlcyNVd3MXRscmJicmFCdHJtMmJ6WE5OVTRhRjQyWFpwd21VQk9oaWRXczBwelRQTkZVYUY1clBqVmlHamsxNnR4b2Y2TWpqZklhbld2MHNoRUlIc0oxNGE1UUxMeXdVOXZaMmJXenUvSUgvNGZkSCtJZmJmL284OGVZUHlMK21QSEhoc2FxeGkwYU96VjJhZHk5Y1VqaldZMjNOQkdhaUUxYU5IRnBNckpKU0pONVRUWTMyZE9rcUltczdhNWRwazNYNW1zcnRYL3FlSjJnYTY1ejFybnFRblFMZEp0MTkzUzFUYTJiTWsxdG1xS213NXFPYk9yWGRGelR5S2JUbXk1dHVyMXBkdE1yVGU4MWZkNFV4R1ppWHpGUXpCTXZpcmZFTCtKUHFZSFVSR291dFpYY3BHNVNYMm1ZTkZZS2xDS2tPTWtnelpZV1M2dWx6ZEl1dlY2L1RQOUkvMWovbDcydGZRLzdLZmJyN1BQdC85TnNlRE5EcyszTnpqYTNhKzdYZkZ2em5PWVBtbjkxcU8vUXdXR29RNHpES29jSERwOWJhRnAwYVRHMnhZd1dCMXJ5TFJ1MDdOaHlYTXVnbG9hVzAxdW1PMm9jZlIwSE9jWTdwampPZHB6cmVON3hqdU5ueHgrdHVGWWVyWUpieGJTcWJrMjFkbW5kdjNWdzY1bXQxN1krM1BwbTY2ZHRWRzNFTmwzYkhIT3ljWEp5YXVmVXdhbVRrNHRUWjZmdVR2MmNoanVOZHdweGluRXlPTTExV3VhMDNtbTdVN3JURWFjVFR1ZWRyanJkY1hyazlNenBwVk9OVTIzYkRtMWoyMTV0VjY5ZHYzWUgyNUYvb2ZhZDJnZTBUMnhmMlA1WCsvOTBHTjVoVDRlU2pzNGQ0enZtZFN6cStLdFR4MDUrbldaMm10WHBsdk1JNTJYTzY1MExuR3RjZXJvTWNQRjNDWE5KZEVsMU9lcHkyK1d1UzRVTHVIcTcrcmdPZGgzcG11aWE1M3JKdGNCdHNsdWMyM1MzQlc1NzNBNjRaYmdkN096VU9idnpxYzRYT3Ivc1hOdjVnM3RUOStIdUU5d1QzVmU2SDNHLzYxN2hYdXYrM2YxbkY3NkwxS1ZERjg4dXZsMDJka25yY3JoTGJwZExYZDUwTVhyd0hsMDk4and1ZXRwN3VudU84VnpvbWVGNXlEUFQ4NmhudHVkRnozdWVKWjd2UFg5NldYdlY4eEs4ZW5oTjhscnNsZWFWNzFYcTlVL1J5dWZ5aGVlcTh1ZXc3TG02M0U1Mk5QcWJISm5udjVBZ1g0QmxwZ3NzYjFyRTR4WG03NUNkQnVPa0ZCV28zcXBoeWtPRUVaTmhXa1BmWjFwamg0a0k4N0tMQWZhbTJKNlFQd3Jqa09ZSytOaU5RendzU1ROQXR6SndLNE91S2FvdmNoc0JHakZSMkkzR0RqM0E5aXlDNXVUWHZndzNaYkxCallhMlpWaDNYc1ROeWE4RkE1RTlCR2h1eWQyYzRiKzBOZnhrVTFSUHY3eDk5dUd6R3I3Z09zSmZMR2gyRkZXLzF0YjJMOEhxZlZMcUdocUMyTnN6TThldUQ2dk5hanlyTUtBUzE5OXA4MCszNWl5Mm51M3QxVTdiNXQ3Zzd3YnB3QklhaDdIZTI4UHVMTDdYTHFieEZ0Y0hiVUUvMjhhQkJSODRKVXlNQ1IwNFZ3SS90akExTXpSSWkzZkRkZUZpZHQ3TkxSSWV5ZmJibHBoN1NzdER5VXJsWkFBa2VVbFhVWk4yUlU3RTM0akhsOEpKMkVtWWpIaVlPTGQycE1IWTZJWHRvMitEUGtHZlQ1cG8rYllkTkdGd1ovRDZDR29hQkJhN1lGL2NHTVRjZy9TbFk1Y3VrUk1Nci92MnJ1MkdZTFp2dmw5V3BMUnQ5dnlGdE9aa3oxSCsvaDIxbllxZFFmdjh6c25DbTVJbVNYTVNqNThsREF5NWZPRml4dEhzREgzdVFTQ0hiY3VXMHBORFF5UDlkSnFzM25LY2NQM2NrWlA1eDBNbnhNeWJGaFF0QlVRazc2ZVQ5a2Zubk5EeStJSmxzRlNXd2VKdm8yc1Y2bXZ3U01DeFZkanBCMVpKTnk3UkxZRVpCQ0w0YXNIM0hvamZnWkZHWHFMdHNjb0RPK0ZZTFNrRFhoVnFXRWxLUWF3SE9ObURTaHJwVDMvSHpEMHNZbDh0OWgyRXhaYVlrVzc0MHo5QVZRVk9RRXFOa3BFQlpES0orajlYdzlhSHlCdnJHTXlmVHVvTkRZSzlIVzVQZkFaVUZWYmRQdWY1TnpRNG1mUVkxeWRiNE9KN0NKWlVxcSt0RnZFa0xCbkExd0E2d3NHMVVQM29uakE1TStIWWxvM0tEamRneXZqeDgyekdzbmMyVmwrRHh0cTdZVWNuRTN0amhNVHZFbkhNVGtWUHZPZUxoa3dSNWI0UFVTY0dmL3psVDc5aGVFQ3ByK1JWcjFTWFBzR1RUMnBvQlUrRkw3c2Y1WjJVTWc0YzNYbE9kKzdvclBnRCtyemczWDFhYTF2UDZCTWFMTVVuVEowMVVUZHg2czZNQkgzb3lSbVB2bWlkN0Z4MmVKNGVKQTArVlJqOFZ2ZTI4T1RkVS9yVDkzWlV2dGErVHEyY2ZFKzZHelR3WkVkZHg0SEJnNFAwa3dlbGVycVFBWEFnKzV1SkQ0RW4vUmo0VVExSDdJeE55ZjUrSXN0bnJYd2p6NnhXbmZvRUs3K29vZGtROFVhaGVPd2paSk5Bc3AvNDdJNEkvM3hRNTF3VFFmMEdxMWVoL0NJa3UzeFI1NHhFTHdyRXkxOWJBUU5aWHpSL3kvdVdpVUJYZ2g2YXRTZDc3TTdEZ3lmSDY2SEp4cGRmTnFCQ2Y3Zk9neDZJYzBnTHJ0V3E1SVE4WklweGxsWE1Tcnpnb2dpRG9FdkJCUnUraS9qeVBqcHhDOTFJRUUrbjY3Rm02YUFXTXhBT0ptS0VEYVdpNWtyWnZYNUVLMTRCZi9zaUhJRHRVc2pURGFvOXNMUlVCTGM3bXRlbGQ0VGd3NGs1VzFhS0U2TW5UcGhuTTU2OXRiRXlIeHBxQ3lJeWcwT0lDVkxTTkY0RlAzelI3Q3d4WnhINkJHMlZIYWhLUHJCSkpESHlxTVhpZHJMWUNEV3FuSS8zYXQ1K1ZjTXhDQ1JISVN2WHJ0UG1iY3M5a2lhZE8wTGZ6RHR6clZ6NzNmc0x0c2NkK21PNjQ0elZzOWJPbGo3TnBaZHVXWmEyUzN2M2VPR3I4cnpSdzBPblIwUWxTWUV4OVBDUVJQOEIyamtyNTYrYUt5VXJheFpVVFhnQ3FtTFljbWRJS1ZnL3NUMWIrV2VsN1BoVTgxWCtES0x3VnpXb29RME13eDNCSGdmaUNOd0h1K0pVbkFKZXVEM01xZjZlZmUybVB2Z3FIVENzZDNJdkhaNkFFZndCdmMybldvM0FGN3FCV2psRWFUWFdlVlRjL04zcG0xWnRXcjFaZnhYVzB0N01nakcwNXNYWlZQKzBJQjJtT3JiRzJoWjMrOVdlUHBkK09sTWZ1T1ZreW5sZFo1Z3R0Rjgyb1Y4LzNjQ1VDN2RMemo5NWZEVXpjcmllRDBHcWppTC96OHBxbVBFQ2txcHRhei9EcWkvZG5uWDdxdm16OWlINjVRK3JXTEI3WFFIV3p5Yzg5dHFyMThoMzBzOWNMZE9DdFhjNTFrbTRDYjRyUUJJZ3R1SmlZUDhCRXlaNDZ6R1Bpd1NZQWZhczV1L3Ewd0g5K3ZvRmV1dDUyRUJVVE5YWnIycTVXYW9BWGNENkF6UTVybmM3U2p2Rjl1aUY2OFVpUEIrNjRTWXdpR1JOV3ZsS1B2cnF1U2piZlZQRDhGZUNmSFFuV3VNbWJDT3RZZmdGNkxtb2xuZmJEVVA4dFRRRFhINEwwOStRR0JodUI1ZmgybHQ4RGFaRDlSdFQ3MXlSaDMycHIzMUtZRWdObktpMVBmdFZEbitudVdnY2JRZGY4VnRYV01IMldqb1NXMk1YSGRiZ3VvOUUwSUJWMWJDV1IvV3ZqOVBRS0JoejFiaUREdmZHdmxqQWkvQWlNa0IyMEJlNHA3ZXVIOUZyVWplMW9pMS9Rdy9ld1BXVTV5TDgrMWx0YkdwbjlHK0RyK04vNFhxYlgvNmY0UUg4aXgrd1BJNmVJdForVmE5Qi9QSFVOOFo2S2FxOW4ySEJaL1ZlaUNDNmFhVXo2S0Z4eFovUVFKSVh0ekd0WWowREovVDJIWGZxdlhTZmJaTk1LdWxKQ245V3l4bDIwSURCK2JJSUYrQWhmVXZFTDAwcVdsYVo2NW5DZmdPSzV2Tlh2cFYvcFNqUzJXdjNGdGZJdjlvUUdjaGpTUGxQOHNOUGF1TW4wano4QjR2WG1VcndHcm1FeGsxKytYK1NMekt3eUhTUnJtVmdpWHlSTmwxa2VkaXJWQ24vOFZtOUdQRkxSVVg5YTRINGI5ZkZ6M0QwS3hHMHpBdXdGSnF6TC9NRGV2WWFPOEZkdjl0VmdEOXFYa05kNEZ6ZjRELzBlSXZTcXRNTUQ3ZkNER2YyaWhmRVVGUll1Q3Y3dWxUZDd2NHRqM2Qwd1owVE5XQ3Q5UlcvMnZWRm5nbUR3aVpLdUFIWTl4c085YkZFRzhLQzVnZnFmbHNtOUR6VXZ5NStnV1BmMVBKRU8yQVkzQTB1MFQvMkZqNy9yb1U2SHUreFZzSjdmL2wvZ2RQL01NMXFsSVk1c2VWWFNjUDhKblRWODU5U1g4dTNxMVVQdmtEMlYzVWZrZjlJMXFkLzM2aGdKWkhvYy9sZjRZM3BZU2VZYi9yM3Mvd3Y2WGN2eS9DVWY0SUhuOVZRazlvUjhkQjVpZ2dWWUN2Z0tYSTU3Y0FBcVl2K3hFQkdQbXJCOFBLNkthSXhFVm9MZUtCOGsyN0I0TDZtZk54SnpxY2RHUWdpR1Q4ek1FaCtERU5NaitsdkRFektSNDVFSnZXbWlQSmZEeEcyWWZCQWZBVDNneU0wUm1RUThBKzhCQU1OTENrRW1kQVBaOUpRaDhFTEFHZ2VlTktNYmFSUjIrQjZJR2xWVXpMVTZXOVVTeEYvRjlWV3FpRVh0eFpLc2RxWUR1b3k3UGV2SjhzUElRWGUyNzFqOFB0ODFJRWgyY0NHNUJ0UDh2MzB4SDQ5UVAwckhhdDdzdndCbVRQL2Q4cUxsTU8xTVNEVEhnd2VnMlg2Q3dNaWJJR21lQXZObi9OK3JwTDNlNU5UbUUzS0tVelNTUkhjNUJNUktGbTB2ZlFSWXQ1cnpoTGp4blJpMnpqcmd2aFBjMTc0RnNQN0twanhETUd4ajVwVXNtbDd4R291anMyOEZsMnNBNGNLb0pWRHFwNWdqUjI3amdxZG5LU0hleDFZVGVxdlNGYXVCMHNGaDFIOU9uc01lL0RYWHdXRlZhK3VEWFNRK096VVYxRDdTblhpb3hweTVQYkNOckU1ZHNLT2YySXJzSWVHRHlzZXB1czljdW13ZVZPR091dTY5YjBGVm1EOTZIcVpubjlyT1EydGdwa3BlMFRTakthd2hKZ0pINDFHVDh4bXdqN2p4WTFMYzg1cGpmVTc0SHRzRUJrUTNGU3Z1WWdkWG1GcmFGWjYrY1M1ZElsZklLcE9uaGJWTFVRZXR4K0xWS0Q2cElaUzJWNGdKenNleUN0TVpQbEtIRlFKanMvaGR2bUNGTnR6SCtIQWUwM0YyWGloeGRiYUhsQlhCd01LZ0FOZUw0L28wSitjeTE5STlEL2tRNmEyaXdPMncwM2ZPVUdqeC9rNVo5TDFmVm1IaVdNZGU0MjdmSCtSQkMxL0NPNStCZS9mWGI5ZFZYRjlhSWNPbzRaNjZYbnoyY1ZMbUVHbTUzdEllcStHWHBBckZLOCtmdjJ4N3NVaHYvNzZ6ZUxvVWRQSFJVcVEzLzVYNUh1V1g0SWd2UlJsSUlPeHJRSEZpbVJxQlZYSlgxUGdnTUpBWFQ1V0NKd1ZQMzcydk5XcmxramU3UEwxMjVmazZxb3UzWG1sbDdQYnN3WVlySlE1UEYrRW5hVkkzbGlPc0IyRFEzRVVMVS9vOEN2eUhiUms3OThIWnh4SkEySndHSm5BUENacm9USFN6QnQ2MlJralNTTllIbjZSUm5kNjJMZkt0dndkVEhrUFVlODBGV1F5d0duMjhkbEw5eDluQmd5UjhMWDNjSVo5ZURhL3FQakloTUVrK0E0S3lWd0JXODhiWFlZT1NlNGJKdDJKSDNGNG1HN1VzSVF4TVhwTnhUMW5janpJRjR1MlppbG96czVIbXFjUE81cVNTWS9YSTFVMlVqc2cvb280enpMelBpMFN1NDBNQzRnbjVVbzcvWExOUkpMbTB5WHhwZm1RcWdyZUZmdFdLYWQ5T2NUSUpHL0VJd1dqYXljZllrWTVuVEx1dEljT04zUEhMRzZLN1dzeEMxTHgxYU1YRDVCMWpjVTVzcS93NWVyRFZ5OXY5RzNkZW1Rdjk4Nmp5V3ppc1VCNjJ1VHJ3aFRTTHMxRCtDclBGRll0bWJONmptNzhzQmsra1hyTnNSZEtHMkV4cTNuNHo1VlR6N2R0WDdGOHU4UUhwcGJEWCtXcVMyL0E1NTI2djhqalprdGV3c09YMEM1RkJkWkVrTUhHZWtMbmJreFE4dFN4VXJ6N1c3eUxjY3Yzcnp5NmYvMmFqVkk1dTN6aHpPVnpkZU5uN0R1amh6Vi92WFJnK2VYSXR2UTlKTDdYVE85RUhzVTRrVjkvQThuenlzbXFneVVUaTBXWnBac3hNTmFVVEg5Z2VMaDBBNUhhRVc2SS84VVUvRXVXTDNBaFNlUzVieWhiUVNPVGxiTE9kWktUNmRaTU01S2xJY25DTDdtQk50dUJOUU04OUlFR3VBOE5OQk9iaHpub0dwc0hQV0JlWTZ4bXNBM3VoaEYwb3pIRGdBK2VSL01ua2NvUDhURXJYOEs5bHlxNXU5MHE4WVFJSFN2VlorR1FjRE4vbW84ZU4wMFRvY3N4RVR6MmlWZ3NRU2NROURTdlZKN0tVa1l5SzJ2WGJmZ2xqQmg3c0VRUFlockNIc2RGM0dVZmdxWWxZZ2xFdnBqNXdsWXpEMDdDUW1GR1Z0YUNJN3FDSzBkdkg5T1BQRWRISmtlbGhPdG1wS3piTWwwLzhRQ3Q2Ymw3NnBTTk1icWhmbEZEdy9VM0p0STVHVm43anVsMjdWNHlmNC9lckpERzRYRUc0OFFVMVZ1aWtQYUVrNm5vSEpuWllvcnEwcnVQWldwNFlQZVcvYnJseG9NWklsYW5kTnNwVnB5NmRBUjlLaEpCL1RucUE3VDZIUHhlODZGNE80TGFUQkVISGtQZ1hZM0hNSnEvWitiTk9uWktXM2d4NThydE03ZkZnTS9LMWtMdDVtMC9ZVWY0amlnOVgzMFZWVmJCbG1wMVpYZXgrcHdJcXo2cDVjM2ppUmhxalJtQ3lhRlNkbUE5VFVkKysvaW5lT3B6NDc3bnFwY2ZJZnFOV3A1T092MTZ3R21mUEtuRlZUcDByeUV6VjN2anpQRzdUM0w5ZmFUYTNmU2ZmU3R4STZ4cTY0dXRSeDBkZlNOU0NwOGRFREJFNjF3NHVTUk0rc3VQenAyZUhoMnVIUm9ZTmNRbkl2K0o1REtEeGxhcjcvZUFSanBRZlh3TTF0ZW1YQnVkb3orMjgveUYyMXJjNllsd0xuSDN0SEJ0V1B6VTVQbFNxNnYweFAwekRoN1RIanVRbGI1WjRuRWR1VUk1QTFjZDM0TFV4NDJxVm1nMXFpMkdROFhWWkIvODdNMHp1VldGWm9lOXFBa2xFMHd2M0Q4OEtXeVQvdEZoK3RZc3Y2TG1PbXp0M2huem1IdmhETXozNjBYWDkrajdaZExSQzZiNTk5SU5HbldoOXMyTmMzZjB2QmRLU0VldzZVc1VlZ3JkRFRDMlVpVjd2MURMNnc2THU4VFZDRllYUWQyaXQxc1JlSlFCL3hTYURFV3dhTGNBZGZQWnN3ZVNROE1Ua2lmcHh3NFFNcGtYMklsK3hUaURNNTIvSy9mY2RXM3hpR3ZkSkt3M09aWXgvQzd5U01DbjUrRDhYSFdnQ2pxOFVBTWxyK2dxRW8xUlZEVEd3dG1pUFh5YWllVEM1cWdMdkY0b3l1c2RFWThUVG9xd3lOZ25RQnlJd0E3M054Z2ZWYWhnZWRXN0tqVlVHRzJFZDc4ZVZSa2ZmYXJBN3hoY3YwVWYzTWordGNmZitwMm1QVlVNUDA1UlFXTnZGRjd5Qnl0YkdGNU1GaEEySG1tTzVSWFF2a3hBRDVySGdiSnFsZ2lmZ2tSL1Vlbis3UzlUUlRpV3BwaUx1aG9xVTJBUU1VdlpRck9uTXZ0VTB3Rml0NHVhUlVkeHJqQVphUjVCMldObkVYSlhGZ1lhNEliaHdEM285RHN2ckNvQjlUTnl0Z0E5N1VqR0RoUklwTno2ZWJMajhPWUlmcGlaUzBYN1UyQkI0VXBTWU44ektIeXFXUVRibGN4T2ErWFJqZ3J6S3BPdnM3Z2RwOVlZRzVGZDdkZTNOZmMrcWlFQ1R2VVFQY1F5ZVVva0lYQkxyZzVBSHVKeGVZbzNDa0VQdG9nd3VBeHBYbElkUldJYWgyejV0ZGthcXlIV1dCSWVRYks4elJHaE9TRHdBYVNSb0hrdkJHZUk3VnJ6RWxyL0toRGFpa1JoZ2ZvUFZaRDA2TS9IYXZnaS94VXRRazk1cWhDYmxCd1RsN3p2OEtGOSt3OWxwaWZHU1kvdEhveTYwbi9neURIOVF2WkdaU1pMZU5ldmRzSG9LUjVQY0Z4NHQ3RURmV2pmbnF3OExTOGZYUG5tNzVyOWJ5SDJqVW8rK2xuOWM3d2RzWlBQWmszUlpBY0h0Z3pZd2pnYWp1QnhERTZBWXdJa3dDY2FmMktKUm1NZXRLT3ZpYW1JS0RhUVg2eVd5YmlsWllHNDQwdHREdFJyWXRadXZIdGhGSXR3TXJURGYwQ1BPZnFZQUpydmc4RGZ1REpTN0lOazdxZFZBQ0xoeHNhVjNtZ0JlcHhEdHQ2akFRRk5lcStESm9ORXpXdHdKaDBuNnM1RWNZMVNhS0lJYzVWQ0U4VnBTaGtjUFFtVi9iRGQ4aVB1YS93UGpkdVdhVWh6TzRNVU1QcTNVbFNnNmNRNnNxQVNwcjVTdmY5czFxZmUyVzFEK0ZvUHp6TDhqUG44U29BRndGZGlIcWJ1UkR6c25VUUdpRFFncXd3ZC9heTUxbk94WWlHUCswbVBFWjBRUEpSYlJ4SXFINWIzQmlBU3pwQmJlNk9sWXZZVzhlelhMMlhvelZkU29JVlNRTjR0N3g4akxoVnY1SkNVVTREQUQ5REpyeHAzR0ViRzhwNHlsbmZ3UDZaUUI1SFBMalBJb1NrcXVXOGNnbHN4aHR5OTRyR1VDeUsyUHVGU01FVHk3ZmhvM0lQWGRPU05vaGxGdWlRRVZxRTF3Ky9vbjd6dmw5KzdJNTA3c3YrZS9yb0pTUC9WRG9aQWcvZlErTUw1T1FrbkpLSVcrZERoNTVMdlB0ZkttK3grZzV3bVROeXlQMFNDbDdJUG5UTngzOUR1V3Q0TkpScDNSSXB1Q0Z4L05neEFic2pEdU1NYi9WWUF5QVFzL3pRUDBKK0E1bndtemZZaXpZNDNOM3ZzcjFKRkorQVhJcklaMTl5MjdNWTFuZVNKMEMwQUVkMENuRi9CNGxjZ0VpWE1vaXJCTWdFV1F3djI1YVVKUFh2NVQzVFhiM1VqcXRMYlY0cXExT0cxb2lwMUJOR3N3emt6ZkhIcXN5Q0RVYWdpZTRpVFZTRmZybndZOVU1akFDTjhGUFp0MjdaN2kzUjROMzMyME9sVHo3UWZQRW93ai9rMlhYQXJ5VFQvdlp6S2ZyOTUrY0dqRThFQjRZblRwaGlrcVFZNkxDRWhNa0RiODFiME9ZT1VQWXZXbk11WnVTczVTcHVRSEJVd1pIcCtsdVNSVEk4NDQwR2FZWDM1MmYxSEFaZEhIWlFpZDlHYTAzSGJabXpLMFBMdWFJdWNHSUhjRVV3MDBnRmlzdmpJQVByV0tGWk85aWFCV3l2RVN4OURiNkxoN3pYNzdNbk9QOGkrdVVoOExraFQ5d3FNbDQxalVMSlljNERraWRpQy9MMUV6TWhYVzVHbzNOdWZiaE45WWUzZGovZm1lNG5RUmk0WktzcTh4YkN0ZWE0aW1rUUsyV29iNTRNbndXS0VFU3hHMThHM1h5N1h3Ny9NcW5XcmRtNmFod1lPamZHZkxGMklIbkhVVTlleDVYQ25CZnFhbWZUbDlTZFBQOUE5T1JZOGNmYmltVk9YNkxFK0d2VzQwdytzUUhYOXl1VkRVcit6SlJFVnVuK3FDRlJRYi9yU1N4Z1RrNVZ6NXREK1UrdjE0THlQVG1LYmQ0L29MOEV5TU13VFg1eFRzQ0I4Tm82NVZuaEpucUJvSERDeVdBM3JXMDRXVXk3cEtuSlBucjhVZkhTVVBqM24yNDVyajlMdU5ER3JIUkZEM1lqYVVRQXFVRDI2VmJaTnRNZXRjWk9hWnRBZ1ZUL1ZuK1o3aVhpMTdCU0Jlb21ENUlzQjRnS3pLRHNnZkZwdTUwMUNSRTRuUDgzZGdoSSthMTdQYXlGcWRKU3Bqank5RmRxTDNza25Ra1F5eVlKLzlSRTJpUHhlQktlTmZmekowNzNKZEVLSldJTCtMaFhMMzVHbm5VekJKUG1VdDdnRS9maGh1K1pIekx0WXNoQ3NpU2VGRC85U0tWbExacitBKytWUDBZa1BrRSsyRm5GR2pSQjlGNnRHRHpqYk56MTBVNVBZSHNmbUhaOTl6TkNrL1lURGcrR1B3bE1SdVJQVGh6YkppaDIzYTVnTzIyRFdoWFJKK3RZQ1drQ0h0OEJCSjNBZEFxcWVqL1JZWmNvZzZMOXIzNzg5dWw1ZS90Q3ZSY3UrbzRuV1hTd1dyQkRMMzRmZlJIN0tEQ0Y3OUt2MmxrMjZNa0dPR0QzSG9JRmk1UGtJNGtJYjhBc1ExeU5GS0s1aW40dmV4RSttMTRtUGkyK2lCUi9KaXVLZ3JDamdDZ01FWHdXejAwMGtRUiswSHRVY0lKbVdiMEVyUG1ydWtEenV1QjAwYklXSzc0b1FDMVpDSkFLd2prUzRDNDRUNUlsVnBva01YeFp2T1BvQ1ByN0lTbEhVQk1pVEZ3bS9NVWw5MG9mbVRkS1BIMVFRY1BFdVBUM24xTnp6T21qeEhWVFE2bUZTUWVoWi9lV2lZUmY4QjlKN0k0SzJUdEJoSjd4Uk1HTWREK3hmUEhlZmhNZmhEWFRxd2ZtWlo3VGdoSHNLQ1lucnRocjBNQTQyMER2aU4wV0ZhczFvU0lrZmpIQXplVVlFR293eWpGeUF1Qno5VFhyY0dlRmg4aXh2RW9MNkI4VFM5OEZiVU9oN2doTHNwS0FFNDVUSmdQZkpCYTNRU2ZSbk5qa2Y5U01ERFlVLytRRHhpZ2lwWmswdzk2TjZrZGh6Vk1Ta2FYb29hdit2WXlhNkpKNDBjd09yTGNoY3hIdWI4VzRydEFTcHl0K3BNeEIvMTN4S3BQcEdUa0NPS01kRXNJZ0Y1MGYwS3hZNzk2WGhWQnRjemJZTm90M1lqNmRvZklybGNhaEZzWHYvM256RWRwLzljSXJrYlJkRVExbDdrNHAxQ1NWWlgrZlIrQURMRysxVGEzdVc5bndETWNwL0tmR1pEOTAyZmRiNHpZT1dBTzNFbjcweENCclBlWU5Gb3U5dm5QZTRYL3ZjOW1RTkQwWHYzK2MrZnFBbktSMVlYaDZTK2dKYWxnSC9Rbm44cnBBVndVV0VOUkN2UEo1alJXVkptSXUyYjU2SGV2Y0xIenBaS3BqYzUzZ1gzWER4eGFOakJhZjFnODgram5xbXMrQ0MvM3Y0Y3oxUU5CLy9hQXI3aUpwT3VBUit4WWdXeFl2TXVlWXB0bWJ0UzFQWW55U09rdzlQVjViM1NlWTlpQTdRaHM4YkFXbThRRWYraG04ME0yMzczOUZMY1NBWmo2VmtQUDc2YVJValdsU2JsMlorbWs3UGpMMm5FOUhEOWwrOWhWVmk2aFVFL0FDRTFmSmRZaTRBWG5sUWxZQ1NXWldqWkZWMm5GcjUxTk5DRW40Q2prL1VNRUErSlh5NlVGeThTdCtMaVZtZUVqbE9OeTRsKzhoeUV2SmRkZG4zdlk3SHBmSmpBelJJVVIyUVRVTFVvYmpzN0VPSHNyUGpEa1ZGeGNWRlNjcUc4VEJaYkZVNVpLbFZ3eGFqTUZURU8zSDBZM0JMVVdXVnE3TXdLd3k2RW43bndOWTE2N1pKRDRnbXVYRDVMTjIwK0czWkY4OW5IdCt0SDd5VG5wUXlNcXlYbHNlY25MOUNQSElUYWFMaGk5RlRlUVoza1VjdzJnZGg0YVFJbzR4OWhPYk1PT3hJRnpFd0N4eEpZS2c1d0tlSzNkRkFCTnlpOHJFRzJhSFNGalR2d1pQbzYvS2RkY0pqZHRuOGVTdm02MklTdCtYcUliT3EwclREczVMVlREYzV2SmNkd0JPZllEVm5oK2FPcU16Y3MySGRWb2tIeE9NWXhXSUlqZ3BZUnk2QkZVS2xhZE1aSlArbGhIOXVVOEwvRGptRDhCRjVtdUVwZ3I3eVZtR1V5T01EY3BSQlFiSkEvZHZxRThZV0NRZ2Z3TFlHOERTQTdlL0kyd25JWGs1V3lueVhkNUV5dUljZEtXaHZablBDNkRBRTJlTjZCbkF6QURrVlBIRnpDTUpXTU1nQWp5cWdEV0hRanVpa2M4QmRnRWVIUlB5STVmdWtHYUJOQmF5MnBQWlUxTnVaZ2hkb2NKdEthR1BCLzZ3bU9WZXovTTAvQ1p3dFJmVUlUZ21ZZnRjZUdHRGV2UWNhMkE3dk1JT1pEaDB3Sy9GeS81MEdFRkpVeHFwYndteUVDKzJJYzQ4NHZIeDlKU0pxaWViQ1M0dWhVTEVTamhZMUtTOXhnZGxLYUd3SVRpbElJdWtwSWk0eFE0d3ZuazdQUFNoRkhEeVZkRW0zWFBRUElyZHc5TWVtVFU0ZnIxT2d4M29lVHpNclZSdEZpNC8rc2hIeDhQWThBcTlpYUtsOE5XNnkvMFBrTG1wdTQyaDhXQ0NlYTdJdjFDTWV2b0NzRDAySnVrd1VBNzRYS2VKYnJQR0FsYjh6SDdZbU9mcEE3VXhSVG04aitzdXF1YUxzNWl4MmhObzVTUFpwTFhhRDJtbWljV2hMNUMycjBrV2pmMCt4TTlST0V1V2JyY1N1VUpza2d1d285dkdlS1lKVkd4SDdqWnNsOWc0UzdYdlBSTkNPS0YvZUM4WDNSUFh5SHpkWHRHdUxPbnJQUWRzSVIrOXBJdVFRaHVQU1JUaEgrSGxQRXFFbFllZWRKQTV6Rk1HUG5DWGFsVmM5Z3lhdlZORDhrN29RY29TdUgxbnNjQUhzZkVDakszOTQrTlJGL2ZoSGRFU0UzNHpoT3RkdXAxK0Y2NkVQazFkTzQvbk04czByZHV6V2JsKzFmZlZXQ1RLWXZHYzBQc2U4UGxaNTVyWHUwdGw1OGJuNkUwL3BvNU9HNytpdnc0Mnd6Z2M3VHRDMzcvYWNXVEZ2eGF3NTJqbXJwcSthSi9FdVMxN0ppNnBWZjc2dmVLL09nYTJDSzd0LzdiNzEremJZVEdFN1h1d0hWTUdoZlp2V1N5L1pHWWFwODhKMVlhdGkwNjlxaTFtd2ZuZ1gxSDlxUC9oZmMrL3FONnlOaEJQWW1Oa3hDeFl1dDRHbHNGSG9FVDQ2TUVRQ0QvYktudDNwaHpjYkprczgvRWRXR2VEU0E5TFBNdWhkQmx1SXZsUmxGSVFIK0VvL3NNYVh5dUFTS3ovRGx3UloxWUcxeHh2c1lRUGQycVFxZzVuTVp6eVR2c1Y4ZzlrMG5zM3kzZEhtTUFSQkg5WHlXR0xYczNjRkoxTTBkbktWN1d1d2t4d05UZ3dQQjBtR3NSOWgrRWUxTVRCRC9OWDZzV2hzWFNiaTRTUjVPTVBMWnkzSmc1UnZJNCtmOFJuaXYxNlB4WjllSk1zZ2ttVVFZd3EyZzBHRTZ5Q1NlY01CcFA0NXFFYkFSeG5vSWtmVHdOYjhxemtxL216RS9IS1Jid2psTjBXOGlJSGlLenRFS0FoRHhubDU2TmNBVjFDUjZGMnV4cDQxZU4vdllsWU0vbUxxc2tPVU41QmNVUjh0UE8xSWRRTGg1d29NS1hEUWxYREZ0d25YU2xMNWNxWVhZV284VHJKSGZsUk1xRTJ0U3pQRXBqaUlaR2JBbFVEVmNJWnJVK3U5cE5VRENadUJERGJaL2JlY2dIVUt6UEFBdy84OFFzb0hmd1FmOGlXZGJVby9xRkVTbzBGWDAvUm5wSmxWSjRWVnVtdFRlaHZ6cTdOODQ0a0krK1RvSjZMSlQ0NFdYaENHeTVqZWhPRWZDc09kUkNCSmlrRGExd2k1cU9iWFAwZEY0dy9HcEZIczZwNTRCdDFSanE1bXdHb3RndjJrMmdBaWl4YXVmekxRQXk4MUoyT1ZxN0ZsVFM1aVRNTklGcGNEQ0JMSU1CTFRyOUFXKytFRU0welJaSFZVbEU4eVBCaG0xL2lVeUN0S2ZHcHNyMzJTdTN6VVpCazd3aXloTGRON3lTaDMvSWNPODgzTG9RZjArTHNjZUdDS2huWGNyUDhJaHJhRHlaL0N4ZUJoaDF4MDJKMTg2dUZZSEFPZE1ROWQzaFJrWGo2cDEwVDMvOGp5c0RBTXdjaVBjUEd6K2xvZWNnVWQ2YWZPRlI2dzRBa3RRUTJSTUJVN2doVjIwVHViYmdoeTlBc1diRDUyeGM3WTNhRlhNejB2UHlMRkI3NlhONzFYUTBrZXdudGNRVU00a0hGOFZ1TWc5MlFneHJTTkxtTWdUdDVHbTNxMlZxSnhZOUs5eGpWNFA0c2pUVnRwb3VoRGZRTzB5QmNoL3ZzRFpFeXMrcFY0RlBFVHNNYndzMytLQ3NaWHFXR1I4YVNBSitEbE5MajhHbFZsSEFVdURDbjJ5UURkcXFCSGl1cm5GRGdoNEhVUVNlTWV2d1o3R0FmamJpeGgwTXpDd0x0S0xYdlZDcmlIY2JESEw1TEVRQVJlUjZybHQxMUMxeDRpZko2Rk9vRGtFNmJqdDI2YVRzaDVZQU4xYUI0eVNiTGM4Q0VDRzF6SGRNS1VkMnVFbkNjZkI0UVJEZWRaVWp6dEVqTHVzQ04rakRCbnlwUHpobytRU1Q1TThwUGlhU1FaYXUwd1lTYWZJR21FTlVsVEVOdVlsSVphcVA5TWhIVlZLbU5VcFZwdUxqOFRvRDlUVVRTeHExZmZTVDMxK0Y5b3dlQjRQQlRpOFJBYVdzaHFJdlcvWDBCRFFHM2VZRTZQUnpNOEhDVm4yNHZ6UmZrTEVkQisrT2NCZ2hlbXhWWHlVNU1MRVI4a1dWSnpTQ0t5a3hmTERYRUxGdUpoQ0k2SG9UUnVZUW8xUFNYTjJGV0E1TmRFUHE4Zkl0TmlVME5vd1dKU0k1Q2FsVnBEWlNYUHB3TDBrbVE1QjdKQXlqV1VGM3VZbnNxaFpuYUVGZjhJeVJlcjFOZU1qQ0F2Tm5uaUZveWxEb2dudGNpclRFL0pTUDFZVC9wNmdnendZUUF5d2t1cmZpMDlpbjVPTnpIQzc5YjhXdXBoWEVvNDhzQ1MvNEZMVlFRNHFpSTJtOUxQYWxocHRCV0FxL0xGUGJmcmo4UU16ZWlxdzAwdzdZb2RzQXR3M1lDSC9oL0FIaExoSGg1V2lPdU83ak52Nm1qOVVSLzZRUDcxOVVkMXQvQSs0Yzd0aElBY3ZjTUVYQmMzN043cjh0c1gxeDZCU2lJN0lSaEYvaUt0aUQwYjduOVF5KytKRmRhMGxxajhSaXU0Lzh1S0dETUlqanlEbkNBUjRkV2FFQU5IWUMvZUJ6dG9XVlZyV3R5WmdReThCMmZnL1RSL0RGWVJNMXpDZGRUUjhwY3J0ODVUTUNkRnY1b3FtSk54SW5RajhXazFLdU53WTVwUWc4ZXllTzZ2aVZnakl4cFRESXd3WlpCc3NNZVlSdk53RS9objBLOWNkYlpLUGtWRTdnRFRCZC9ydHlPTGROK2VQUDc0c2RjVHh3R2p3L3NNMXo4YU5mVFlBSjFqcjE1dDJ6N3AvYTNveXZFSHQvVzRMN1FWTHVlRWpEMnQ5dzhPRFIrdkd4bHgvUExsM0x3YmVzQzRuK0Fmbm5jNVNILzVUUGJ4eTdvYnVhSGp4a1dFamRUemVDaWVVRzFNcmxhQmlqeS9xaW5DbU9pNElDbTY4Mm5tODQzYm4vVnlKWHZsVU1ZWktiTTZuR2s5YkZnYlBmL2tyQ2ludUltZnJvcnlBVkxmYzV6RXZnUWJHdlJQUFFzUlB0NGRwalB1MkliR0R0NHZMNkp6V2Fod3VxaTRzOUE0NVJoNGFSSFkvdmNZdVBsVG9PMFJGRzhWd1BZUmUvWmdRbWo0dElSSittMERoR2MzYnp3dUhuR3pteDY3a29OZlVPeTUzYWFJWUdWbkhHSDAvelZDQ2E0c2xhK1ZxY0NxVXM2dVZCdno3WlQ0WExHUzJHWGtiTk0xVXpiRHczdEZQenFFaUdkbHFWRThSTlM4VXNGMGhZR2o4a3lhTHlEOFJQZ2hRRE5ZQ3ZaNEtiYkhTMmk4RkpZSU1Bbi9vQ3NabUFRLzhDUUEycE93cXBuMVhINU9CdVdGL1BDbDJpQytzQU4zc0FYQmNsTUdDOHJxMmdXQnUwUnlyak1ZaVNuUUlQTHdiTDNCbUpLaU92c01sbFhDaWdxMWNkY1pzUjFxTDBwZWRpTlR4eVpNa25Bd2hOQ0tsbWVmOGcrWm0rMjFwb2QyMFA0dnFBdjJleVc4aUZYdVR0QUpaMmJuWDlmQ2MzeGVnRmtzZE1TZGdrTEdUQnUyc0FtZVh5WkFSK2hJNDFuc3NJMStCNE5QMnZCeTdGcURjUTVaRHZzWVhZUmh0MHpGdjFUWUFDdUhqWVFjL0lEbVlSdUIyWVNRbmF2YkV1SFdMWHdCcnNKNXVETHNGajZMOC9GWnlCODJITTdoSy9nOHZucHJ1SkpDODJUSVRQa3dnQXpZanFjdzJ4N0puZkhBSUdVZzZ4YkMwbnZmU0x5VGNsb05ybVFnYjU1dmpsYWpmNVJyRU1DUWxLL1BvTlZRQkd0bk9DS0Z6K2hDZUUxaUx6MkY4U1R6eU9iT2hNM2ZoVkMvNEdZUjJKQ0VkOCtnQTBtSWJOVmE0VTlacnEzOFRSSWFLamRYb0EycFBBVjZ0aVJWeU8yTEFHMUY4a01TdFFYNjlqVG5OOS9ZK1VleFpvRDlNZ1ROS3pTL0p0dUw4SjhjSjFIeksyMllxUGszTFVacG51VUt5dy9DMTE2NXhRSk5TWjN6Y0U5SDhSR0NmbFZxaUo4bHdCREwwdVVwTDY0eVBUV3R3c29FckVpdGtoOVZxY0QzaFh6L2hScVNvS1VBL1NDY1RIUUdYTUVXTk9DV2YzRjI0bW5wV0FtZDZUZGsxd0FkRHNTZTVETjVoUjcvd1JpTkt3Um95bUJTQlBmRDRUUklESGJGdGxpRDNjYU8zNzUvc2hUdVE4ZGN2VE96U0FlQjRBa2VFTFJLejh2K3FSWHk0eXJWcFJmeUEySkx1UWsvSGlBR3UrR0d1QkZ4M2JEdENQSC9WNzJUemZVRzRjbEFLRXlHSU1LUVVEM1ltZXVuZWVoaXNaaERIRGx6K21EVUNQdTNMbDIrVHQ4R2VZMUNZSE5RbEhnZmNZRG9panhGb3R6MWdjTkVTUWhUdHZsd1k1YTRuYWhoa0RzVHlXc1ZLOHNoWW1VWnJXejE0Y1pjRWNCWnhIWGdNTkVnckJVTjRqRFJJQnFTRFQvY0lCcEVVMFdET0V3MGlHV0tCbkV3U1lSelJJTllORk9FZ1FycnRGbWlYVi9DZXVWTUJFbUU4NktGSW5ncGpOUG1pbytKWHJKb0RucEplQzZhUmg1YXdqSXRYWlJWaE9PaVNTTEVFSWFMa3NTdGpxSnBKTytGbHNPVis1QjBIMXhTVkRVbE1LSk1EWjNoam5DZWpVbzdsbnhSOS9YVzgyOWYvWjYxOUF1SmowdlZRNlNQYVMwTE82R0gwQ2RzOHFqUndhY2ZQVHA1OHRyMTQ4RjlKRDRLOGg5Q3drTnl4MHdOQytWWHd0WDlFVk0zNmU5bjBGZG5qNy9SU2RmR3A0ZERpNUx1WDE1ZnVuRjVsNzUvQmoxdFlXTFlTTjNZaVhtUGk4K2R1S3puVjhDVklxVWhSS0c4WHdiRG5xakJRVTRTaW82ZnVYNzlXRkMvQWVFQm8wWkVuTDh2d1RaNExmamdDT2JBL09pRHczUnRCM3ExYlhtMzI1ZEx1UWNQN2RDbnJKbXhhcUgwbUZteFlmbWhnMW8rRXZJTDM5OG92NmNxS2dQZnAycG9RUlRxdkRWSFRsN1JYYzhNbjd4S3Y4bFZpSmliTUcyc2J1emt2R3NyOUxDV1diVjY4emJ0UDBPTEhicDA5Y1VVWmlyNnY2bTRlcjVndDhSalI2ZzB3TUg3MzRrYW9pRlN5cFdmQy9lN25tZlBabTdldDNQRDh1WHJwVUoyemRKWmF3MjYvdU1uZDlmN0QrMS9HeDhzZzRNc0h3MWVoZS92d3FUQ1JTbTJEOHBnUUltbTRqNmNFZnBzdWp1NlJnZWFzeTlxOUhDM1Z5QkJWV1NtUnFXTjBYVVk3Tk9wYlZIZjJzczU2YVJMSWF6djFLais0Nk95eml5UlBwY0xvOFB6N2hZY1AzSDF5dkdRWVVQQ1EvejBmQkpVR1NEN2dYa0FTNkVWa1g0WGVaMXdibFZHN2puZHRUMlJnZnI3b2tkNDJKeXBpUklFOWpTdExXVjVITHNidmZ0bSsvcXJXNG5tSGZpUzRZYTNQdmd0cS9rMlJ3N2VoSEFBYWJEY09lWDlOMXRvOE5XdGxPUVI0WWdRTzI4R3VkUzRhdFZpYVFpN1lzM09wUWQwdDQrZHVhdVh1WjVLUVdpd0NRM1lqV0M0TW8zVWNvczh4Vmd2NHVZMDNDVnpwdVF6ZStic1g5aUJmc2ZnRmpDTzV2RnkwbXA1TGNtc3RKZTBRRjVMMnNieU1JVEVRODc5K1NtMlpEWTJKMTl5R1FEY2xTWk9Zczhkemo1N1lXOTBrSVREU2lDUVNENzd6UGswYy9BSlRHTmZEejh4TERBa2RXS2NkSEpteU41QVhXalFqQWdEd2NHYzhTVmQrNitVQ0YremtEUlBpWlJXQytjempwOVhaQ1RkRnoxRFEyYUdKa21hcytkNjRiZEVTUDdpY3ZBM1FJUDdrRmkwME55YWthV2FUNlFwdmdMMFlxZnRQazZPSUQ3ZmZ2YnR5NmhucmNqVEVUMkxnRE11OWpKRks5ZklyZ3Y5UXllTkdoVnlyb2dBTlFwUG5MdCs0L2pFZ1JJLzNjeFFtZVFFWVVQbStIQXlFK1EyaEtFYzNUdUFEUC9CT1ZHWnczV3RoM3ExYlZYWTlkT0ZZMmxIZHVteEw0dUh3dzNMYzVBWE9LQi82SVJSbzhMSWM4RGpVS1ZMZTU4dVNiRjlYS3A1U0RaRWVuTFJlZUdxaGJxcGdYUEhKeE9zeG5XbEorQkpzQm9seHcvbGI5cThZamt4YmJlRC9BSlllRnYxdEJpc242anZ5eTJFMEhYSGgzelVWWis4ZnZuU2xPT0R0K3ZIYktHVDE4M2V0bGVibHJiM3lJVWRVZFBYU1BmMjBsbUxZMjYzMS9YMTh4OCs4V2pvOWJuNnEzUHBnNHUzcDA3WEprOVBpUXhNT0pTMWpEU3BKOXk4RDJIMy8wNVJBU0lENjJkY0xQUWJ5OFRNU29xUVp2Uy9pL3N3US9MQ0M5TDNybHU5VHJyTExsOHdmd1ZwN0p6dG1YcndmSHkvTjh1UFVxNnA1cERuM3pLUHo4RjNnWncxckRZLzBldVdIVDZraGN5ZWVCSTdJWDdLK0hHR1kyY2ttTmdUVDJGN1hoaFdmdnpVem16eWtIYmNqVlF5eWtOZG1VNTRUUWRZUTNzd0lPRzNkQ25EL3lCSnNETVBkY0ZMZXNNU3Vpc0RWaVRoR2ZNU1ZsZmoxWXJHcFlLM2RIZW1EMTdTaGFUekhpVC9NVEx2cXBsMTZ4Ly92WFpESlVhTlh6TUoyVDMvVHN5R3V1RFYySTNwanVsdVFOUE9EUEM0SzgxM2cxRUdPWUYwdlFkMEZ5QkdUaUJvMXJZNG9SVWswSjBaY01SWFBIQmZtbmVETzBVUVVxU0NENFI1RVI3SVFqOElvKy9odEFGa1d1RytPSVFld1BLOGNpK2dBcHdxbEhzQjhseWlabDRXc1kzNUlodnhOZk42elV6RlRuUXpyNW9MQ0d6SWo2MXdZbzZDRXcwTThlQjRMd0ZzekRsSUdiNUxpdkhaSGxYUng5ZGxieitvb2R4QitNcEMvUjMzcWw1cFh3MThqS2swYWZZYUdnTFlXek1QKzY4UGYzVzA4YXk3RThzeHQ4UG16eDR0V2F5YTA4TzdvN2JkbmFGZkROTCtKVFFSZnZkdDRRVkw3bmFNYWJ6WnZhZ0Q2R2JidEdMQkc3S0VTYkZoZytkSk1JeTltM280UEZpTE44TjU0WHpXOGV0YkpEeUVIYkF0S2Vla2xsLzRCUGduMEZCeGJYZVhRYjJ5Wk1YUi9KTFQ1V09DeVlBcmFXZFdOa0E1YmZKOW5JdzBHTXBOWWpMaTd5RllXS25PWHkzaVFmdWh3d0dnMGxWd25zeVBVU1dDZjA3czZhMmIxcTVlSzYwWUhUWnE1QnliWWV6alRWL3VRVnZ0azhCai9nRVJFY0VTdjNnLzBLVEVoQkpoVWs3azJiTTVPV2ZQUk9aT21oUVpFU2p4Rm5oNzlpZTQvRWtOZjhCVDRlc1dhQWNTU0Z0d3UxYXQ1dUYyV01MU1BHajNWU0k0OWkyZFR3NldocHg4RVBwUzkvSkIzcDJUK3BOM3QxUVRIUHU4NnVDNzBwM2dmbm51T3ZkK29VT0M5Y0dENTNVbU9QWTdDTkkrcXY5ZUlscFE2d1VXMUxyckVMRlF6TFNBMW1QOXhEc2l3QWYxc1d2aXR6ZU9xMUFSa3J0OFVaOFlpUXJFNDJhOGVyYUNWOSswVEFReVVadUMxSzZLNE5WSGhFeWVac2FyZjk2QWlnaGVmZUFEOFRkY1BaMGNhODEzbGdWbUpWNTFVUVMvLzhMVjc2T0R0OUNaQlBHVUJhM2VjZ2FhdC8vSFBoaERISExPRDRGeUoyRU9zUVBncjlaelJES1gwNkg1UHFobmdHZ2xuUnk4YVJyRFpFdVcxOHZ4QjJIaTBmaThyUnZYRUtFdkh4YzVkdHc4bTFGczRhWTNOOEZlZXo4a2U5S2tLVlBDSkQ1TExGbUUvZ3RjMzdSSnpCTGxtWXRGQ3dMcHJobUJWRUVRU0Y4MjMzdzRROFJXS2Q0N3hmSlRsNCtnSXZHcmdqOXE5cmsvd1I4VmJFZHdNMVBFUFk0aGNLbkdnd24rYU1hSjFPTW50SVhuQ1A3bzVHMXhraGwvWk8yaDRJL0Nka3pSODFkUnNSbCtWTnhkUENmQ2ZMSmRXekVlM2NHVG54bTNrbXM4SHlDcVZpM0h3aktoWnVEcFhzZWxsZ1JtdENlRndJeXVuejUyNTBuTytGN1M2OTMwdDM2VldHUGZ6aGRialRycWQ1MmdqT1pNQ0JpcWRiazMrVW00OUtjZm5UTkRRUmtObXp4bFNLL0l5NDhsMXhrMHBsWVg5UVJiSFZBZmlzSHEycFNyZmdSbHRPUGNoUUl0N3ZCWU9KdWtvSXpDNDZjYTVrdXRyOUtUMGhXVVVlNStNOHJvdjhDZnRtU3pPdmV3ZUU5VXB2bWQyZUp2TUlGZkhMb3J3aFE1VFBoL0RJQkF2Q1NHdjRLZzN3REU4L1B1Z3RWZDhGTmMyMTJGbHdvWDNiOXdGNmo3R2p4UFBtQ3NTeDRyRTI5K3JPUzZ0R25rVXVIby92UWo2MFJwb04yQWEyTUxINk9CbzhjT2tEUy81Z0ZyOGhHVXFLd2oyL2VuU1lscG1iTnpkSTlSWkV4cWtrR2Zib2plTVVXblpOVkQzV3ZDT2xGaG9vY2Vkcjk5L0p4WDBPaS9aOUVzZVpKWWVDYWtya29tZXdXZnJtOFkzT0lDTlBFRmplN3EvZzJiTS9WSmxmVFNPWEVMQTNXdVhVKytDdFBEU0daL09ZM25Nc3MzcmRpNVc3dURuRWx2a1dBZHMvOFpqVGN6dGNjcVR0ZnF6aHhjdUhTN1ByMlMzaHlUdU1GUGh3V3M3WVZiVGRDN2RDdGhWaXhaWVppdDVjMW5Dbk92STZKdko3aUpSTjNlYUZhM3AxalViZUZwNzBLRUwzU0hCUloxdTczM2g0c29DNVZNRjRrekN4VmJydmo4TGVCeEwzR0w3eTJsYXhkcFIxQVBBd1FlV3ZBb0FQUU4xTkxvaTNUTGx1NjRCUjZuNVlzUmRLNVF3eEpTQnNhNVE0dVczNlhSNCtsdldGMkFFZmJRWW85aEdEbGl0WFJ0UFAzOSswdG9BYVFNMXNGRjh5WHRpN3ZGSnhhNHM3TVo3WnhpUVR2ekxQL2tON3paV2ZqSlc5RE5LV1owOHpsa3dSbmUrNDB6Wk5KRWFIWk1CSWQ5SXJZcFFlY3N4VzdMelg0akMyM1NFSFk0THVKbSt4QXdKU0llUXA2OGliOXZwNDJRVjZlaWhQMGliSUkyVVlnMHFzamNxS0xkb2hKNUc5cE1GYmZQTVNPaGNuNGpvUXp5dWg0aTJDcXRsKy9CeGQ5V3F4ZEsrT2NhRXJaWXJhWlpXQkxqaTlsTEV5L2lZWC9xYStoVEF4ZHF6WGNtV3FZS01OVjhjNlQveHBXYlZtelVtd1JYeUdPYzVuaDF4WTNOVVBsSElqUUdwbndrVm1YcTN4eWhRWXpBOVdxd2k5bThxdWREUllLQWptNHBhblk1STc0SHd2M2tLUkdvQjFvbG13TEVVUEd4QWZUdEVRNlVvNzFKNkxaaWZrKzlpVkxlYWlhdkkwWFdyWE5HR21ieUh2bWJZdjZyTTdtYlNFSStLRlNzUGFEWTZiZWdtZjFFZkVJKzI0cEVIVmNnSGljK0hpUjJ4OHgrWXJSY09GVEVYdlBGQTc5eHNiM0tVWHNDQTJCV3lhNUM2SkhvRTNsSGp1UkptbU1ub28rRWhrUkhoMGc4REVpdEJlL1hXMm9oc01hMjhPdkF3b0ZmSWZYak9MS1l6NVAvZ0tWQzdYekdhY1JRcCtaajc5NzdVWnRkSk5YT1lUVi9VUk9IWkQyNmRlbmtyV2NuSnZaWXAvKzRpLzY4YU9nSDNFNkhPUmV2bGw0WHg5NGh1enA1WHM5azN3RU9Xc3gvZDRNTzRGa0xOT2lremRXdjhTR2lhdHhCRVBwUmZYYUoyQjkrR3Q3OUNFb0JvblJvSGg2UTB3V0hsKzUvL1ZYOThxKy9PcjkwY0hCM2Q1QXUycFhmdnZ2OCtaM0JYYnNPR2V6dFBmUnV1UVQxdHdqbjlySTd0aXljblRwdlFhcitnTDF3bFlrb3BkTzI3Tmg3UUp0RDNwZ2hlZUJ4K1l6bVdPRU9sc2ZuNUFzRzZLZWNHRDlFelprNDNJOSt5UEQ0bW56R1VQa25NUW0zRXFMU1p4N1p0bUhkcWxWSHhNZzlNZEZ4S1ZQMVBINHFIL216a2hScUkxY0pSNVAzVEoyN2NNbUtGZEwrMVlmM1ordE9zSDdEUW5xUE9aWnlLQ3RqNzFIOS94K3F0NkoySytvM25pUVgvbENsLzhqK29VNlBGM2s4MUxqK2grckFqM00vMUFlbUlSNG5yaGVoazRJNmN6SHVNd0JLVVIyMllOUFVod2Nwa0hqajNpb1ZGQnYzQ2xYNG5BZHJ5YjVSQWFkMUlKNjZCSjZtZUE0ckpuTGMwTGpreVhYUy9LSEdKY0szeTRYMzF1cTltS1RsMDZmNDZmeFNzdEtYazlDZ3Rma0R2K2w0L05pNHl3QWFZdHMyM2hLaURzZG01eHcrbkowVGV6Z3lLalkyVWlKMUdGUHV2cnVyT25EdmZhRWFWaGxmQjRzRDdlSU5LZFBpVS9abVpPeE55emlZWm9nbjJlb2JsMjhSRDVZcGx1dnZQMmt6eUhEWElCSWFnYkJBR2pmcXA1WFpXczNSanhoWUNSd0orSm9EeXZBY004QkkwbFRmaHdpcm1SZzhrbjVDb2t2eEJHVjhEcmlhaDJjVDJUMnRPU0pHN0ltTmprdU8wZk9wTytUa0hkQnV4N2tkREE3YXdmNHZhRU9DZFdyUVIrN0orazExNno3YlhiZWVmS01SQVo5YzFsaGVWOGRRamFrQUtvR2FRVjJrL2xRMVZuVlF1YXQ4VmNHcVJOVjgxV3JWS2RVMVZhbnFteFZ2MWRMS2hkeDQ3MC9lSGh4c2RkL3FxZFVYTmErT1Y4OVVMMVR2VXFlcno2alBxKytxbjZrL3FVM1dBNnlUcmRlVEcrLzdyWE90VDFwZnQ2NmdtOUd0YVRkNkRCMUNSOU9yNkszMEEvbzVYVTMvVGY5azdCZ0hwajNUaGVuRkRHSkdNdU9ZQUNhR1NXWm1NaXVaVFV3YWM0LzVpMjNLdG1PSHNHUFlpZXhDZGpXN2xUM0tGckhsN0E4YnhxYXhUVXViRGpidU5rTnN4dHBNc3BsaHM5bG1oODBwbThzMjEyM3UycndteGdtcVRoMXlpNzR0ZWExZC96cUR5VXZ0SXV2RTFrbXNzN1RPempwNzYrU1JGOXZkcmZPZ3pyTTZIK3Y4UWxiSUJ2R29FV3FNV3FPT3FEc2FoRWFqQUJTRXdsRVNXb0NXb3BWb0cwcERCOUZSbElQT29Pdm9BWHFLWHFGMzZBdjZFLzNpYkxnR1hCTk81SnB6N1RnM3JqdlhueHZKVGVEQ3VXbmNURzRPdDRCYnlXM2lkbk1IdVd6dUJIZVd1OFJkNDI1eGR5dlU5aUlIM2tBT3QzQWo3STI5dXlEd2xqaUIvSnR1VzZ2TlNVL1B6dG1UR0orWW1odzNVeG9XVGcrUGlQY2ZycDBEYVlXNE43dG0rN1p0T3pZL1B0djQ5TUdEdWVlMXQ4ZGY5ZlQwOXh1OGNOV2MxZk9KZlZlVWUxZ1BGMzlEaU1DeEphaHdDejBITFFFY1JFN1ltakpsd3hRZFZudDRZRHZNUGgxYlVuVXYvMm41bUhQZHc4Tm5KTXpVUDl4eUlmZWVMaTF0NllLOWV0d1Ard29uYy9abFoyY25Cd2RISlVkRlJlNDdLZkhDNmczS080S3ljbVlIUlU5TERBNmVtbkY4c2I3L05IcnMxZ3ZqWHVsZTNieFc5R0JjN3NoMStxL2w5RjI4ZnlEMFlOdDUwNXd3NVVEQzBheU1BMWxIODhTcENmRlRKUmhtUjZLeWppcFI4UmxUcHloeGZNcnZDejBIQ2F3dm5LRDZEcm9nVFdQdU9QTENjUjZJV3lvU05NMStwQ2xzb2J5OUNJYjBmdnI0WHVFZ21PN080RDU0R2cxREZncFl6WUFhOURRUGdkZ0R2SEFnbm9UZE1hR2NjZ2tucEtXbzJlaE1jSUpjaWkyNVY2TjUwMElrN0I4Z1VOZENWNzBjMGNZVXltSnE1TkJXcllmZkJrcVNRNTFNRVN6dUNtcG5hQ0Z4eXB0VXpBdVoxQVp4UVFnenVLbHlXNGY1ZlZ1SHlMalhRQ0VnSmp2M2RHYjZpZlY2YUxXUFRtYWJEd252TGltdlpoUE5yMmI3TWxLVWszRnhHZE1KeWIvK1ZONGdWaFVyV29DZnAwVHp6UzlOb2ZucUYrbmdLU0tEVGtRR2NVb2prODF2R1d1Tk9HeUxCY3U1S0FoY0dkc1ZjY2UxY3RQMitEVGJLOHkvaDNmTXpTSUpUclhuK2lrSEJndnVxSXBLeVhtTXVraHVLZmlkQ1NpK25uMzR3QTdKc0RxVmFPZkZ6SXExeXc3djAwSTM5bjdvTFlldW8vMkhMcFllenFLUHJUMXc2SXp1d3Q3NG1MbUw1NmNzMDd2T3BVY3VuQmc1VEF1YUlHSEs5SDM3RDZkdHoxaXIvN0NEVG1YN0JDZU5sM2hGTU9GSU9vNDRvZUxleTBIMFc4WmlBS3pMWUd2TTBYell3YVNzelN2RnlUR0JnZk50SnJEWE56NjlDRWg3SStwUWFIamN0Q2tTQjFkVzFzaG5hOGhXUTE1RGRodk5qUTBFcUE5Mm5jbkl0Y1JxNTlZR1BXNE1OMnR3SVB2bnNiK0JnZzVhaU1UZG9DRWVURDdkY0VNY2lUdjhqYW52NFJLZTVBbzNvVEhUT2cyVElXMnBCWGV3cTRiNkVoK3E0QjRkMnlQdUJUbnVTOWt3VmNkbGJkNjhaOXVXeFF1M1Nkc1gwSFAzcE0zUDBGMDdsVk9pNTQwRlFnZVJneVl3Q3BNZjNZR0JQL0FvVEg0MDF3L3hDMUR4RFpHQUpjMVhRTW00L0liL2trK0Q5bmdJSjRSbXh1VGxIY25NeXlPYml0Q1k2RkNKZTRPckljWnlOVFFXcXQ5d2V3WFBXWlBtUitvU1o2eFpPMXZ2d1M3ZXMydnBTZDJUeDZlLzc5Vlh5aDFwY0t5NkplNHNwNnQybmRtVW8wdmJ2WXpzb2F2WTlkTm5yZzNUOWVvOXVXV0tQZ25UTk5aNGdCWERseXEzaVhxdlFMYmxwNUhtb3V3NFFkeTI3TGduK3VYNkhzYXltb3E1K3pNVzV1ck03OGpTOC9HcEMyYk9tYmQrNDJ3cGRSTzlOU1ZoUzV4dWRGQzRqMzdXQTVaYmp2NGs4dWxNUnJBYklocENOOFJYS0MvZGFTWStzMnVHdU1GaXJzaGRBa0hvY2JmZjUrb0w1N0xUSk83STltMXBGdm50bUUvUDNydHZ3V0hkdFpQSGlQekFWMmk1NlowelNEcG84ZjRMOEtEdFVJRTE0OGJPbWhxcnZ3QkRhY2lzeFIrWUxyZzBhKzdoT2Rsem1odytkR2IzT1YxcDRTU1hya1BHZGZjYWZyVjhzWjRQRXlFdVF1U3FxL1A3dFc0OXBtZG41M0VjVE1BVEJTZ3lkcWNkaVc2Q1gySW5lR2syTFlhWWV1SzZlQVBOS1J0RTJ5dmRSQUx6OUVGRXQ3Wi9DUzQxM0pKVkM4Z3RzNU40R0ozTm5JTGhORUh6YmxpdnpVMDRFQm1Sa0JBaGNRSkdqQnQycEo4ekhIUVVIbVB2Y3ZBdXhod0xYU0NkeHRZTWJvTzNZMmZZYnI1UTFBT1R1RHErMEswcjd0WWJ1dUdPbjZBand3dllqbkhFSFAyZTRiZUt1REdlendrUmgyTnpjek1QNStiR1pFWkV4TVpFU0R6WnkvdW5rTnF1ZjRickxLeVJuY3pNQitPSGVEQThOTDgvVFE0MU5xV2RHVk00TWFseWViTW1ubkxYNGFZZHVYS3hGTWJUY0orMGIyS2FBY2Eva1QxU09Ed2YrcEw1MlpjamowNTBqWW96TDB4Y2lNaEhac2JrNUJ6T3pGRzJMSkV4Wk12Q2JSVGhwRjF2a1RjQVIrcVBTWWlkUFZXWGxMaGhXNUp5STRtYlRudk1IUnpRV2N0Tm5wVVFGYUVkbWovaG5jUXJ1bHI5RHpDRWZPcS9Cd0ZzbmcyelA2aC9jOVM4c1dkcU1HbVlML2tvUGIwbVhMK0J1NXR2aC9jZWVSMTN4YjF3VitnMWNpUjRFMTgzN0h0OUZIaERMMXA1ckdMU0U4bUwzL2FURjcrbHg4UWtKY1ZJME40dVpqK0pTeWR4U1NRdWtjUnhqcFBGWkFYdGZOcUNkdWFFa0VPSk9XVDVtQlE5Y2RKOG13RDI1b2J5eTlCQWV6TWlNNFM4bDN1S3hJOUZ5eXd2YnN0QjBBU0k3SE1PSHNqS3lVaUlqSWlQajV3eUxTTlg2bUhYNCs3d0owL3UzU29yR1hTclY2L0J3MzNJc0lkbnhodzducGw1akJQT1ptZWRQcE0xWlJJbmZGZU92dFhNZDJoT3V6Sjl2UHBVMEJ4MjFnVUZiTjhWcDlmSVVBVzFRdWQrNDNyN0RMaFk4L0xCNWNmRkQ4ZDJrWGpGU0tpNnAxZ0kxZENNMjR4Z3E3V3BFempTWFZnb2NNQUZEc1FqZDRLV3lvdi9tSGpUYXZPdHhRWkczVVNVRzNlWXpJM1lpSWpEY2JtNWh3N2xTcHpGVXFpQ1BjL1VCWndGZTc1K0ZhY0ZKNC92dURVSHZlQ0k4T1Q0clJMbHlxVzBXUncxTW1rWUdkK1hLMzlqWGpsbGlwMFNPVmltdkhRdWlQN0E0cnZRSHNpUGVFMmRjREFaaGM3S0pYSFRTUmIva0UvUytBOENCSkJMR1ZsaktpVTlYVHBmNU9UWGRtOU52Vmk1bTd5SC9tQTYzRWwyWmsxZFRidm9OaXhYMDZNTW1MSWVOZHlqMUJXSXErcjNRSFpPNFJZKzl6ZkE5T2RaeW9VbG9yUmNVNjRzbFNvT0ozZkVPZ1lmTVRXaG9UaFp3Tk1abUE2UGFCNmVwVDdoWUtTZCtZSUlad2N6R014aWIzb0ZiaVA4Z3p2U2VDckRkMlpUK3d6eGQxNXUweGVjdWJKVUJUYk5nVTUzOGZUczJmdjFtays0Q3I4WFhoVmVLaTNsaE42SUUrTDJKUjg2dEcvZm9VUEo2WEZ4eVVseEVnOTJncmZjNlRuTGdVMHgySEJQaUhtYWcvN2dDdlVnRldaalo2aVArK3Z4S2c2dzBQa3J1MmJ1cWpsenRLT0NSdldMazlweFpCbmtvQlVMZndEbGpQdmh2dGpLRmYraDUzQjd1YVJDQmJmbEVxRUNaM2l4dkhLTS96YUZaTmVuY0VzSVFGckJ3bmZpV0dndytBNnVJODNwdVkwcDJUKzFsNTVqZXlWTzlUR0hvYzdkTzlCQXowSGR0U0tuUUpPL2NtRUlobnprd01kdWc4anRRQ2xjaWtyMk1FWUtKbzlma2JUeEdjTmRROHB1Z1dQbGVuSnZvZlZvWDdmT0k0dS9jRmQzU3ppZkhiMDdPTDljeTF1d0xFTnA3dkp6bVNBL09RVzFURmoyaGI0Y1pobmNHV1pBZDFoSy84MHhCVWR5Ymo3U2JscEJQaExYRTRXTG5MR3B3T0U1Q2dMSk0wVkZUamE0ZzhyVnNlNmtIYmFscHhHblhPYmtQRm4rTW5yQjVFSTNtc01PenFYd3ZCb3FTbFhjd2oyUXUvdXA0dGh5bDFHTkpRUGowNHIreUpSOHBYbURNWWcwaG9uQUpOYm9UNHE2Vk10VHFxQm50WXJiWU1pcmhKMVZwMGw2aEdoNTlTYXNJcGU3dTNxei9IeFJ4VDJHbnNYY0Y4Z0M2OVpFOCtZSXFFWmVUUExpTVZoditEbVUrTWlTUno4RVhva0x4YTFMamVsbHBKQUIvSi9EV0tYT0oxL290a3l2MXJUeWpyYmRMMEdxVlhHcE5kRHFCV1JVMjNJQ3RDRHRFVGdvSmhnR3V5ckNJcUN2NGFjTktYZnZlbjVSMGFqOFFZU3BjNmt4aGZCa2ZjWk9HMEUycFFwMG5Yc0F3KzV6c0kxa1RDSDNpVG02aHVIa1pJSDcvd0FXQlZWeUFBQUFBQUFBQVFBQUFBRjRBZTE4QzNCY3hibm0xeU9OTEIwOVJwS1BMRXNXWTF0K0lCdmJnTUJnNHlkR0dHeHNROEFCYklOQitJR3hqWkdmOFFzU2MrL04ycmxKZHVOTlpRT29iakEzQ0FLQkNBSkpVQUltTU5sZzhLcHV4Vlc3VTdmV3dNNEdSTWpjRFFwaEFJL3g3RmZmZGs3TzFHakVqR1Z0dUZUMDFhL1QzYWY3NzcvLy92dnY3ak9uRHd3QUJ4ZGlPUUl0OHhjdFJjWEcxbTJiMElCQ0FFaWxFQUJJWGd3R0JTaGMxYmExRGZYNlg3OWh6WlpOR1BYLy9nUGl4LzlFQUVXNFVYR0RZcEtESU9FZ1FCcUxXUUR1eFhkUmovdnhJTTdIeThRMC9JcVlqbDhUbCtBSVhzVU0vSGY4RDh3eUJhWUFjOHl6NWxuTWxVU0ZxS2g1OS9KbnJ2c3VqUG1xcEhzaDBGM1ZXREF6RUEyY0ttZ29ZS2hnWWNIZWduc0wyaXZMS3NzS1hpcWNWTGlwOFB1RmllQk53YWVEN3hWOXJlakZvbGpSUjBPcWh6UU5XVkx1VnZ4bVNIdjV3dktGeFV1S2w1YUVhMlpYUkV0dUxGOVk4ay9PZnVjN0ZhK0hLa3NiU2h0THJ5eGRVdFZjTmJkcWJtbGI2YitXRFMrYlhiYTA3TGF5dldWZnEyb3MrM2JaUS96L3M3SVh5djZsN0YvTDNpdzdVZkdiY25JbGlQTDY4ckhsemVWeldZTlE4WHI1TmVVL0tZK1d2MXN4dHVMNml2MFYzNnlhVy9Fb2MwWXJXRmVvTWZTTDBLdWhxUDMvZWlnZU9zVTJWRmR1cVp4Wk9aKzRSbGhldVk0cGV5dS9Xdm50cXNiSyswa1BWajVkK1dKbHJESmU1VlExVkRWV05WVlJXbUpKMWNhcWU2dStYblYvMVlOVmoxVTlVL1dicWplckYxYWRxcTZzSGxZOWloaGZQYmQ2NGRER29VM1ZxNnUvVS8zRDZuZUhObGFmWkp3cHhQeWhYeG42OU5DalE5OTF4N3JMM1crN3I3ci80cjVlVTF3enNlYkNtdGsxTFRVTGF6Yld2SW9BTGtJQlFnQ3FVSTF5dUJqQjJFaU1RUzNHWVR3YTBJU0pDR015cG1BMExzQWMzcmtVODNBZUZoRE5XRVJjZ0tYRWhWaEdUTVVLNGlLc1JDc3V4aXFzcGlXc3hSMjBtazNFcGRpQ3JTeTlFN3ZRZ24zRWZPekhOM0FGL2lPK2hjVzRqN2dHRCtBUXZvQW44VFN0OERuaVpyeEVyRVNFTm5hTGJLeFZOblliamhLcjhRYmV3UnI4RzNFWEVpYUFOalBhak1IZFpwd1pqNitZSmpNRjk1b3J6SlU0WUJhYWhmaEhzOWdzeDlmTlRlWlczRzl1TTZ2eFBiUFczSUdIekVhekVSMW1rOW1NUjh4V3N3ZVBtd2ZNQTNqR1BHd2V4clBtTWZNWWZtSithSDZJbjVwTzA0bWZ5YXFmTTgrYkY5R0ZBRXBTVWZOQ0tvb1N1S2tFYWtqRFVqSFVNbVU0ci9XTWowakYwWkNLbThPcGJnemgzUVJxU2NOSnVrdHFTQ1Y0Tnc0akhrVW9ZR21HMHZKT1R6MkxBbXFuQ1oya3AwaGxxQ0JITjVWRURZTE1GMmUrSHRUenpuUzRtRUZheHJRbmVUMktaak9PUEExZVpxeUllYnU4Zk12Z2tLTnJEcXNOWmVJWXMrMklTOElHMVI3RkRFbkprcWhPYldPT09QbDBzazdtUWhnaldJcXR0SFU3ckR1QkZZdy9sRHFFNzZmK0N4NU90YU9ENFVkU0IvRVk0MCtRbnFRZC9JajVPbG4rS2RMVHFRNjhrb3JndFZTMzVLbEVFVGtVTXdkYmlIclNTSVpITStjdGNMQ0Y0ZWNvMHdSS2Z3NXBFbWtLSE5OQm9qYk5pN3hQeTRaRE9YdFZhZzVUNW9FbFNWdEo5ekhuZUsrMG85SXZNdDMxNmkxbnJKcFhhcG4xTytJeWovRmJtS2VWOFhWdy9kendPOG96RG80NFRpRTlvSllrVUFkeGswYVRHQVZYbkZyaGtvT0RqV3dyV3lNdWUxTlJ5eWxtQXFrdXl1ZVlDZUlZbG95VGVaMUNXc3Y3MjFQZHJDSEtHcEpzYlJ3MXFxV2FJZWtLRGtaSlpoZGpXQ3ZsbHN4YmZIS081MVd0RjJmSHl0eGxPcVhEaExRUmtqWXE0SWlyT0pMR2tKdjB5WHV0NGhpM0xYZjhIRENlcGFQcUIxb3JaWXZBbGJVZW9lWDB5bklhNExCZlkrUWNsRllhcmJ4enBPc09TTmZrSVYwemJTdTU3bUo4SDNrOXg5cmZRalBlSnYyT05RYmcwdEpqYkZmRVRLRDhrMGhzazFrTDJ5NXBxNWZ0Q2xPbUluSXFaazBsc2lxSDdZbEtTMnZZRnI5TmJDZkhCOGlSSlZFTWwyVnJTTVBnWURoajliVGlFV3BIMkJ4bVdwQ3Bqa2JPZEpKR0Rma1crZndEUndscGh2VUpRV3VqR2tkWUJsZDZLL0ZHUCswT05qL3ZockNDSlY2V2RtTVlTdG1UcUNCVnAzcHRHM3JVaG1WTTI4aTB2UXp2WTlvaGhuc1lmcCtsVGxDZUpNTW5LVnVBOUJnbFlYOWhralJSSnQyRXlEVk9ya2ZFdFJHMngzbnZVamlzb1YzZVpRVzVydVJWZmNRcit3aDNrRmd6ZHNKbHpWMDRKQzgwQnAybzR5aW5OMkxhVzd5K1RhSkVTRkFISDFLaWowZ2ZNM3lDdkpQczI1UE05d25qcHhoT3BiclZ0dzlUMmc2NGxEakdQblJoeURtTVpwVFlzVnJCMWxXekhHM2VzNk1aSk5xUjVLU01sTS9CZHVhbmZMU2pPR1hzMUlpamhzZ3RaUDJyQy9vVy9KejNmMEY2bnZRQ0tVSmVyekRmVWNya3RZSHBDZkw0a1BRUjZXUFdmNEplTHNud1NkSW56SHVLMTFTcTAyeWdwcitFa05sSjJnWEg3RlpiRXJUTGhHeXlBbVdzZFNRMGF0bnJQWlMrbDMxNm5OSWwyT3RCMWh6SCt3eWZVTi9GVFFldkwxQ3FLbnJhS0QzdEVYcmFZK2dnUFpJNnJQbmlSOVJoSjBMeXNNOHo3UVhLOTB1bXZVU1pYaUduMTZqTG4zSnNkRkhPUzFEQ2ttVnc3WWlOYXNTT1pKMmptRk5XSUIvdnlNZlBnVXZOZHN2V1ZwQldwbUxlYUYxbHJXRWJxRzNTTHQ3YkEwZWo5ajd5a3JabEZRNGxjNmp0cUUrckRub1lmeS9GdGpMK0o5SUhwQVF0NDBQbStZZ3QrSmpYRSt6VkpPa2s2Uk9tbmVMOVZLcWRsaEttbGwyems3U0x0QnROMW1yaW5NY2RhanV1dWJRT3FsM2VXSmF2TnRPRHd2SGFQSVo5TUYxdHBkVWp4TGIyWWdYemVXMVZPOVUrdFlzYTk3VXB3WGJFMkE2T084WS9JcDBnSlVrblNhZElxYjlZTkl4S2w2QUdqamY2UjhoYlJPRE5xZURJaHdzanIxTE1QTjFhUTB6bmRZYmtpekpQR0VjeFUvbnFVVVlPbXNkNDFaZ0FXOFB3UE9aY2hpQnpheDZ6NDVVMnpyUzN5T0Z0VW9KU2ZVajZpUFN4UEVjM2tpeDNrdUZQU0tkSUtUc1dROUpodFdvSVFqWEluem55V05RVlZrbFBDWEozMU1lZnNEOENkcFlwUVFzdDZDSFNQNU8rVDNxWTFFRjZoUFFvaWJyUktzRDExamNyNUN2Wmw3Q2VGdlNMUGs5Ykw5MUZyYWZ0WkQ3clM5WG1BS2hqZWRFQzYyZkRpckVPT05LcHQ1YmgxYWhIQ2hrS2EzWEg5WlBxRmhkNWU2UFNySjMvVlRPdk0wZ3JWRXMzaW54ck92VXAreW9tWDI4MFBnUDRKcGJqVzJoR0FVTmgvQ2ZNWkt4SnNTYkd4akRtTXBmYWFrc0ZVUWRaTHFtYVVubStHa0htNndWYmJtZTFHTlFUcEZiU0xoTDdXcVB3WmRZZGtWK09lajNER2NMT0RqRkRENE5palEyT0M4MzVHMWx5cngzRHRCYXRQUXJWNDA4QzZDUTlSYXBBa0hJN3BETE42bHgvWVQ3bU1uNHI2VWxjNDYxazMrQzlOOW5hR0svL205Y3lyMlM1U2piSjA0ZzM1ck5FTTB1TVlZa3dTNHhoaVhCYWlUcGJseVAvb2pwNGZZUHBLb0U2bFREU2krMFRyV1g5cTl4dWNMeElqN1JnMGdwb2ZFaHZFZW5JcFk3aTNoemtxRGVBTXV0eFkxWUxEdGUweitJWjBrOVRqOVBiSHFPbjdUYjB0T2JudlA2Q05sQ0l4WUNkZDRKNGlqU2VQUm9uSndkc3ZaMkZvNTQvR28wbStlQTV2TTZqejVOUElORVBlYjUySitON0VLYi9pYkZYTzd5WnFoZU85YWNPUGlCcDF0TE1HNEZtTGMyODNiNVpxME96MWdzYW82NjMvOUJxWGJFd3BGL3BjeUVjRkdqTVNHT01GY3B6MnBnM1VxbGoyWDBFTEVOSkhYTkRxc2JjbUpwbWx2RzZQRFhGckRqMWpya3BWVzl1VHBXYWxVeS9oZUZiVS9XeWZZMGFoVHE5VUlkQ0JWNkkrdzZsdDhzYkttVHphcFVsT1RsK01ZS2hCcExSS09SL3VKUzVqR1hzT2swK3RrQStsdnNjbFNtMis2TnUzby95VGp2djBBTXozS0MxNVVIV1FtK2c5ZzJCeXhJMXBHRWtyUlU1d2xXcmFxcUZJMDh4d3U2L2pPNFo2MWRjenp0SnozQTFVeFdramJFaCtEZnFiREhYLzB1WSt4cGVyeVZkUi9vaVBXYVFkK2VaeFFpYXEwblhrWll5TGNEVWFlWUx2Ri9BMEVpV1RES2Q5VEpXRDkzMThvMVVpTFd3UnhhemhpVUlzdVJ4MXBEZ25iQzVIZzdFaFhkVnJ5UXF6U3BSb2JtQkhKYVJiaWF0Skc5alZqQTl3UDVQTWs0cGxGcEVtMGlZR3hIazNlTzBnd1JUdzl5NTAydnpUcElwU2VWSnNseUNOcE9rdlNpVnRwSkVtYm1Ob2RXa05hUzFwSFdrTnRJVzBnN1NsMGc3U2J0SXUxa2l5TlJlcGlaOHFRbUV5S2VYZk9KbURXa3Q2WGJ4aXBzTmNFMGJyMXRJNGdmSDdDUnBUY2R5ZTBEcmx4UTdWSk5xUVlsUy9Qekl5OCtINWFnUmhoSVlZclo3c3ZhU1E4THNJdTFtZUE4NVZXaitXYzJVTmFTMXBOdFo2enBlMjBoYlNQUURkcVdaSnBWMGs4aExOMFZtRzRLK0ZycmtGU1F2RjBQNjQ0TUsyOXBlczRhMGxpUVplVzBqYlNGdEY5OGcrUWF0akk1a0xGZkovbHZIa2lvVnROSUVVZkdwSmJ5ZVNpdnBxcjVFZWovRFNldWJiV2tjVkJMR2tJZThROFI2aDJZNDBOcEQrN21ZVFhWQkgrT3RXWTdhZFVNeFdsajZJZEkvazc1UGVwalVRWHFFOUNncFlOYzZqanhZMUZzcE9EQ2FnNHIxbktpV0lmRW5UNjJBNFBJdS9ZbnVGZjE1UDhlNzFXaTIrMVlYd3hHQ1Zqa3FYYWQ5dDFac21BK3REZENFdDhrRnFhaDJHWnlEdldjcjlFU2M4YU5hQ3ptKzFqY2hNT0hyVE1YRXZaTm5Zd2NtQTZrNDc0UlMzR3NpeVArOHBucVptbFNzbDBneUI5TXhhSCtzT2Q4U3gxS0gyRHFramhPVW1CSW1lTzFoTEVwdkg2TFV4NWpHZG9DdFFKamtJQXoyTzhHV01kUU54dnJnSEVtdFQzV1JWNHk4cUJGZXlZWDhvb3p2aDhNNjRnQWNTNURlMUFZNENqdmtIRkl0RHVIblRGMlNYN1F2VFRLL3VGZzlCeG1LZStrc21aWTNubEc2SjNVUFM4YXRWSzVOaGlTS0tZMmsveUZLRUJkZndzOEJnTXQ2SE5RaDZFcy9rdHJGM2FyRDZ6RzJpOXFSMW1PcEkwUTdYT3I0dU5vcUhyWm1GeTd2TXA5NGNpeElNcWgvcUNIZThWcXQ5RjV4N2xRNnVVZ3V4OHJZYTFzY0F0UEVPYW9XTVNZS3dyRWFJdVZnTjUxbndGcWZ6VEZmVnhhN3B0WDIwZjh4L285K0tsTnBXUHFLOXpPU0hPVC81K1piZ0gzZm5uTm1KMC9PRVlDVUMxZUhlazVtNDVPUmNqQTFUOXFMcGV1YXNReFBSSzV1N3UwaFIvYjNwL1JnaUlCc3V5ZExEd1l6VWdmZm5nOXJES1Y1cW5UUFpEMXRkeGJaMUZQcXRXUmV2ZTRpOUNtMjUyVGVzZEtRY3JPay9rZEtwZzhtbmFFNWl6bnkwNGJqaFhJZW83UzZic3BOeTh2TkkyWFZSalJkOHNHM3VzRllGUXlhek5SekRwbWE0SjRPNzhIaWJGY1UzVG5tanVUdVJYUDM0NTkvMjhndVYrWjhNbWkyNTloOCtXa3JkOXZvVE9NUVBwUDlRQTZEMzRPRExwL21qdjVIVnhmZ3JlcWpqSGRUNWliNjcyaEdTZGZyU3pCSEJFMERHRldzYStDdHo3OTI1dm9yOVdCV0w1WVU1YjNpdFQwV3lWWGJLZTZaejdBdmRENmJ2bTdnblArbWpjK3dubDNBN2d1Y005d3J6c0Q2M3ZlRXdyRWhSNmx1RGkzeS9uOFc3VGtWUGNNclV2SDgvSS91d1YrTERxbzJzcThrZ2htYXlicDM3ZHRDeUszSFN3aG5zWms2aEh6OCtSWmRYejJSYXU5WEc0T2dheXZ0djI4dmFqV2ZwMnk5Y1BVODE5ZXZxYmcvN0pHYk5zNmJNNTRVeGpOV1FlVGN2KzE0bkxPTlM4dDU4UHRxTUVjMzlSblBmVjJucHl6SjNLeVV2YWNTT1hOT1VwWm9EcHdIMVo1VFhibm9OZjk5ckxXVy9XeWovSkhuNWVMK1o5K0swNGFaejkvcUp1VnZVc21JU21kYTY1R0JlaFBXL0puekc2bjJ2RXQwREw1VWc2a045aS9KNnlXa0R2cDhXMC9HbUlrcjROSnF3NW0vbzV5WkhYM2ZjVDVyM2FiZkFiK1I2dmFsUm1pNW5aQkc5TXVqZldhT3BxeXRkWFU5ZmdhZW9IUi96cCtxWlVnblg1eDdHd2F5a29sOWRsWUZmdityLzdubnp0OXZER1JkTi9pMkVZYXJNWVFzYXlUOVhrL3dycTY5UGh0bzlyOUZvSnd4SDRmOWc2V053VnMvc3dmLy9YSGUxamRQYWltTnMvcTRhMUQwblA4SzYrRGdjTTdGOXJ4ZnJNRnJlelpkVTFPbnh6bG12V3A3MWw4S29nUGlIQmZuL0dSdXoxVm00SXhxSTByZTNicHl6WnBiYitmT09WZHQ4TDcrNTZubldEK2NPN053Ymg5d0QwWk9pM1BVa3psSDI4aGY1dnoxRE5qbjl5SGZXMXNKenc4R3ZYa2s4eTBSUjJORTl4SDYvRHdsbG01QytwKzI4dUkxU0dSYmZUa0VyR2FDZjNzYW4rWFBZQWNLVUlRaEtFWUpTbEdPQ3AzTnFjRXcxR0k0NmxDUEVSaUpVUmlOUm96Qk9FekFCYmdRMHpFRGMzVFdleGxXNEJiY2lsYWQ1MTZEZGRpRzdUckR2UWQ3c1EvMzRVRWN3bk9JNENqZXd0dm93Ui93SG5yeFI3eVBQK0VESlBBaFBzTEhPSUVrVHVJVG5FTEt3QVFNejJlYkpqUEJuR01tbWNsbUNzOWlyektyelJxejF0eHUxcGs3ekhxendXdzBkNXBONWk3VFpqYWJMV2FyMldhMm14M21TMmFuMldWMm16MDhvZjJ3NlRDUDgxdzJUeWVZdytaRkJDaGJBYkVVUmNRTURDSENLQ2JtbzBRb0pTNURPVkVoWElscTRqcTR4Q3pVRU1zeGpMZ0J0VVFUaGhQalVFZGNpM3JpQ3hoQmpNSkk0Z0plcVRuaEhEUVNDekdHQ0dFQ0VjQUZSQUV1SkhnR2dxQkVrbWtPVVlWTGlUTE1JMjdHTXVJdXJDQzI0QmFpR3JjU1E5RktsR01WMFlqVnhIQ3NJYjZJZFVRTnRoRXJzSjI0RVR1SmVkaEZYSUU5eEJ6c0plWmlIM0VWN2lPbTRVRWlpRVBFUkR4SE5DQkNUTVZSWWp6ZUl1cnhOakVDUGNRdy9JRllpZmVJVzlCTDNJby9FcTE0bjdnTmZ5Slc0UU5pTlJMRUdueElyTVZIeE8zNG1GaUhFOFFkU0JMcmNaTFlnRStJalRoRjNJa1VzY25BQUlZV0VjQXlXc1U0WEV6TEdJK3phQjFOV0VJTG1ZQnphU1hub0pTV01nbVgwRm9tNDBKYXpCUk1vdFhjaG1KYXppcFUwbnBXbzVZV3RBWjF0S0sxR0VsTHVoMWphVTNyTUlFV2RRY20wNnJXWXdvdGF3UE8wNG4vODJsaGQ2S1pWcllKRjlIUzdzSjBXbHNiWnRMaU51TlNXdDBXTEtEbGJjVmlXdDgyWEVNTDNJN3JhWVU3Y0JNdDhVdG9velh1eEdaYTVDNXNwVlh1eGpaYTVoNXMxL2NEenRiM0ExcG9wUjI0bkpiNk9GeDlSV0NNdmlLd2lGYjdBaHhhN21ITU5pL1NmcTlHZ05vSkVxUGhFS01SRWlxSnMxQkZoRENVcUpGRjFqQXRUTXNiU3hpTUl5WmhQRkdMc3pHQjRZbEVMZTlQSWlZVEJaaUM4eGx1Sm1wbG5aTmtuYldZU2t6Q1JjUUVYRXdNeHpTaURwY1E0ekNUS01Rc29oNXppUkZvSVlLNG5CaUYrUnhENVZoQUZHTWhVWTZyaUZGWVJKUmlNVEVTUzNBMVU2N2g2Q25EdFVRNXJpUEtzSlFveHhlSk1seFBWT0VHNG16Y1NGUmpPVEVVTnhFdWJpYkdhbFNNd0FaaUl1NGtTbkFYY1JiYWlJbTRtd2pqWHZ3SEdPd25BamhBMU9KcitCWmJkNUFZaHY5TVRNSzM4VjJtMzA4MDRRSDhFMXY2UGFKUUkyUVNIdEtiOXovQUU1VHRTVHpGVmp4TmxPUEhSQm1ld2M4WTdpSXE4SE84UURrUEV5NWVKRWJobDRTTGw0aFMvSXFveFg4bHl2RnJZZ0plSWFwd2hDakVxMFE5WGlQRzRqaGVaeXZlZ0U2MEVaWDRYMFFqWXREWk5xSVN2eVVhOFE0UndydEVDWDVQaE0xNTVqeE1OQmVaYWZ3L3cxekcvMWVZcXpncUhqR1BZSWo1Z2ZrQkdtUjVEZVlKOHdRYzh5UHpJNHczVDVtbmVmZkg1c2RNZWNZOGcvSDZva1d0K1luNUJZck04K1o1dGpSUTBrazU0UXh6M21iOWkrMmIxM0hNMUY3QjBUT281b0UrVnljL2wyaUN3cHJmbThrNWtlZXpBRWxtOTBXdTNjTTdBNWRNR05DVGM3YWsxM3V1N08xenBMM1k2ZitHS1k0OUdUcHlsTnBKN3NuOGZybTFLekRuVER4blpjc2kvVDBoK25UWlVrZjAxcExOeWZaSTQyaFduelR4WHJkT1F1UXZXVFJ0NzI5UFJIanZneWVKaEgyNm1tMW4xazNvM1dxVjZyTDdqTEQyZEg3T0E1SXM3YzQ5M3E0ajBzL3pXTW1SOGJRa1JISlA5dzE4OVVDbnowNmRmcDhMTzZLc25EeTdqdy84dDNqNWh4Z3BrZk83Y2s3ZjJ2VnNTekVTdWRyL3JzY3J6MmVuM05mSE1udlQ4dTJHRi9iZnliNlg5eVJqQ083cFB6R1daSjJ5b3I3M3RCMmVaTkYrSld0UDczMVB4aTR2M3BIZkNHRGQzRWtUOS9oT0JqQWtMWWkzZDI1SHRYbVNabm5EM2VvNDdxV0VmVmJnbk02ellIbHI4Zk5tQmtmVzA1NmVWWHYwN0hzNDE5Zm40dUMxajZIOEpOUHZ4WjNFUVo4MU9RckpIM2xXSkMzNXZWTVduWFZCT2xlSzBnZXluNWZPWEhyU3FJM2JsbExtZzZsRkdTVU82VTQ4dlVlbDlaZ25tZVoxNVhEU3h3NVRJM2xMRnZYS2dMMG9YMDdKN3NseTdpVEsrYWlyenpuTThVSktZNWljL0RrWVl6dlVlb2M4SElFK1VJamEvMTBEK1gyRjVhVTduUXM5SDBFNDJpOVVZU2dhdEQrWWpaWFlnRHR4Rjlwd3QxYWFiK0JOcmk1alhGWCtGdS9nWGZ6ZW5NZjE0OFZtR3RlUE04MHNNOXZNTVhQTnBXYWV1WXlyeUVmTlkrWUpyaHE1WXVSNjhSa0UwSWdnVVFxSEtFV0ljRkJKRktLS2NEQ1VDS0dCQ0VtQ0Ftd2dBbHF4RjJuRlhvZzJJcUFWZTdGa0t0VHF0MXlyM3dxdGZzc1FJOHExK3EzUTZyZE1xMTlIcTk4aXJYNkx0Zm9OYVBVYjBPbzNvSFZ2a0ZJL0NxUHZ0aG10ZTRkbzNWdWlkVzlRNjk0aFd2ZVdVSW92bzRDb1FoSFJpR0ppTE1xSVNsUVFKV3JobFdyaCtXcWhuaGxnbk5vNURTNVJqaHFpRk1PSUN0UVNRUXduQ2xCSFRFTTk0V0FFNFVvdlF6Q0thRUFqVVlPeHhIU01JMW93bnBpby9Wc0xyNFQyYnkyWVRGeW0vVnNMbW9tSjJyKzFhUDgyRVZPSkZ1M2ZabXYvTmduVGlGbVlUaGp0NGlaakJoSEFUR0lLWmhGekJPN29oSG5FMldnaHp0V09icXI5eHQ5Q1lxcjkwdDlpNGtMdDR1WnJGemRWdTdqNVdFcE0xUzV1dm5aeFYyZ1hkNmwyY1pkakdhRzlIT1ZhUVdoSEJ6NzFJR1pxUnpjWHJVU2RMT044N0NPR2FSYzNIZnVKUzNDQW1LaGRYQXNPRWpPMGkydlJMbTZpZG5IbmFCYzNTN3U0S2RyRnRXZ1hkNjUyY1ZPMWk3dEF1N2lwMnNYTjF5NXVLcnFJaTdTTHV4eUhpWG5hdjgzVC91MEN2RXlVSVVLRXRKZWJxTDNjVk8zbFptc3Zkd1dPRUZPMGw1dWp2ZHhNSENVS1pkUG55NmF2a2swdmtrMHZsRTFmSlp0ZUpKdGVLSnUrRXU4VFRUaEJUREJqelZpTTE3T1FJajBMR2FHbklDUDFGR1M0bm9LTTFsT1FVWG9LRXRaK3IxblBHODdTazRZeDJ2VXQwSzV2Z2ZaMUU3V3ZPMC83dXZsNjZsQ3JwdzdGQ0V4WVNta3g0V2ZuZkllVzk0OWFlM2RwSFJ5WFQrVE13Ymg4RmNOZEJOZEcvQi9SR2p6Sy95U0NhMkdobldVNkZDY0hvcGV4WTF3ZlIza25BbGM1T3BrV1lkcCtoanVFZG9JckV5S3F2ZVhwLytuOE5PcytyQlBhaHlsalhDa1JFaVZubktUZDYwR2loNGlsZW5KY0MvY1NkajRGeERXZTY5cyt6SnZNbGxQMXE0Yit6L2V3ZHNxdGsvVGU3Skg3YVVMTlRTUnlrZVEyek4ycHJ1d3AzenhHdmtvN0J1ZlBjZ245MXFaMjZOZVJuTFVpanZuL1NkYitWL2RPYmpyeDlZcTBBRmpiNzFIYzYyR3JMY0x1bHIxeUNqbnAvU1R5L1RLUmZVZVo5K25wWUI2bnNOMGMwN0t1Ty96UEtLU3J6RHgxcEp6MnZOSm93aXVubEd3MTU1YWFNWUtPZTJsWkpGSVArL1lkM3BoejRHU1hQNzBuQVkyOXpIZVkvVDFUQjV2YmYzS1dvYURORWN6U3hvUTNnaGorLy9wZXMrUGZqWGtjdkpHZnE4ME1kR1I3L2NRdlFFaVNDRGtkZ1QzVHBuMlB0T1A5UCs2MUdKcDE0aW9WOWZxV1ljV1MzcjdCVlMrS3RCUG9VZzZXNC85ajZYc3NrdnhqZWc5NjFxQmRXRjlhb096eXpKNTMxUTZDZEpoSU1IN2NzMzJvcGNmVXptNEUwNjJYY1p0UDNDSkVqMnJWbk14WWwvUUFoU09xTHlJa1NZUVFKUkhNMjBsd3R2YXNPS0taT2FLWnVVazVEcEk0TXpQZmZvWXNQQTdkYVRzdHA4K3dBNnRad3BkRHVqNnVlamtpeU9td25XZWlucjB4VG5UQzFlcUNJMVg5NGFaNVZ5ZWpadTlMQnhyRFNlc0hjbjUvVGYyVTNhOGMxM01teVczbjJ4Z1I5Yzl4M3JNNVJ5R3Rqand0QitIODJTYlRacDE0aHNXb0ZkYitIRThibm16MmlXZWQ5eXdrSXU3d1diKzFPRjhMdkZpLzNyWTMxemMxcFZkZGN6cjlJN3Z2VTdmQmZFNTVhclFrKzViTjN3dlNTb2RQejdGTVBaQ1BOMStUZW1GbmUwOGVKMTByM2hQaXpGV01TbVpkYlFRei9TdmhmVjNGTnovRVZiOWpaNFNnWnltaHRMSldKbThPVnUwa2pYM3ZGNGFrNTdrZHk5Mm1LbzcwNy8vMDY3MTdzb3lMMkVCV2NjeVZmVTNvMDRvNHFsWGVPekZLeXpLbUhiVUorcS9SNWZXcmNxYy9KMmFZYlNNbFdWOUlHaVZzNjBOcC9GMlZsY2VDcTlHajA5VFdnK201ay9YeHg0SE0zM2Q4VjNsc0FDeWhMNGVTZys2RVNTemhuWUowNWNOWW13VW8wVUhaaDZzZDBuNzlmeFl1VTZBMFFqSzVZQXdnT2RidUQ3T055Z1hvN3VPcFp6VTc2RDF5N2JVT2tSTTlQYVVJTXk5anFTNld1b2Q1bzlaeTJwbENEOHc4NmU5aFdYMkpyQlg3bjN0bHZ2bVViYlh6NS9KOWpLN2VYTjVJVjkvNmQ0emltbm1TS2J1TjJsYlkrOVlhNE9lbldycXkrbEdWOWxrb3g1cnRIYnRDOGVUSWFKZlNNcnlIeW5uYTlxNnV3c2N5Nm5ZSldNdUpxRDdZZlhpSCtvMTNKVTIzVWhQV0dtVEZrdGhiTitrT3hFZjZ0T3VtbUowQlpRY3FtMVJha211V2IvaE9VTFJyUitsOThVeFhSejFsMnlDZFVqZFdRdFhJbXUxNjJpdWp2Qm5udzVocTg3YmJQbjVjL09GeGovdTBGRTA3WWR5aEZHajA3QmRpdXVNZlFURzFlejhna3Y0NUhvNVJBd2xQSzRjNWh2amJxdFpSSFBta0R2SjJLQkcxb25pM25qaXNaNnpIMnRFOWpCK0hLNDVCcnkremZna3BoMzJRMjRmbkRlWjQwdFVoQU5GQXZybWlzaUhybXlXbDFxODlHZXN1eFlnYzUzclBIekJFaXFUWHFDc0JYYjF3UXVnbTlma05PNjNReGRGNjdUQUpLaE5SSEgvaGc4SC84MzRIRWVXeEQrLy9OSnB5bmFZOCtFejk1ZGdPYi9VbG04bnJEZjYrZnpkV2ozUjd6NEJpZlkvSDdMODQ1OThIV1o2ck9EYkYvOFZHSXVkOWM4TC9pMnp1T3FaV2VuMnJPMjhWNlA4MVZmdzgyL1h1SkxLUGFLK25uRFAxcmpEQmVVa3Q5U3pnVTlZTVlSSTBNeldCTWNMeVVsaHBncTV3dmJBQVpKU2hkNGZ1c1Q3R2hMRG1LejhjTkZsWUhpeExHZXp6aWJoZC9ZbW5OL3RTR3J1R0NDc2U2ck4vSGM4akJBR1ZiYVpHbXVDcVp4MWJxbzVoL3JlOTVHU3h1NngrUUhYRWMxdTVBNWw3cmd4YkdrVHZLa3ZvL3o1eHVtZEcvL2FYcTMvbXZjL09YL1BnUytsYnJTVDk3NmZvcHBQbHVWSXVPMlBYNXMzbERHY1RWSnVITE04Y0ZQSnk5UDFjUEcyLzB1TkpFdXhIWjhIVDFTdHpmNDdIUXZZK3RyWnlPUGZ6MGRxRFpQa0NSRmJ2M1QxNDdjbWVVMDg5OC9EMDl0bVhTaXJXbnJuaUY1SWtDeTh0a3Y1VVZlazkrdDlORWhUS2hFN3VlblVnL1NzUlF2eE1mV2RUTFl3U1NZSjhvVFIvTC9vMTJmY3ZhYW11d2ZqV0RhWElhMzdXSEJzOGMxcnhlamlSZlJXWC9WdWx5cC8vU2ZjbVg5Z1ZCemY3RndDeW5yUGpXczlieFhuMWVpMkNWb2J5cGd5NWZjdW1kYVRmMTlNK1dDcW0zSFhRTzF6MmJwM3ZwTFRUVDBzZE5QbDBGOHI3L0grZDc5dE1iazU1a1dsUjlqc3JUWDF3Y0h3dGQ3TFc0YWFGZ3JhZkhMZ0U2eVhnWHhsemJBVFR1SVg3OUxtUnZMeFl2Sjh2R0RzMmxBczNaeUN6UmRZdlVYaS9DK2wzVWNYK1NuTnBNTDNYTW5zZ3gzY1VzdWZJWDBzT1F6MFpYKzd6Skpha1RyOVBXcnJ6dEpYK3Y4WEowRjluUmZLWFp3ZisyR2w5cVNXa1Znend1eUxpNE9xYS9kbFRzTytaaTRob3p2WitIZGVzR3ZQTy9UQkVhc3FtazdROXMwb3JoYlg3bjJOS3RwQlBzbUIvL1pyK0Z2SnB2akh0aUlNanliS3YzWUpadnlLZ054ZlNORVhZVm9rM3lRV3lyL2hGQ1o4dE8zYTFZWCtOUkxydlBwakwyaTUxZkZDK3Q1Z3ZuMkFmWlVLZnlzMW5Jd09RTllCS2pDV0E4V2lDd1VRMG94QlRNUTNsdUlTb3drek1RalZhY0NOY0xDY200Q2Jjekh6MzRydVloUHZ4UFZ5R2gvQXpMRUFYWHNhdCtCVmV3M3E5NTduWlBHdWV4dzdXY1RYR0V3Wm5FOFZvSWdLWVNCVG9qZUVnSmhQbG1FSVU0VnhpQ003VCsrSE5SREdtRWc0dUlrcHhNVkdHYVo1OEZaaEpoRENMcUVRTFVZWExpUWJNSjRiaUNxSWVWeEl1RmhBMVdFZ013MVhFQ0N3aWFyR1lHSTRsUkIydUp1cjEzdkFJWEl2cnlHY3BVWXN2RW1GY1Q0ekNEY1JvM0VnMFNpTmpjQk14RmpjVDQzeW5PUTIraG04dy9FMThDMEVjSklyMU5uQlFid01YNDM2aVJHOERsK043UkloNmZJVHlQMHE0K0FFeEZJL2hDYmg2SjdnV1R4TU4rREV4UXU4RU42Q0xPRXZ2QkRmaU1ERVdMeElOK0NVeEZpOFJ0WGlaR0lKZkVRRzlFK3ppMTBRcFhpRkc0UWdSd3F0RUpWNGp4ckhucmtDTnVkSmNpVnF6d0N4QXZWbG9Gako4Rlh1MFhtL29GdW9OM1dxOW9UdVNYTjlFSVhFTGdzUldGTEZsUUFsUkFJZllpbEppSE1xSUpTZ25ocUNDYUVLSXVCZVZ4QVpVRWZlaW1qaFhwd0dndC9HL2hwRkVBMFlSWDhSbzRuSTBFaE14aGlpVzVlN0JPT0tBTEt4VmI2TWZrRzIxeXJZT3lMWnUxZHZvQjJSUHJiaUFPSUFMaVZiWjFnSFoxaXJaMW1yWjFocmYyK2hyTVlPNFRIWjJ1K3hzUDJZVHl6R0hjRENYdUJ1WEVrSE1JNmJpTWdLeXhYV3l4WDE2UzMyejdPOGUyZDltMmQ4KzJkK1haWDlmMGJuamZiSzhObHhMYk1aMVJKdnNiN1BzcjAzMjkzZXl2eS9KL25aaUdURkxWcmdMSzRqRnNzWGRzc1cveDBxaUZMY1FOK0JXNG02MEVrVzRqUUJXRVRkak5Wc0ZyQ051eEIzRUZWaFBBQnVJOWRoSWpNYWR3aVlDdUl2WWdEWmlQZVhhQ21BYmNRRzJFK2RqQnlVRGRoSmpzWXM0RzdzSllBOHhDbnVKUnR4TmZCWDNzTTNBUHVJY3ZVRy9SeU5ucjBaT0svZ0dQYThjTTd6RE1jTXd4d3pUN3lPdTE4aTVUU05ualViTzdYaVFPSUJEeERDOVRiOU9iOU52MXNqNXNrYk9abzJjTm5Ea01Qd2NVYTN4czBYalo2Zkd6MjZObjMwYVA3czFmcjZzOFhNTklzVFZHa1d0R2tXYk5ZcFdhUlQ5blViUjdScEYreldLL2g1SGlSYjhOL3hQUU8vWGI4QWJ4SGE4U2V6USsvWGJFQ08yNi8zNkhmZ3RzUTF2RVZWNG03Z0pQVVFGM2lIdXhlOEk0RjNpVHZ5ZStDcmkrRDhBL2tCY2hQZUlpOUZMVE1NZmllbDRuN2dFZnlKbTRBTmlKaExFbGZpUVdJYVBpQlg0bUZpQUU4UkNKSW1yY0pKWWhFK0lhM0dLdUE0cFlxbUJNWUMrZXRCc0NzeTVnRTZ5ckRmbm02a004endMdzlQTkpRenpWQXZETFdZK29CbmdIclBJdEFMNjlrRkEzejRvMGJjUFF2cjJRYVcrZlRCVTN6NXc5ZTJER24zN29GYmZQaGl1YngvVTZkc0g5ZnIyd1FoOSsrQXNmZnNnckc4ZmpOUzNEOGJvMndjVDlPMkRTZnIyd1JSOSsrQThmZnZnUW4zN1lMYStmVEJIM3o2WXEyOGZYS3B2SDh3emU4MzNBWDM3WUx4T0pIeEJwM0kyNmxST3VVNG4vSVBPNXBUcGpNSS82SnNJSzNWT1o1TjUwandKNkxUT1hmcEt3bnlkMmRtb016dWJkR2JuTG5uTVZubk1PK1F4MjNTbW9WQm5HcUF2S1V6K3YvMnlZRnNBZUFHRmxtdHdsRmNkeG4rLzk5MTlzNFFVUWdnUVFnZ2hEUkVRR1FURUdRa0JRcXlsUXJpRkFBRlN3clZvQ0VoQ3hVSnJMNVJTUUsyM0ZpcFdwYlRVM3F6Vll1c0ZPNDdXZnZCVFAvaWhqdjFRdjFnMTlxNzFWanl6dTEwM05EUE9NKy92T2RuelArZmRPVG56L0JlQlVtNk94aEsxWHJXc25SRTkzZjI5dEpBQ3VIU0pNVUJFaW9RTXBaUXhnbklxcUdRc1ZWUlRReTExMU5OQUkxT0wxa2hNbWhLR01ad3JHTWtvUmpPR2NZeG5BaE9aeEdTdVpBb2ZZQnJUdTd0NytuazN4MjJCSnUreGI0ZGxPVzd2M2J2SGloeDM3dS9lWmxXT1BidDNkVHN2eDk2d3lxWThEK3paYjB1T2UvZHY3L1hxSFB2Q3JHMTU3dTdkYVh1ZWZiTStiR2VCczkxUzRCeDNGampYbmdJLzR2NEM1M213d0k5NlU1NEh0dlo1NUQzdTYvTjRqdjNoYTNsWGprQUVDSmdmVlFHU0FhNWdHS1VNcHl5TVJqQ1Nja1pSd1dncUdRUEllRUFtQUZJQ3lGaEFxZ0ZKQTFJRHlFUkFhZ0daQkVnZElKTUJpUUZKQVpJQU1vNEdydkdoNkhqMFF0d2F0RHJ1ajgvR1Q2U21wbHBTWGFuRHFUT3BpNm1YMDVuMHJIUm4rbVQ2UXZvdlNWM3kyNUtwSmMrVjlJVG54VXlTcWM3TXpMUmtPakxuRUpBTUVZK3l4aHU5eWM5NzBRZDgwSnU5eGZQZXlvQmY4SXQreWJ2OHNrODV5NGY4cnR2YzdnNTN1c3ZyM08ybi9MUTk3ckhYdmU3ek0rNjMzd05lNzJjOTZPZTh3VU0rN0NNKzZsZjhxbC96Njk3dFk5N2o0ejdyS2IvbkU1NzJSejd0TS83WW4vaFQ3L1VibnZHYmZ0OG52YzhmK0VNRy9KYmZEdnlPWjczZmM4Z2FFa3JJWk85dldkSHBUNlNXU2RReG1lbk1vWmxGZkp5citBUlhzNVJyK0NUTFdFNGJLMWpKS2xhemhuWTZXTWQ2TnRESlJqYXhtUzYyc0kzdDdHQW51OWpOSG5yWnl6NzZ1SkZiT00xWjd1Y2NEL0FnNTNtRzMvQWl2K1Azdk1Rci9Jay9NeUJPc2RFUE9zTVBPWk1Za0F4eWtTdW9vNUhadExDU0xucTRnV1BjelRtZTVHa2l1ejFNMnVXdTQxVnY0MitVMk9aNkRubUV2enZmbjVPNHdnMzBlenZ2MkVUaVNqczU0RkgrNFFJU1Y3bVIxN3lEZjlwTTRtbzM4YnJIK0pjTFNWempadDd3VHY3dEloTGI3ZUpOai9NZkY1TzQxbXQ1eXhPOGF3dUpIVzdoYlU5eXlTVkVidlZDWUo4L0l5SkZIQVNqcVVGYWc0YXpOcWlNQklnb3BaWVk0MlprUnQ2aG5waUkybmc2VWxVWVFUMGlHekc3Nzlic0dhWUtKN1U5NjhPb3BJWUdaakNYSmxwWlJydnppYW1rektiZ1k0SXZDRDQyZUhQd2NjRVhCcThLdmlqNCtPQ0xnMWNIYndrK0lmaVM0RFdVSVRLOGNQT05qdktId2w5UmRKQlNYdVVRL1J6Z05WN25EZDdrTGQ2bVVFRU53eGx3dVcydWNLV3JYTzBhMjExckJ4RlNRUTBVN1Q3VlZoSWdUVG4xektXVlRtSkFXb21qaXFnaU9NUmhUQVN6TVR4QXZxYU95TDhHUWt6a1M1UmplQUJFS29qUjU1SEt2RU05RWxQQmdJMGtnR1NJQVQyTGR1UnJCczhjSS9LVVRVUE85UkI3T0todXlOazJVblpsRlEwNVA1TzB6VG54OHBBVlpTVFdtQmZQRGxYREh5bmhuU0tkR2JMcUYyUjRZWkN1SDdMdVhvYng4R1ZxRzdKeUg2SDN2azhOUmJkNG9HaUZWQ0ROZ01DVlJFRURRYmpPTFRpb3NoS3B4Y0plRVRLYUdrQWtKa0tYMndIdjI3KytlUC9jR3JkNmlGSWlwSlhOVUhSWDF6UE53L2xjRDRudXJkN21FVy8zcUhkNHpEczk3Z2xQRmlYOC96TDZIazk1dXBERzl4a3l1Q2lCcHhIbk16aWtMNlB5Zlc4czQ2aGlQTlZNb0laQ0doZmxhUzk5bkM0azV5dmlsRUphRnI0MWpaUm5lOUI1UTdmSmQ0L0hmRHpiTFVKZnlIWUZLU2VrZjJESStYeHU3MkV2SWFlemlSenl1Q2hWNW1VOVRWazJWK3FaNnErSVdjb3luOHY2Q245SnhGSi9IYmpNNXdOWElMSzBLTU5iS0tXYVd1cHBaRG96bWMwOFBrWXpPaDl0UWhlZ3plaENkQkc2R0cxQmw2Q3ppSUxDMjRFNVFjT3dzSFBpQ1VTbUY1MUJKU1ZlS082TVJFR3RRWENXOHpoby9YV0lyQjMwMlZPSWw3M25FVVFxQjMyMkVwRjlSZTl1WUtUZERKMXhweGtJa3BIRVZBejVmOTlJeUo2aTNkcG9jSjNyM1dDbkc5M2tacnU4MWkxdS9iKy9JL291L3lWQjRjNW5iM3JwZndGQVpwNjRBQUFBXCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9zdHlsZXMvQ2lyY3VsYXJTdGQtQm9vay53b2ZmXG4vLyBtb2R1bGUgaWQgPSA1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///57\n");

/***/ }),
/* 58 */
/***/ (function(module, exports) {

eval("module.exports = \"data:application/font-woff;base64,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\"//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc3R5bGVzL0NpcmN1bGFyU3RkLUJvb2tJdGFsaWMud29mZj82OTQ5Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmFwcGxpY2F0aW9uL2ZvbnQtd29mZjtiYXNlNjQsZDA5R1JrOVVWRThBQUprMEFBd0FBQUFCQmFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJEUmtZZ0FBQU5FQUFBWEcwQUFHdFlFcnNiOEVSVFNVY0FBR21BQUFBQUNBQUFBQWdBQUFBQ1IxQlBVd0FBYVlnQUFDb21BQUI1eXJrdFpOUkhVMVZDQUFDVHNBQUFCWUVBQUFxNkVKd1EzMDlUTHpJQUFBRjhBQUFBWUFBQUFHQlBPaytrWTIxaGNBQUFCY1FBQUFMb0FBQUVYaHdVM05ab1pXRmtBQUFCSEFBQUFEUUFBQUEyLzdVc1FHaG9aV0VBQUFGUUFBQUFKQUFBQUNRS1F3bkhhRzEwZUFBQUNLd0FBQVJNQUFBSFJNOGJLRXh0WVhod0FBQUJkQUFBQUFZQUFBQUdBZEZRQUc1aGJXVUFBQUhjQUFBRDVnQUFDR0hiUmltOWNHOXpkQUFBRFBnQUFBQVZBQUFBSVA5Y0FGQjRBV05nWkdBQVlpZEp6YzYwZUg2YnJ3ek16QzhZZ09Cc1Q3VUdoTTZWL1YvN1g1eU5nM2tma012T3dBUVNCUUE0aVF0TUFBRUFBQVBsL3ZRQUFBWDUvMzMvYkFZSUErZ0ExZisxQUFBQUFBQUFBQUFBQUFIUkFBQlFBQUhSQUFBQUJBSWNBY0lBQlFBRUFvb0NXUC93QUVzQ2lnSllBRW9CWGdCUUFTRUFBQUlMQmdRQ0FRRUNBUUtBQUFBdlVBRGtld0FBQUFnQUFBQUFURTVVVHdDQUFBRCsvd01wLzBFQXlBUGxBUXdnQUFBQkFBQUFBQUhoQXNVQUFBQWdBQXQ0QVpXVXZXNGNOeERILzN0V0pIOUlUbEpZc0p0ZzhvRVVrYlU2eVZYa05KWU5Hd0t1a2cyWEFYaEw3aDBoSHJrZ3VUcWRVNlJOWGlKVjNpSHZrSGRKblRhOHlXQnpzQlVFV1RZL3pnZm5UM0s0QUw2b2ZrRUY4UGRkOVlOd2hWMmNDbzl3RDYrRWIrRnIvQ3E4aFlkRHpFZDRoQXZoYmV6aksrRWRmSTZmaFc5amU4aTlnNC94UVBoZW9kK0ZkL0hsd0h2Vmk5R2Z3dmR4dExVci9HQ2o3ajUyV0ZXMWRRZkE5ZWhINFFyajZwSHdxR1R2Q04vQ3BQcERlQXVQSVZ6MG4xVG53dHNiOWgyY1ZiOEozOGJ1a0hzSG4rRlMrQjYrR1gwcnZJdVhBKytOZnRwNktud2YzMjhiNFUvd2NORDJLZmFySjhJUE5qVHZvMmkrTUxQZXFZZ0xHTXpRdzBFaFRsUWZqWDlIWjdIMzNzVG5OamJyb05kWkg1NkZjSG1lbGJPTldDTVZNNjNOOUxmOXJZbkpCay9IOVhoOC9KU212WFdheHVQeENTWlE2QkZoNFBFT2hMUENmV0VQZzZFSTJVU0tjbFRhTEZTOHBORFN4SHFUd3lsdFZqemNxSGhLSitQakovT2N1OU9qbytWeVdUdE9xSnV3T0hvek53Y3ZUTEl6WDJUaE9Td2lHc2crOFJvWkdvYzRReWpqRXVmSVVIQ3dhRDZJSlltbUlacXdHZjhXQmhHcGNJQUg0UmcxeG1VYzR5a0lVL1N3Y0p3LzVuSHl5aFJOS2h0TjF2TU9hTHFpbDhIbmlacVdMZmJhaHBxZWgyNFY3V3llUzFBYnFETmVXeityYjFCbmtVQ0ZDUmtSQ2hvR0MvWVZwUWhvUVpqQThtbG5CSnlDL25XUGh6ZnZrWE5PZUU5UE1FY3VveXUyb3pLV1BHcTRqUW8xR2dRc2l2Y041akE0d0FzWVBxRVp2SnpXS3hoaGhRd0REZUlWaGpwOGRpc1FYdks1WnU2aXFTanRvZm04YTk1TFFJY1ZJcTlmMU1sS0xVS2hqdXRvdHN4UVQ5U3k3UjMxeWF3YkxNOE50Y0huUkNIeVJLdXNxQ2tXWmIzUnRMUjVidjBRUnExMUpwRzVibHl2Q3l5Q3R1MnFYTXRqaWthbFpCWlRKek92Rmt3cGgxaUFncWV1TDk3R3JVaGRLZXZVMUJsS0psNlptTllKMnFac3AzM21hT1YxOFRsWHVLWm5ma1c5ZCs4SnQ0bnlxZ3V6cUxxNWJTaUZOaTlWTkVXeWN6UTExTVdRVE5Obm8rdlNXNUdVMWpiYjRKWGpob29MdFo2VkttYnY3czB2YVBJUHJwdnpZR0liNDFPUnhEZXhSTXZkUStpUllJWk95NWp6ckpWYlMreUpHeDROVlZnVmFpUkdTZTlvRUphd0hGa3NINjdHWk9GZ2VGMkRhelJ3NktIRnNrQW9iTkZpSlRmK0dJUUlBNFhFT2hlWXdyM244MUJZYk5nU2QzRVVDOG03N3RCTGJxbkpuYWx3QmNWNkZIc001eHJFWXVjdUh5cG9XRjdWOHY4Z2I2eXQ0S0VsenczS2FoQ2V3WE9WSGg3dVAwN2NJakd0MENGZ3hxK3FZM3NEUXVMSWpDVy9kU09uN0hpdEtjODdSQVJldFVFdjc3R1d0eGRacGVZOVpQbkxLYmlOVnhiNWZ5TSsyWXZCSHU3K3IzL0Y1Q2JyOFBvUDJOL3diU1h3S2YwRlN4SzQrUUFBZUFITnp1dHZrMVVBZ1BIbnZPL3NzQk53ZEZNMjZ6am5zTGNGQmhWVUZPYVZPbVdvVXdmemhyZWlFSVNpZ2hnRUExam1EZkRHQlBHS0FjUkxFUlVFTHdnYVhkS1NJVjRRVFlTNm5xUHpidlNiaVFucFhwdkc5Qi93aTAveWZQOEI3citIRVFCT0J5NENDRlBoVEFCV2t5SkFFQmpJY253eFRzVEZOREZETEJiTHhSUE9QcWZINlhYWHVXbDNyL3VSSENDclpJMnNsdzFTeTRnY0s1dGxYTGJJZGpsZkxwR3I1RFlWVWxwRjFCeDFoMXFybmxGcHRVdGx0YU1EZXJBZW9tdDF2VzdRVGJwVkovUXNuV25NZUp1OG5kNG4zdWVSV0RRVXJZMnV0TTdSaW43Zjk2RmtrV3dzV2lhSnFTSlJ0Q3dyV3JKRnl6ZGxTMlhSRXBKRFpWaktrbVZpMlhLWFRKVXRDVFZQclZIcmk1YnRaVXQxMFZKWHRzd3NXVFo2YjNuN3k1YVU1U2dsaS9ELzh2djhici9MNy9RWCtyUDlkci9OYis2djdBOFUvaTdFQzdGQ3VGQm5EOW1EZHIvZFo3TTJZN3Z0YnJ2RGJyVnB1OEhlYTVmYVJiYkQvR21zNlRWYnpHYlRhVkptZ1VtYTZXYVlDWnNhRXpMVlpwQ3B5dnY1dnZ5QmZFOSs3cmZKWEZkdVJTNlp1elVYUEJJNTRoM2VvMW9DazUwMkJQK2ZBazRRUVBDZlZTNFZIRU9BU2dad0xFR3FPSTZCREdJd3gxUE5FRUxVVU1zSm5NaFE2cWpuSk1LY1RBUERrQ2cwdzJuRUkwS1VFWXhrRkUyTVpnd3hUbUVzNHppVjB6aWQ4WnpCbVV4Z0lzMmN4ZG1jdzdtY3gvbE1JczRGdEhBaEZ6R1pWcVp3TVpkd0tXMWN4dVZjUVR0VG1VWUhWM0lWVjNNTjF6S2Q2N2llRzdpUm0wZ3dBM2lRaDFqRnc2emxhVjdnUlRhemhaZDVpVmRJOHhwYjJjYnJ2TWtiYkdjSE8zbWJYYnpEZTd6TFh2YndBUi95STNjeWsxbk00V2NXczRuNUpJWERJdWFLMGF6a1dUR1NoV0tNaURHYnU0VVNqV0k0aDhVbzVyRlV1THpLKzZ6Z0ZtNFhJemdnbW9UbU5wYnhDemZUeVFNOFJZWXN2ZVQ1bmo0TWx0MWlQQi9Ud3g4Q2Z1TjMwU3FtOEJOTCtJNGYrSlg3ZVlUN2VKVFZQTTRhdW5pTUoxa1ByT041TnZBYzNYektWeXpnQ3c3eUpmZndOWWY0N0I5UWV3SVllQUdGazJ1SWxGVVl4Ly9QZWZjZFNaUVJVblN2cnJOZEZ0ZTl1S2xqdG9hRG1xS0xhOElncU9BTk50REFidlFoc094Q0laUWxRUmN0NlpObUliV1dvSDBvaEFXUlNrMUJNQmxZdHcycFZpVEZ3VnJ6NmZlT0l3MGxOUERqZjk3blBPZk1jNTcvT2FGRnNTUlpYS1pEMWZhV1ZvVVRhZ296bFk2a3llRmpqZFU1cmJKNjNXdjEvb0gxNlpHUVZidlYrS0QxYXJ5bEZOdTNmaWlzVVlQbFdWZnJnNkhlYjRSdUh3a1RvWjA5ZjFKMW1LWTRkUGl3WlRUYU1uN2Vob2x0VWk1Uks2b3I2bUR0RHY4cXJGWTZuR1Q4QlRvUHBzTVEzLzFLMnlUR2pSb2Qza0ZycUc4UE9naS9NOStOWGtNZlF4Y3FEck9VQzdzME82elQwdWd3WjNyYWo0ZU5XaHQ2cWJ2Ukw5c0I1ZERkMUpVTjQ3MWZwOGpQc3ZjTUw5b1Z4YVh4T0dydFZrT1k2VDhrdlRJRCtkYVFWaXhYSEhXUjF3TDFHazNPQ1hvVzIrTndoRDBlWlYyakdtMVFUWkhVYkpmOUc3dk9mNStEOWFxekZEVnM0UCszS1d1eHBKdCtKa3hWYThoTFlUN25XTVFhY3FoRHRrNjVhQTdmSnpYWENrclR0NjZrOTZYWUVzN3hKbWRZam01VnArM1hVcHZJV1hMd0ZIbmoyUDgrLzhneXhJK3hmdGdMVVIyOWE0ZG5tRHZ1L1VuZjcwUTBndUpGNGtNbGlRK1ZoSU1WUHZ5Yk9yV2lxY1NMU2twZXJHQk5WN25YZHlESys4MlNGL2hRU2VKREphWCtsMzM0RDFscXFQZUJ4SXRLRWkvQ0FpOGtXdHFqeGkvWkZCK3E2c0d2N2F4YmVNdkg4cDNCTjdqZ3AyMmpjaVdXUUk5eTJvL2VoZjdpWDl0empKK2w3enY5SXZjNVcvTGdTYzYvUnJLVVNyL3dncHFydXRXcFg3VmM1MWszNE1mdFBTMjM3YXg5aGZFZVBEdElYanR2Z3JzY1hkVmt3eStydzdjMmNVYi8zSTVRMjI3eVBvVjM4ZkJWZUFKL1gxZU83MDdtcXZHN3liYjZDUGNoVFY1TVBDWXZKcSthdkRUZjZkQ0hubFZydEVuemtucnRrbDhNMS94aTFTanFQOHY0THkrZ2hhcWlGK0kvaUIwbVZ2QkMySUllNDF3WHlCMERRYktqYWtZemR0U2QvYkpSN0tjVERUZllQK2MzbzFIcURLZnc0cm9YbzhYS2M1WnMxUXJtMzlDaXBGL2hNNjNFcStZd1FWUHRKVCtVM052d3Z0cWpGclhhTEw4YWR0REx6WkFGU09hVCt4OXRVYjVFai9jbmhHbjR0MHlkSlpMNU1YNGlTaEZqL0wrMHFhbHFOdlVlb3RaTnZOOGVXS2FHcUJjMnEwR1M2RzJXM3VJVmRlRTl2YzFXZUpDanQ5bXlCMDIzUEZCTVhuWFpnelI1NlVvUE5FTXF2ZXVmdGRMNjBGUHdwUjZ5dkRiYTkrenpuUmJZV0szZ1RZK3pmWnFyb2hhRW5WcEl2S2Ywbmkrb3pRYjBzTlZvbHIyc2VUWkhlZHRMRGR2VUhSWnJ2bjJvWm51YjcxMTZNSFJJb2NQL1JNZENCbXFoRjE2RFVRQStCRVc0d25jTUUrRitTQkg3RWQwRzYyRXUxSlgxZ1pEMzM5Qko1TnhBRFZySzY2YkRCT0tPcXN6ZGtJSlc0bWZRS2RBRmJWYkxmYS8xUHFQbjF1Z2pzTS9XNng3YjRIdXRnNTRWb0ZjWkcrWTlGbjNrOW5zcXY1SEJNRVRQVjFOMzB2TlAvSXdkVUpmT0txYytBSHd0Ky9tUHY5YUliNjNpRFF0ZllTMWs0TVV5NjI2L2MzZ2VRQVVZOE1HL0FiOFFwOGw0QVdOZ1ptRDQvd1dJVXhrQ0dMQUFBRjJvQTZzQUFBQjRBWlg4ZDF3VXk5STREcyt5OUFBOU9oNVpCM1hYMlRWZ1ZneVlVTXc1WnhFRE9VcE9DeWlZSXhnd0t3YVFvSUNBR1RFclpnRVZSU1diUGVaMFBLY0dlNzMzN2RuMTN1ZDUzcy8zbjk5bm9hdGpWWGQxVDg5VTZGWXc1bWFNUXFGb090dy8zRE1xMEQxOGVxUlgxMkVoSVFGakk5MEQvVDNsb2o3U0gweTloVm05aFZJU3pKYzBNQ05PRFpUVkRjeEpVeEl2TWd4citYTWFvckRwL2tZWEtKZ2ZZazNENXFyR3pDZUtsMkdaaGt3VFJzTzBaam95M1ptK2pBTXpoQm5OVEdKbU12TVlUMllCRThiRU1FdVkxY3dHWmh1emgwbGpzcG1qekdubUluT2RLV0VlTWsrWU91WWw4NTc1eGtqTXZ4V3NvcUdpaVVLamFLM29xT2l1NktzWXBCaXBtS1NZcVhCVitDbENGSHBGdkdLbElsR3hSYkZia2FvNHBNaFhuRkpjVmx4WGxDZ2VLV29VTHhYdkZkOFZQODJRV1VNekc3UFdaaDNOdXBzNW1BMDJHMlUyMFd5RzJSd3pOek5mczJDektMTTRzeFZtQ1dhYnpYYVpwWmdkTk1zek8ybDJ6cXpJN0xiWmZiTW5ablZtcjgwK20vMWo5aStscGJLeFVxMXNyZXlpN0tNY3JCeWpuS0tjcmZSUUJpZ2psWEhLMWNvazVXNWx1akpiZVVSNVNubE9lVVY1VTFtcWZLaXNWRDVWdmxaK1VINVRndktYdWRMY3lyeVJ1V0N1TVc5bDN0NjhxN205dVlQNVlQUFI1alBNNTV2N21nZWI2ODJYbUs4MlgyKyt4VHpaL0lCNWxubStlWUg1UmZQcjVxWG1sZWJQek4rYWZ6ZXZSK2FvRVJLUURuVkIvZEJ3TkFITlJLN0lIMFdqeFdnMTJvWlMwR0YwRnQxQ1Q5QUw5SjFWc28zWmxtdzNkaWc3a1hWanc5ZzRkZzI3bTgxbGo3T0Y3QTMyTGx2THZtRy9zVC9aWHhabUZoWVcyS0toUlFzTE80cytGa010eGxsTXMzQzE4TFVJc1Zoa3Nkd2l3V0szUmFiRktZdFN1K0Nvd01Db1lQL3UzYnVQTUlLaDNVM0FtT281M0VFRzlnNjlqR0NvS1RWc2VLZy9qZlRzM3IydkNmUXpnV0ZHMEt1bkVmVHVZUVI5dTV0QUx4UG9iUUo5VEtDdkNmUXpBUWNqNk5mZEJIcVlRRThUc0RlQlhpYlEyd1Q2bUVCZkUraG5BZzRqbzhKRDVHaVBIdmFUZzd4OTNZM3hQdDFOb0ljSjlEUUJleFBvWlFLOVRhQ1BDZlExZ1g0bTRHQUN3MDFnaEFtTU5JRlI3dUhoSWRHQjNqNlJ4a2hVcUJHRSsvdjZtVEs4UXFLRGpUVWQrcGhBWHhQb1p3SW0xRU5OWUZoM0UraGhBajFOd040RVRQMGMzb2NTaVBSM0QvVHk5L0VaNFIwWTZSNGFIdUlWNVJrWkVSVVU1QjdwSDJJazFyTkhieE53Q0hmMzh2ZWtlMEN3ajMrd2YyU3NmM0NrdDIrNGU2QjdLRzBXNHgwVzVSNFlIQkpwaElIZUVSSEdpRys0dDN1a2Q3Z3g3aFVTU2JINnljaDZEZS90NDA5cmVYbUV4SXpwU1dmTVBqTGMzOTAzS2xRdTdEM01QakJrb1hld3I3Y24zWUVDdmNmMDZOZmIzdGp4UGoyTmpPcmJ3OTRFZWh1QlBNOHk2R0VDUFUzQTNnUjZtY0R2bW4xTW9LOEp5R3diU1plcmlTZTlUU201K2FoaGNxWU03RTJnbHd4R2pocTEwRHM4aEs3em9QQ1FZRzhqakl3T01VRy9jRzlUams5SVZMZ3A0cTgzNVVUNHg1aWd0OTQ3MkJqemxtZlVHQXYyLzQzSWlOa3JPQ1JJeGl4REdiTU1UWmpsbUl6WkZKRXh5eEVac3d4Tm1PV1lDYk1ja3pHYkNrUGRQYjN0Zk1MZFBkM3RRc0s5Z2oyTW9hY3g5REtHM3NiUXh4ajZHa00vWStodkRCY1l3d0JqR0dnTWc0eGhzREVNTVlhaHhqRE1HSVlid3doakdHa01vNHloM2hoR0c4TVlZeGhyREJjYVExTXZJMzBvTHp5OEtjdDhnMm5DS3lTUXZuOW9KTlE3M05PYllxT3h3S2dJQ2p4RDZBbzFGZmlIZU5HSXpEOEtLUGRvS1BPT2hqTG5LSlQ1Um9ITU5RcGtudEZRNWhpRlJuNVJhT1NXakRZd0pOaFlIT1QvbjdpOGxpa3dMbUVLZjY5b0d2dmRvd2lhb3MrRXI1d1RGUjd1SGV3WlM2T3gzaVk4bnBIK0ppd2h2djZleGdmazl5Q0MvSU9OSXdtS0NvejBEdzJVMjNqNTYvMjk1RzdRMnVIK2NxdmZlK04vWS8xTVE0NzBDNG1LY0ErV3h5M3ZVUlQ4Qjl2L2VoWnA2aitQNCs5Ui9QOE40VC9KVUhmYWFYblRzZk4wai9BMnB1UXR4NVQwaXczMW8wT1JveDUwQ1FWNFI1cHEvazlhcnZzL0dkNy9wOWo3ZndxOVl6d0QzWVBrSGN5WTlJMlNuLytna1A5QjkvdGw4WDlMLzl1ZWR0WTdRdWJsZnpGNEIzdTVSL2lab2tHbTZPK1dFWFEyQW1XOC96Zm5mM0NOdG91STZONGpYQTd0M1lNb1EyVm15cWxlZFAzSXNIZTR0NjkvaE13alkzWWZUL2R3T292dWdaSEdkZWZ1U2FmZUZJMk1DZy8yY2ZXaGY2NytjaEJvaEhSRHBVMGovQ1BzZ28zNzluK1RVWjYvYytpK3FmZW15ZjlWRXVUdVNZblFpTHRuVktSY0p1OStVVUYwNW1Ma2hMdXAwQ1BjMjlRd0pOTFVEUm9QcDZPaklOSS8wRXN1b2p1c3IzdDRWRkNnZTVSYyt0KyswM2hVc0pkMytQOGF3MzgrOFZyU2I3eVc4amRleTk4ZmVjWHlweHJQZEdDNk1vT1l2Y3d6NXJXaUJmM004bFFFS2hZcU50SFBxZU9LYTRvN2ltZUtqNG9mWm1abTJLeWwyVEQ2NFRUZHpOMXNnVm04MlRQNlVVU1ViWlVqbFhPVXVjcGp5bXZLWW5PMXVXanViSjVwZnNMOGd2bDkrdEh5d3Z5MStWL21QNUVGR29pR0lWZTBDSzFDaVdnaktrSWw2QkY2aGo2ZzcwaGlNZHVDYmNNT1phZXdjMWhQTnBEZHdlYXgxOWhTOWduN3lZSzE2R1l4MkdLTXhRU0xVSXR0RnZzdGpsamN0L2pMa3JGRWx1MHMrMWtPdFJ4bDZXVHBiaGxrR1dFWmJibkljb2ZsUWN0OHk5T1dseTF2V0JaYnZyUTBXS21zV2xpMXN1cGsxY3VxbjlWRXF6bFd2bFpCVnVGVzBWWWJyTktzVGx2ZHNYcG9WV1Axd3VxTjFYdXI3MWIxV0lHdGNHTnNnOXZqSHJnUEhvUW40aG5ZQmZ2aVlCeUY0L0F5dkJadnhGdnhBWnlCaitHTCtBcStpZS9oY2x5SlgrRFArQy84Yjg2TXMrUjRyZ21uNWxweTdiaE9YRzl1Q0RlZW04ek40dVp5THB3ZkY4N0ZjYXU1SkM2WnkrRHl1ZU5jQVhlSnU4V1ZjVlhjUys1UDdoUDNuUVBPMElBNWNRYTNFeWRqYmFWTks4eWxKSzlhbDZUYlY0MDJySTNjNmEyWjBqdVcySVRxOU8wUk4xaHNpem5wbDdOSXByWVduMHF0RVV6MUVqbmhjSHJLRVczdXV1Ull2ZHBuUVZ4UVdNemVkSzNxaHd2cEplUm1wNTg0bWhvZDdodXE5d2dJMlpPbHZkcEtxQ3M5OTBDbmVwOFZlVGg0aC9iaXZvemp4OVZYNWg0YlpUOXp6dGp3L1lHSGx0S21rK1A4UGQzVU04NjR2dER5d29ha0hSdTJhbklPeFN4d0Q0ank5QTdMeXQyVXVISDlKdDJvMVNoaGRjS0tWZXJodDkzSzMxNHB2bmZlNStUY2JWcGc3KzUraE1ndU5uNGNnbDRzWVVjaHZxczRDWE5DVzBNTTZobzllVVl2VFdmWEM1VjdOK3pidEYvM3ArUzBFZHNaeHFOVm9lc2lJdFZFODJZd3RBTHRsNmZRUGtmN2w3UU1jZmx3dGpWdHJNODRFMzljQTlyNzMwSDhNS0ZnNUlCaHMzcU5MSElwUzh2Wm5ycFBOM254ekpCNW1xQ2dyWHNqZENDK0Z4WkVITWcvazVlUm4zMHd5dDg5S01oTHh3dmRSSEN5NlNaeWZiQnF5eEtzU3VzaXFxYlo0ekdZNEJJN2FIempZczZKWE4yNnVNU2xLOVVjY1lVK1pBQzRnQ3YwZ3dIZ3lnV21SV1huNVJ3OG5xVlBDL1FKRHZYV2NpRUhJck55Y3pPUEh0Sm5CUGdGQi9scE9YL2NGMnM1ZUhCVlNGaWN1R3kxMmsxOGJZZnQyQ2trRDNINzN5QlN3L1lSRFlOWXJxZElPdjF5Umh5YnNEVXhhYU02SmZINGpndGE3alNXWW0wNlkrNE1CQ0c0d0tiOGljZ0Y5Z3dFSTZqWlFFYy9tSTBoRFcyUEJVejQ0V1BYNVlMN241K3Vkcmh4YXZwYjRJNnRLQ0ZXM29oekVkL29nZXN0cXBweDBrUWJlNUViaVZjTUZGNitmUFNwZXVJZEJ5NFJmOWREdTQ2WUczRUdlVVc1ZUF6UmpKbHhvV3B6T2Q2aTQrQnA0a3VwOEtXaTZJdTA4WXRTNmxML2h3Q053S1kzNlVQYUVtV1BEbm9kYVFiWFg1SjVGdCtQZmdNRzdOVGdSd1pDWXpLQi9nYVN4c1NQMkgwanpEY2ZMWmxyRDllaEdkc2hsU2hmUTFzMTlBR2I1OUJJeS8rSXhmQzB2cW5RRmhzWDdRSW5UUHlqY1p3NEJYTlJVRlFDVWFYTG9xMXZQVmJkRDhDcW8vOWNGVmE0STlYOTlQakFRMU9XaWVHaTZ1aGwySVo0Z1p4a0Y0OUZNSTJOaWllMlJPRkJSbGhXczFkZ05LQzZhOGN0ZWVGbHphWCs2Qms3QW5TSUlKWTBKVHJFd1hTQk5IelpCNXFCN1RkUWdnWWE5TDFQTEQwRFZ5NE0xbFpDSHdUWjdQN1hpSHhoaVk2Y2Zqa2RIVGg0ZVBjWlRmbVorU002alhRYTJzT250RFFwTVduOVpsMlhXSlN3Tm5IMU9qVXZuUm9tY20vSlJES0NPRk9KQ3diRGxJNHdDM0ZzWDBQclNNelZjMEs2MStTdE16VmtKZTJrTDlHVEhuLzFCVXZhZ2NidndCN1lnUldrOFNpbnNJQkFIVFRPZTE4TEdzMnBZeXNXNWV2SUp1SXRWSjZiTjdURDBKbERoOCs4OU9qNW5kdlBkUHhFa1JmV3VrUzd6ZytiR2Roc29PdmtpZTNVOXZjSGdBQWRQbnlBRmtuYUxydFEvL21ET3c0Sk9IUCtmTWJ4QzFuYWk5blZaL05LTmxjMVB3NmRuUEdmWktBZWh0ZU52aWYxaUxZdWVRZVI3MVExSldTYThBNmMyTVVaV1N0ek5WZHZwbDNJMUtuT1IyOEkzYkJVKzVxdXlqVjVaOVZTaTY2a3dHS1l0L05neDZEcnBWbzQxY1dDRDFnVnZ5UkdFN2Q4bmhnNUYzUENuYjJYYjlab1hFVk8rRnI4YUR5cVkzc0FoNTVpb3JrcmN2NGlhVmpaRGxwdzBBUjYwWjgxMXhyelA1RXdpbFhaRHNlcVp1TXg1NHRWYnIweGw3Um5XKzV4TmJDanFva05GM1FjUDRISlQ1U3dSbm9wWE16Mm5kRnIxcnlaY3dQeXI5VmR1SEJWQnoxNkNzOW5QdWpZMnFFM3diMnZqZnp3VDlWclFGcWVkTnBPT3lGTnJMZEhSTW1TS2FTb0R4U2h0aXhnUTJzeWxtVFNsVE9lWEgrSDRSS1VTbmFJV0xFa2hoU1RSbENNYkZudXZjZ1NqbkR5ekRVVldvbmNiSkdQMkJHLzU2QTY5MUQydWZ1cDgzMDJhNSttb1l1clBWOFNhdzB4R3p1ay80d2M5Nkp3WFZrQXlvNVBqb2xRQjBRRXpOSnltN2N1MFMzWmluWXU1SVRwZUVGbXlIRWRCd05UOVREbmpkUXZtcXMrT0dQdWlvUVZDV3QwM09MMXk5YXYxbktwK25ybmFNNHZPeWcvUHlzN1B6ODR5ODh2S0pqdUltSDdvck56RHFYbkhZeE9EZmFQQ0E3VWNxT01HejIzNmNDR2c1dlUzZGgxNjd5WHVXajdHbG91RnVQV0xWbTNURGVSbkVhOGs1QXJwdTlmSzRidVBPVzZTK1RTUmRWbE9HNHpBdk5rSXZEa0Q1aklrVTRFa1QrSUEzZFZBRWNZQm9QSThLdlh5Q0FZQVFOaCtMU3JaQUFaUmdiQXNHblR3SkVNSndQSmNNVFhEeGZzK3p2Vm9MNXNHYUZQclFVTE5rQjdVZzFqMGFidEczZnNVT2RFSGZCM2p3ancxWkk1RnB6d2lKME83YTVnVHVqQ0dyNy9haUZ6ZExrd2FkS2M0VHRGM1ZTQ2hPek1sSXlkV012MXprZXQ1dldmMlY1RGJCeGZnUzBNL0FROVlkZ2lrZlBZSDM3NHJQck90ZlBsSU96cjRxTjl1dzlWVFFHZURDVXQybllsdU9lRktWVisybmZ1aUV0WW1yaGlyWHAxNHZMMUs3VmxCMFFPT29FNU5JRStuTHVvNEFTL3pLakRXN2R2MkxCUnUyeStpN3ZUOG1YT3pYNGtWYjM5cUQ0ZmNORExmVUdncDVhSElZbXZwWDlISzZSVnJ3V0Rpb1ZwMGlaRWFnM3ZoUHBPTERsYzc0eGFzM3h1K0VGZlgrOEFkeTBuakdGSk04TkdCQTFZME5YYk91TmFES01xeUNobzRVQmFrSkdEWUNSUjE3SmtKL2xEa01aV0djYXlmRjU0U3VDSzVRbnIxbXEzbnlvOGRXN2I5blBOMnE0YzBzdE9QUzhuN0doQlZ0WnhMUWVXOTRmM1NCWHR2cEtCR283ZDl3eHgwaG9iK3A0d2RHS2xiZEtCbExmSXNJT042WUdrNXF4aGl5RWx1alBpMER2Mkp1U2lrdDJuN3o3UlhNOE9uTVhGMVVHN0o5Q29qdE1ERjgxcGJJZDFKZWI5em81NVVaQ2JkakJWeDcxSmZBTkJmMEx3RzQ0OUFnUG9QUHFTQVlneTZjMXFrVnVQcmJtbG9qVUh0WUtoTzNpZ0xoWlFRcm9TK2sralVuZHdSL3ppNklqSXBaSHpZL0oycjlJNUJTQU9VdU5lUzFkZmMyNFl6T3RiWE1aY1o4Y0JYUjF2VHF5akUwQjVSanVoaStaWU1MT0JXSll1TjBlMGdIUVVIcEZ1aUFTeS9KcktXWHFJcThxdGhKNVZTNk90cjlWQjE3b0ROT0JndlFCVHFzZ1VjSElnVG1TeUkwd216clVzRDhKS1RHemlNQWZ2NHNvcHlYZlNOV0d6eUZVRVBhNnJjSHFpZXMvSjcxRFNUWHBVbzRBMzBpTmhidzBpbWV6Qy9vaWZjZGJ0ZWtuUjlWdEZMb1ZUdVRMTnZiTW5MdVZINXJoczFuSDFxVXZwQWlFeHF6QlhyamhSeWJHSjVDanAwOWJRVXZ1Ti9RWmZJQVRzeTg1eHdxaUxuYUVaTkRuMzZ2WTEzM1BqczdSanN4RW5WSjZlMTRjMDdUK2svOUQ1NTU5QjA4cnlXaDBuTE1nSVAzSTA3L0RKM0lnTVg0OUFmeTh0djEvMzlpQ0NQOEs1QTJ6S3hyUk4rN1JjL2hjcCtnc25qTUNjSVJCeHA4WGtiU0tJSE5UcDRjOW9yZ1NzaTI4Vks3aTcxKzVBRXdyMVQwb2dNbHJCc1Y4T1lnN2NTWC9vVDl6cHo0RlF5QjF3Uit1VE5pZHUxSEI2eVRxYU95UVczY1JTQTQ2RnRtRDVCbXkvRDZrZ2pYUmNGaTY2TFJaeFdXSk5GVmpYS0M5d1BxRVJ3YUd4S1psYzlTVDltVE1pdDJSdjJwSkRHdTVpbGRTUmtvSkJlU0ozNjl2dHQ3ZXM2UXppYUd1dWVnTU5sdTJIby9zcTVNQmExWjBUTG9wK1VlbTVwL0p5anVRZmlGckFYWWs0NE8yaEhqdkR0WCtDbGd2Q3ZIUnJQVlp3KytuYnB0NmVyb0ZGZ3hHSFFNVnlBaG1maldFOHk0RjU0Z3VZOUJ5Q24xdHo5ZTMxbUc2QVlQZXcrZ0drMHk1RWkzd1pESCtnNUo1QWswb2w5eGlzYUtpdmQ2ZEZKYkNhc29YMUo3MFFSempFZlk3K0FMTSt6ZjFJRjhBVy9mRmEyRk5YUUd1Um5zK2xCWFV3NUxtQ1c0VXBGOEV5Mm5vN2g4aE1sanV1NWVubnpSOTN3SXJXZTZnSDV5cHdvckZTUGN5dmczazBGdmNjOXRlQjlyV0NNZ1JHVjBBTG1pZlB6aEg1bTRRci92T09vcVQ0ZmFtU2k2dUJxQ3J3cjdibWtBUExHZWhHK0dISUJ4anpUdldSSXk0ajlUK1ZjcnZhSkgyOVRaMkNLMHZWUzkzdmo2cmoyTmNTWGYrVUUzK0tIK2lRWEdpbDdSL2dLQmR0ZmZnRDkxMktRcFJGVFRtRllvMkNVYkNNSDhOWTlXWGlHR2FZcUZqSE1HNW1qQy9EZURGTUtzUDRNTXdLaHNsaG1FU0c2dE9abll3aWdXRXlHV1lwd3h4Z3FEREhaREJVcTg3RU04d3Vob2xnbUhDR1djVXdPeGhtRTBOMTc4eCtodXJkbVhTR1djUXcrUXh6V0VFVjhFd2V3eHhoR0lybkdNT2NZcGpqWnN3Wmhpa3dZNUlaNWl4RHRmUE1PUVZ6aVdFdU1Fd1dRMVgzekRXR3VXSkdkZmJNUG9iWnpqREZESE5Md1pReXpCMkdxdkdaSklhNXl6QVBHT2FlR2ZPWVlSNmFNWWNZcXRwbnFobW1Rc0hVTUV3Vnc2UXd6RmFHZWM0d2RXYk1DNFlhQXFqZW45bk1NT3NaWmd2RGJHU29lWUM1ekRDMURITkR3YnhpR0crR1djd3dheGtGSGZVeUJiT1NZZFl3MUpCQUxRbUs5U3dUd2pDVVMwTVp4cEpob2hqR24yR2lHVWJQTUtFS0pwSmhZaFZNZ0VKQnlWSHJ4allWczV0UlpMVmlEaktLTzYyWUlJWGk0MnBGbVN3T3QySGFVWnRGRjJZRU01ZlpvUmlzY0ZQODIrd1BzekZtSzZoTjRKTFpkN01mWnY5V0NsVHJ2MGlacU54THRmeWx5aXJsZDZYQjNOSmNaKzVtN21NZWFoNXRmZ1BwMFJMMGtyVmlIZGxockI5N2tYM1AvbVhSMThMZElzQmlqMFdHUlo3RmZjdW1WR3dOdE54c21XeFpZUG5lU2tjRjFONVdNNno4cmRaWTVWcWR0YnBxVllNZDhCeThDMmZoYTl3QUxvQ0tqU2U0Rjl5UEJrRU5GamRJYUhDL1lZZUdZUTNYTm56VzhCdmZnQi9FUi9DTCtEV05VQ05Ob3oyTjNqYjYwQWorbVBXSDZ4OEJmNFQ5c2JYeGxNWnVqVE1hSDJ4OHBIRko0N3ZXNXRhc3RjYTZuWFV2NjJIVzQ2MG5XcSsyWG11ZGJYM2Erb3gxa2ZWN1ZYUFZDTlVjbGFjcVFCV2hTbElkVS8yN2lVTVR2eVpoVFdLYkxHdVMxdVI0azZ0TkhqYjVLQXdXWmdqekJTOGhVRmdwSEJLTzJkamFkTEd4dCtsdjQyd1RaSlBXMUxIcDJLYXptZ1kwM2RYMFdOUFNabE9ieFRWYjEyeG5zeVBOaXB0Vk5IdmY3Si9tVnMxam02YzJ6MnQrdHZtOTVsL1ZsdW8yNnIzcURIV2UrcHo2bWZvdlRYdk5NTTBZamI4bVVWUFNBcmZvM0dKU2k5QVdxMXVrdGpqWTRuaUx5eTJLV3Z3ak5oRjFvcE1ZSW00VWs4UXQ0amJ4a1ZnaFZvdDE0bWZ4WDlwdTJvSGFpVm9QclY2N1hwdXRyZFdaNmRTNitUby9YWVJ1dlc2SDdwRHVwTzZTN3BhdVRGZXIrNkQ3b2Z0M1M2NWwwNVp0V25acDJiZmxpSmFUV3pxMWRHbFoxV3BpcS8ydFVsc1Z0cXBzYmRHNmErdXByWmUydnQybVVadE9iVWEzY1cxejA3YUI3UXpiQU52MXRybTJKYllmMm5KdE83VWQyM1o5MjhOdHk5ciszVTVvMTdlZFI3dnlkby9iL2ROZTE3NTllOGYyZzlyN3RuL1NnZTFnMDJGQWg2RWR4blFZMXlHcXc0b09oenFjNlZEUkVYVWMybkY2eDlzZDMzYlNkQnJhS2JjVGRPN1lPYmJ6a3k1bVhlSzdWSFdSdWdaMXZkRzFzbXQxMTFvcU5qYXdhMlRYd3E2VFhUKzdVWFpUN2ViWVVjV3VYYnpkYXJzdGR2dnNjdXhPMjEyeUs3YXJzSHRwOThIdXU5M2ZkdEJ0ZUxlRjNkSzYvZE45VVBlczd0OTd0TzRSMkdObmo3eWVMWHA2OWZUcGVjMittYjJUZlVHdmhyM2NlOFgzT3RxcnByZFo3eTY5dS9aMjY4UDJjZW5qMTJkdm44SSsvKzVyMjllKzcvQyszbjFEKzhiMTNkdzN1ZS9CdnFmNy91ejc3MzRXL1JyMkMrd1gxVzlwdjFVT1F4em1Pbmc3QkR1c2NkamdzTkZoVS8rZS9YUDZIK3QvcWYvTC9tLzdmeDdRY3NDTUFXNERGZy9ZNDlqTWNhZGptbU91WTZIakZjZkhqbThjL3hsb05yRGhRSytCT3dhcEJuVVp0R1ZROXFDYXdZMEgydzZlT25qNjRKbURuUVo3RDQ0Y3ZHVHd6c0U1ZzA4T3ZqRDR4bUF5cFBtUXZrTW1EUWtjc25KSVFWbGlsWFN1U3BGVUpUV3RVaWJaU0tmcW5RMm4yS3BmV0pET1NVME41eXg0UXl4UElvMS9ZL2U4RVorQnEzQ1hoV2JTUmxrYTBmMnlUUkg3U0QzMXNEL2FHaHBMb2hBb2Z4dDcyUVNLUE1SZm9QSm9Sd0dhbElxa3pXQ3dYb0doTmYzditvUzBZUE9nRjRMT1Q0aG1oVWhhMDM5YkZ2d0dDOUM2bENaWnZycXpIaHJwcFhjMTM2T3RrMS9SejZ6eDc2S2VxWDVDZDJJbFBHRlR2eUd3ZWZYeTIwUFh5dzRGdXJndFp5QU1xZXJ2Ukd5ZkdxcCt0aGZkOEhsaGUwaWJEZ2dOWnFOc0VXbWMwSzBmWWRRREN1Yzg4TkdtTFpsSGd0SDQxSkFiTjlTYnl2RTJiYzg0bExBOGNkMDZkWjl6bmNBeVZLdjZaNDhVSjF3NWMrck9KcTA3bWIxMkEzSTdvTTgrcFlieDVLNlFNTjNEZTl5cUV6Q3QyZW53dENBL05ROUhOb2wxS2cwRFhsSi9CNnhLdlF6ZlNCcU5qR0JnZW4zTFlNb0VwNVd2SnVucm16eTEzdlVsOVNNTSthaUtrNTdidElaT0lJQjVGclFnbm1SMFM3REwyNCtLanp3NjkxYjliRUlaVWRpMW0wcjRtUWZkMGdLMHUyTmlseUU3NTZGVDZBaFU1enM5Y1FTMjVucnVsZHZhYlZ1Ukt1NjJQU0wvZ3VIQ2pjeThXM25hd2d6Z3lLRFZhNURxdkkrYms3K3padWE4dzdkMDRBajdoSWc4dEhqLzRvT0gxSGV2Wmh3cHpBOTE5VnJvUDlwWHk1TlUwOXdwZnM4ZFQrYVJ4cS94MFZybFVaZ3ZFRjBoc2J6UlRYdjNLSnIrWWNGM3NGVERjckNDb2RBUkZGcVhXNGpNSmRvMkpJVEVxdVYyTnE4eDlLOVZ3bnBwaEFCcU4yZ3c2WU4yckE4cTZwemJobGlveVNwaVNRYVJUc1JNV3pnWmdSTzBBc28xV0t6bW5TU3NCNGwyb2JJVTkySDFSRVBZQXIrUllPbGgyK3JxL0svQTNDR0trak1UdjBPemd1VVBpWTA3NG11ZmlMQ1lFcnFmSkJKWG9xTVN1QjdFYU1XT0lzSDdVR1RlTmlxYmJOSXVuVFBIWmNheXBUT2JBZHI4OVBOZjZzditXZTR1Zmd2Y3RQd09UQ0wyYkJBVlphdm5pM3pZWm4xOU5CVlVqdFQ3Q1oxWXcrNWYwZWdEeXdNWDkwcGErMHFSL1JGZWZsU0NDbFlJWUgwSnZLSGo1L3dKbllscUZsbEFPblR4dXZkUkN5cXlSWUI1UHlBS1hNQm1DalFrRHNTckUxbE1wcExtSllRSGV4MVBiT25IaXAveEF3bUcyWUJZM3lJZnR6ZjRJZjVLNGhzcDdxbWkvRDFzK3F3TW1vQ3Z4ajJYNGw0cDFueUE5SzlLQ0JpTHYxZmoxZEJPZ0FmWE1EVGNnRW5EVjZMQndtQ0RvRFJjSUZFc0ZNSjF4RitvRkZlL2gvUXZ5dFhEeFVlUGNjWTNPUGhWS2QwWUxhNmpaSXRlSzZUOCtoYUNJY2dvNnlqMmlwYjhnMW94Nlo0SXB4enhJM3oyQzZUOHJZVDJvekJ4b2p5QkxRZXc2dkpqeWhoVjkwcjRRZmxEbkVoVFBUaEdBOW9QSy9XZ080MDNGZ2srbVZHNTI3YkpYRjQyYjU3YnJHVkxuWnFCWW5QMSt5L3Fpd0dIUE53V0JIaG9WYzJnRXhSU0JGdE80WXpWR0pwRDU3ZFlVYklmMDdRMGRvMjRkNCsrWG5pcHVQbCt3MXZvVGtlN0JseUZqWVZwaFFVWlYzS2FWWjYrYy91cit2V29TaUtRRHAwN2t4YXJ0ZThYbzVvelR6NDl6SjgvWjA2bzkrd2c3ZXlnSWE1ZW8xYzVOdmNpblZKRWVEcXZIQlFQWU1mdGlZL0J2Tnc2di9aN3JkU3VRdlZGR2oxUGVQNHRyK2k2enVNS21qdDVlTlF3RFYycEdKckNjSmhPd3laR0FWMUpGS1JkZTZjZTAwT1c3VXZidG43Ymh1MjZLN0FKT2JMTDV5RFYwMU9MbkZNOE5JVHAxb0dvYmUrTWZsMXc5c0NwYkozN3poUFJaelIvUFFjbGRJVEpwQnUwcEd2Umw0d2s5aVNPUkVOLzBoVVc2OHFrM2tMWHRmTkdqOWFNaXo1NzY5SFpSdyt2WlB0TjBmRXVvc0tvaitRQkp6NkgyS2NRK2R4YUd2QjE4czNKbjFWdndhRVV6eFFoaFlWV1g5OEJYK1o2WmNwK25lclY4L1NyVmMvVWY5TDlvYUdXakNOM2hITVFpY0NNZlhETWIvcmd5ZE82NmNoWVVrb3pZeEhZc0txdk5ibWVNd2FPbmQ1VHg4Tml1cHF2dlZia1UrMWpiN3JPWDJBeUNSb1RHOHFDcm1CZUM4MnU2MEpGSGp3U1gwaUhYeWlrSzUrVTBQU0ZBS3gwR0wxbm9mblRjN2lYT1V5aDdHb0h1VENFV0ZKMmpkV1JtZHZ3Y2xIaElQSlBxS2h4OFUrSWVhTUFaSE1ITHNyNjFmMUcvZXA1aURIcVZ3MkR0bUhZR3ZkcTZDT1krQkpPdkxiTy82d3FwSXBRWGxna2tpbDBpYlVqMmNRWnRJU0R2bS92NTkrOHBGUEZyQmlBbnJEbDhBV1JQK013SkxERUtyak42TFlhWXROZjFta00vUTUyTUpnT0xZSVN2L2NHcnRKSCtJVE5lckVqTzU1Y1JlUVpXd3hYVWNjRVhBcjNFRHhqeDVKN2lDZnVrU0pZMkhqaUcvRXY2eHRGSzdaL1ZFb1RTakZSR0xhaVFRdTk1NDNSakZwUVdKeThmcyttUGJvZGw5ckhyWTVFcXlQWFJ1clZ4T3hlZjJnQ2Z6eDhCbzBQYXNGTTJvNTRHQmtwU3Q0Mm9HVEpBcWtWQUpRZ29tRU5MY2pIY3Znb1V6NERvV0FETE9KejZHS1RmcUdPMjdBME1WS3MzMEI3U1d4WThzdHdsN1NVN2lKaU1STi9aTUZDT2dyTkRVZlJJeFkrU1NlSWhlRUVwYkdaMGlpemljTHJSRVdhcU93Zzh0K2ZZQ24rczlLMFFENnh0K0VzZ2k1SHhFVzk3bUdpWmkvQkt0b29ZNmIrcHF4R2tKdFEzYjdnSjE2L25uem9pcmJDOXVINWdUOVExWU9yWUE1ZDFNTXdGTHNMWUU0Nm8wVUIzc3M4TkgxeDV3QzdxUk4xeEF3NlVEUTJsTlNTejBxcHU4MWZMTEdFS3dpVTZWVjEwRkQ5ZlRpVmdyVmtZUUkya3JkbUNmTkNrRW1EbW4xMHpITktqN0ZPZGpyK1E5eEw2ZGFMKzFqMTFndXJ5c05FMWRzTElsOURkNlIvMHgxSmt2NHRVSzJ3NGJTOEtjbktqS2FHZjZOUExPWFR2eEcvQ3l1dWZsUjJ3VHcwb3ZNMXRCUjNaSC84Y283RVVpZWozb2hVR3FvUkwvblNNcXNYU21rRm5jQjB3eVV2NlJMcXdoWnRGNyt3a0NzOXZHTjRHSW1obWpib3dKSWt3L1VKRXQwb29UVnRjd25TQkdoSTBoQXdMT2tOWCtFZS9FS2tFVXVXa0VPa0VSeENMVm5vUS80bXhVUkN3TE04V05ORzIrRzZrOGlEUVBmcmpOZUtlSkd2d2pDQ2RCRDJQRUxFa29YKzlSa0lMTms5ajh0Rk11ZGZEb2lmYm5xcFFFNmM4SndsL3ZYUnFEZEwyN3loVFdET1Q0ZHljZEVRdVFIcC95dUR6ais3YUNqaUgwaWM2UjI0b1g2T1FHWlI2cDlaRUdFSHRDQTdhSlRNQWdueFp4MnJGSk1kQldsYmxXRWJ5NVBzU3lMWUIyTGVCVnR2ZjYvS2d2MVN6ejVZdFdzSlZtVlI0OHRzZTF5MStLa3psWlBySURiYVd1citRUlZUWjdPM0Nxa0twNmZkOEMzVFFKZS9vQ2tNQkhiaU85SjRxbE9zcjUvdUpoeEJkcXdxaG5UOTVZZmd2TlJkcUQ3ajNFZW5LaVROQnd6cnJSMjYwYTNvaVJxc0g5ZlVhdmxkY1UvaHcxTkYwbnVsNUFjZmhUeE1ySjkyQmkyWTM3LzM4S2h1RStiOXNFeVg5cXpRMUxNSzhyZXdibUhpOHBWcVZZeWIrS3FYQ05iU0IwcHVQTG1HeG1DWmlNbFNkRG5uUkk2V0wxZ2lLcmEvZ3d6NitzVlEwQWFUcm5Qd2M4WC90bklvMkgxMWlDZ0dpM3cxY2ErRmRsVndzNWFxRk9hOUNucXZlaVh4Y0VZZ2VOS3c3djI5cno4QTg3dWx6NS9tVFp5cFZWVVlCcExIUXM5N3ZhQTVqQzZGSnRBb1UvdGFHbzA2czR2SEk5V3JzNkV6RG83UkVOdDJ4SXAwSk9oQlQvamoxcG1EaDFOMUs3eFFxNmlaayswMHFyZU9QdWR2NkxaWThHV3B2NW1ya0JwL1VrcGRiWkp3eituejRyejh0SlNQR3pHeCsrVzNXRnlTc0dUdFlwTVNPVm1FRFBsRHE3NzlQQnoycS8wNWtjUVM5enJwUzdTY3ZXS2E0TElzTnRwZEU3c29hZjFhSFYwaGE3WmtMRHVpS1M4NlU3MVhCNXgwamJKcUw0eWFoL2xUcXpEc29ZaGUyZnhnU1dzNEFjdGhGaUl0V2JLQ09MK1RKdEI2TXVuM09BYzZmS0xQQ2xsWWhqL2JnRjI5bjZsUGlJY1B0T2M5N28ydXRhNXY4MUYxVkZMYjNJYlQ2SDd5OGN1bG11c1pmbTdMcU9KN3FXNDhLWHFQNzBJSjJyaG5RL0p1OWV0eDU0Wk1teG8vd1ZsN0pzWXRaNnBtb251VXU1OU9kWDlUK3ZyMERWUnh2bXF0MTNKUFdYSCtIdCtHQXZRdytmakZ1eFNidjh1eWRVdE4yQkQvVXJTbXJGSWRwYnphaDFYM3ZjVmtySGd0S2lGRjZtNkxxNS9oaDhPZldVczlQcWdxNExUVWRiOUk4RjVCOVRZcGZYM0daa3BneFZyLzVXNWEwdGhROXg1ZmhiMW81cUhpQlRWWVJ5dXpVLzhramFkTWpYU2hIN1RWc2tWbVRBMjhxMTBjYlozMFhsVWg3WlNpQkR0MnlSU2tlbnMwY25hK280WjB0Q1VpNlU0c3lqcEQ0MHVGQi9KeWRjNWs2WHVzcWxDOUpVcnBzMUNUUDNNWWFUQ3VhN2YrbnRjZWZiNEd5aDg2bmpTa1BHdjZiVVcwTlJWdnZraE5oQVBmMGZxVlM5Y3YxOHdhR3pQZVM2ZEtUZHE3NldpcWtSRit5MTFOakpCZmdMUzZlWHJKMlFyTmpoMEo2M2JxZU5lNGF2aFI5Wkx1ak11ZzB6NVJWVEdYYm82dk1PbXd1aGJvRzZaTHRPTEdSK1dOcjhLWU0xNWxXWHVUTmlScDkxU2doQldMRTVacWZHTjNaVzladjJYRE50MWwySXcreG9tZDJGem9nbnJMTzhqY1pRRkIwelR4Ykd3ZjlKS2RRWGFndFlzVGxpeFI4NG1ZYXNKZzJtdFZUQTlSVmRnTjgyc2ZpTklxeXBKV0xQRXdtTStTekZFbjlya2hDcjFoZVRqeVFJUnZ0SXhNSVQ4RDRTZnF3WjZuSlo5bEJUNXp6c0JFWXRncVJTRmJsb3dsWkQ0UXhHK25EUUpnbVBDR0RFUGZXWmNhOXhyWEdvaUc1YzJlWXRLRkRBaStHbHdVY3JXNUxRdldaQW45SlNCb3lQS1hSVVVsbVRaTFhKTDRESXFmS1lEWUxNV2tHZW53Q0w2K2dHK1ByYXVyUGF0VWJ3L0JRYUh3Yk56MDVRbkxxUlVtaUdpUjZ1dnFxSFhSc2VyK1oxMi9hbmV6ZFBkZHpFNE9UeiszYzMweWZXWG5RRHM2d3h0MnJOKytYWDFsUWI3TERtM1p0c0l6dSsvbWcwT3pzdDFaK1RVYTJ1UXhpbVRKSDFPZFNZc1FYVEJGT1RSdWF0aFVEVThpaU9vMUx2bTlQOWY5M3NaSlU3bFBYMTdBOThmV0lGYjcxcWkrd2gwd0NNNXVLWmUzYnRoT1B4THpvRE9sbVpTNllmOWVkWTFUZmc5dEpFc2YzUDNzemRSWWo4WHI0dGJFNnZ5SUErMzNPanFJRmRRNDRYdHhtWFpNL0J6UHhSUDlTTDltWStPOTV3eldMSkZuYnpjTGplN2RwSjhYdW16UW91cTl0L2RkMHZEUURmeWVMbnhxclZvcXJZYS9CTDhvLzJnZlRXeDAwbzRZM2Z3TXBCcXlMMkRCMWlETnBKbitrM3gwMSthai9NemNBMGMxZS9ldFhyWmZkeVljcVpiRzV1WXV6OUhjdkh6NDFsR2RVWHhmUkp6ZmlHQUhKMlBFK3c5eDRWc2xETEo1d3U2dFJhQzRWM3ovaUc1Z3J0NXJnZmVFVmMxTG9maFlYRXJBVnIvbXo3UGlML2tVOTAxdHZ2OGxHaXlyLzBtTFZVUkJsS1NIdXNzVng5ZWgydG5nSW9ERjdkc1BkMnJIa1p2SWJYL1l5ZXRxL3BvSWJaK0p4UVB3dS90aWVSM3NlSzRzSDRnLzNSREx4MkVUcjJHMFpDTThsZHJVaVgwTmJWQ0FJVWQ0SmlmNjBBUmZTd0lxNjlNcnJSUGZSTHoxL1BEeWsrZmI4RDlWbnphdEVOWXVTb2lMVi9lOE13eDRNUHZuQVRRc2pEcm5sYXRWdlQrNysrNlZXdlg5MlNkbm5ORDJLRUVoS1hHWldlbzdSU2R1YUZXZjd1WjZUbCt5TG41dHZPN3ROclF4ZWYzdTNlcVhreDZSeGtUUmNoakJjMVBubjF5Z1ZUMXlpUnM1cjU5NjFIbVhxNTdhTitOUVpreHlXSkI2OUF6ZjZSVDd5SUNUMTNadTJMVnh0dzVDNGFad09HSjNaTEI2bm9kMzhFcHRyMktrZWhTUXRqajlrUHJjOGFQWlc3VThhUzdWNk1HeURoZGlaVWtQekc4Ulg5Mkh2UHZQOW9qdks2VTJMYkVVOGx5NEd1OTJ2NldHY0owNmtaWnQ3ZzhFOU9lMW9odlp1bkZaeURjMndIdXlacHpiNlRKUWxsNjllejNieTMyN2poOGlyaWpBMXVEeDJWZUU1akJJRDA2MUNtbjhVNldVQWgwRnlEWjRPa2lOaUpNRmxXeTNpTEQrRnFpSzMrNFJwUmFQL202SlllTk9JZXNJUGtKOGhFZnNPT2lHN3U4OGYvR0IrcnJMbFpIYUNwd0RIZEVwbHQ4aDBpOGgyWENrS0pMTlJrcndrQVk1WVA2ZktoRldVekc3SWxac0F4OUx4RTkzUkJna2JXbUhKOFByRXZ6NEZvWTUwczYySXZHNEpNSzFXWmdmSjBJck1rWmZYMVpEWDRqMWxzSmJsb3o0VllicVdCaFJYeGFKWlFzU3pWSVRzVC9wMEwxczlEdmROcFlvRGZ0cEJYNEdKdE5KWUJFTWoxYVVseW5MZGd1RHgrYUttWHZYaWtFN0NqeDJpVldsaUVxaWt1SVFoaEZBOWFXWW55RnVvU3c1SjBYNVlDaE9sYzA2ZmZXMTBURGxZakhkb085THlCdXJ1aGhhSnRHcXFwWFNGMGtoYTJMcUVrdGM5WEJObjE0TWZlUjZVb2hzQ1ZHTnFIZXJieEVzcXJwVXdoRzUvbFpwRkxGcWg2VTJSclNhMGpTNm41VWtSbHNYbFVHTEp4VDNmRytLRTJ3a2xyYnBIQ1hOYVN1R0VDcFJDTkdLeVYraDYxdjZRUVR6NGVSWXNaOEkvYVFGd1pqdkowcWRwZWR6NUF4V1dqQkdkQkh2eVphaTZnM1VuYVNCMUZCNkpkdnRyWWRqVllQeG1FcUdmeGJLZXlxR1FZQlZXZ2dZaXVHa2paMm9laGI3NjRyUVdhNEEvSDBGSEMzNzhWQXAyZFZmRXJKU29rTVhoRVlGQmNmc3k4ck5PbkJRRjBYOElqQmtrVlBDWjVaWTFIZEVSOU16VGhXb2I4NjVNSDdNbUptTy9udUNNcU8xaHBhL09rL0R2SlNUK09iTHl5elppS21RSHI0UnFBOU5QR3NnMjBYNGc0VytNQjFCSHV0SnBpTnBFQlhqQUtZSWNBbStEeVhmRVpVcTVRbHIvOUlrV2NMd01pVXM4aEVMajBHckxUK3FpOEM2ZWFqNEFwUCtuMGxEYUJ1aDQvdGgrRkdmS0hNRFM2ZC9tbEZ1WURoUm56aEdYQzQrcEFNT0F3em14Z0dIMFFFdk5BNTRHUjJ3dmNpdndUQmJicW02blBrdk04RVRyOEhTa0o5bXM2bWFrZlQ2bFdqTUFHMTk0a1NhVVd4TUUzZDNzZUp2NjI5L24vOWIxZTliR0cxSVdsTlVuaGpjcVpFc3ZoWkNUVkp1TXBRTGQ5a3hwQnpCYnZiL0llQ3k4b1kybXYxTTdnbm5JUjVCWjNtckpKM1lzeEFxQzhaaTlUbE1aVFIzOGQ0SjZoWlVyNXBLT3pEMlgwaUl3cDB3OFFTZ1krMkVVNlhnT1NKTkh3QVlJNjRUYzArSVJuc2xyYy9TK2xjTkx3MVBwOUQ4YTRVMC96MWdjQUhzL0VYVkJ4WlNMcFRMWExodDJHbllNMFVzZXFLWHZLSVZYeGVJc3BWNGlMNit6ZXN0dTdFcVVKYndSdTZkZEhpT2R1REFHOVBLSHlIVlh0ZExaUkcxbW5COGI5R3RvSE82MnJvcDF3WU5RcXJjUXFlUkdYMDFybGozWmJzQUF6OUNieGgyOWNMQ0JVZTFCbzFCaCtJT3J6aFdxS1k5ODhjejV1NDU3S3VWbWtzaTJoMnd4Y2ROelhmSEpPMUNNS1p3R0F5Y0k5TGtzd3RqeEYyWXJ0U3JILzhDL0NkZzJ1WHR0TXMrY3BkdnZXL1RYdVRCZWlWbGlFbDJVbldYQXVTV29LRGllcmNYc09vRjZLSVZramNWWmI5TDBmY3cwUm1GVjF0RHRKQUwzUkQwT0NLUzVtdzI2R1N4K1VWY3BUdFZGdFZadzZEbld6NGNmZWY5WHJVUUNOUUtCL2ZzVE5tdXpVbEdWekx2bnY2c2ZqYTZncWlJV1ljSnBHMlFsakNHWGVnZCs3ZTBEdjA0Y0N2L3VxYnNpSnZIWEw4d0Q3M09MeFo1NkgzOEpxbGRzenhPK21zejlGUmRtaGFkdkRoSUhiblEyMmw2M0tuRDhqZldGbTJ2eFdqZDhrVDYzdTczWUhZdFdGMTRWbm9oOExUWFlXMUlHbHEwYStIdXZXcCtMNGJrUUt4SyswUU9kUmIzWWlsdUZrMk1JVUpuMFFYL09JQ3A2Tk1Bd2thSXFqVFFrS1p5NXB1VGNxWTVCTTdIS254U1ZKbW5VamhlVkIyQUJxUWxsZDAyVTludEFKWGRwdHBqRnd5TkhvcnZMeFppVmNPbDBMMEh4Y3owSWZPRzBJSXlhalNsY3RVN2FqYVZ5eDZGaUxSc0k0a1lnaVZ6MldQaExyU29VcXo3S0gybnNsTXBIQlZJeTlXbzgxckh5ZDNVam5jbWcrTHJqU3VYOHJVajh4LzQxbXBDOGRnSllYUG5hZ3RDWnVZTTFIVHA0ZHdyVkZjVGhpNGtuODI3cm5tYzUrRWVFTE13SkVGSGdrazM0Y3FwOUZNYnROQnpDeUlvZG9EbkpJMkxkMXFCVGxwREtiaUtaQnRyY2xqaWQ4bmJRcnZmc3VGN3VpdFkrb2luajM3ZlhGSnk1SDd6VGZoRk5zckRMVy8yL1VyM2hPMFk4aWovM293eXRHbUR0MlBKZnhaTmtObGtjeHRNeGIreUE5Z29BS3Fhd1VMS3hEZFJaS3N4LytWRDhkMjVRbXovVVZhN2Q2R01lYldVeEpLS05qaFpsSjN3TWpBMHBrSXhUYXlpNnc1K1VweVgyeGhPbkJPVHhSOTYwR1hndHlORVdnck0zOVkzL3NuN1IzVjVNVmIxdTdJQVgxMVVCK1Uxc0R0YUZqdVBmMU5LbVpJa2hKWVNmdjZzb2tuWnZqdWJldy9QVzNJa0ppZTBlV2ZmakhIUTZFeVdWK3FjYmRPYW40aVlrVVVseHM2ZFNGT2lKUTBxdTRBR0JuNkJIakR2VTJpRjkzV2REeWtUU0JQN2lVTWNYWXZ2UWVPcU81VVByODNycDZXeTBMV1RXSmFHTENHR0xvY21kRGxZcGxJNFhsNHZtd3dYQlNvaEZYbUxhUmpTS0k5SzNwQnNXNXlHcFVXemFHSWNhV3FMa3pIbDBHdDVqRXNvZTBxQUo4M2x6S3NuNWN3L1lENUYydUVramFWU1NKSGVnQmFrdFZ5Qjh1OURVU0h1OTRFK3M3MHArMjczSkM2MnVMWkNoRG1TdCtBaEVqQ25RVjlvSVVqejZ3enpXZjVxM05QQmVtbkMwMTNSMWhSellFcUlVSHlMN2pOQitXZGpyMnNpeElMbEoyTHlkS1Yzbks1TW1vcFVnVmwrOC9kTTAvaUw3dHU4OXZuclJvMUZVbjlJRkZTNXBLbmpzSDZCb2R2M1JtdGhNVVNoVFhFYkZpMVVrMGFnRTNJeWx5OU0wWkY0RW9IVzdscTNaNjhhbWxZOXBDcUdBZUo4YVZHUVNDRU1yRzg0RzFOaFJwN0NqcmlmRkQ5TXBDbG9wQWZMdCtJeHNNcC9QUStzVk40TUZYSXltVzVZcFY1S3VraEZuVVQrc21rZFNEUGtkVUFDZm9YTkV0OC93ODlnSWQxL2hueFErcEZwd2x2Mkt1eVJ4Y21BR215U0phZE5qM0wzMFZIOTFrWU03Y205L1RJYUk2MW9hMmhPbjBoSGFONURScmZ4VitFc3VxNFVpekdmZ3k5Qklvd3QzL2VDakJrbTYxRTZzcU5JVlNldjJGNGZqazhrNXhGUFpzdGkrQ1A0OXYzVS9oZTI3cmZnNUVZOGt0UjI5SXpwOWZuRVdISUw4ZEsvNk03K2VNaHZuNkloVkUzNlJUVkwrcGZVb2JzSTN3MGRCRlgvbm1Jb3NVYXFIYS9tOTdwRUd0RE4zRTk4OGpqei9HMmRxdi9peVJSQlA2bzArVk44STJ0TnBHOXhRaWdlT3N4LzBtenROZjlKeC9wb0pvblY5NDVjUDZlYmVPeCtRS1dHbU1IMUNTTDV0VkNZaUN2T1RPK24vYTJ5dXlxN09sRzkzUjB2ckxwTzlYWjNMc2dyekwvK1RBZzJTYTVsZW1nZC9STFRURU1BTFRhNEcvTDIwZFUxbDhaZlliQjJOMzYvNkFFL0JKbFArcUVZcHNrdmhjdkUzcEQwUDFxMEI2dHBWcnc4TVprL3pVS3dTUlI4SnFPMnBubUtBRnJhNmRkd1lTbGVVeWIrUFJvVEcra09OZGxBTi9yc3luRzVvZ0pPQllqOERwRjBrazVXRjlmaEIwcVlMSjBVdmhXVlA5aWpHOFNHTEEvem5hMlpINWVWdWI0Y1UyOXFWaGJDbHFzbm5acGVyZVhKZmVtK0hvUTZMUDBRQXRMRDg0N2w1aDdQaWNqMDl3ejA5YVdsb2RLaEdoRW1oMUJpU1NUd1B2U05Wb3l0VVI0a2dVTEd6bzFKdTNXN2k5SGEyQldKS3pVUjBUc3ppNHJ6VCsvWFRkeURuS01IdWZaVnp6NjY0S3FXYnltZFA0bFZRMEJEbjhKVStoUU9TYVZ3UE1XbnZDVEMxdnFSd2wzc1FOcWgreXpzZzNZMDBjMlk0UFhpUUhHY0NDMVhWanZwcFRhMTFxQjZCdzd2VkRGU3BOUkdxS3MxSkR2VUd0cThrOXFBQXpuQnFnb25IWmxhbTcxL1M5Sk83VU9MdGN1V0ppelRCRVhzT3FMamdlTkpoR3kzQlR0SW9MTENlVWpJeFladG03RkU1UFRQSlhMNlh4TTNZN0pKOHRQTFBrS2dsNUtGL0xBREFTdVdyWlBkNnM0VW5ycTBiZnVGWnExWE85cDFVczg1SEhyOFZHN09DY3FhL2I4YmZLL1hSSWxrTjFIcG9aOGVta1FyRmw2S0VnZEpFWHJZUlorc3RsS2FzRkFrWTIwV2ludzNLZFNZK2ExZUl3ekNNTlptRU9ZN2tZWjZzTmNESDYySXZTRG5EcFp6UjhCNFBaVFZRRWZhbjZXbCtDd2VROHBRTFhzWHlvNWhmbmFxSGpyV3dBWlQ4U2diS3JzVWliSk1vV0l2dzRaajJJRTlpMmVSRFhKNllmOGlNWkIwUlB5ajczckpQbHB4RTA0SkJMM3RDaXl3Yjk4QkFndTd0NFFsckowZHNkRHlrczBlUGRoRUs1NnNGdUl4bkxhaFFTRU5lQ2x0azFoTHhTSFZ1V2NtNjY1czJoMkpWZEhQWUx6MElGaWsrZlcyai9xTGMxMmpBd0owaDhPOFV1WnJFc1hDd3YySGMzVUJHU2Rpem1wNE1yOEFLNmpjbGk2YW9sUmVTY2M4MUo0VnBXMzF6bjNscDJJTHllNHJTcU9oWVYrUnYvb1ExeXRrV1lSM1BTdkNjMU9OSVhJRmZpaTh2b052M2hKdlNrRzk4RlJKa1Uxai9kcGpmaUM4UGlwSzg3cmlMdkE2WDZ3ZjJ3RVRLMGx4RzB0aXZmTlFzU2U4UGkyV2JLTkxXZnBpS3c2RU44ZEV5YXFqT05UeERzNjRKV1pjNjRXSjAreERHRm9NbDJXcU5zTkx4SUk3SWxpOG95TGV3QktjZkF1RDlrdGJjZXJzYkRGcGswek1NUXNuM1JhVFRsQnlqb2ZFcEpzWXFpQmJKam43Tm9ZUGNJWlNkTXlrMUNpdGdVZXhXMGNSM09LZVFiUHF1a3BRUDFjQS8wbDVRVklJMWV6cXNMVWh3ZW9lN01JQlJqMjRMZzlVQThGR2MvZlczc1BuZFFzZW9WRHYrVXVkTlYwZHp6d1AwY0UwOWtvMUlsdlo3RTBITjJkcW9aQzlVb25JZmZiTnhUOExubXB1WEkxWmtLKzc5Z0NkY2gyVzRhQWgxcVRUQ05KeG5LNFh5OGV0ZmlFZGZhR2dmdHdEM3lrL2dFb1lVamp0eDlIczNkdTJhcWs3NktybEVYRnVHbytnNU1LdEcvZFRWVTdLZXdTMjk5K0JHbGoxQTdlekE0ZE5uZFU5Ump1WExBeGZIcjRxY2szejJGN3BHOUkycGlVMVg2MlBueEtnaHJIU1VPSDg5cFM5QnpRSHRzZEg5WGNhTTJhZWpwZWFTd285WExpbmtKaDZRZGg5RDVITGJQeG9CT2JzQkhJQlBXSHZ3QVVrSlpNTFFvV2tRTzFZMHBOc21RNWJVSGQya0VGQmk4L0R3a3RrSWJyQlFudUluMFBpRVQ5UTNKb2dRc2VWbUhTS3cxSkxkd3B6Uk9qc2pubklvQVU2V3RBeUR0ZDNjS2Z3S2phY01Gd1RxR2NqVEZtSmVhbkFEZGVQZVhsVk5QQ0dRQnJtMGJLZi9XbEZYVGFHVnU3NFgvM2pNT2pZRGhraWFjWHkwcXF0NHM4bXRQUXdDM3NwQmd0YVFjV0NwejJkclZ1MHlpb1dqbXpGa091R0Y3NjhqT3VIMEpvSFREWE4zUEd2c1JRVkk5Yzd0UlZMcTl6d1UrbWFBTWpZOEZBY051SzFvZjIyTVNLVjd0b0xOYlRqNjFqQ2JNWDFtVzRZUGtFcndVWHFpeUNEclRFRUNyUUk5aHpFTlN5TWxsUGphSWZIc1lEcEFQYTlSTWIrVTA2MElPNlVxZ1Y3Z3hJNUdFZmQzN09vRTZ1SjdsV2FsUmFIVzZCZGxMQ0dFbTVCcS8vMFkrdGo3SzlqQ1VtQjF6SDVKZ1VLVDJrdjFyQnRhQXoyc2lUYzBGYzJMRzBWNi8vWmczLzl6VW85eUZPQitKTllaSmNqUHQ4b3ducmEweHRRWnNvalpwVHZiV2xGMnpqOGpSWnFFOFROb3BURDNvQTgxSm4xSURNUjhidUtlZERIdlJqK1VFcDRGUmR0WGZoQnRVdCt2b1hZZmtpVmRjdHYvTkhXR3RLWFRDZHFzcFVNZytiRUFybzh2SkplY0Vxbjhsdm1KR3VQRjZFdTdKb1lOQ1oreWpEQ2FZaVovV05RZ1NjMGVRdjR3L05KUFRmcDNyT3FYYklabUlja055eVZmMUJDSldYQlUvWmoyVFNpSkM1RTA1Wm9kQTRzMldBdndEc1crc0FzRUdBL0RDS29qb2c2VXNJdXNrZWdOaTZDRm5RUm5LTWp2UFZTc0dWZlM4T0FNU1RUTlFrMTBxNGVoaUdvUFdYMlBjck9ocFQ3alNqY3o1SkhocDN0cFoySUpORWlTeU1PTEZlaWVJN0pIMHUyeFJqQ3ZnbGdXeDlSOXl2aUJPWjlpVXIvYzB5MEF1YlVLV0ZsL1VtQnpDUHJFUFQ4TmIydWZqcjBsTnQ5MU1QQU9oZ2NyZmk1QUU0SUpBbjhFQm44YTBLL2Vub1N4b0lpYUdWQzRGaW5sUHEvRnNqZytnbjlmdEVpRm54SkVxS1AzNjVpc2FnVWs3TVdZQVZZT21FNGR1TzY0WVIwSEN6Qml2TG9KQzJXR3BmUzNoSXIrcXdjdnpGVk9rNzdpZ2xHY05hQ05rOHRGdXVUYldpY1lNSVpqa3ZIcDB5VmFEMWlTZVRtaDJreHZMWWhGSmwwZ3BaUjFMVE1DamhFYUd2NENvM2VZRWlxVTlUNzF5cWwxbEtsQUdQWW10TDVBL3FQZGhtaUkvOEdXNWFFa1VrUVJpWWlzSlhNTFlDaittNGUvbWozakhBNk1wWGxvWURhR0ZZVlkra3paVkE2L0UxNUIwOE5xK3FrQ2tOUHlqOVlZaXJPcDZYWVJsb2xOU2EyRmhBR0Uwa1lURUxFMXVCbHFLRDlPRlNKcFZlVVFhOUtzV0dWb1RIWVdoQktFaWhwbWF5WEpOZUJTdnlNVmprRGtrRGJOWlpXOVROVVNGNHlPaGtWLzBLVXp0Y3BpK3BaUVZwbGNDQzJySWtHaEZFcTBucERCY3ZYS3piVHdaNmdVNXgxQnRNcFhsUDNhODBKL0RQR3dBcS9lL05yVGIvNk5SUWpENDV4TCtCQ0hmVk9Wano0QUk4L0tTR2ozbG9Bcm00RUdiSmJseE0wS1hPQWhqUW55SjYwSVQyQkd3ZzhqSGtQTFNFQ2lzbmtFdEpneHNpbEFUTjBoNGVpakV0WE54L1czQ0FIaER1M1ExMXlkWXNUNGhNV2F5ZXU5aUtOaUxWbTBMQ0xmejZsT2pxRmp0ZUw0RUlQZ0ppOVVMejRCSGVwZ2ZLTkRYVnEyL1RMK1ZPOUdkejlaV2JCMTlMekNabXZGU2NvRjE4Yk1BczVrRUlPUURLU0ZLOE5xM3F6a0VuMmsweVNqdmh6c0w1S2Nlb0c3dkFRU3hheUk4MjBYeTNRZTFhYVZ0OENVYTBsaktGMFVsOHE2dWZWcHdvdnFRNldMUGsxbjZna2pPNWltR3JJUkc5WTJGK2ZpbmlvQXI0U1JsY3JDdXVrVTNYS1FpZ1FPcGNQLzFwYWRQVCtEZTIwMDdmbVZHcStsai84OEdGWWVidHgwMzFHVE5VOW1EYnA2RmhOdTJIRE91dGd4Q3ZoVXA2blU0SE8yY1BieDFrenpmZll4WXRIamwvVEFTR2pCV2VmNDVmY2RlY0w4bzVmMGx3NzRqVjd0cS8zTkIxUGhwTjV6K3Vqbml2ZXZGTytXU0RNQ2d4eDF3YjJMbUEvWGJ2MVNTZlZXbHcrbEhsYW0vM2NoKzB3ZVhKSEhROERpN0MwWFJvNkZjOG1IYWVKUEtnZjZyKzh4Wi9yTUh3V1lEbmJtMWdpMHNYeEhUdXNQZnJBbG45QmtMa08xNTRTU3hiS29SUVdnMmZJdXVkMXhiOTF6NjBlZlcySllkdE80ZEFSdkhlOFVIZm5kbzJzY3RaVjRHeG9oM2hKR3lrK28zTlM3L3pMbWFXcHhNZFMwUlBGczFycFZLMnlQdCtHWnRPZlJXMTlRMEU2WlNpaTdvZzgvS3NNZzRFNnJ4ajZVUXRtZmFXY2svaTRYcVJLVnh1YU1sQy9GcFJBK2dxUVoxaUlETGRZL2tHa0NEbGdMcEJXc0JwYXdScG9TZGFnRHVRZkFWemdIK0lDVUNjU0Z3TGdRdjVCUFB4YVZDVlZWU3N1MUVybGRjcjZ3L0NQY0ZnOGpMWDliRWdmMG9RSXBCZjlOUUVCK3RDZkRIdlJuNXpmUjB2YlVwOTBhZ08rSURmQ2gwV2E4ODVrL3o5UkNXdHJJYUZHV2IvekRKNkVKK091b3JhL3piUTRwM0FYTGZFQVR3UXJMYUJsOU4ra0FlbXFOdHkzZ2E1L1FRTm9tYUlsS3kza1V3a28vSFQ4cGF0cXFDSm5CVmhrQWQxSmQzZlBtYUdUVnpRbnk1NEkwQTI2SWJMSWdwNkZPK2h4MHBLSGM1djA5WXVqRmZVLzYzc0trMjhZSHZ4U0VEMGtUcDRHK2JMM0M1eWlIbGNlMFlxM3F3VTRDNWZoTExsOC9UbzVCMWVBL2srNVRzNlF5K1FNWEo0eWxaWmNJZlFmOFhSQ0RaZGc3QjRSdGxYQUNqcWZ6OGs0UVZLTXNGanA0eHMwSjhIUzZUbFpaeUhYYWxBQ2E0cS8wbnBkSDRHeUVyclhLS1VPZEtvbTQzYWlqaHczSUtFVmhpVXh3bVNmOE5tVDFjc2d0WVFNdDlpNGU5ZXU1TzBQQzVzVkhEeDQ1S3o2MXB3ckRnN09NeWVzV0w5NHd6THRJM2JkdG9SZG05VDVhV2w1K2ZzandpTGlva0lXYWltcHYwdGhkUW13bE5TWFNtaFB1N1Jwa2JCaHk0NE4yelc1K1l2Y0EwTWpQRHdDTW8rdDBvMEpSVTQ3ejgxK29YbHh2YWowM3V4ajA1SjBYeXJSSFpJK0RnWmEyQTB5am0xR0NieWlpQzVVd0J5S3lMeTFBQk9IVnp3c0xoa1BNWDFZTXBLRUlwaTRRaUJLRnBTZ2sxdjhLSUZHTjYrWGdpVnQ5YllTN0dncmRYdGgzcTRyTGc4MWJ5OWRmMUR1Zkdab2FNaUs2RmhkMm5NRWRxWEVqWjFESmhkSG9EMTdVbmNjMUJ6TDBudDRoVVI1K1lZY3lGK3VrM3ZBeU1kVGJ0LzVRZkUxcmdPeEVqcTJ4RkpIR0NMc2pGNndaWUdHS1B2MUl6YkVvc0xwVVYzeHBZcnFXV2NHK2ZqRWhpL1UzZDl4N2tpeEpqVjF6ZklVSFJsTlJnZ244dy9rNWVWRmVYajRSL243K3gwNEtiTks2bG9LbUQ2Szl5bk9NVEJLSUJmR2dqT2JTSEM3V0RKSFc4dnVnNmxmNi9MVExZMGRLZjV5OCszdHY4dXQ2Wkp0K1hMd0UyQ2ZESDRKcld0VXY5eGFpbkFzbjlvZTkyZGxwdTQvY2lRMUppdzRLc1pQUjNxWnUwYW1aR2VscHhZVXBPdUQ2Y1VicnJyeDVtOHZuYjExSkR6UGJZOU85U3YxU0hMSzRWejE3ZWtGZ3daTmQ1dTRJQ1hnU0p4VzlhOVV0MFgwU2dIMXBFdnozaG9udE9UbWJXaFM4ZzlsUWNzbklOWkJDOHJWbm1TSXNDUWxsNTZlQkdYTlk5Q0N4WkJMUS91Tm56VjRZTkhjeDBlUDdzdllxeHUrWW5iZ2VJMWV2MmxidEE1R3dsREJZMEdrcjI5QTJzbVRoOU9PSE1tTjlORFNseGlNcmxOQzJDSTZzYVkzbDRPMHFzNVFZVmhQYkZsZStqT3VUaXFyVThDSXA5TGRwMHFJaExZQ2pBWWZSTnF3WUEvV29JSmVsODdIUnhSb2p6NUMyVE1uN2gycklhN0VnZjdjRW5Ta0tWdGZueUJBQzViUUpuUUtmQkJvV1dKUHJJbUs5SEthc3p2ZFRlc3pGQVZkdWIyd1ZBT3U0QUQ5d0gyOWpwZTg0bXFraDNXS0MwK2xlOVI4ZDUxdUdmSlhRUy9TbURReDdqSFdrOFgvRjJFM0kyRjM0Z1lVZ2h1NFU0d1U2c0RHMkFIRVEzUFpPNmFOK0wrY1l2cmpRYUlrek1HdkZmVjYyZU9FTkZ3a3RQby9COXZCZyszelZIekh2aFBKWmRxZ0o2WUtnNkdRZFFjWDNSS0xwTzZ5Y0FqWERtSG9iN1NMOFozZ1NJbjQ5bzRJRHRKTTJRYVlWWUpMYm1HWUlsdkFwc0sxYkxFSWlGRWl6YUlTcVU2V1NMT29STnBBRmcvaEdwVklWZlV0WklrMDY3Ull0RTJFa2RKeFdTSTlkRXlFTzFRaVhYa0g1OThTODBHUXFhYktJcW1OTEpFbWxvaVhLY1hHMEo5U1hGV0NNeWpCRGpDRUVreWxNcWszcGJZeUN5ZmZGcFBCbkJKY2VVaE12b25oRlh5VGlhYktNcW1rb0RSWFpvcXdrMUpiZFJSbmRSUU5JL2toWWlKY3ZndVJkNkduN0x6elJBbTlhdkdPeThnMytXVFlCYzFmVDE1RGd4clh1L2FldnZFUmticVRNQnNOWTFzYU5pSHdnWHpoWW03Z05QdXBjNTNtQmgyOVZIZitVcEdPZHpxT0h5dWxGdElaNGNKU3o1dmRORzE3TzVDR1BXNk4rVlIxNGR5bEROMkVUQlFjSHhZMFYrUGtsMy8xMVpYQ0srZlNBeGRzMGZGNjA4bHN1UXUzSGlzRDhBV3lVZ2dYWDBtT2FBanJScnhRZW54QTVyUmxJajhITGhXL3YxWmRyTGhSRG1NZks2RzF0Rk00dFRQdjJHWE41ZjArZ2JyVkNmVFVkT2swWWRPdXpla1oxQXZoZWplN2JnT0pxbjNaakdmbGw0K2ZUdGRPelVWaDhVRmg4elR6ZlBNdWJrcmNzSDZUN0pNc0g4RTZXUExYUFFYY2xxcUYzU1ZvTUx2akVqcStMWFhYSVUzeTlqWHJOdWwyM2FFWEpNUnVDOVhNblJwckg2T0xINHVteW5jT1hHZW5rb09vZ3IwR0J4RWZBZjFMM3QrQitTVXJvNjB2bElVOFZyMkN6OUoyWVpEN3ZLa3p3NCtlZTNqNjlMWExHWjQrMU8yS25DZGh3b1N6RXo0RGYvSDV5MzNhWXJoRng3bmNqZnBjWlMvMFRYSFd0QnZoMEhyQXhZblBUK1hzVDltdFd4V0dSaTd5ODU1STNhMm14aHc5cnVQRG9WWVBSNHpjZ3JvcUpSamdsbEFJZm1qRHRnMDdkcXR2ZTU0YzU3MWdhV2lFOWhTZHJTRVA4R1AyRkRpamdtM1pCZWMweC9kSCthMUlYTEZ1aGM2TnVDQ2VCQjRVMzM5UndJQ3ZTaGhRdjFXSTJCOTk4T0NoOUp5TTJKU1FrTkNJQU8weWc0dndFUDVFUTlsaDVFOWEzNE1PVXVvZExiZVovVlg1SFE0SnE0S1h4SWNsV01ZdFRscW5XVHdGSld6WXZ5eEhjK1hFNFp1N2RIV1NtamJjQ1p5TU4vT1FqRGNtSmRTSWw1OTRVSVFwdFArRnRiaU83UWp6d0JGMGlDaFkwb00wSzRiTGFPZ0QvSWhOL1hMbkVpVzZnazZRdElsV2JsT0xnWkUyeVlQaVlVaTFLR1ZVcU83RDkxcGNBRzdvOUxhRCtRV2FZL3VpZ2xZbXJLUURkQ1hlNkRGN0JnS1J5UkhtdHR1SkdkNnVLK2I3YW5QakExUGROWjRCY1VFUk90VlJXcm8vU1Qwc2hkSTdUZEdvN3AvZWxwNS9Sbk5pVDJUZ3FnU0t5b2lJRDY4VzRYMGxOWGxiMUdJanIzZHUyR3JrOVVRdjd5WCs0Vm9qbnRSTkZJK0ozeFRQYjQ2blVJNG4vSmZqTThRMTRLeUhQKzVDeE4zbDFPNk9ucWpld2tucGhYQWhKM0M2L2ZTNXMrY0VIcVpuMEM5ZTFRMUtGVlFWbTVJVDkyOVVEMlBYSlVTc1hLQzFOL1JBajlqak1CYjU3eXVJUEt2NTZ4RjlPbldxdDdYdUpmWWVYZ3VESTdUOGFobTdkUWxFbGxMc3R4OVRuNjlCOUZOOUtMdkNFNm5lcHNYN1owN1QyQTYxSStZT0Y4YThTTkFkeVVvK2NFRG5SL3BTVHNrdVh3NlN2WEFwM2QrNXYrdVVLVTRoUnk2VUhDdS9yK09KcS95RTdIdTBpU3FrVStHeWRFL1lXNDNXcjFwSmxiNys4NWE1aGVwVWx6ZnQzSkM1UXoxVVptSSs5RUlWZXdzT1hkQnMyNWF3YnB1Tzd3aVhic0xLbTliRkpaRVA3ejFTdlMyV2Vnb3UyU08vdkRwNjY4eUppUHk1QjdRdUtVaFZzV2pMOGgxNzFRZjI3ODgrdlM4Z1FsdTZCeDFaRzFwc3B4azBaOVpVandNaEJkRzZRajFLWGJadFNaeGF2MGp2cjFXOWRZdklPVVo3TnhodUZJUHYzUi9SaW44cWxSQkdoYzE3N082N2FBeDc0QWNhelM1MVJ2NHI5SHBQelZJMmZneTZ6ZnFRd2Nqa2d6UW5ML2p5L2wwYk4yelc3cnFORXFobjNqSk4rSkp0S1VucjVVc1krQWx3cFFUeW94VkZGVXJZQWwrRUJHci9sQStDcjZZSHdjc1BpRmRnRzEzYjdtUU9jbDBlNGpsUDR4R1hjWGpiZXRrUjZxVDgxQmxMMXNZbkxGbXNIbmZjNWNIaEkzdXlVN1Y4dTRPaVF1cEs1Nk12UzBTeTNnL1dvMEhzVGZwZ2xiUDhaMW9HeDJnWmFVeFc2bUVsR3M3bTBaSktGZ1JZZjVpc3A5c01qS1JQNGdDV05DQ3JnbVQvNXVGeWt4V1NvM0NUV0tCYXRoc01BbnNZaU96WTlrUTVEWlIxNGt2aVFQcVJZZWdkeXp2UWRTRUZSaXVnSll3UTROWkIzSXNsS3VJK0E5d3B4bXFTVC80ZzB4QS9CRzZYZ21lcEFsN1U0dDJsaUl4aklReTg2STVJOXJOMDA0T0JMQWtobmpURzh4ZHdnZFJSZUZrcTJnNSt2Z0tET2YxSFR6cWJ6aklwbjNSWklSTHpGV0liRm9ZTUZzQzhsS1pZdm04MGNIcXBvckptdi9XdTU0a3ZZZFFiZmEzcUozUnNJenhpVXo0aFVEMS8vcm5NN2FMaktYcU9xUkFXSUZYOXJjanQwOExVdFh2Uk5kK243UTlxMDhBTURXT2oyaVBTTUtIbmdOYnFnYWZuM2ZPbHg1am1FMTgwTVNYMDJuWDFSdmtZVSsvNDM4ZVkrcDNwQ2lpTUhtTktsb0tGUzRVbmIyM1NlcERwOUJpVHh3Rjkxa2sxakNMWGhZU1puajRUVmgySENjMU9SYVFGKzZ2NU5mZkFwZ3dheTZIMW1RZUFIa3dyQjJXNWlzQmFLVXR3OFEveVBTOXFuYUd4Y0I3Zm0wWEZPUGhHekFSRFBIa1MzVm1LaDBlb0M3bGpyS1ZWL1RvdjZzbzNDbkt0ODFqTFB4RmhRYTBTemllSlpFSTZkRTBIWlpvQ090NFIzS2hCWWZ2T0RSczNhWmRNbXpaN3dwSWxFNXVCc09VanNNQ3BiM25selhYeTlIYlc4cXZTQWRINjNxdUVjeWVQWFR3ZWZOaGxqcWZISE8vc2dOTTZuaDVwU0hpaG9FMGVmRkwrQmVGQ2NSb1V3S0F2R2FPR0VJdDVaQTFwM3o2aS9MRVdyTWd5QVZ3L3dCcHdBNXZoWDBrckV0S2ZIQ0NqaVBwQkoyaWo0eCtMR1ZTZktUbTdZektGTlhyWjltYUR4Z3h5SGJCcThZUm0wSVh0Yi9nRDhhWnpPbytONTNSQ0ptRFRNWjFscG1NNjNtTnhOWTZIZG5SOVhjTi9iOEN0WG9ua2wzeEc1MnE0UUFKWXlKZlA2RlNLU2NZak9rbkR4Y2M0elhSQzU5cG8wWFJBNTdoVUpFaTZ2V0xLdTJhR1JKYXZGVGZmRTZGQVBwMlRaVHFkSTR6QzIvWFNXcnFPNXk1ZGhLbEg0aUxNRThjMGFIVkFWck1GcHY5endGclZESTdBcTBWWTlZeTBKbG1DWjFiRWtlMDc1QU02UzV5YzVrNWR0bVJxTTJpdzVkVVBNRk5mOWMxeG1lZmpOMS9MbjhLM1ZtUGpzWnhEKy9FcExBV3RvUjJTSmVxTHI1VXdtRG9HN24vOTkvclMyL2wzbXcvS2pmWU85Snk0cW5rSjNNcVBTMW13YlVIenVrT0xML3JlN2svOUF0K2d3V3hzWDBTYXIyelZrdGlwdTF3ZTlESmNPeHVjQldDTDc5emZvUjFIcmlQMy9XR25yaHE5QXY5NEpoWU13UGZGMjBhbndOc0Q4UTB4YXh3bWJoWDF1eXV0MTcrTytOUHIzWXVQWG04aTNxZytKZG5JL242TDFmYTNoME5EWVA0dUE2NHc2cXkzN085M1puZnA1UnIxUGVlVE00OXJlMUovdi8yeXY5L3RvdVBYcWI5ZmFhN1hESk8vMzU4bWY3OWQ2aGZVMzY4UllWb1BJNVp6VTF4KysvdU5tdStnSG4zZXBjaEwrM284eWpENis0Mlo2VGREOXZjTFBISDF0NzlmRUZ3VkRrZksvbjd6amY1K3ZXVi92OEFEc3IvZjJlTkhzNmkvMzMvYzhWclE3L2xRa3p2ZVNBZjRKcnZqVllrUVNCZi94VmpSNUx6elk0RllJYVpDd20rN092UWxJWUtIQ0xLNW5TOFRvZk5velBNclNuNlV3a3dhV0IrL0czMy8wdjNva3EvM1ZYOHZoVzdmaGR6TXpLeEQrMkxEam90YTFjK2x4RklhSkV3cW5IZm4zcTJyNVRmbm41MDRmTnJVa1Zxd00rUUplVG5KNldtNmlMMkg0bzVxU20rYlNuMEQ0eUwwdXZSRm9jbCtHb3B2K0pUSkl5Y1h6cit0ZzJxcFRqQkVrcXY2emxJa1hFR0R5TCtFNCtKL1NHbkpiaWxJb05Ua2hDbGJ4eTk1QVNyWm9xTjVvZmp5UVhsU1V0Qlh6NnJRdFNFaDZrR3lRZWM3UzFybGd6QU1CRTFtZHRMRzdiclZUOUhhbU5oMXNacnVBMDQrRDliQkNQWmtOU0t4YlBiR1E1c3p0TENWUFZtSlNBcjc1L2szQlRXYUd6bUxWKzdSbmFwQU95Szk5Zy9Ta0c2RTYwSlUwM1dEV1Y3V3hCWGV3RVZZYWc5THBvbXpZY1ZVekp2VVZOR0tYSk9lcW8rc3ArcnErSjRkS3V1cEhuMUJrTEVPbnhKdkxxU0I1QktEbjRzNVZjb2NXQytRRmhmSUgwV08ydHNGYVBxcmdJLy9xQ0h5SFhTR25zQnEzYTRnTW9jMDdrR0RJRFgvWElTaFZVcElrbVlLME1JWi9waFJwWjNvaHE3MlBOeXBwWnBFMnBLMnBDTnBvQzJZaVdBYTJIeUNtVURiRUJXY3IxWEFGVGkvREQvSE1LV0hRQjJQaVpLRkh2VXhDSlRzbmlmbElwbjZyMGFJZjQ2Lzl4Qmc2czlHaU15OEl0SWkwdU5YakZ3MWJnamlTYk1lajZIbU9WUSt0bjVmNTF5bmVuc0VTb1VMcDZKbXJqQzZSRWNRbHJvV3I0bGR0M0NSdXM4VjV6KzF1MWhLWmpFN016ejF6STcxOHZMTmdJYXlTL1RPRFR0M3FDK0hucHE5WFZ1MnZmQjg4dDBjYU4yc2ZNL1J3M2MxdjVzUXErR2VwRjBRUldtQmhpNmFIRDVOdzVPbWxIamxjNmg1YkEydDY1eHJWVitoVEdvcE9Mc2Z1R3c2SUpjT0xFVythZC82dmNucVo3TXVkdE11bG4yZmQ3R1hNL1h6bGlZc29jOWZPS0hrdjFJLzlLWEwxTE95UE00djBZNVk0VEk3Zmt3Z2FkMXM4RUxmNERHYTMwM0E2c0VKYUpkRFVWcWdSOGszTTY1VDhtTlQzNGl3UU5vWVEzMWZSV3Z3Z0k2K0lsRkJLZVhyZFNoZGhyZlEzTXZTSVIrOGQ0blI5M0wxZjN3dnQwbWJ4OHBPenVlTmR1L3ovN1Y3MC9UUEpUUnRzbnZQTHhBVk10SjBrVGZHS1NyWk1yczE3aldNZUFubjNpank2ZG1uUHZYK3duL1BwMDBFZ1RTRHNlQURLdWdKczNkUWpUNGJZNDhnbFcwZFpqK0NXR21JVGQ5WFlHdnkvUmtHbHZkSGRrOFZPMzhsL2VsZ3RLdHdodkhnd0h3cFN1akt0alZFb1hmc1M2a3ZXbXpoZnpEaytLbWplWVZhVldwZVdKYVhuMytrMjFJdEQ3UGozb0w2MWZXWE1QbTFJdVBib2MvZzlFbFpidzErd3I1WGlGeGtZM3VpcjZ4RDVEaW5nWnEyOCs5UXgzR3d5cjJ0eTJXcGwvWVVsOXpMeFJlUFhyaVQ0ejFMdmhOcHVlN1RUclJoZStLMjdlcjNqbVZFMGJLVEExRk16M0V0aU5EYTAxMWtER21uSnNyM1BhRUQySDc1RG44YzFQSlRIb3VoOGt1eHRUc212WTB2eFh4c2ZBOU9oNS82ZDhEQUNHcFNsOUtFTnMvNi9QWFg4MmQvL2RYN1daczJmZnEwMFo2M3FiNTFwNnJxOW9RQkF5Wk9jSFNjZEtkYUN6YTdoTzJGYUFlYnNuWEZra1h4eTJOMDRlNUNNcnR2TExyRWhqOUNtVnNPWk9hcHMvU1pIdHFSckFlWmpTNnlQRW1YL1R0R1J5dGdCVlVpM3NWanlXajBrR2Jma29yMWxkOFV0ZEJBV1NLZEZoS1NxQ3lydVgvdDByM1RnWHRDRm9Ub2ZjUDNSV2R0MlVyZmVycUErSURsd1JxNVNkNzNpanBNVzhCRTZhMlF2akFsZU5XS2RldFdhek8ySE42VHJVbGl0NTVBSzlrNS9ZTzcreHlPUEppZm1abXIrMytwVXY0L3FsRmt6UXR4bGtyL1ZwUlFCek5seVFKTUp0UnZvU25xa0tvc0NjTThTZG90d2hDak4yeW4rZ042d0hYWTVQNnFMUG50L01vVGRYMUtuUUorMXFjSWNpL09iS0d0bkdpcmU3THJiSHNhNlNMN3pzcVJNdGwvaGpTdlgvUDRTaDJtTzVWYi9ScmgwOVdTNHYwNlJ6WmlWVGc5Rk9LOEtQM0FCcVBjUDVDbE53cXVXcTJlZUg3MmE5a0pwbjZ2MFFtbXZraFlrQmFXLzlzSnhzODdJTUNibG9iV1I5ZUlNT2FuU3RpSjVidWxkTVJpcXJCVGxHK2MwdksyOWV1bzE2dWIxTmwwNjFqU2NLeHlvOTdMdHJSRDIzNmFDY1NNN1g5WExHZmhBSEJ5b3J1YzRNbGU2YVVlcHRHWlRhaW5XN0FsTzQ1TVEwOW8vbTR5VTEveFZSSGZUUWhMaWNuYXVrVytYQ3BncWQveUVNMXlMNVN3ZVZQaUpzM0ZSN2xQVHdYdUQvRU5pVnhBdi82U3BhaGs2Sko4SnBrbDdza1cvNU8wcEVtcmw3aUdLMDl1MEtBbXVVRkQ2Vm9US1ZhNG9ESmR6c2t5clpudXpDVEdsd2xsY3BoSGltYUt0b3BlaXJHS0tZbzFpbzJLUXNVTlJiR2lVdkhVakRQclJ5L21kRGNMTUFzejIyWldyM1JSWGxHK1V2NDA1OHdibTR2MG52RWg1dFBOMDh5L212OExqVWM3VUQ3Nm16Vm5HN0kyck1qYXNqM1lRZXhVZGlZN2h3MWlZOWxFZGl1N2owMWpUN0ZuMmF2c0hmWWUrNXg5WXlGWU5MZG9ZOUhMWXFERktJdXBGbjRXUVJaNmkyWDBPczQwZXBkSmdjVWxpNnNXZFJadkxUNWIva0h2TmVsbk9kNXlpcVdIcGE5bGlPVUd5NjJXeWZSS3pzT1dSeXp2V0paWlByYjhZdm5Ea2xneFZzakt5cXExVlhkNjYwbC9xMUZXWTYyY3JEeXRRcTFpck9LdFZscnRzRXExeXJHNllIWGI2cTdWQTNvOTV6T3JkMVlmcmI1YVNaakJ5SGc1Wnhmc2lDZmd1ZGdiaCtORmVDVmVoNVB3ZHB5TVUzRUdQb292NER2NENhN0ZML0ZiL0FuWGN3elhnQk00SGRlVzY4ejE0UHB5QTduaDNHaHVQRGVMYytmOHVCQk96eTNrVm5JYnVWMWNHcGZEbmVRdWNyZTRFdTQrVjg3VmNtKzRMNXpFL2JzQmFvQWJOR3JRcEVIekJtS05zcVhJZ1NOUTVTZHBRaHpwei9xM3ljVWFCSERVY29LZkdJNkhZYWthekxxTDNBVHgyV0JodWtqVXhJYVlrWEhFOXZNUTRMNVVYTG1UcDNVVWVVRjJacHVJZFJCQ1JBRWFEdjFDZEpQRUNGSEx0eEw3YjhFMW8wUk9HTHJBZThhS2daWndrSldGdkFuczV0MDdrak4yUE1sdGRqM2oyS25yNm10dUYvdjJtK3pjWGZ1WXZYd3cvWGplM3ZESWtOaG9MMnAvRUdEb0ZmRUptL3h3L2NiMTZtSzU5VGhXdHI3YnM4U0R1Q0VZRkMyMFpFRUxJdUtFZlpGZW0zMDBSRzFQRktSeHg3dHo3MWRVWEg1ejErWDA4TWdGcTJOaWRGZFRyMlNkMStTa3JWcTJUMGRhRTRWd0pDMXF3UnlmcUFWK29hbEhUK1lkcEJxdlMxamxROTBaRDFKdnhtYmNPbEYyektNZTN5VWRxTk1jOTVrbGplcWQwVjFzR1BETGVSb2VKN1dOd0p4MG85NjVQUjNmeU90em5qeTdjN3VpYlA3UnNmRmhhNWZIYVhNZUl1ako3aXI5RXc4bi9ZdDkwZlpkK3pidjB4dytHT3Z0NGhlendDUG0wR0VkMzB0OERCTGlSc2U3VFJ5dW1SQjE5SHp5aHVTTmUzUTM0UEJHUEpua29UVXg2MklXcXUydVR2eGNlQ1cxOExDVzI0WGZyS2IrMzZwYlhURHRrZlN6azhoSjZsamNSZ1IvSjB6OG9qRTk1R21IZWFIM2RlY0s0RzhBaGorZXpMOWxUMnljU0l1VzJySU5Ra0VLUFdkK2FZK3Y3K2lnMW9QblJ4NStKS2I0Qk96dzEweWZFelREVzNkNUhzck9QSnljcTBsSlhiVTBWWGMyREtsU28vTVBMOHZWWEwrWWZmbW9qaE1xODJhTUluK002ZEp0a0UvUms0OVh3ZUtIamlOOGp4cm84TnUvSGZqWERxUUR0MXg4Y0JFN2lKU0wvY1ZFVWNmOVRUZjRUYWN4K0VxdEJmRC83K1o5czdVSXo2NkxXdFg5bXlKa0N0L1lOY05kUjNVTWlXN1RET2gxUTFXbGdGSjA5dnZRNUdVZXpxTTF4SWV0eVQ5ZnRxbkdFZ2F3KzU2WGk2b2ZxdzZ2ek1sUjE1d3BLTG1aN1VFL2dlaTVSKzNiM1dqRGxnMjdkcWsvajdwSmxFVFZ0ek5wRUp3VXVqbEFPNVRsSlZZWTVYbjZmTm1sQ3kvdUhuTjFIajVsM21DZDZnZVpTRnlGSjhYbm50YWVtRDl0NkxpNWpvT2RqOS9XU3VZcHdoMi9heE5UcVh6eU52M3l2UnIxcXhIbHBCbFJ0UnhFR2swL01lUFVRcTNxaDIzVTFCRU82cTVsL2FFOXRBSkZKZnloNVdHRjRMckw4NEMvZHRqZ0cxUEtuNkRJdkpQeHB6VW5UK3hNemRXVkRiOXhZL1FEbEpHLys5UVo5ZGxGQmVINTJyTHl5VGVHRDBVcEM3eDNlR3JjUFJkSCtldUdWRTZlOG5nZ2l2U1A5M0JSMTlsVVhML3k4T0hWbVlNR1RwODVmUGpVSzVWYTNqOGpPbWZydHZYeWhZQ3VycDV6bGkrYjIreGIwdU5YYjlWbkF6TjlQQUtEdmJSY2xhUkFvOWs0WCsrd09ldVd6VzVXelU0bkc1SHhxbGhHdml1V2tTK0xaZXh4L1JYQlR1UmdNbWtJamNoRVY2emxmbCtLdVhTZUdENFhsN0djSFV5RUVlQXNuMEVjVEtaOElyTVFKN2lIWloyNGVPSllRY0hCVU04WkhyNnVPazRhS253c3YvanczcFc1US9wTW5kUm55Snh6NVZveXdLQVJmQXZLRnhacllCazBnbW13SGh3NlBTYU5pQTFwMUoxMEpRM2ZEZ1dtNnNMaDQ1azZZclBZcmhzUk5mT2NkMlM3NmZnVXdXR1J5ekkvVFVUc3hrM3h1bjRXcS9idlhYTlNVLzZ3NEZ1S3JsYnFocUJkSFJIWVBkV29hcytaWGZtYTdEMnIxMjNXMVZsc1doSzcyVlV6YkxoYjIyaGRKRUdJcVBxQmt1V1A2ZWNlN2E4aEhkc1NMZW5PUVFrMVlPN2FzRU56NVU2d284T0VHZjM2ZXR3cDJaYTRqUjd5N0x3VXJWdVd1R3k1dWwxRmUyZ0huZCtCRXJqdlE0b2R0bWdoR05xbEFVS0dzZktuSU54bnlTTFNIZkZ3UXdCSFdRZ2pqdXlpNGJMcUtvRFlSZUxEWUlkby9wNkhpQXhrOTFiTCtja1BFT0ZaOElkMDQxMnVzMGh5TjBoR3hJejltNlRMSmZ6aHpidDM3dGNrNzFpMVlxZHU1d3EwWkc4R3ZkTnVPZVpzSk44Tm1QekRwbHcrbDM5c0g5amVhL2IxWE1uOXY5VWZ4bFdSbHFSelQ4SVFsWGFseGZzVmFLdkY1MnMzbmxZZW51TTB5ZDF6a0krV05KeEtta3dhM1g0eGFkaWNOM3FERDUxYjlNem82czJCSytrSC9Za3JSMXhJSHlKSGJ1eksyWGRDSTE5am10UWJjN0xVQkJZd0I4RUZsanQ1SlBkMFh2Z2hMemMvWDNlTytNUFNEYUtpQ0xJRStWclE2VmpMc3pORnJuN2tiTXlaSG0zVmZkUFpaeWV5Qm5FQytZTWxGcVFkZXNweVFtNTRocStQZjRESGd2VHdJeWR6OGg3SkNwbldkZENIMnhtaW1USEhyL3N5SGFmSDBTSW5YUlIrczJQYmIzWndmamcrbWlNVHlFelNuaHpoRWw5S2dTOFZIRXZkMDdqUTFPak13d2N6OGpOaVVrUDl3OEw5dGR4NnNmMDJESHZMQmNMT3I2N2VsTGhsL1RaZGg0VW9ZV1hpcW5WcVl2YUlXTU5FYVAzaE15Z3JYVXU2bnRaMktrVGNrL2FZUzhkVVlyQ3dHU255UWxCNGNIeUFKakppeTY1SStld25WN3VzaHFvMmU5YlE4UXpzUkhxUllaeEVCRThSV3RsNGlqeXNsbDRKRjlMOTV2VnptVHpGT1N6L1lzblJSL2ZwUTNFaVNPVGVpVjFaVzBNVVpjUnpkZ2h3aUdES2gzYmpSeFhYaWMvdWl0Q0FoWlkwbHplK1RuV09JdnpEVGhjNStsaDZZT2htNDRFNUdBOHpvUjBjNFlRTDVJNHN4WFBvSTh2SkYyOFFiTGhJb3FTTGlGZ2xZT0NsQjdEVThBRHh3b0tNMENOSGp1V2U1T0pFMWJOTUREYUNvYnVqMUoyRk4rYUc3dEFPOWJXQW0yM0l6VFkwSW5XSHRvaW51L1BxMDVpN0tFamRxd3kwM2pCenFUdHBpNTVha0p0L3djMi9hTVRRbmJTam1BdFBIRDEzTENUYmJaNjMxM3lmUTRFRk9vNk50VWZjc2J5Y2s0Y2pNMzA4Ri9oN0JhYUgwVGZGWjVzZ3pFSFB1OExpU1lpanZwK3k2MkkxRk5PWXdWSStNQTFKTEtrbUpWU0x4ZWRpa3I0WkY1M0tlYitIb3ZNbEErbENPUUlERWNlMnp4QzUxTFVVejFyYU1lS08zbHVRTzlBVjZEK04waDU1eURlTXJKUmZ6bm9wS3BxcklndllaMkNKUUtnWXpwWi9ScDNaWVIwUU9jZnlNL0VubHJ1eHJIb094YVdIZHRFY1MxVm9IT3JLY2dQeWtXdVU5N3loR2tlbks4K2dSZlc5MmdkSDVzM2VxZU5LNExwOENIOFBQYms2NVNySExuUkFQRXQ5Q0RuWmNUR0RKWHJxdUVqUnlsY20zRnNsL2o0end4R1Y3T29OcHlGaEdjN2NGeHNSRkJFZEVyWndUeVlIWStQZTFEZU01cUt0MDBUdXF2RVdCODRkRXd1V21FTXNoTU1hOU1NZGN5NllucHVRVHpCeFNianYxSmtMblgyMEhId1dKTThLZ3lkTE1zd2x6eW9hNGRsMWliS1JaakxKUmR4eVBJcmxOb2pXWERLbS9YZ3RzMElZS1ZJNjhoa2JtcGlDZVNrUTBVRnZ2RmdzWHhFSkRXN2VMRlZ3N09lRG1MdWMrS2YwSzFvaGpiT1JyNDZwWkRuaWJyUjF1OU5mZjZDUUUramhPKzdlUXFlbnBLbUd0Q1dZL2daelJtM3RtTi9hMnRZc0J5cDBnVDJWR3J0Z3RtLzRMQjJYSlo0eDN0R1p6QldKKzJvUWFjSWVobzZJZzB0M0llcWU0aFpuOG8yamk2TFc5NHpJM2RSTEsybS9vRUdlc2RQUE9MQ3FCQ3NPUU9BQ1NFZEVyTmxZNmxqT2pTTE5TU2pwU0JCcHB1UDZqeGs5WVBSRnA3TEhqKy9VeVhkdURud0N2WjdBQUlwR0R4eGR4VzlGbVBhYUUrUjFpWWc1eS8zemRPbUxQUHBQalVwY2ppajc0WEpzQ0YzTjc5bEQ5Rm5nQkJpNkVwT2hySHhycXpTZ3lqQ0E1YXVnV1pXU2s4K2VLaW5PUzVSaGQySGRYUVZYQjdaR0pxNHFVWEQxemdKSEdKWVRIcDJrRjdDTW9oZXdjTlpKbjlkK2dibmZJdDdTYnRYNzBhb3NZYWdOVzA2MW9LbkVUZXU1dUpmUStTa2NlRzY4cFBQZ1UrajRURUdMNGF4OFFFL0JrV1pzSDBOYlZNNXkxTlZQV2tYYkVHZDZJTDQrNDdHeFZyczNVamU1QXhybzhnV2F3aUFPYmd0Y3RLS0VJdzFZVHI2RVllUlRlRU9iOUhoY0gvT0V0cDFDWnNsNkZNNTZXVjNNR3pCN3g0M3pPbnN0UWNmcmZ6b1l1V1ZiUnpua3ozSlZZRm5CSVhxNURZZmVzdHovRDB6UUgzb0FBQUFBQUFBQkFBQUFBWGdCdmIwTGtGM0ZlZS83N3htTkhrdVAwV05yTkEreGhaNXNBUko0ZUFscmhKQUFZVjQyQm93TlFpQVFTQUtFSkVDQU1BOEgyL2RlWFZkdUV1dW1jbUpiNVJpZlpHeGpqTWMyMkVpbnlqangyTEV3TlpXS1VqNXpUbG5HWi92QTJNa2tlSUNNZ1FIdDg2dC9kZlgycW9XbVJncngvT3RiM2IyNisxdGZkMy85OWRlOTE2cFJrSlRwVEYydmhndlhYWDZOcG0yN2VkZDJ6ZFU0U2FyVjFDQkI5VlJRbzhadDJubnZUclg3Mm43bmJmZHMxNGxjdVVybXh4VTBhTHcrUmlob0lwU3BDV1JxZ0JacGxhUlA2aS9WcnMvclMzcWZmZ2hXNkVmZ1hQMDllTDhPNm5tdDFNLzAzN1VxTklaR3JRN1BoR2QwdmlWcTB2UVQ3bGgxNHFVL3Y2eWlFTFpidm04M1BOSHdkR1BXOFAyR2YyaW9Odnk2TVdzc05XNXUvUFBHSDQ4N2Rkejk0NTV1R3QrMHMrbUxUZjgwL3ZrSmN5ZGNOV0hiaE05UGVIckN6Mlo4ZVhiL3hQNlp5eWM5UCtubms2clprNU83Wi85aTh0TXpsMDkrZFdwbDZubXovNjFsM1BTNTB5NmZkcyswUDI0OTB2cnl0TzlQZTZIMXlMU2ZOWTlyL292cGM2ZDNUcjk4K3ZYVC8zajY5NmYvZlBxcjA5K1lrYzJZUHFNOFk5R016aGszek82SGN6OEFNNTZjOGQwWlA1bFJuZkgyek9VQXpQNjNtVjB6Lytlc3lxeXJadjFaYVVIcDJkTFBacXYxOWRuaktmMkwyYitlelZOYlpyYTgwUEp5eSt0ekdueHRtRE54enN3NUo4NDViODZGYzdiUGVXck93M1ArN3psL051ZnpjLzZhK0xOemZqem5uK2I4ODV5M1c5dGJWN1JlMm5wcjYyZGE5N1UrMGZxVDFuOXMvWG5yeTYydkl6blVOcTV0U2RzMWJmZTMvWFhiUDdhcnZkeCtldnUxN2J2Yi82TDlCKzIvNkpqWTBkbHhROGY5SFovdTZPN283WGkrNHg4NmZ0Yng4NDVxeDYvblpuTlBuWHYyM0F2blhqWDMxcm1mT1lIZVIxY2FOVm5TVkUzVEpNMEVrMVZTaDZab25oWVNXNndsYWxORlM3bTNUTXQxZ2pxMW1ydzFXa3Y2WW5DYUxnR242M0pkd2NoL0NKeWhhOENadWc2Y3BmWGdiTjJvbTNXT051bFd0R0N6YmtkanRvTTF1a2Yzd3VsQmNLRWVBeGRwano2cmRmb2N1RkpmME9QNnNKN1N0OUc5L1RxZ0RmbzdjSk42MGF5TjZOWHp1a1V2Z00zNkgyQ0xYdFNBdHVvMzRHNzlLN2hId3lIbzNyQWdMTkFud3FLd1JIOFVLbUc1UGhVdURwZnBNK0dLc0ZGL0dtNE50K3EvaHMxaGkvNDYzQnZ1VlhmNFZQaTB2aEsrRUw2Z3I0Vy9DZDE2SW53OVBLa25RMC9vMFZQaGUyRy92a25mVGFyMWgrL1Yrb25OcVEyajhSbWFXNm9OcW9WVVIyMHdQRXM0VHJPNXR0UkdLRE9rRHNJUW5sV0pPZFJZNitmK0FQY0gxZTRhSXpxMzlneDhTclN2RE5jZU9INExLbWthWldjVHRxaUo4bFcxcThLc2JtTjJkV29sOFV2SnV3NGVmMEw0WjZRL1MvZ1V2ZGhEL0Z1VU1VL29CV1ZoTWJ3WVkvajZ5Y1JXVXZNNjB1dWh4NkVleWEzcHBmWUxsSm1pS2RRcFVjcHlRdWZXK3FoVjlUUFhVK0tIeUd2K3RUNjN1bzFXVitIZnJWWS9vMEt0dzVwYm95YnhsU3FubW8vRCtZbmFYajFaMjZkdjFCNUg2aTcxa1A4dDZOdmtQUTJQNzliK2k3NUgrQ3hrdWZ5a2ZuUjFQQnltd21rYU5OdDlNNkpXU3JRalFRZnArWlJjVFptMTNMdVpNdnRwL3hMb0ZFYm5DN1VxWTVveGdzTnFkbC9NVFRYNnFWRU9nVklOMEJLVnFURWNUcVgwTW1nNTlJaEtjR0NNUFQ3SW9ZbkVKa0ZUSWVTSnNqUzVoNUVGN2huY08vVmdiZGljRjBXdW56Q24vdkJGMG5BTCt5My9PRGhNVU9RSTl4TGMycUg1S21zQjZZWGtJNmZ1b2NjRFhCcHFCK0ZZQ1pYYW9PWGNETWN0NUcybmxUdWduZEI5MENNcSsyazlQSFUvZkNZamU5WGMwV0cxVzhZUzh5YXpuSXNvdFpTUXZySmNVeWs5akV4dDZFUldhTjA4MTY2a1dvKzRSYzNNOVhIa1RGVEZyWmxpUGhYNnFLcVpOZVRRTW85ZGl6WHlJQnpMY016Z1dOSThKSnlQSGkrZy9FTHVyU1p2YmUyQWJpTHZabHEvaFhBcnRCMnA3cUhNdllRUGN2OHhOT1UzUEYyeHJ4dTBKaXkwWkZlaS8zMWhTZTFBcUZqSzNuQXk5MC9oM2pMS0xlZmVMVG9uM0FyZEJtMkd0c0JuSitHOWxOc0YzYWRsNFg2dEN3OXdiN2U2M01wUEVINkJaMzJSOEZuSzdCZmNaZTJFMEFiMzhHeW9KZmIwZkdWYTRER3NhZ3RsUGxlTGt0WU9oL21FUzZGSGxNRzFMNkNoak5Vd3ZUWmJaZmVUZFZ5bDFFOHJvZXVnOVNwN0Jucyt1dmNyR28vZVZPT01IYXpQSCs1TnRyV3lmWUxhaWNkNUhlZDBxVDZuU1krUGRxS1RwNVNTbFhwQmpDejErczNkVmtSTnpPcVJXS0xpdXVkYm4rTk10WVl0b01SQ1c1SUIxMFNYdGFZR2YrN2ZUTGlKY0J2M2QwSG9MYU02cEllSVB3dzlacnN4Rk52U3BGY28vMXZ1RFVHdkVuK044cTlELzA1NkdMNi9JLzRHOUNieHQycTlHcUdWYnhOL0J6cEN2RVlMRzlEd1cranpUY3lOV3dsdmc3WkFXNkhib1R2SXY1TndHM1FYdEIzYUFlMkVkakUrOXhFK1FMZ2JlcEN5SDRlUU40MWRseVp4bmFLU3BrTDBnbVlpQ2JNRjNXNldaelAzMXloRHY3dnBoVUhHNEpDczU4UTNRZWk1YmlkL04vUWc2WWNJSDJQK1BFN2RwOGo3SmozU28yYXZHTDNRQUdWZVVlYWVlWlh3TmVoMTZOOVZvbGYyMGl2NzlBYmhtOUJidFIwYUlmMDJsdllkZUI0aHJOWDJNVzlLZ1dlNzVUdUpZeGZDdllUM1FmY3p0ZzhRN29ZZTVQN0hDWHRxdzdSNHhMWmlIRkpWa0txS1ZFMldLaUJYSjVqQzJFNVZtVjRZb2hjTzZFVGJqV1gwQkNzYXJWbkovYldNeTNWcWR1dDN1NlY5Ym1tUGRhOUp2ZVM5UlB4bDZCWG90OUFROUNyMEd2UzZTckdsRzJOTDk5RFNYWHFMOUFqeHQ2RjN1SCtFc0ZiYncvZ1AwZExoMU5KZHFaV2xlaXZKNjZiY0U3R0Y1OUdTcU5XeTlYTkxzRk54SHZWck5hMWpKV0VjTTIyQ3RrSkpvNGsvUlBpWTUydWIrK1lWMHIrRmhxQlhvZGZnWVUyR2hpRnJNalBtVGNLMzRETkMrRGIwRGoxMmhMQ0c5V2hBbTIraEpkWmt3dHVnemRBV05ESnBzOGQwdUtqTjNMdWJFRHZxMWVJQkNIdUtOdmRibS9GSXJNMk5qRzBXMSttTWtmZ3l1dHpOODU4ay9BWjYreFJ0c2U4QmZSdDVuNlkvdmdjOUMzMmZNbjlMMlovZ0VmeVV2Q3MwaFZKVDZZRnB0R2dtMm5paWJVU1g5UUZyVkxmNmhGajlPQnZLbmcyN0NPK0Rka1BNT3oxRXZjY28rem1WWlAyenppeU0vc1NnWjhaTHhGK0dCc2g3Ulozb1RxWWgwcTlTL2pWQ3p4S1Y0eXpwcHNmMzZVM0N0MGlQRUw0TnZRTWQ0WDZ0MXMwczZXVFZLSVZib2R1Z3pTcUhMWVJib2R1aE82QTdvVzNRWGRCMmFBZTBFN29idWdlNk4rbGNaN2dmZWdCaWRVa3o2eUdvVzVsbjJINlYxQlJiTnhSYjEwYnJxcnBBazdoT1FYYjNwVmZRWWZwejBKN0hBbXJaNWxMR05wZjh0ZEJGYXNMaTlFZHIwMmRMczQxeTdrL2lEeE5IUy9VNGFaNGEvZElTVHp5c2w0aS9uTE0yL2RIbUR0cm1XbE1oYXlyMzNpRThRbjROamNLNlJKczdtR3p1NXJ6ZGpacGFmVGU3YTAyOUI5b0YxZWRwR1kwZER0MzJuYnkrcVV5TGUrVTFzdGFYMWtnMHdaNzQrTmdmL1Y2eG9zL3JWUXRyemQwV2FBNGozVXJZenQwT3dybGVLdzlFbmxYQjA3d2E3ZDA4SmRubU5kZ3U5MENUc1FROTlHblY2NWZ6b1JlSi94SnVWY0pmMWVnUExPNSswb3RrdTZJc3JoSHJaSS9QbnVsenpJU3FSOHIyaFBCMmFMY3FhSDBWclM5cnY5dFdTbHIrU3M0eVpocUc1Kzk0eWh2UW0vVEhXN1J0aEh0dlErK1FQb0trTmZ3alZrVDM2cE8yempOVnNRNWgzWkpWdTQ0MnJvZHU1c2xJWTUzQlRvcitqenBUUXFMTUZzQlNxVG5wQzdxU1g1dXRKLzFJTWhqMVpERHBTWlNFSjExS3JUL043WEU2TlQ1NXJ1Y2kwMHBDZTBJZURhOG1FQ01yajZiM0pTMFEvajRqU2oxYXpZNG1qbWd2cGRFUW52Y3M4U21hRFRmN3Bjbm55cUxQeGRPb0VaK1VmS1VKUEdNb2VWU3R4TnNoODRlYXZJZURUL1NZbTZ3endaN2N1Q2k5L1RoYnFlQnJvM1VZRDg0YUdiaGlmWkhlZXpIWGo1TEZlWjEyWlZEZGcrdDN2UmtxcGRiM3FaV3dIZXFBNWtKUm4rbmpObXh5bDY0bVRQT0ZudnVCcEY2NHhIMnA5WnMrRGQyVy9ueXVHMGw5alpud2RXcU10MVUvSDlxb0NtVXE1RlRJcVRpbmxNcFRPOVdaRXZlNHBkVGZIY1JUWHhPbXZ2YmNMWHNkS2lXdjU2UzBGck92MER4eTdGblkyNHlqQzYyRzF0cmFlVDNXWThUUlV2dXNhR215QXNtS1FXOUM5aHk1OXphVXMySzFYbHV3TFl6SDdkQWQwRFpvSnpLeUpzWTFjMUN6OElGSDdQT3doNHY3dHdIN3ZOaGczVWlKbTZGdGtPZVAxNm9tRFZCK21GRmdudkFrKzVQbXh1NEJ3bXZPV3hQa3NqVng2WDVLVnRVTWw3SXk5eS9lSnVGcWRYcGtyaUNQMFlsOTJPWTE4a1hpVlpXOHB1MG52U2pWbnVyYVhXSWY1UlU1anFEdUpMMk5jQ2Zody9FRXdSeTlMcFhnV05Zdm9TcjBLOXNrdUVPbm93OW5RK2RBSzZDVlVCZTBDam9QV2cyZEQ2MkIxa0lYeEgzVjRseDc4Q1BqN3JDVWw0cjROdHEzay9CaHdxY0lleUJMQkZraWxTeVIvVWhMVlVHcWNqZ2JPZ2RhQWEyRXVxQlYwSG5RYXVoOGFBMjBGcm9BMnUrWlA5WCtYcDllaEd6VkNXM1ZQVm9sejdaK3p6UnJJbmZYUS9rNVdsWHdydkJNVFNIUEt3QXAyMTNLWVBudEU2OVhabDNaUlhnZmhNM1ZReW9uVFlaZjNjNG0zN2hjOUkwcG4xWUM2QzBvYVRoVTEvRGh2SCtqVXNHLzJabnpZN0w2N29EK3dZZFFzTWZZd0xYSjlpUFFWNFBKaSttdit4VEVHNk9YVWJKR0x0YzRTazdpL21UQ0tlbkVwMCtlNWZTSi9SdlBxU0dkUnhyTzhyd2kvOFphdjMyYVRhVHhKK0xwUUkvWWI0dlpvWmNJWDRZRzdMZnMwdStnTnlEdkZhQVI2TzNhSFhxSDhBaFVxKzBLN2c5NzJOWGtZVytGbm1SKzl2aE1jTkF6Yjd4bWE1M3RXU3ZVbnV6Wnd0UkNuM09sVktmOTVZQUZsaHJpMnBMSnExaEtUU0RWbTZ5OGQ4RFFDenpkMm1NOXk4SkhhMHZEeDJycnczVzFNOEwxdFd2RCt0cjRjQVB4RGR5L3NYWmJ1S20yUEd5c0xUZnZBM0RxOWQ2cUlhYjZIZXNSOXgzclRyRjlLZFpMckMvRnF1YmtHa25tN3BUaVhBNmVQZ2xNNng3N3cvcnE2aHptRUhjcTdxOTBodWYrV2tiNUxuTHJ2Vm1PcHg5bGNqdWRPeTZlVVZiVFdqbWVFbkUxUWRKMjZzYlRFdnVGM1pwTlcxc2duMUxXK3VMWlppOHp0SmY2QitBWVQwY1N4N2p1bWdzakVmMEp6bnNoY3FJLzBVZFplcENZdlVoaWJxZjd0eFRQV1R6aWFZZlVrRHpHNEhrd1VmL0tPRjNCbUg2SW5lYVYwTldNNlRXRUg0R3VaUldaVElrektERVVQbGlqRkhRbDhROURWeEcvR3JvRytnaDBiVzNZL0M0MnZ3OUdmaCtHY3Z6aUU2dVVHSURmQUtVT1Urb3cvQWJnTjBUcElVb1BVWG9vUGIyZjBsVktEMUo2SUh3WUtwWWV5UEVlcFBSUU1HL2lWMEZYVzVMaHhIc0NwVmRZVnJlc0xpK2xSeGlUZnozeUtybUR6b1dISnBtNzc4REJQUUc1dkh2QjdVczlPdUJTZWE3dUJVMElINlg4ZGFTdWh6YlEzemNTM2dSdEpEY2pkNGdaUlFub2V1THJvUnVJYjRCdWhHNkNOdExYNWtOSjg2SFVTSUZQbGR3QitBeFE0akFsRHNObkFENURsQnlpNUJBbGgxeXluNUpWU2c1U2NpQ3NoNG9sQnhMUFFVb09CZk1rZmdPMHdVOGZUanpIV3phM29pNGZKVWZVU002Z2M2aXJpVEUxRk54YXlPWGNVcmZEclJ4d2lUd250MVFCYmUvak90dFg5azcyY2M5UnNGWGt5ajU2SW5PaGp4SzlsRDBjNStDaCt2NktleE81VzVYOWVnaS9QdmZyQnQ2YUdwSnZqNzBoWFU5NW50bFh0SjJ4Yjl3dmVwSTd6ZWhNSXluUGJzam5udEJLNTFiVXEwNTd5OHMwbmxJVGlmbkVHbWw5WXExTzVCcEl2NFI0L1NGY1FObUZYbnU2dFlheWE5WGxzd3IydGRvQ2JlUCtkcC9YOTNwZi9URHB4MVNPNjlDZ1hpSnZnUEEzOUxMaVhuQSs0UUtWd2tMdUxXSkVGa01WN2kxbHZFOGhQQlZhUnB5OWJ2UUxlMnoxeXJIbjBqbTY5d2tON1QraEw5Ung2d2tuNjNKYXB4cDdMYWkvTmxRN1hEdEl6R2xqbUJoeEFQU2Y5a2Q3ajdYR003V043SUd6MnBCVFZjdGNyZEZ6S3Z0T3Z5VS9SR3dJaktpa2pQUXc0RXE2cVRZQ2gzMk81em4zY3Y4QWZPV3lRNVNrRER5WWk4NGZJR3h5MFdaQUtXVVFNVWxaNUFFSE9aKzZ3NHAvOGRtOXhQcHFQYTZSdVZUbW5IN1YvN0lVc3R0TnFmaFUwb0NXWnVsNWgraVB3N1d2Vy9xOTlkcXhid1lMbkFzcFdsajF6alJENWtQRVN2RitEMzNVazFMSVNOLzBJMytmeWlwNW5mWDR1WFVEMUt2VWh0ekNYa29kaXJYMjFMcVp4L0Y1NU1ZeGg4dEJNVU41TW5HSlVsV2VQYUJTYkZPL2EvRlVNQURuWGtvTVF2M3dTSDg4ZGNDUk1qUEpmeDdyWWVRZWhNZWVvK2lQUjMwTU9wM2xhOVg2NGQxdDZRK29sSjVYR3EzbVVmTEtPYzU5eUVzN1BWNjlvOVIwNjBZWDJicVIvbUxmOXRBalBFUEZQK3ZsbU9kZFZmWDQzdHB5Wk0wU0QrZGJqd3NTZ2JIMFMveEwrakJNbi9TTTNsWXdhcjVuWi8ydkV6MWlEdFlHb1I3R1gybE8xMGVDTnBGL0FNMnlkUmxGZzByRjBURmxvNDZjcjJQWE8vZXRlNTVZOWIyenRZbnpzTHdHakVHZXNaY1llMitVanJrM2JJV2cvalRqQ3hwZHVET2s5K3l2em4zc3M0YTUwcWRzbEZXdkJNWThPd3Fwd3R3OFBzNTV2dkN6M1JoYlB4Ly9uN1V3UGRPdHFNK3dGQi9EMCtMOHFQV09RVGV5NDVLMEd2V3ZxSmZXNXdpcG1GK3UzNlBrZjlaZmRqeGFuUHI1dUxsN3pXSk9qdWJMWWNmelQrMWhoSTVmWjNyZnUxbGNzNWM3aWs1bngrSzEybGUyUmEybmxmOXJTcm5aV0dTTUh1TlI5ZG1sNERRV3J5QzFyd0tVN3BTU0JwZnFXZ3JLUlhzZXRSbWttSGs1WHZ6THpEL1ZKbTIvT05mR0V0U1Via1NQVDAzZytHZUJ1WXk1UmlXT0o1U3owNzhmSzBHQ2luTTZNK28yb1BLSDJBRVZXNTNYNkxxMkhhLzNWUFQ2OElsQVFlWXN6ditxN3hWOTRvemM5M1E5L2NQMWF2SWV1cFFKVFlkajBjTWVydS91Q3BwWDFwWEtVaWw2cFNCaFJka28xbVE0dnlxTzhsY3ExaDFUNzJiSDdoWEVmY3FCVVhoNEp0UnJqYXF4YVFjcU5NeWN2ejY2clFPcGo4ZkFtVDJKMDQ2L3EweWRJTTd5WXB0UzZlTDRsVldDZDArdGozbXhMODJTZzViTnRmeGtJVUVmVkMzNGFWMlc2NmgrZmEzUFBIcVBOaGFwUjk3REVVN2M5K2svNjYvMEI1blZsRHRXKzVMejdpcWdUY1crTE5kNjBteU8rK0I2WDZXYzQ3RGZZNVdXZmZGR2RLTFRNcUovOFR5TUhVYmF6WHFlZ3NGUmRnZVVleS9zbzUvcXZ6K3NWM3NjKzlYc0QrUmRaNk9rNnFjUXpHdWZwVUg1bmlUVzd4V2NrM0dmVkF3VldseXBhK3Z4emlmWGZPLzliMXZiNDdFSHRYMjJvbysrKzV5TVduNUlwQXF6Tzh2cGVLbmczZmY0ckhIdmFMNUhjVDFQa3VYem5adWUwdTN4Mi9QdS9lczZoTzk2Q3BGZkc3UDhjNUYzajA4Nzl5aldxei9mYmVsMzdDQ1VYOWRJZzhFWTYzTitYWVpNbElNemF4WFhvWHpOeUxrdjlYTzEwTSttcEhXcGR2SlM5dGI2elRtV3lyWG5BTHlITFFtcFFwOGZsYk5LNHE0NTl4VDZPWG9OVWVicXFMYlRWckh1YWFVNC9ZQmtlMVFhWmRXdjMrZDV4VFA2TktyazVtU3VNb0tQRnVyWkswZ3lweHk0akM1ejRteXQyK3ZleVBNbUwzRStQRm9yL09URStXajlsWk82cVRCdkt1U1djblBrZ0sxQ3MwYjVxK3NBdGNWMTJMeEJ6bnM3UEFZL0llaHlOV3E4Sm1teXYxcWJTZm5aYXRFY3RhcE43ZXJRUEoybytWcWdoVnFzcFRwRForcGNyZFJxZjdOMm5kYnJKbTNVemY0V2JhdHUxelk5cUlmMW1ENm5MK2x4N1Zldlh0QkxlbGtER3RKckd0YnY5SWJlMUZzYTBkdDZSMGRVQ3dvTllYR284SDBZMzRZRnZnd0xQWHdUOW16WXJ3WmRwa1p3cnNhREpab0VKbW95T0VWVHdSUk5BNmRwSmxpaEVqaEpzMEdYV3NEN05RZk1VeXVZcXpad2p0ckIyZW9BclpvSEZ1aEUwS2I1eGdKd3VoYUNxVm9LR25RR2FOU1pnRGNLTGNkS01FR3J3VFI2d0Y4WWdGVzZEbHlxOWVBeTNRUjRGd3hNMTgxZ3NqYUJkdDBLU3RvS1p1cDJjSmEyZ2FWNkVDelh3K0JrUFFiZXA4K0J4Zm9TYU5MajRFVHRCM1BVQ3hicUJYQ0NYZ0t6OVRKbzBRQ1lwU0Z3bmw0RHF6VU16dGZ2d0JxOUFkYnFUWENCM2dJWGFnUmNwTGZCT3IwREx0WVI4QUhWd0NWQlFRcU1Tb05XTWpLTHRZalJxZWdNZjhGWFpwVCtScWN5VXQxYXhtaDlYVE1Zc1NmVjRhLzVPaG01NzJrU28rZnZkaGpETTlWQUc1dkFOR1ZnbXByQlFrMEhIWm9CRm1vV21PMFJtazI3eW96eUloQzBHSnlpSmFDRmtWMUsvR1RRUW5ncXRBdzAwbS92STk0SldzUm9FV2UwaUo4RlR0SFpvRlhuZ0hGYUFacjBmakJlWFdDQ1ZvR0t6Z2R0dWhCTTFFVmdnZGJSRTFOMENaaXJTOEVVWFFZVzZISndvcTRBOC9WQmZZZzdWK3JEak81VllJcXVCcE4xRFppaWo0REp1aFlzMWtmQkVuME16TkQxWUtadUFMTzBBWlNzSlcyNkU3VHJMcEJwQitqUVR0Q3VSMEJabjlUL282QTlvRUgvTDJqUlovUlpXcmNYbktUL0g1eWlQOWRmY3YvellJNitvQy9TMHI4Q0U0UU9rZnRsZlpYV2ZVM2ZRTGFuOUMxYThXMHdSZDhCay9XMG5pVitBRXpWZjlQM2tmTTVNRXMvQUF2MHQyQ1cvZzZjcUIrQkZ2MFlUTkhmZzFiOUJDeldRVEJCejRPS2ZncEtPcXhmMElvWFFiTitDYWJyZjRGRnFvSm0vUXBNMS84R2kvUnJzRkQvRERMOUN5ajdpK1pUdytuaGRMV0hzOE1Lcml2REJXcjNWNlp6dzFmQ1YzUnkrRnI0bXBZRzlJL3JOOEkzZEVMNFp2aW01b1Z2aFcrVCs1M3dIZTQ4SFo3V1BIOFozUksrRzc1TFN4c203VVFUTk9sbldiZW1NNlpTWmkreXFzemVVZW00VDFIaTcrTHlDUWNva2U0bjN1WDc0Smc1bHBFcXhuVGNmMUdxZURvaXBEcitreDFxZjUzVmFVVGx0Ry8yK3dLQTMvV1BmUmNBcjBIOGtSMUZLV3A5WUhqc1BaOU9YNHNlS2VIWUpmS1pjbzk3YmQ5LzhCeXM1SlA1Smt2bHR3ZXNJZjNFaGdsN3Vkckx3RWNjL1MrMnJMYlA1UjlGcC9KZVlRYkhIbkpHSUkrMXlxUDh2bG1pejd0alhiZlUwbFF0U2I5SUhkTitOYU9YUkZ2d2hRdGowbzluTmRZL3o3MThlK1BKZWQ1cktvMXg3OThERlgveEx1VlA2ZXRqZmxTcER0VjY2MUxsdVJ6emJ5VGVqY0tSY1N6bVcrS1JNZXBWTjNxVnp0bzlhb3czR0FSOXg3SXZ0Yll6U3VqUHhuck5OTGNIa1BWUVlWNE9IMVdxdldsSFVwWHREbVNwanZIMFBVb0Z4enVLSjVnK09hZkZZenI3enN5bldxOGJOVGZPU1dtc2V1WDNqVVFMRDBCMytMUW85Wk4xdDJMSmh1enZtemZ4N0toeTVVOGpTUlhqWTlFeGVDVDdWL2p0emM4WSt4eWtoZnZTNnVDNjV0cXJDbUhKK2NOajZDdVhveWV3U2Q1NWIweld1VnpyajMxVlR1ZmZjV2RQUER2cWpDNVpsOXR5enk2Qlk3UEhXS3Awbmw2R0NqdCtaTDAyTndxV2UzU3BvanlWWksyeVkxMXg0dmlVVEZuaEhDV3JuMTJRNzdzcHAyK1U5Mmt5bDNNY3l1SnZwMDJLL09PYk8zMXVJOFNWa1Rld1VHTS9zeXUyMUx3eW1hZkhPdUNkKzIwNFRkY016ZEpjKy9mbjZVYmRxYnUwUXp2MWlEM0ZGL1ZMdk1PcWZvVkgrR3M4d1gvQit6czduQk5XNFBsMWhWWGh2TEE2bkIvV2hMWGhBdnkvcjRZbndqZnc5L0QxOFBTZVZvTVdxQWxNRnMvbTJnd3lUUWZqTkFOa21nV2FOUmMwVzRKR2U5d045cmpIYXdjWXA1Mmd3UjczUk1zMHp0N3JWSHV2MCt5OVRsRVZUTFgzT3MzZTZ4UjdyNW05MS9IMlhpZmFiMjJ3MzlwZ3Y3WEJIbXNUVW45VkFjbWZVTERIT3NFZTZ5UjdyRTMyV0NmWVk1MkVGSjlTSXlpNVZSZHJQT2dRYlNNK0djelZGREJMVTBHTHBvRUpidk1GYnZOcG9zM0Vad0x2clhTV1NtQ0tab05tdGJqT0hEQk9yV0NHMnNCWmFnY1QxUUV5OTlSa3pRZnRXdUJkOGlKd3RoYUROVm9DVGdKTGliTWpJOGFPalBneXNFVHN5SWgzZ3BQRWpvdzRPekxpN01pSW53M085WTVzcVZhQWs3MnZidkMrN0JTdEJJM3FBcWRxRlZpbTFXQ08yS09SZnlGWTdqMWFsL2RvbmQ2anJmUWVyZE43dEM3djBVNzNIdTE5M3FOMWVZKzJ5bnUwVHJGSEk4NGVqVGg3Tk9MWGdqTzhSenZQZTdUVjNzbFA4azd0VEswSHM3MWZXNkVONEh4dEJPKzMzcXl6M3B6bTNmczg3OXZuZTZkMnR2YUFjN3hUTzhrN3RUWGFDeFo3cDdiR083V1R2Rk9yZUtkMnNuZHFwM3FudHNhNy9abmVyeTMzZnEzVCs3WFR2Vi9yOUg1dGxmZHJuVG9BMW5xL3R0cjd0UlhlcjNXSi9ScHg5bXZVK2lFSTZnVk4zcnVkNUwxYnAvZHU1M3J2ZG9ZT2dsTzlkMXZtdmR2NWVnRk05eHc0elhQZ0VzK0JTejBIUHFBcXVNUno0RkxQZ1E5NERsemdPYkRPcHdhTHd2d3dYMldmSFl3UFM4SVN0WHJ2dHRJbkNHMCtPempCcytJaTcrTXU5RDd1UXMrRWk3eGZPOG43dFZVK1I1anFjNFFGYWxBN0dpdnJZcUE5Z3RwVVVvVlVDSTNrQ3hwdkxSOW5MVyswbHN0YUh2ejlpNnpaRFdwWThrbkthTW5MbGU4ekx2K1g1TlB0QTM1WHU0L1lYcTdkUG5zOEFMajZ2TEFIMnVkMXJaczBSS29ISERDcVlJRFVJWlc1N3NWTDZ5Ui9MOVNOcmUwMFB6aVlCMDhyQUMvY09jWVkxK3loOU5URHlMWFAxcjQzV3Q4UjdudWZ3ZDB5SzNtcGhreWtCaWs3cUthamNqMUVDL0o3S0hvbWIrV041TjBsR3M2ZjBVZXZ3VmZnMG5rUEJmaSsyOTdyMkdHdkc4bXpJaXlCc2ZRRklHVDBvUFJPcXYzWUVlY1Yzb1d6ak5HTGRpbHlpM3hkSzBrY241UmFEVWdabERBUnkvbkJ3RG5wRHZFTVV0b1Z1SlpsN3dkOURoa0Z4NGFjU3o4a1A2d29aL0cwMnpLNzNhbmw5ZmRUSTlYN2didmV3YWVScWRlTFpRNnErTHVNL2ZDOHgxS3ZXYWVqdnN2RVdVdmFzVlNJRzBtemZBVXBIWGtUOHg3dW5Mb3ZPQlkvbWZZOXAxTHVIU1RsT05nRFVwWktSRm1UWjljRXVYYzlJb1dlU0tPZTFmVWl0dEtqVytpRG9yL2ZPK3F2NzlYNlhKSnkwcGZsVVhTSXZLUHN1RHdYb09lRS9oWGVIczVBR3NNa1lmeXVaUXo3TGN1WUwzVThKekZKc3B4V3liK0xHSVNnenp2QjJPSXhuNUtOL3QxQ3NYZkhsQnQzTm9kckk5YXlKcCtsbEdvSGszVVlnUHFUWGc5N3poK0dvcVk0ck5vcXg3YldOZEZQTEh0UDVicSs5a1k3MFcvUUY5QkJ4ZEpRSlZxYUFjdVd5VWpmSUEzVjdUelBIUEQ2WVU2VWdZdlhwNEhhSHNBemZsOHJLZjBjcmVLT1N5dEtQWlIwbXJwUWo5ZWxibVM2bHZJOVhqRjdRQzgwN0poWFFZZjlYZ21KSnp4VDYzUEp4NzJLM3NGS1NBaDJRWTZuTlJLNFIyaFIxTFFCUDdtdm5wOUdKL2Q3bzFjVjFjZlRQZHJuMWZ5UTN3QVppajJCRkY1aDk4VVdjNllIclVjV3hncnFLMnBWZW9aUE1IMHY4N2hrdGhQRUhJYzhrZ24rQmdpeXZzUVZ4aldqdmxoS3hncjBPVS9XSnZvKzNqMklQS3dZdE9FZ29Wc2tPY2QyVkJXVm8xVnJpNXJGL2J5MVN4WlBhTEhnMHEwMlc0S21aQitRM0J6cXY2QTM1OTRQZ3lPbHZmOGliTExjQTcvZlQrYVg1alZ4cUhoT2w3TkVTYXBVRDU2amZpVVEvUW9RdzF5QlNucXJyazF1ZmVxSndsdm42TllodDZCZmlqMlJMOU5VdEF3dVg3ZVlzWVo3b2xxd2pZeG04YlFlT0pUcVZMVHFNUzl6K2Y1a0o2cjErc2xDT1BTMU4xcWNQcStvRmFUTGowRUdDdjJaV2dWZnA3SzZ0aWZyUHVRZ3M0ZFJ0S3lwdDlJTXJLOFY5bWw4eDdYU3ZRaTN2Q252czlSOW12d0s0emtTVDNoZFQ4bmlWbzErd3pQbDk3VkY1eVE5Ymo3Nm1oSGhQblpmRnRiRHduc0VqbHNPN01pN2VtNGxVSTRuTWIwcXV3UmZwZnArcDlCTlFwZnlsVFEwN0hnbDF1LzAyd3FFWE11dVEwaTZpeExrY2MyZ0NLejZQbU9QZHlaN2pWNXFyYU5VR1hUVjV3UDN5NWJDVDFJbDltdzU3cGFRbUhTVHBYcEdsS3Jac3BPN0o5cDJiS202c0ptVXNLWHZOYkRnMW9IRDVEK24vSnZqcFVKL3ByWW44aldmOWw4S0U2ZFNuV1B4bHozazhMcEplSUNRUFI3UzBKcUVjbDNQUjVrZFF3VnZyVmpHK3hLSEx1R1o0QjdJN2F0eVg1dGFic2VpbFNySG5WQUdLWWErNXRKbDRsRlBYTDdObWdFWWhVN0NDdFJKRHVXZ0N1QmFZMythVm1SZy9SaWtQRFZNWFpCblYrUU82aWZqYVhiMFJrOHg1bGxUbytaejdVM1dxRnRsMmwwRzBXT2sxa0h1S25rdCtSN04wdW05eDlENm5UOFJ6WHkxeHViOVI5K0xxNUtmNFBkTVkzNW1UbG5PS2ovS2JOaFRoMVB1d2RqMlN2MHJZKzVub0p6MEs4bE43L1dEcXVYMTdva1dNOWExZmM3WnhaVjVBajNLL2IxZVZRZkk3UU1IK1lWMWwrczg0L2xDL2FMMnVXZXhqT2FmUlpCZlR4R3ZwbmdsMW5ZZFMxeXZnOFpBSG1IUGI2ZGROdnFydWRPSkVXRlJvcDJvNUg2ZE03KzB2MHE5bjliZUxLMFdwVGozL0tVVEdJd2pYbkY5dEFVa0g3VmdVMHZGWFJPbDBhbG83Mk51SGVadk1vWkJ2VlMvcjMwcHZ4ZHlQSWQrWUgvUG5wYVJ5b0FrMVhHL1dWMnNZWC9PcTRmSGJFdzg0dHErcjM0cWNkU2VpTmRjVDJSY2UxT1pBdzVMbyszNjdHdERmbGJrRnZlZ3hSb1pHTXRYQmxtNjRrWEtzemVkSU9YN3FBa2t2Z1dkR0U0OVlZeXFFNHhuUVNjT3BIeGk2ZmVSQksvbGRUL0xQWkhucjdiNjZkSFlkNytVeXJjbXpmajRsaXh6d3hnYWxVMlgyanlib28wbnpUM2dtR2R1SmNGcDV4QTYxaGw1ZE5hcVRybE1MTEVPQ1luWFFWOTdCeHJoTXlzMXA2ZFJRMjFwdlNCTWNldEtTaGYrTEVrK0xlOUxPcEdnRERMN2FxWENPV1pCSnp5RG9rYlg3Y1M3NjBUQ1VOVHJkSjZYc3hNOVJaMXkvdUZhTmUzMER4TWVNcGVJdk45OHZOOVl1bjZLMjQ4ZnFuTThLdi9jZWxqd3JKTE5UdmV5M0RsWmx2S2lKeFhMcC9YRllRSXRqNGo3VldKUkY4MlRzUG05L1hZdHJyTkR4LzNkVEwwbnlvNER4eFFKeVpQVzVudkNkV0s3T3BNbkZrSGJ2WEtDcWtFWVoxTm1GTFcvZEx4dE9QNmU4NHFXYk8yWXVXZXVuVHd4dDh0Y2lxZHhVVlByL2VCNHp0YlJoMFhKUnBNbXR3TThtUGhrK2JOb05SMnQxaC9nUzZ4OGk0bzlZUUo5dVFMbDkwYW80N1ExdmVsWEFuNE5neDRYOThDd2MzcnJjTnJrM2ROem9EZXR2MzIrZG5OSHp1MkIrb203elFuOXVkQzdjbnNoaHZXak5QWjVYZHlWRlR3V3R3b00yQzVYUis4ZFA5OTFmRzdaYjM4aWpwdGpDVTZiREo3ZzFMRHYwSHJmbzU3WHltNG9sUVg1V2RFSFJTQ2xlOEU5YmEySUh1SGcySDFNU2hVMUlma1RZRGlkSTQ1ZGt6enFZNUVoZjJhVlRtTVRsK09iYTduNWNSeWVWWEZ1MmlxUGJWNlgxWnpXd2s2M0Jua1NZanl0QUprcVVOa3h3dWpSa0k2NzhuSk1lZCtGRE1UcjhOajNnVjVmSFZNcDhoZDBwVncrOVVyZDc2bU04cnRZRTFST3Z5dU1PT1hkTmFsZU5RTnk3Yk5sdVJPeHpMSHNhUDJVeGpVempkbGlwcGtDT1pXdXVmSHBNN3hIZHFvMzk0ek80MTRQeS9ISlRWemQwdVFwK3E2SjYraDJJdWRqOXRsT1ZBSG5oSTRsT0cweVBPL1RDdHdycnQ1M1pNNk4rNDVrSFFlTmFCK3dsQU5PKy9lWG1FdTVOR3BqZmcrNmtGc29pVjFIeXJIWTRlSis4WmpLbHd0MW5aOU9YZ3EyaFpiSHZaZDdJeTlkbDJlSGt2ODY5bTlReTBXYlYvaCtNQU9qODNJYmtzMCtrTzZNMldMbTU0U1V1QlQwTC9aRkZhSXZ2SnZOdHlmN2ozb1E5QzJ4Sk9PSWQzbkh4TU50S1JNK2s4WitMRHBCS3E1UnliZEl2MG1VeWJHKzUwOTBRWGY5RitMQ3ZqaU5sMjNzY0lwRG8venFXOG5ycFgwa3IrSmptRkdGTVk0Y2VndS9keFgwc05nVHl1SXo1ZEE5NGZVazF4UHVnUjZ3RityeG0wSGR1V2QwcGFmR1g2anFQY0ZvamFiUlBNY3Q0TXpTVW5sWG5ldUpURTFqMDZxQ1hvK3VwejZCVHVOVS9BSXpuZ29YWmtkNkQ3MzRhNkRMTjlkN1lxdzJ3dkpuS1RXUXM0L2VnYVIzYm8vU1pqVm91aFlCYVluZllEdFpuUnFuczdSQ1UvVitNSU14V3FXWnVsQWZROGJyd1ZMZG9BMDYyZjhaOGxSOVhuK2xDL1JsUGF0TGRFQS8xRWI5U0QvVkhYN1A3bTdlb2Z1dTd1Y1pIOVFTRUhRU21LZ0thTkRKb05GdmJEWnBHWmlxNVdDOFRnTVRkTHJmMk8wRUUzVVd5SFEybUt4endCU3RTUEpOVXhkbzFpb3dYUmVDR2JvSWRHZ2RtS21MUVpzK0FHYnBFbERTcFdDMkxnUHR1aHkwNkFvd1J4OEVyZm9RYVBPN211MjZTbGZENXhyUW9vK0FFM1F0bUtlUGdoUDFNVERmUGJKQU40Q0YyZ0FXcWY1OVhOQm45UDhSL3hOOWxyYnNCUlA5N21XVGVQZVMrT2ZCSkw5N09WVi9CWnJweDY4Zy8xZkJMSDBOek5RVCtnWngzcjFFaG0rRERuMEh0UHZkeXc0ZEFIUDk3dVY4UFFjVzZnZWdRMzhMRnVydlFJdCtDQ2JvUjZCQlB3YXo5UGRnc240QzV1a2dhTmJ6WUxwK0NoWXhjaGVyRkQ0UVBxQ1djRW00UkczaDBuQXA4Y3NZMFRhL0ZUbk9iMFdXNFhkWTQ4QjFhZ0ozYXp4dGtpYUJjY3JBM1pvTXBDbmdLazBGRXpVTkxGSXoyS25wWUt0bWdKMmFDVTd4bTlueW05RmJOQSswNlVRd1EvUEJKVm9BbG1naG1HU2QvYmdXZy9YV3JRMStEM2k5dFdxRHRXcTl0ZW9HdndlODNwcTBRV2VBOVRvVGJMQldyYmRXM1dTdDJtaXR1bG5uZ21EZHVrVXJRWU0xYkpNMTdHR2RCNlRWWUxMT0I3ZHBEUml2dGVCOXVnRElXbmlydGZBUnZ4Kzh3NXAzaHpWdmh6WHZFV3ZlSjYxNW4vTDd3WTlZNXg3VlZXQ0hyZ2FQV3ZOMldQTWV0ZWI5a1RYdlBtdmUvYm9PWEdEOWUwRHJ3WWVzaGJ1dGhRL3FSbkNOYmdKWGFpTzRUVGVEQ2JvRlNKdkE1Y2k0aGZoVzhHSGREajZtTzRCMEo5aXNiV0NlN2dKM2FqdVFkb0N0MmdrMk03YjNTdG9GVHROOVlKbnVSdzVwTjFpZ0I4RkNmUnhJRDRHeUhnWW42aEZ3bHg2bEpkSmo0Q1MvcWZ4eHo1bUhQR2MyK0UzbDlaNHRqM20yclBkczJhRFBnUTdQbVJzOVoyNzJuTm1rTDRIMWVoeGM0ZmVWYi9YN3lqczhaejdwT2JQRGMrWlJNV2VJN3dlWGVlWjh3alBuZnMrYzNaNDVqM2ptN1BiTSthUm56Z2ZWQ3k3MS9ObmcrYlBEOCtjbXo1OC84dnpaNVBuenNPZlBnM3BCUDVmODF2Sld2UWp1MVMvQkxyKzFmSStxNEY3OUN1enlXOHYzNkNYUXJKZkJ0Um9BZnBlZlB2NE5rUDRaM0tsL0FYZHBVUDhtNlJYUXFkK0NNelFFenRTcjRDeTlCczdXNitBYy9UdFlvV0Z3cm40SDNxODN3RXE5Q2JyMEZsaWxFWENlM2dhcjlRNDRYMGZBR3RYQTJxQVFKTDlGdlR3MGh0TWtmMCt3T2J3dm5FV2Nyd3FJbnh2ZVQ1eHZDNGhmR05aSnR2cDNoTXZEemNSdkNiZW9NV3dLbTVUNWY3Rk9EYmVGMnpRdGJBNmJOVDFzQ1ZzME0yd05XelVyM0I3OC95YkNIWm9kN2d4M1ltdTJoVzJhRSs0S2Q2azFiQS9iMVI1MmhCMmFHM2FHblRvaDNCM3Uxdnh3VDdoSGk4Tzl3Zi9CTWV6U3llRytjSjlPRGZlSCszVjZlQ0E4b0F2RDdyQmJGNFVIdzROYUZ6NGVQcTZMdzBQaElYMGdQQnorUnZMNzMxZjcvZS9iL1ZXRS9CYjRwLzF0eEVmOEx2aW4vVTM1OWY1T1lsdDRLandsK1d1SjdmN0svS04rVS94MmZ6T3h6ZDlNYkxkOTNHRDcrS2kvUVcveXUrUHl1K05ML3cvc3hoallBQUI0QVkyVlczQlZWeDNHZjcrOXp5V0VVd2doM0VNSWFVQ0t5R0JCbkNraEJJZ1ZGQTYzY0w4MGdSQkt6YzFjYWhTS3ZWSmE4SWJWQXRhcThWS3RGbXRWdEEvVzZsUEg4Y2xISFhsUUg2eE9iRXRicmJXS2E4NDVUVTdzZVhDKzJkKzNaNjMvV21mUE92LzVMUVRLT1JsQjFIenJwaFltZGJZTmROTkVBdUQ2ZGFxQWlBUXB5aWdud3lRcXFLU0s2Y3hrTnRYVVVFc2Q5U3dzV2lFeFNkSk1ZQ0kzTUprcFRHVWFNNWpGSE9ZeWovbmN5QUxleGFLMnRzNEJydVg5U0hEZWZOdjdqMHJlMjd0N3Vremx2YU92N1lpWnZIY2VQOWJtNHJ4M2gxVXVLL2hnVjU4cjg5N1QxOTV0UTk3N3c2enJDbjY4dThNTkJlOWY5bDZ6bzc3Y2xsRmY0YjVSZjUrdG83N1NqbEYvdjUwRkh6emNiOS9iM3R2dlVONEh3cWQ0S3U5QUJBaFllSnNKU0Jsd0F4TW9aeUtaOERhSnlWUXdoVXFtVXNVMFFHWUJNZ2VRTkNEVEFaa05TQktRYWtEbUFsSUR5RHhBYWdHSkFVa0FrZ0prQmpleXdmTlJSM1E1cmcxYUdtK05UOFhuRW9sRVRlS1d4SjdFVU9KUzRybkVuNUtaNU1yazdjbnp5UmVTYjZXZVNTZlN3K2tONGJtUy9sWDZhdnBhV2Fxc0JRRXBJMktZckhkNXlrLzZFNy9wdDd6YmUzekNleG54VTM3YXovaFpQK2VQWGVhMy9ZNkhQV0s3Uiszd21MZDczRHY4aUoxMjJXMlB2WDdVUGdjYzlFNC81cEFmOXhPZThFbS82L2M4NytkOXhDLzRSWi95VVMvN3JCZjh2azk3MFV0K3ljZjhzai93R1IvM2gvNklFYi9pVjROL3pXRy83amVRTENuU2xPWDZNMU4wMW5PcFlSNjF6R2N4eTJta2lXWSt3SzE4a0ExczVFTjhtRTFzSnNzV3RyS043ZXlnaFYzc1pnOTcyY2QrRG5DUVE3UnloSGFPMHNFeGp0TkZOejMwMHM5ZDNNTkZudVhYL0piZjhYdXU4aUovNGErTWlBdGM2THRkNG50Y1NsdzRTYmxDaGhycVdVWVRXUTV3QjBPYzVoR0dlWnJJTmsrU2RMTzdlY243K0R0cHMrN2hoUGZ6RDFmNVUxSnVjUzhEUHNBYk5wQnlxL3NZOURUL2REVXB0N21mbDMyUU4yMGs1WFlQOElwbitKZHJTTG5EZzF6eklkNnlpWlF0SHVKVkgrYmZyaVhsVG0vak5jL3lIOWVSY3BldHZPNDVycnVleUg2dkVCSG5CRk9wUm5ZR1RTUUZSSlJUUTR4eEk3S2trRENmbUlpYWVERXlNLzlXR0JmWmp5U0lPWnc3dGNUbzJiVG5jZ0pWVkZQUEVsYlFRRE9iYUhFVk1WVmtiQWc1TGVUcWtOTkROb2FjRVhKTnlKa2htMExPQ3JrMjVPeVE2MExPQ2JrK1pEVVpSQ2FPOXJYUmFmNDQxdVhSRU9XOHhBa0dHT1JsWHVFYXIvSWFyNDlWVU0xRVJ0eHMxaTF1ZFp2YjNXR0xPOTFGaEZSU0RVVzdMN0taRkpDa2dqcFcwTXcrWWtDYWlhUEtxRElreE9HZENHN0c4QUNGbWxvaS94WWNZaUt2VW9IaEFSQ3BKRVpmUUtvS21UL2RtRXBHWEVpcThCVXhvTVBvcmtMTitKa3pSRjZ3b2VSY0o3RW5nMnBMem1aSmVDaW5xT1Q4VXBJMjVzVWZTbFprU0ZsdFFUeGZxb1kvaythTklqMVdzdXFYbFBHYmNicXpaTjBsSnZEa2VKRXRXZGxMT1hlL1EvVkZYVHhTdEVJcWtVWkFvSTRvYUNRSWQ5dUs0eXFya0JvYzNTdENwaFk2UjJJaWRMTzc0QjM3MXhYdm4xL2pZVTlRVG9RMGN4Q0tlblVQTjNteVFPM0FhKy8xUHUvM0FVLzdvR2Q4eUljOTY3a3hmaGZ4OTFFdkZGSDNjUU5yaTBoN0UzR0J0WUd5VENuY1p0T1p3VXhtTVpzNVZJOVJ0NGlhM2ZRWHNmSkZjY0VvSDhlK2VpRVZ1UnZtQ2NOZFVyZ1pudkp5N2lZSS9NL1JYeW9JbEE4ZWVGNmdjeGM5T1JvSEJoTUlYRVNWbGJsTWtzbHhwWTVGUGtmTVJqYjU4MXh1OFdkRWJQVDU0SnY4UmZBdGlHd3Nvdlk2eXBsTkRYVXNaREZMdVptVjNFSWp1Z3B0UUZlamplZ2F0QWxkaTY1RDE2UExpSWh5dnc3TGd5YU1NWUtVWnhGWlBHNnNEWkdkNDhZdUk0NWZtL3MvcEdyYzJFWkVlb3ZPdEo3SnRwWG1GaGNaQ1pMSnhGU1cvQy8zRTNoU3RGdVdlbmU3eDczdWM3OEhQT2doYjdQMS83ajMrLy8zNWgvcjQxejNsdjhYSnplSU5nQUFBQT09XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9zdHlsZXMvQ2lyY3VsYXJTdGQtQm9va0l0YWxpYy53b2ZmXG4vLyBtb2R1bGUgaWQgPSA1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///58\n");

/***/ }),
/* 59 */
/***/ (function(module, exports) {

eval("module.exports = \"data:application/font-woff;base64,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\"//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc3R5bGVzL0NpcmN1bGFyU3RkLU1lZGl1bS53b2ZmPzkxOTgiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6YXBwbGljYXRpb24vZm9udC13b2ZmO2Jhc2U2NCxkMDlHUms5VVZFOEFBSitJQUF3QUFBQUJJRndBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkRSa1lnQUFBTTJBQUFYQmdBQUd2dldzTjRhMFJUU1VjQUFHandBQUFBQ0FBQUFBZ0FBQUFDUjFCUFV3QUFhUGdBQURETUFBQ1RuTC9xdDZKSFUxVkNBQUNaeEFBQUJjRUFBQXNneXNIUTJFOVRMeklBQUFGNEFBQUFXUUFBQUdCUGJrOStZMjFoY0FBQUJiUUFBQUxwQUFBRVhoeFUzTFpvWldGa0FBQUJIQUFBQURRQUFBQTIvKzBzcG1ob1pXRUFBQUZRQUFBQUlBQUFBQ1FKcFFiQWFHMTBlQUFBQ0tBQUFBUWpBQUFIWVBxSFR4dHRZWGh3QUFBQmNBQUFBQVlBQUFBR0FkaFFBRzVoYldVQUFBSFVBQUFEM3dBQUNEZGtLVmQrY0c5emRBQUFETVFBQUFBVEFBQUFJUDlvQUZCNEFXTmdaR0FBWXFkNWhSZnZ4L1BiZkdWZ1puN0JBQVJuZTZxRElYU3V4Lyt6LzRWWVB6QmZCbkxaR1poQW9nQ1hLZzUzZUFGallHUmdZSDc2N3dzREE1dlMvN1AvTDdKK0FJcWdBTVliQUw0NUNHOEFBRkFBQWRnQUFIZ0JZMkJoMG1iOHdzQUtwTHVZSWhnWUdMd2hOR01jUXdDakNnTURFemNiQ3hNakVEQTFNRERvQnpBOHFRYXE0V0FBQWgrL0VIOEdvT0MvLzh5YS94MFpUakEvWmVSUkFHb0V5VEUrWnpvS3BCUVl1QUdmRFE5K0FBQUFlQUdWbE0xdUhFVVF4Lys3ZHV4ODJBa0JKWUlMS2o2RUJFN0dhMGZpNEhCSllqbEMybHlTa0FzU1VzOTA3MjRyUFIvcTd2RjZjK0xJRzNCQTRrbDRoVHdERWkvQmxYSlJHbFpoSmNTdU5QUHJmMVZYVlhkWEQ0QlBSNzlpQlBuaG05SDN5aVBzNFd2bE1YWXdVZDdDSi9oRmVSc2ZERDVYOEJHK1ZkN0IrL2hjZVpmOWYxUytpcDFoN2pYY3doM2xHMHkvS2UvaHM0SDNSNmZqdDhvM2NiajFoL0tkdGJ4M3NTdFZqYmF2QWJnWWY2Yzh3aGVqTGVVeHo5NVYzc0xqMFZ2bGJhN3lkK1VyT0I1OXFieXpwdSt5LzgvS1Y3RTN6TDJHajFFcTM4Qlg0MXZLZXpnYmVILzgwL1p0NVp2NFllZWg4bnY0Y0tqdE5zLzRVL25PV3MxM3dUVS9kL00rbUlqbmNKaWpSNEJCbkpvK3V1WU5QWTU5MDdqNHhNZnEwdWxGdHZlZk9ldjdXcFZJTE5IZjBpc1hrMjhiT2lvbWs2T0hWUFkrV0pwTUpzZVl3cUJIaEVPRE55QThadTZaRzFhRzJPUVRHY3JSV0ZlYitKcmFHVTE5NDNKN1F1dkpOUDhKSFUrT0hpeHk3azRPRDVmTFpSSEV0NmphK3ZEbHdoMmN1dVRuWEhuQ0UzaEVWTkNWNFFVeUxPN2pHUnkvUGV2MXYzeEl2V2pkQzYrWUl4S1BXalJzTzBLQkNTYjhmc2lqRWoxYmdzeWF5UC80cWVNS1RIYVdmQ1AxVXJtaXM3YkpVMVB5V25ycjI0S2V0TjBxK3ZraXM5T3NwYzQxMWpmellrTk5IZ25FVE1nOE5yQndxTVgybXJVV00zNU80V1ZiTTQ5UFFCdWliRmkvZUI3TFNoNWdnY3ovanJWRC9pL2xYeUNzeFMxUThiTm02MHYyZGpqQUtaenN5MXg4SXZOVE9HV0RMSmxJSWd4NVpNZFcvRHlUM2N6U0pLWFcxMHRsbkVsVzBLSmp6eWp4dVRxTk5FUEwxRWtlSzhvY3hkUXNaMzJnUHJuTC9za0xSelBlN2tSdGxJRTEyVkRGaXZHTnM3VDBlZUdid1kxbVByaEU3cUlLdldXb1crdG5LejZNZXhTZFNjblZaZEJSWTJxaGxOdklRRzFEWGMvV0txekluQnNmVEJrY0pSZlBYVXlYRTZ4UDJaZDlGbS9UV0xhRndGelFvMlpGZlJQZUtkd255cXV1blVmVExYeEZxWjNscFltT1N3NkJTa2RkYkpPcit1eHN3UjBWeVZqck05OCtFNlNOWW0wdVI1ekY3Vi9mZkV1bS8rQmxTeDVNZmVXYXhDWEpTU3d4azU0aGZpYTRvYjh5RmpLYTZha2xzY1ExaTRWaE5reVYraGp0SGN2YUVsNDhXZGtRalVudWtKTzREaGVvZU5URHFsS2paZmJzdGRJVHY4ZHFaS3RCa2pwcmxBanYyQnEyMW10YWtpNk9xcERlNWc2OXp1V2MwcGtHNXpCU2p4R0xrN2tPa1hYcDhpRUQxeVJSdlh3RjhscHN3MityODhKUVdjSEtJelNTcGVkMytJOGQ1K2hDSzNTc3p1VldkYUpYRXBzOTJicVVHKzUwbDRQRUttWGNzZDVLMUFxOTNzZEM3MTZVS3Eyc0lldTN6U0NzM2JJb1h4bTE2Vm9jOW5IOWYzMHJwcHZVNGZZZmlMMlMwMHJpT2Y4TFc0ZXVXd0I0QWMzTzYyK1RWUUNBOGVlODcreHdFM0IwVXpick9PZlF0d1VHRlZRVTVwV0tNdFNwZzNuRFcxRUlRbEZCRElJQkxQTUdlR09DZU1VQTRxV0lDb0lYQkkwdWFja1FMNGdtUWwzUDBYazMrczNFWk9sZW04YjBIL0NMVC9KOC93SHV2NGNRQUU0N0xnSUlVZUZNQU5hUUlrQVZNSkFWK0dLY2lJdnBZcVpZSWxhSUo1ejlUcmZUNDY1MzArNCs5eU01UUZiTFd0a2dHNldXRVRsV05zdTRuQ3piNUFLNVZLNlcyMVZRYVJWUmM5VWRhcDE2UnFYVmJwWFZqZzdvd1hxSXJ0TU51bEUzNlJhZDBMTjFKcHp4Tm51N3ZFKzh6eU94YURCYUYxMWxkVjlGdisvN1VMSklOaFV0azhRMGtTaGFsaGN0MmFMbG03S2xzbWdKeXFFeUpHWEpNckZzdVV1bXlwYUVtcS9XcWcxRnk0NnlwYVpvcVM5YlpwVXNtN3kzdkFObFM4cktQa29XNGYvbDkvcGRmcWZmNFMveTUvaHRmcXZmM0YvWkh5ajhYWWdYWW9WUW9kNGV0b2ZzQWJ2ZlptM0dkdGs5ZHFmZFp0TjJvNzNYTHJPTGJidjUwMWpUWTdhYUxhYkRwTXhDa3pRenpEQVRNclVtYUdyTUlGT2Q5L085K1lQNTd2eThiNU81enR6S1hESjNhNjdxYU9Tb2QyU3ZDZ2VtT0swSS9qOEZuQ29Bd1g5V3VWUndEQUVxR2NDeFZGSE5jUXhrRUlNNW5ocUdFS1NXT2s3Z1JJWlNUd01uRWVKa0dobUdSS0VaVGhpUENGRkdNSkpSTkRHYU1jUTRoYkdNNDFSTzQzVEdjd1puTW9HSk5ITVdaM01PNTNJZTV6T0pPQmN3bVF1NWlDbTBNSldMdVlSTGFlVXlMdWNLMnBqR2ROcTVrcXU0bW11NGxobGN4L1hjd0kzY1JJS1p3SU04eEdvZVpoMVA4d0l2c29XdHZNeEx2RUthMTlqR2RsN25UZDVnQnp2WnhkdnM1aDNlNDEzMnNaY1ArSkFmdVpOWnpHWXVQN09FelN3Z0tSd1dNMCtNWmhYUGlwRXNFbU5FakRuY0xaUUlpK0VjRWFPWXp6TGg4aXJ2czVKYnVGMk00S0JvRXByYldNNHYzRXdIRC9BVUdiTDBrT2Q3ZWpGWTlvanhmRXczZndqNGpkOUZpNWpLVHl6bE8zN2dWKzduRWU3alVkYndPR3ZwNURHZVpBT3dudWZaeUhOMDhTbGZzWkF2T01TWDNNUFhIT2F6ZndEWDJ3STRBQUFBZUFHZGxWMXNVM1VZeHAvM2Yxb2N3Mm1BeXNkb1M3dlMwYTN1cTJ3eXQ5a0oyenBtWWVwZ29vdkJtR2ppc3ZoQjJBVVhSRU5pQ0NaZW9ESFJSTUNJaVFraWVvTkU1UWJqRXQwRmlTenhRaElTQjBRTklWNjRRZnlrL3M1SlVZY1FFeTkrZWY2ZjczblArN3luZFhrVkpVay9BMWl2SHJFOVNyc0xhbkNiMWVUMXFjVk5xRmRUU3RzOWFnYlpTY1ZjajFxdFdldHNYQTJXVVk5OUtia3h4anNWZGN1VmRLdFY3WXFCSmx5Zkd1MUhoVjJiNmwyQk9JMHEyQnE0cUpSN1NIazA2U3FVOURyWS8wS1Y3akVOdXl1TXA5QUNOR2pZbThmOEJ3M2JLdVlwUmR4Uk5NdjZjZlFQTk0zK1NGbWZZVzJyYW9oVDVZNW9renVrU3U4WHhudmdlZUx2VXIwMUUydFNRc1B1TnVJdFZxWEZlSzhJNy8yb2lpNUdEVVpnRmZsdTAwSzNTUm0vVmpaZmQxdGw2WkpMTUs1VTBSdmxiQjU2bEE3dWJlSDhMdlltbGJDbnViZE9CVmZGOHh0NXRtbUJXNmtLTzZOYTlocnNWZzJqWWM3RWc5cW50TUhWOFB3SGxYY0RXdTBlMWxML2pMdExHKzBsSmJ3Y2VSOVdwODFTNDM3dVUvdGdiVWh4eGt1b2M3ZnRWYnZ0MTFxTEsrNDJrTTllOXFMNGxGSFU2cFcxODhwemY1RVhWYzVMdzVQNCtEMTVVdmNiRVlyb2xzQUxmUGdIK0ZBNjdYdUJUc05WK21YaE5SK3VoeHJXQm9vWGMvQzkyRXE4ZnZLazdqZkNld3FOQ1IvbVl2TkwzK0JGRVQwTFY5eTlySmQ5K0JmcjFSb29Yc3dCTHdMUFVEK1c2MExiVkJGNmpyd1BjNTRlOG4yODFqT0JieitWenRuTGlnY013WGJGOWJFaXRoSzlRSTEzcTlwZW9JL2VsVHp5RHp3WVY0WnZRM2dnU1hLNzFSM3ExWURPS2EzdkFHdy92Rm5tRmEyd1Q5VGs0dXIyRG1vbzFLZ1dTeXNLaTd4ZXBlZ0gyWHVxc3cveCtRUzhCb2ZnQUx4RmY3Nk4rbnN0eXBiNzRhYm44S0hiM3FHM25nRHl0Y3YweEFMbFFqR29ZRnlMemxNdW5GUnVYZzN6UzhEYzdZTXpjSjc5RkN3cC9XWmZLeFdxVWN4T2wzNzF4dFRsZmkrZDhoN256SXd5M2dPbEdXK3BzdTViOHI5YW12VUdOVWpzanRBT3pvMnFqbnJKZlVBdnRGT3JyRnA1UC9sOVMzNUplanhyR3hXbVQ1TCs3d1hmWGhmay9YMi8vNzFYTlJwUWtMdyt5UTN5TG0wOEU0TDlUeFZ4czFyQ1BQdWZWT2oyMEFEMy9Qb2ZwS2ZIWUZRTHZmY0JKQ21vYmV0MXRYM3gvM3VnRmluNHJtYzBiS2Q0cjhzd3lYeEVYVGJGZUpyMWF1aFF2NTFFUTlUcEdEb05mTS9Cdll0b25ZcTJEejhMYXJRSjVnZTBqTnlyOFRkSlBaZmI2OVN1UTRMNWtJRUlOTU1KK0F3U3NBMXlFSVVhdUJQU0VJZUc4dm9FZkE0RDVmdEZ5RU03SktBSzdvYzRkRUFMTk1FaVVKbkY1ZGlkVUYzZXY4L0gxcWdaRlB5MzhEc05ZZi8zRXNMVVlMUC8reGZzelJMUDhZd2RhZyt0MWZxL3ZoRlA5WHk3Nlp0aHo1THZjV3A3VnZWMlZNdjBsZUthaEdPSzRIblo2Nys5dDA0dHRrRkZiSVdxN0lpVzJSWXhadTBOeGo3YmlVR1BXUXpHZFlmdFZDU0krWkVpZndLQkVTclVBSGdCWTJCbUFJUC9xUXdCREZnQUFDZ0lBYmdBZUFGdC9BZFlGRXV6T0E3UHNNek1Nb09qc2c3cXJqT3JvR0pFUUVURkFDYk1PVWR5amhJV1ZERHJNZWNFS3Fpb0tGbUNZTWFNT1djOVJqeG16RFZycitkK1BidSs5LzNkNy9rL0MxMGRxN3VydzNSMVZUVkpXRnNSSkVscStvVEhCeVpGK2NlUFRneHFQelE0S0R3cFdvbDJrK3NSUnQ3S3lLdmtodFpvdkszcWthMzFCRFJmSkFqcTg2OVFDc09HQytzZXgyQmFraDEyR3huckU5OHhQb0ltNmhBTkNCM2hRTFFtWElqT1JGZkNtK2hQRENQR0VsT0lRQ0tDbUU2a0VIT0l4Y1JLWWdPeGxkaEY3Q2VLaVFyaU9IR1d1RXpjSXU0UmZ4TXZpWGZFRjBJbS9vZWt5VHBrQTFKSE9wQ3RTUmV5TTltVDdFY09JOGVTdm1RWUdVc2F5RFJ5SWJtY1hFZW1renZJSExLUUxDZXJ5TFBrWmZJTytaaDhTYjRqdjVLL3JDaXJPbGIyVmc1V3JhMWNyTHBhZVZuNVdBMjFHbU0xeWNyUEt0UXF4aXJKS3RWcWdkVXlxN1ZXVzZ5eXJQWmFGVmlWV1IyeE9tVjF3ZXE2MVQycnY2MXFyRDVaL2JUNlY2VlcxVmRwVlE2cWRpb1BsWmRxZ0dxRWFvSXFRQldwU2xTbHFoYXIxcWpTVmRtcS9hb2lWYm5xaU9xazZyenFpdXFXNm9IcXFhcEc5VjcxUlFXcTM5WXFheHZydXRhQ3RjNjZtYldUZFh2cmp0WmRyYjJzKzF1UHNaNXFIV29kWTIyd25tTzkySHFGOVRyckRPdWQxdnVzQzYwUFdoKzNQbXQ5eGZxQjlUUHJOOVpmclkyVU5WV1hFaWc5MVk3cVF2V2hobEJqS1Y4cW5FcW1abE9McVExVUZwVkhIYWFxcVh2VUMrb3JyYUxyMDAzcERuUXZlaWp0UjArblUrbS82SFE2bnk2aEsrblQ5Rlg2Yi9vdERRekpNSXpBaUV3N3BoUGp6UXhraGpBam1YSE1SR1lLRThta01ZdVlOVXc2czVNcFpBNHl4NW1MekEzbUFmT0crYTYyVmpkMGprbUtpa3FLQ1hkeGNlbHJCcjFjTE1BY2N1dlRWUUVkdTdxYlFTOUxxSGVmdUhEc2NYTng2V3dCWFN5Z3R4bTR1NWxCSjFjejZPeGlBZTRXME1rQ1BDeWdzd1Ywc1lDdVp0REZ4UUpjTGNETkFqcGFnTHNGZExJQUR3dm9iQUZkTEtCcnY2VDRXTVhyNnRweGVIUndxTC9aNytGaUFhNFc0R1lCSFMzQTNRSTZXWUNIQlhTMmdDNFcwTlVDK2xoQVh3dm9ad0UrL3ZIeHNjbFJ3U0dKWms5U25CbkVoNGVHV1NLQ1lwTmp6RG03ZWxoQVp3dm9ZZ0VXMUwwc29MZUxCYmhhZ0pzRmRMUUFTenY3ZU9BS0VzUDlvNExDUTBMNkJrY2wrc2ZGeHdZbEJTWW1KRVZIK3llR3g1b3JjM1B0WkFGZDQvMkR3Z1A5bzhKalFzSmp3aE5uaE1ja0JvZkcrMGY1eCtGaUtjSFRrL3lqWW1JVHpUQXFPQ0hCN0FtTkQvWlBESTQzKzROaUV6SFdNQVdaZTU5T0llRTRWMUJBYk1vQU56eGlIUlBqdy8xRGsrS1V4RTY5TzBiRnpneU9DUTBPeFB0UVZQQUExeTZkT3BvYjd1Rm1KbFJuMTQ0VzBNa011cmhZZ0tzRnVGbEFSd3R3dDRBL09UMHNvTE1GS0dUcjUrTDJoMUNkTENHbHVFOXZGeGNMNkdnQjdncm81K016TXpnK0ZzL3o2UGpZbUdBelRFeU90Y0N3K0dCTFRFaHNVcnpGRTI2d3hDU0VwMWhnc0NFNHh1d0xWa2JVN0lzSi80UElqRGtvSmpZYVl6WkRqTmtDTVdaTGpJTFo0c0dZelI2TTJRSVZ6R2FmQmJQaVV6QmJFdVA4QTRPZFErTDlBLzJkWStPRFlnTE1icURaRFRLN3dXWTN4T3lHbXQwd3N4dHVkaVBNYnFUWmpUSzcwV1kzeHV6R210MDRzenZkN01hYjNRU3ptMmgyazh5dXdld21tOTBVc3p2RDdNNDB1NVpXSm9aZ1dnUUVZNUtGeHVCQVVHd1UvZ3BoVDF4d2ZHQXd4b1o5VVVrSkdBVEc0aGxxU1FpUERjSWVoWDRZWU9waEY5TU91MmJLWVdpbUd3YVlhaGhnbW1IWFRERU16ZlRDMEV3dEJXMVViSXc1T1RyOFAzNWxMbU5nbnNJWS9wblIyUGVuUlFrNGhOZEVxQktURkI4ZkhCTTRBM3RuQkZ2d0JDYUdXN0RFaG9ZSG1oZkluMDVFaDhlWWV4S2RGSlVZSGhlbGxBa0tONFFIS2MzQXVlUERsVkovOXNiLzlYV3hkRGt4TERZcHdUOUc2YmV5UjJId0gyei96MXJFb2Y4c3h6KzkrUC9yd24rQ2NmNjQwY3FtNHh6b254QnNEaWxiamlVWU5pTXVESGRGOFFiZ0tSUVpuR2pKK2Qrd2t2ZS9FY0gvSnpuNHY0bkJLWUZSL3RIS0RtWU9oaVlwNno4NjlyL28vbndzL2svcWY1SGp4Z1luS0xUOFh3ekJNVUgrQ1dFV2IvUWZyNlZrQWg2TktBWHYvNDM1TDY3K3pna0pMcTcraXV2bWo3Y3dRN0RGNngrWWxQakhxMnc5U2RHWWJDbVdjR0o0Vk5DZnBLQndUTHVFOEFSTEtCNmpOdnZpRmJlamZ6UWVIL1BZNEpDN01oMHg3QlFmSEJxZW9KRGNITzBSNkIrUEo0Vi9WS0l5alhHdGVDWlp2SWxKOFRFaHZpSDR6emRjY2FMTU1PcC9hNHl4ZkFiK0Uwd0svQk5qN2dNTy9qOHAwZjZCdUJMc01YY0t3Ly8yU0FuNFd4SUQ0b010QldNVExjM0FmcVZIR0poN2pDSGVzRVA5NDVPaW8veVRsTlQvYlR2Mko4VUU0WVg1M3o3ODU5ellGQjhjbS80NU9CNVhqb0QyUkJDUlFCd2tuaEF2eVNaa1I5S1RqQ1lYa0t2SUN2SW9lWTk4UXRhUXRWWjFyV1pacmJIYWJHVlNhZkRCYXB5cVFIWFNmR1I2cDBMV1Rhd2RyUk9zRjFqbld6K2lTS29lMVlMcVFBMmdsbEZycVV6cUdIV0p1a3U5b2o1VEp0cUtya3MzcENYYWlXNVB1OU1UNlVnNmhWNUxiNkt6OERHbmduNUt2NkRmMDk4WkxkT0RHWXlQTTR2eFVhYU1PY2xjWlc0eXRjeFA1cmZhUnQxSTdhcnVwTzZoSHFBZXJwNmdqbFV2Vmk5VGIxQm5xbmVwYzlTRjZrcjFNZlVOOVdOMXJWcTJJVzBZbXpvMjlqWnRiRHJhZU5uNDJBeXhtV1lUWnpQZlpvTk51azJtelc2YmZKdGpOdWR0THRsY3M3bGw4OExtaTgxM205OHN6ZFpoTld3anRnbmJobTNQdXJJOTJjSHNNSFlNTzRYMVk0UFlNRGFSbmN1dVlEZXpPOWs5YkI1YnhCNW16N0xYMlVmc0MvWXQrNW45enY3THFUazdyZ25Ya25QaFBEaHZiaEEzaHB2QVRlYUN1REJ1T2plVFc4QXQ1Vlp6RzdrTUxvdmJ6ZTNqOHJsaXFEK0xoZnBPSXFvL1VJUXVMVm5VSlp6bGdsWW5yMWdpUFJhWHJWbThyMElMaTVrUG81NmhOc2pXeTd2emZPbEhBblYwVFVGSnRlNVNUa1RBekFWcHNYL3BVWDAvRm9hUEZxYkc3ODh2M1pkVnRGWVBta3dxaVdrM09tcVF4QWxlYkI4UjFiWDNFMFBFN2l3dmJFcUlYQmVwUTR4YlY5UUlxZTZPZXZ6eVV0V0RoMk1PZW9lRnB5Yk4wRi9jY25UZkdkMnVuWDh0eU5Rakg5Uk5LTnkvSXpkM255RXNMQ1k1S2lvNnExRGloYmNuenorNGYySjQrL2JqQm5sNVRyanlSb0lNMUZlSVdEVjlCTHRzNDE4bGUxbEVEV2E0MXFKR2RoT0ZNWnZPVEw2dmUxOTE3dGFkaVpWZWNiRUxaczdVWjk2bXdPMHVpcUNub0JGM0VxajA5S3lOMmJyQzNUT0N3eE5Td2lMaXN2SVc2WGxvQU83UUVlcWpCcWdyOGtRSzdJamN1ZWFpWnIyenlBbVJLWm5aTzdabjV1ZHZTekVrekVpSjFDTm42NERrckQzWk83SktTN09TRTZhbkpBZm9lMXQvT0huNFVuRk1nWCs2bm9PR0QxbmpSQXJwSDdLL0o0NFNVUnU1aFMvTGZXSldMMGhZRzZQTHdEaWhOYWhmZzVkZURrQzJwc21NMDlneExxNWpUdFZLOG1URW1RSVk1QVZxRjJnbDhVYktpZVh5Wi90V2R0S2hwczZJUnMxUXkzOFFCWTQzamhjZDNxbm43RFRQMnJKY0Z4SDVYbUxPY3lIc1ZRTzBTbTdHY2dmU2QrUVhhS3ZIVm5oNGpQRWRGcjRqb2lSTjhrdUxEUS9TRGprMTliM0U5NEVqMXlEaE5ubXVCdXEvVUoyVEhZVXhsWk51bjhqZnZYZWJsTFJxSnA0VVQraGxxNWZzeXRGQ0QrWjZZRFVpWENlTUdyMUllanlUeWwyMWEwK3ByaXpMTUgzdXdua3BTL1NkWmxPakZrd05INllGTVZTSVRNM2FzVGR6Uy9acS9aUE5WQ296TkRqNU5DdmN1SCtqSi9XSlJnUTRVcWdPM1JRNVVseDdWclBYWCtTZ1lqbVE4a3F3SWl1aHJqd0I2cXBrU2Y0bGdEWFEzVkZ6cEdubjJTRkZqN3JBR1NEUlNLYTI1TjFYYUtFRlArUUo5ZEJnL1BORTlaQWZhdkd1ZVcyUWhFWWlFbWZzUW5mSWJQY1lORnBvRHZSRHNNYXo2TmFsdTRNcHNLSVJCL1VvSk5CSWplcFJuREJSMUxkaE9lREhpZC9XSnR1VmloQUN0T1lEN0RaR0N4azRZTElIV3A2Rjd2L0ZncjZmRUpBZlhsNWVVRkFtYVI2WGh4ZjQrMGVFKzJQTTg1akFtV0dSaVpKZk5EVXlJR0JNTjIzTGg2MmdOYlM5QTBUdDFtVmIvMHFYRUwyWldqMW41WXhVN2Npd2tUMTdoeDA1VVpDK1B6OWJPcFJQblMzYmVmUzhObjNaNXFXYkpWUVhISmV3K1lFQmtSR25XZFFZeG9BV3hoOFFVUk0wRG5Sb0xNWDFIWFR5OCtmTEoyN2V1alMrWll2QjQvcm91VjZpYVZDdW1DeENPbGhyQXFFOUxHc2xhbXc1MmFvcnN6QTBQSFRVTXZYd1Z5aU40Y0EyV0lRZ1lEUWZCcklRZElCbE5JK05ZWWhCODFEUUpSeVpKZllYNFNaWWMvWXZtRS9wWjY1bFhXeGQyR2hCYkVMdzFObHF5R2JLWis4TVh4OVZXOWhvNXNYUlYxdGxxRis2dURLSVRPcm1ndXBvRWZld1BWZ2xTYTVNTjNnZ1hNMnZPSndwb1F4bVNtYkVvYXRhSG5raDFnUFpJZzZ4ejhBTGJ3K3IxbTlhdVVHM0p5TnRsaUY1ZmtKWS9NNHRzL1VCRTZtRXpJTUpWYnFYaFpXSGp3WG1qMXFoNTRUQXZkTkxObTVZdFhLbHRIUXBlMzQyTzhVL09wMkZJZmFCT1RoK3ZSSy9iQ2w3YmpZNzFUOHFuZVdGUytNT0R4cytic3JnSVZWVHpsZFhIYjRvOWJPUFQwbVpucENTdVh0UFptYjJuc3lVNlJJUDF1Z21qSUF5SUZFWmpNQVRZUllMOWZCMldHK2dDSjN4ZHRnWmI0ZlFBRHlscnZiSWo5dVpzU2tqSTMzaHZLM1N4b1hVbkt6c3VmdDBweXFLYitzNTZDKzBXUC9lR1pycW9NM2JMOEJERStkSFNKZzZjVlpNckw0VXVsQ3c5enNDdWh0NkJGUUF0V2RYU2VZaDNaVnpnZDM2akpuYTMzdkNpZXVMOVR5ZVZqYXlQU2Zjb3pXMmhBZXJzU082c1NnY0ZodWdReko1R1k0THZvVVJCeXNLOHlzT2hoWDYrb1dGK2VHMjYyQXNhZ0xqS0tRS0VEa0JpYlFiYWtXOW96bmh4T3J5MDdkMWp3NU1HTFZTejFHZ29hK0FEd1ZWTkFjUk93emdBeXE1U3pJSDVhOWFzSnpzYjJ4Q09kS21nTjlOS0c2SFFiYi9ESGhNa2xjbWptQTVOQXoxUmlKSzVYWnVXYkowSGFmTXBlWWlOM1l6bTdzN055TlBsNW0xZUY2bS92QjBTclBEVUp3L2Z6YzdGTFVRSWhPaTB5SjEzRzF3VHY1NnkrN2FxOCt2M0Q1cnZrTVFkNDh0M3IrdnVEaDZmOGhobHZ2RkNLQ3NOaEJvTUs4K2d2WWUxT2N5eFJtWFQ4WDFwZ0d1RjRaeGlMaldDZFJuem1SWFpFc2NEVm8wSGpWR1l5anV1SEQ5T3VvTzN0QU52SHl1STA4OHB6eXh6d2U2WVY5MzVIM2RSMG1oZUNkV1djV0xsVlhNd1REb0F5S2tjYVh3VTBEKzBCVjFCWC84OHdRenhBZzhrVC8rZFVVWVNod01YSTdKOUM2WlhHNXQ5S1JSanJKeEMvUWwxRmdBYjFNd2hkN1QvRDJZY1k4ODlRODBlYU1DSjA3b1FrZWJGbFBnUUtQbVJudThNVVNXbGhia2xaV0c1d2NHUnVEVnUxU0U3ZFltVDJoR09URlE2WW9xWGFuV2pPd0pUU2xlOEMwS3Jhd29McXFvRENueW5SWWFPZzFYUHhvS2hFdUZ4Ni9jM2p0NXVMU0xIZlVjY1dOSEpvNk9sTGg3a0hpSFBQZjBjNDBLV25LR203Y2hQcG1FdVRXcVUxeHlzc2pCRWtIMlJLRVVxQmgwQ2xyQktYQlMvQ1pQRkVieHg1ZXpRSHpnZ0pZM0FNVVpaQ3Rjc3RGckZTUnc4OWdiajhSbndHdXV6MkExVFRualJQd0JXczZndS9KeUNyWFBFZVVDR3I2YUNpamViakhMNGQyUE1jMWl1THVRZUplRTdhOXh6ZmRaR0FNMHBuRXF4djB6bWZ1QzFqT3dDa3FwajZaR0xXQXhnNWFqWXVxYUNQOEk3V0FFbXZnSkpzS0lkMmdFakcrRnhqUDgxV1VzcCt5ZUFlSGhtUEtoYkNIVXV5SGlWZ2pkUk80U3M0TGxucVIrZytydm5EOTc3Skc0VDlUVTQyRG1TcFpUbjJLR0wrbzhFZFhYanNrUFBWeWV1NzlJNHErS0lmc1MyWmpvRUV6Qzk4SmJVMng3Um81RkU0VjNwdGgyREErT1Fsdlo4ejNEUGZjeEhINitLdG1PQS9zYklIQUdxSWY5QzhUWkl1d0dHdzczeFJuc0lCbFNVRHRvZ01icTBXck9QaVFua1kxTlp6bFVIeFo5SmVFUkxGb3JDbDlSWVhPR0wySGhRekxYb3BnS21SczJ6a3ZYZThpcGp4OHZWdDNrbU92N2M4NUxPMThsMG9qMUdZb2E2TG15eVB5QWdJaUlnTUQ4aUxLeXZQeFNpV044b3VPR1MwbHV1MmhncjE4QW5BZnF6R0U1OE1LT3dSaVlUSEs5V0krV3o0YUluRDJNcHRzaWlWcUtlZ2sxU0tDNGJ3S1M1Q0VnZmVQSWZTSUh1QjhyV0lrSHpoRTRDRGNEelFlT2tXMWxIOEY1N1BDZVhtUE92K0g4UlI3NW9zNTRqdnR5TDMwTWxhOVc0STZmTk1qcHVDSUROTWFCM3hQQmxudUcvMHRqOXdiTm0vL1hzcVhTeW9ORlhBN0xBNnZpVUNQVS9oWFUxRUxOSzVKREtocDFnQWpvQkFhS0N4QjUrY3AybHVRT29iNEdvM2N5bDh2U0hLaFYzQmRNMGR6U3N2MVIvcjdSMFFHQmVKT0I1ay92UElVTVhDWHo0K3FEbjNwRWJLWW1jS1VpK0lJTmhBTER2VDUxL3Q2RHF1RXVFcitkdGVQb01OU0o0cEx0N25JL1VRKzhmWDJGTTErNW9QeUlrdEs4L0pLU1NBNTEvU0dQL2dTdHZwUGNLZUdBSVQweFVoc3prMHNtN3dLREcweVpab0dhVzdkcTVXcHBHWjdYQWtjRlpjM096dFBtYk9XV2Y0TTNUNERIN1FEOWNxQmxBMURjOHEvUTh4Mk1yN1hqakp5d1BYWmkrbkFkTitzcnpQOEVITWFmYkhkakFjdXROWUJyclJ5S3k1MnMxcTVmaG4rUzBpdUhIM0p6SEdlOElIQXRHZDRSR3BxR29JYU9uRjBzeTdrWmNYbzluQWkyTjc4Y0JncTNhNnhUalRHNmh1VG9Rc0M5TThCdW5GcFlHTGMzak5zT2g3Wng1TE9QS2h4cm40eTNSenhOQ1pxcnhOMGd5YjlJZ3FTSk1JS3c2VXlrRWtSdmtWeEtFSDVXUkNpQm1TaGlCMEdFRU1RQ2dzZ2xpT1VFdmowbk5oUGtNb0xZUXhCekNXSW5RV3dqaU4wRXZrTW4wZ2hpQzRHNUxpS2VJQllSeENhQ1dFM2dtM1lpazhDMzdFUTJRY3dpaUVLQ3lDUHhkVHRSUUJCRkJJSHhIQ0NJY29Jb3NTSU9FY1JCS3lLRElBNFQrQzZlT0VJU0p3amlHRUhzSS9CRlBYR0dJRTVhNFJ0NllqdEJiQ1NJU3dSUlRSSlhDT0lpZ1MvdGlUVUVjWlVnYmhMRU5TdmlMa0hjc2lKeUNIeVJUendpaVBzazhaZ2dIaEpFRmtHc0o0am5CUEczRmZHQ3dOZisrSmFmV0VzUUt3aGlIVUdzSXJBd2dLZ2lNTWRJbkNPSlZ3UVJUQkN6Q1dJSlFlSmV6eU9KaFFUeEY0SEZCbGh1UUs2Z2lWaUN3RlRxUlJCcWdrZ2lpSENDU0NZSUEwSEVrVVFpUWN3Z2lVaVN4TlVGRXVRR0RaRk9rUHVhRVhzSjhtSXpJcG9rUDZ3azd5dE1xaVBSRWtzbzJoR1RpZW00TitQSjFWWWRzSFFnQ1VzQW5scDlWdWxWelZROVZTTlZGMVdmckFscjNycTc5VURyUGRibnJLOVROcGdkRGFUQ3FVUnFGdldHM2todnBYOHpMWmdCekdqR3dEeFNVK3E2YWg5MW5Qb3Y5VkgxSmZVOUc4NW1oTTFtbXdMTUZqNjBNYkVlYkNRN2s1M1BackFGN0RuMkEvdUxzK2JxYzZIY2NxNkcrMmJMMlJwc0MyelAyTXAxbk9yMHFMT3R6b0U2aCtvODVqdnlZWHdxZjRTL3h0ZldiVlhYdDI1dzNlbDFkOWF0cVB1bW5sdTlUdlVHMUp0WTcwUzlTL1hwK2kzcWw5Yy9iU2ZZTmJUVDIzV3djN1ZiYjdmUkxzL3VxTjFadTJ0MjkrMGVhbXcxdkthTnhsM2pvZW1wQ2RkczBKelIzTkU4MGRSb2ZqWVFHbmcwK0t2QnFRYmZCQ3VodnVBa0RCSkdDT09GY0tGWWVDbjhqNzJ0dmRiZXhYNlEvWFQ3VlB2MzlzYUdkRU5kUSsrR2t4dHVhdFNta1d1anJvMEdOQXB0dEtUUnBzYWRHdnMzVG1pOG9QSG14dVdOVHpXKzFmaUR0clYycS9hSTlyejJuclpXVjFmWFZqZFpkMC8zUmljM3FkdkVyVW1mSmdGTmtwdk1hMUxhNUtuWVFnd1U1NHU3eEF2aUV4SEVmeVZPYWlnMWxnWktvVktTVkNDZGxsNUpyNlUzMGp1OW03NlR2b3UrbTM2d2ZySStXcCtwdjlGVTNkU3VhYk9tZzVyT2E1clQ5RnF6bUdZcHplWTFLMnAycE5tOVpzK2F2V3YyclpuSmdYTGdIUm82NkIyY0hEbzRkSGJ3Y3ZCeEdPWXd6bUdhUTdERGM4ZkJqaHNkTnp0V09ENXF6amYzYmg3V2ZGZnptaFo5VzhTM1NHOXhwbVhybGpFdEQ3YTgwL0tuazcyVGg5TllweVNuRFU2bFR0Q3FVU3ZQVnROYXpXNjF0OVdUMWo2dEI3UU9iYjJoOWZiV3BhM0xXejl0TTZMTi9EWTMyL3hQVzZvdDE3Wk8yMkZ0cDdTZDAzWjUyK3kyTjl2UjdlcTMyOXJ1Y0xzUDdmNm5mYVAyTHUxOTJ2dTJuOVYrVmZ2Uzl0ZmFmM01PY3o3dmZNSDVrdk1WNTJ2T041eHZPejl4ZnUxYzYyenNvT3BRcDROOUIzMkhWaDFjTzNUdDBMdkRvQTZqT2t6cTROOGh2TVAwRGpNNnpPMndvTU9pRGxkYzZyajR1ZVM3MUxqMmRaM2h1dHYxblZzak4yZTMrVzRIM1NvN3FqdU83YmlrNDB0M1IvZEE5em51Qjl4ZmRXSTdPWGZxMENuTmcvT0k4NWpyVWVweHJiTnpaNi9PSXpwUDdieTA4OGJPbjd2VTY5SzR5OGd1TVYzeXV4em9jcVRMeVM0M3VycDM5ZW82dzlQR3M1Rm5LMDgzendUUEdaNHpQV2Q1eXQzaXVxVjBPOXJ0bjI0ZnVuM3A3dGg5ZlBmQTdqTzdyK3Qrc3Z1WEhxb2V0ajBhOVdqV3c3VkhyeDRqZTB6cEVkTGpjby9IUGQ3M1ZQWFU5dXpiTTdSbllzL2RYczI5UEx5MmU1VjVQZld1NzYzeEZyd2JlamYyMW5tUDlsN292ZEo3ai9kQjd4UGU1N3d2ZTV0NjZYb043UlhTNjY5ZW1iMnE3eTkvTDZlL0orKytoOVQzcXJ2MmNuZmpSRk4zK3IzSktNanBrR3BLWjNqVEloNnROUC8xU2pjWS9aTEo3MENwSVBXMGlKclIrMHgvVVU5cHhLRG1RbUJlUkdsWmZuNXBhVVJCUUdCaytHbTJxZHpLQVB1VDdZcmxsOEl3VmxNRkEreUhzVHo4aFhmNExpK2c5UXZvbEV5K2xac0xVSitPUkswcDVPQU85U3JaZDNkWWFGTEp2c2VnelF2VWlNNkQxaFRPak96dmlHMFBZNGJ1anRnT2crWTB4TGtMME1SU3Nnbk5mMnhyK01Va2s3ZkE1dlkvdDB0RStJbHNoQjhNMU4xMjVYbU45dFd3dTRqYkk4MWZTVUYvNWxoSzV0UTEwVUFVTkVxN012RUpZalBWUHpzMFk1QlZhcmV1cmJTdHJ3ejlrU0J0LzR0Q1E1Z0JXNk5PTHo2RHJLTWFiZWgwdFJYb1o2b2RtTjd5TStIQTdxSWptT1Bzd2t6Y21KaFhwSVg1NklnUW5CZzZjWjRFWFpoamFidWlRN1U4dkpuL2ZMUUJFbDltUHdlbmwvT1Q3WTYrZ1dadmF4UkhveVBBUVY0NGdOWHNxSkxYbzQvWTA1ZEFDYWl0TUZia0lYVDJkM3dxb0QvYVhRT3VLOURnQXJRbVNqNW1EeDFvNUE3ZFB2eWtvQTJEZXFCQmlJVzZ1YnVvWXdlT25iaWgvZEhsQmxKMWFEMFkyUXc4UEtZZ1RObzhlK0ZpU2xQV2E4eWtpUzVhNXp2T0lONi9jT0RjS1VtVHFDbERZOVlMSS9FeCtsRDJ2b0xkK3V6dDBCRHBseTJqZ2tMRFlxZm9OUGxENVduQzhkTGR4WWZ5dy8zajVrNFBpWlVDb3BOM1V2RjdrM0lLdER3cXRRd3FhUmxVL2d4NzVLUHFDTndXVU9JcjFBNnNrYlYwclpweUJIb0FhS0cvRm55dWd2WWIwRkwvQ3hUQ2lXNm9IVXJVNGxMZzlWRUZPM0U1U093STdSQUYxbEwvb2RSM1JGOUJXdVNqUmYwSElxMERvcVZyd3lqQWlTK2hIZUJ5aytDWFFWWW5rOUR2clFxeVQ0dnRVVU1hY1dVeG5hQk9vRmZMTzJQdmZudmtjUHRrank5UXB6UUc4d0dCRlAva21nRW00bU1LTHJQd2srcEVtb2pHb3VZR0dHeUFkcGhidkMxTXpZdXUySEpLSE84L2Rlbzg5UWptMm9aMzU2Q3A5bEp3K2JncG9jb054Um9SVGMwd1FPZGs4dXBkWVJybVBpcUxpeW9yUTRxblRRc05tU2J4QVZ2VFJYbUtjWnJRbEVaZmZnZFNQMmtlK05RZmNzZ1BzaEk0cUFCT0JWM2d2dkFrL1dKZXFiUnZaMjdtWWQzaC9Ta3h1L1M1Z2VsRHVtcTdwZzJKQ3BSaUVxTlRwdWltUkdYdVM5SkhsYVplZktKRm5IMm5kTStLZ2RLUThtdCtIM1Fmcmg2OFdLNnZ1SkwrK0xuMmVkcGozeXZTUmY4QkI5dm8ydlQzRytLdjl4Mlk1dGtKRDAwZHpKV09NQi9UWUdpZUNLZnRqVTBjbWJUK2c4YzdMMVYzQlZmVENJWXZYZjVEbnZDZExBRTF4Rjlsd2EwZmUvSXl1d2RzWUEwT3hRNWlhNjZJOERGUHpBY0hBUzRqQjJEQkFjZ2ZpSlNiSStlSHJNbVdnc3NKQXZLandRL3lLUDdrQlRFUEtGaDNsYzBiTEQ1Ti9RS0xhOEgrRzNrSUdzT2FJNnk4cnhvVER6a2hCelFIZWI1Rk91Z0tUY0NxQm5UUTJPVTVFbnlHeG84UDE0UGRwcGVQZ2RkVkZjeWVuYTFIdDlBRDRkN1p5bXZYems3ejhoNDV0Zi9BNFlmdlNQd1MzTFBTNzZTYzlvZzFwVGpBWjNvNU1weGo5OEVMR0F4ZFRsYXErV3ZuMmZJZEloUjJZcCtsZmdmaE15ejZZbGNNTEt5NHhwNHFZS0VweklGQVZPYzkwcUVtbDFpd3VYOG1tWjB5YU1Db3ludTN6eDYrY3ZuYzVENFNqOGJqY1hiSWhFbUthNmVwdW5rblN0UzRMSVBYVVNLUFJpRXhHWG9uZzEwbWhGclNuOTI4THZqdGp5bmZmRXFjRk9qck8wODltcm04b2VZME5OWldoNVpPbkJZZUVTaHBHaTJEOTdqMHdqMWk0WFR4TTdSODkrVXRLUmNzRVhHRVBIazZ1d3Z2cHN3M01oK293NTl2SDJIaENJUUl5OVl1WDdOU1c3SXRQMytYZEhBL3Z1SXFQLzFRKzZYYlI5UUt0ZlZHcE5Pc2xiTldwMGxBTGFEKzJyUTBNME43cHVUTW5kdUZrOGFIcDhWRUpFaFRJNmlSL29tVGhtdlRWc3hkTVZ0S1FzMlhzQVdCQWNwbURFK21QUDd5R09iZTdQdjAreE83OG4vZXZKRWJ2TkRVeXE5QkVyNnRlUE1UMm1waE9NSVhNOGdQUmFCK3FDTktROG5RRGJXRDJVOXE4MDZjbHFaVlU3NGoreWNQMEtGeGlJRUcwQk9HWWJjZWVFTW5JSnNqeDFZVHU0MkxuNzg5YSszS2pTdlc2S3RnQmRXUm5qK1owand0VDUyYUdhaHI2dElHTldweHFkL0xpa003eS9mcWd6Y1dKeHpYdWNKTXdYMnA3OUJodXJHSjVTY3ZsOTYrZm5SUDVEZzlQMW9rMjdJOFdDMy9BZ0dmWWRJWHUyZkF3WFN3ZFFKZTgvM1phUkd6WGhrTU5IcjVCT2luNHk5N1orazFjdlhPaXROM3RhRHE5Z2cxa1ZCOVZDWEFwQi9NN2ZLZzRTUDhBL3ZwRVluT0N4QUFkb3ptKzUweXYyRkRwZ1QxMGZPUW5ncU12QjRvc2x5NU9tMmVLc0JBSUlBQjJ6ejlHQmJOd3YyWFlEVE9sN1Fjck9RMHNOb3V3amVvcndKL3NCTGt0QXgyTmJJU1Z1SG0wTHcvdTExczhFek9zdThobnNjZnVCSlF3V1NndG9zNHJ6ME9sWUVLbGVHWU8wQ1podWFLc0Q4VnJOcTlnNDdmWVIybzdNcHh2eXFOMCt3Qm9Wb0htTTBNV3pTMk5YTFVJUjVadjRCZTBCZHNud0FEMUkzKzNiTDFRQjJrd0NZWVdYMUMzam8wQlBWQ1RmQlF6WVl1cUFrTUJlcDIxWWxjdlNabGd5dkZ3M0xja05OQXdhRmszTzduVjFtamt6MityNmlERHFIbmNBalo1b2c0OVRrNnpmREl2NWdGWGpXRDVZK2xBaVZETXBrRk5oQitoTTJDQ0FGSkwxMUFEN3FYMzhGT2t1ZmgrNDZGVEo5QXY4RkRweFQvTFYxaGtFMENybXBFTVl0WC9EWjdhRXVqZzNKVEtJVXJGSEtqMFZuMGhvSTM1cnI4bUxkZktmNnN3ai8rZ3h1a2t2ZmFBNDBleVA4ZzIxeFJub2hiWUNPWEFhY3kvbEJhMlpsQnlhWURhS1o4Z0VMdXZ5Zml0RzAweEpxMlVkOW9tQzVuVXFaTWhvY2R1SkF0d0JIVzJOM2VJSWF5WkN5cmdxNEFEdUozM1BYOVB5RHVSemtyYXdTSWcvck12VU4rL1FkTTlmZlNiMjhtUUpPYTExQWY2cm4rZzVybzBWYmN1djAwRDlXQmhrTUo0ajdXVDd4OGVWdmVLZWxGdThmWE83K2xUbDhvZXY1ZDI1MkZ1dlplckUvSzJPZ0FDYkhRc0dzL3NFSDIxS3lJa0lXaHVqKzN0SG9lNnVPYTgzOUE5QS95R2RTQjFaaXM4bkI3YUtKOHZTdXBUOW5WOXo5cndkYmpIUklsdEJ2M3F3N2t2NlE3L2hBZ0dnVG16aEcvZ1lNbSsvWFM4MTlTZ1pCMy9pQXY0UDZ0VjNBY2tVdDdzbUNGTjhJM1FKSHdGNmIyYS9tTkFKVHBBYUpncHVrTjJNcHZHSDZXU0c3Q05IaWIyazZFZmxFc3ZBWlhBVTJTajFMSW5vWnR2eWRTd05Pd1E3bWowOUM4dkMyS05jNkE0UUxxZ1NtSzZ0UEkwNVNCSE9RTUN0blJNRlhKWFpjR2J6a2Z2RTM1Rk5TalliSlNzaDRtVld0Y2tsTk9nTGdNMm9LNndoWktPWlBOUVQvUlBBUVVOS09oRzJ5R3JtZ3pCYzFwTkFkK1VqdzB3dzNhZEFUL1E5Vm9sajhua3ZJLzlnbFlOSWM1ZURpQlhJWFhTRzNjQ3VvYUZQRXYvbFlGNG04cmZGNHM1TEdvMWhoSUlTdWFQOHRDSFp3M0Z1ZjlOUUpGdUlMNjkxYWtkbUg0ZmJLTkFYNGxrL0lxK0M2Z0NmQ0xhaytqQ2VnWEJUUU45ckFFQkxTRTRndmF2aWZsN1cyRjk2YjFiUmtlaFJXSjBFbXVITW1Hc0RORlRXVi9WcFBTVE9SL3p2bnE4aHJPZllYRUl5TFFrQTQybWxRWVlYK1owUnlka2xNVmZWMEhEaTlBQlU3ZzJCMVVxS1gzNkxEZ0pEMGNRelNqU2YwZHhzZ2NMQlhhamhucDFXdlUyZmNmenB5NmMvL2ttRFlTWDVINkE4NzhKSXRMUkNpVjlVSXFpMW9CaVZUZ0NBMXUvMzF2bDM2OXFPZS96L25pV2dQbmNjMXhJbXdCYTgxUmFJK1J2VGw5N3Q2OUV5T2RuY2NOOGVvKy9zSWJTVmJMQ1FLaTBHRTZOOVd2eEVPSHhIYUlRVTJSMDF0a0JVMnZIeThvMjZYWHBDYXZpc1JDdnZWL0ZWZG8rWGlSWE13K1lGWGdBc2Rhc2NnSjMvV1NwYUpxSUF2VVowUmgwVmRaZXE3RS80UDhQNFBkSjhpcHhlZlZNckNCbFlCbEhhVnhRdXN0TmQxQTBNSGdxMUFIN1BYeVVHUTlGRXMrU2cxVGNyMTBTT3ZTRk5rajhaMFQyTjg4bW45Z2gzNEMwMnJxbEE0RHBsU2VYeUNCQkxhQzE0U3FaMzlYbmJ4enEycHNsODRUeHVMcGZSL1A0NmJmSVVHNWUxTERWRXlWMFZBaVhGaFplT1NTVHJuSTFlOWlSejVIdGhQR3pQQ0xrS0FZcVgrSGdacmhVMWpJcWhMWHNET01MUVgvZ29peThvTDg4amtpajJZaC95L3lpMlRZZ2ZHVmlIY0RoY0JaaWI2elo2NWNzVmhxeXl4ZHMzTmhpYTdtMU9YWGVqa2ZxWmtaNEIzSjhvZmpXTmhZSmNvNThpd0JPZE5vT0pwSXlUNkl3UlV4MElRNWZ4RWMwV1R6SmJVZkZGQzRpaDBHWTVnWlBZeTJONFlwTFdKNDJSYjNvMW1ONnplN3U3alVlS0R4djdYbU1ZeXloM0xtUXNtaEMxZHlmRWRMNkJqUU9IeSs5RWoxNVgxK281U3dOVnpIOHdtRXpxYzdEaG1WTkRoWU9qTjk5TDdCdWpIRHBrK00xV3NlWDBBcWZHL00zMlR0ek9RQnRhWXlXdFRjdjN4U1pQZ0Y0bTFXTlVia2o0cHo4UVJsSUIybmZraGk4VHowVDhCRnJ5RHIzMTEzaXBMbVE2WDR5WHdMK0FYT3ZYYjVpbzlETnJCRkVkREp1OUVvd2RnVnFRYmgwUzJjT2FVY3p5QUhOMFNqcGxnUWlLeEJmKzM0M29QWmVyU0NRVnZrL3NLYnFyUDM3NTNDMDIvTVVDK3ZzWGo2OGNnRzk1b0RkdEVSRWRkOUhVenliR0hGNGprcjAzU0R4MGFOUzlScmloK2NGQ0dWMFZ4L1hYYWladk9XWlV1M1NIeGc2ai93NGpWWkNTUzBCV3RWSGpUcXc2SkdpNzVDNlZkb25VeitCRVlGOGNaNmdrTnYyaTh4WXJ3VTM3d0dMYVZkVG8rdEtkKzVmdFU2NlQyemJISEtrbGs2djVUdEIvVmcrUHoxbXZnbzdadHJqZHpzb3FoSmtadWN4QkxSeWwxaXprbFczcXdNS1U4ak8vUVpDZkNaUWcxb21HU2FSWUdhNXVIR1NSYStLUmtZVk5NS2FwVGRETnlVUkk0R0ZyNUNIZlJWeVFndThpd0tzWFFiVklNWW5JM2ZlcExkWkErTjZRMFpyNkh4eGd5Z1VPZEd5cTdlRDFhQUZ5eWdNS2ZhRExuTVQzY0R6ZnlNeGtpaW9UZGFSUEhGSWptWTVSUHhRYWJvQ3lrUHNFOFY4MFZvODdIQnMwcllJNXc1TXIydkh1blhzK0RKWEE2dUhKd2hYVW8vVUhsWkM1NGJSTlNVNlRkNStpaE03Um1va2VIWGtPUUhJZ3hHN1lWZlExci9PNFRoTVJZYmpBVnV5emJDcU1sN2J1aWg2UVlXZVRLRERreTdsQ1lOVGcyZU5raUxQRGVKb0dkdUh0bHpSdUlmUWRDbnlFOTJtcmxRQ25PRmxNS0MrZm02UzJjS0xoZnJCMVpSNFVrUktXRzZHU2xyTnM3UVQ5MU5hYnd6dzhQWFIrZ0dqd3diRktLL01vNHEySjJYVmFqYnRtM3gvTzE2ODBWQUFCcGpNUG9tazYvd1VNSndPQkFoSHNYclEweFd4dmZSYXhVODZDMitQeThDQWN4WXNJWkdZRFVjQ00yN3E3SzEwTzRqczNMT3lqbHp0S01DSmd5TWx4emgxVUV4Mm0ra2hQclJwM0p6TG92UUVZczdhTTMzdFB6WitjWGE2c3JjSTJjUGhBMWNJZUd6Ri9WNHljUXZ5RVdIK002ZEhQMDNSbXlKMXZNdmo3T1BQc0dzV3RXakx1elhjaEdXbG9oeUhqUVhucUxlZDZEM1UyVERnQnRrS0Y4LzVJQldvNWF3bWtJNkdqeFFSaTdiR2J4NklTL3NYbUV4a1JzYmZnM0ZSSDVtTEJWTWpoOWxSNmExNmZnZkgzOGRoWDAwcG53azc0TU43aTJwa2xOaG1WQXpvTExYQWFsRkZSV3hiY2FlL2Rvanhma25xd3VEZkhCTHM2Z2ZTM3M5UW9JT2tVNjlFVE02WjhMSkVIMVFjb0R2TUszTFpkKzd3ZExYY1ZUdXJNeTRLTzJFa09oeFE4TExya21JVE01bFY5MzJVclpac3ZZT01DZGpxc1lWNjB1eXlpcXF0YWpUQ1RFeEtWVnFlZktNbUwwelErSWQ1UWNQUlRKdnVhaktheS95Y0NmMVhzMVRtUCtzNXA1ZCtaUFhyMlg3cDVxTUFhSW1TS2FCRmM3dUNRbGZyMyt5bjZxZU5mcHljeDJ5NnVTQldHVHozQjJzUDUrNWZINjd2dHMrS21aK1hNQnczYWlKQisvZlAxWjJXczkzRkZkdEZtRnY3U1QyT1hRMndQZ1BwT3o1V1NWblpiSnJSS1UydWZ2dG1udGsrUk53ZWE3dzVuWlBWZVdaSXZMN2p5RDRpVDEwdFFpSHpSSmhxRVdUaEkrMEIzU2dqbWJtVjV6UzNoeHhwb2VFV3B0YVBJZm0rK2lZMndLb2pqS2x1d3hoNFltR1FEMi9ta1gxNFkxeWIwTHVWQzVNVk1ESVN3YXcvTlBENzZIN1d4Q1NTVmowU1hVeGduV0E5ekdpZk1tQjlZQ1hNMFI1UkhPV1I2RkZJbXdZeS9MZUxMUlY1Q3NuMzVDdzdOMjdkeXA0SzV1RWQ3OVB2ak9lL1BER1pJVzNoMlo5VUNOazlkb0RDUDAyMCtwM05EOU00VmVuR2FBdVVDUU1lNlFDRzRlK1lzbDVxZ2M5Mlp2aTBXU1pTQlRoL1RoMk9LdVFwNloyTWdzbmRpaUN4WTZHcDhsd0t0a085SzlsNnhwTnUwV2k1aWJrb3RCMnJHYUp5UW50Tk4vc1ZDKy9OOFlBVlhmNlluR2lPU3Vzd3JKSlRST2NlY0FwVklqemFMTGxlRWgwWUdXMUdhdjkzVzNKa0h4M09jNk1ONTFiTlpvMkoyUk5jMVp6QXhCNmhWRXZORFd4b0o2SFVyNGJxV1J5MnkwUmdxREVVeHpLVnNzUlUxbCtLQXNuNWRmNzJkSGlhMFdxMGtIVU5NcVhJenFMbU1HNjlrZXloK05zWWJmOFZ1ZzFqOWJZOVdZMXRvT1U1QmQ3UmRCQ1krZ05qVFFTYVA4UzRmeHFVZk1NaE44WGhEWktCdUR1azdJVHB0RVArWjR2QzRUY1JZaE55dHEvYjJkV1RzN081SmpvcE9SWVBkZ2ZFMjROUDluUFovallQa0hid3ZjbVNtalQ3N2FqeEt2SWg0S0dOTnBpZE1ZeS9xMTVCN1M4akJWWnJLOTkzUVlrakFCclVxNDh3djZLc2NjcUdtc1pVNFJ5RUcxTkF3TURLTmlQQnRBb0ZJb0VDSVhIRkhyTThKQ094OHg0MThMRXdkNUhLcG5HdzdhekVKeTN2dm14SDZ3YWoyRlJORGdoSGZSTDFVZE5vdmlGSXVUN2lwbzNzdjIvak5CRFhDaktNZE5ZelJzWS9YczVEdnF6TjFjb3N0TkdrTktEMWJ5U1cvNkp2Ym9YeDNhRHh1OHdSWFJRLzZvNFZZUVUreWs0Qy9URVJPa2hKb21iZkVVK1NZUjEwMWgrSHZ0NmhWbE1YSTNGeEM3emV5Z3hOUWF3UzdaYkN2V0RnUStGK2hyUHBWZkZzTDJ4aFlVNU9ZV0ZzVGxoWVhHeFlSTDBzc2R4UllWN2NWeGNUbGlvRXFjNVU0UnJ3RXdSbnl2Q1g1Z1ZoZUEzTUJ5c3lFOWdhK0ZIdjlpdkV0R3hyczVQMEMwYXgxa0pFQXdOMzZDR01EeUR4V3pTUlBiYU10eDZBTERWTkpJUC8yS0hzR0QvKzV0Z0VPZUs4QVBUNHY0MDAyNEhISkJmWUVyY1IwV21WZzZZblRxdFRCb3NZSGFCeDVnVWwwZGJZZ3NzTXdjbllGeFhmbkZEV0ZNcjAxb2w1Y1JlRVEvQlJtZ01vNkR4QnFpcjhZQStaanJkczU4cWFpNmc1NllRQi9INExZT2NoRS9xUXdORnFBNDNsQ2FJWmNuN1dFUWU2SGgraU5UWDVkR0lheStweU5PWFpsM1doWWhBQkw4WWZsRi82NThlNS91NlVIbWpCMjhmcUpzZzZqRWpCbDdBUGdPdXRIUmVTcUdFVHB0MFZGVFpqSlBYdFhLcy9SKzltYUNnRGRzeE9VL0xPbXBmUU9iWUFWcCtJUXZubGI1Q3YzL3QyNGtMV1htajB0bm8zeG50eEZraUhxNU5lS1FnUytrcERMUkU0bFZ3SDdoZ2FQUU5HZ1dDTGU2UDIxVnhDZ3R6bFhHL01PNzMvWFlpTkp1b2FBVEFKcHg4M2NMWmFKcktLZEI3UC9zRmM0Sk8zMkQ2Tnl3dUxtZGh0UURUTFd5b3o4Q3BmbDc2TFk0Q05QNzRHdXBDM2RiL0lLMGVpZERZekNnNzBmenoxTmY0QTJ2MUJaLy82S0wzbzhCbUR6QStZS1V4eVBYaHZaQzVlZE8yalZKMkJsVzU3MkQ1QSsxSGo0ZW9FYXJYckJ2cUlKblNGUEVzOC81VVJmVzFnbUQvQ0VOQ1pMSVVQeE4vNGFOQ3gyaDdubzA4YXBEeTBpak5vWUxVclNreDJvVGsySUJ4TXl2MkxaUGFKbEVqVjFSMmhqbzY0RTQ4dlhwelN0V3d2ZnFJREVwemNQcW10UFhMZHFwNVYzR3BIRFdTZFJWaGxKRW94RXpUTlFNNFltVzVJRG5hWGVSRDJKTi94T1NZbDlvNUZ6TlQvbk9iaVZnN0I5bkxpVVBGRVBiaFhiWVMxRU9YaTk1QWEzWXJHWUtVRERvQ05aWVBCZUVNUlZkZVhXbkdRalA1dW84b2M4dFpVTDBsbjRnd0JTaFlVaUlhWThGTG1EUXpOS1NmcnMrSUUzZVg2T0VYdldMRGltMmJ0T0RjNlJOcU0zVDQ5R2wrVW5ua21IMmVPbVR0MnNkOWdmNkxnVHEwcHFUMG91NXlYbGhnNnNKWjBWZ0JzNUVmMi9OaVAxRFhuamx5T0ZjYVZua3IvSUVPcUwrdlA5dWpOOVVNRVNaTjM1OWJ1bmZYZ1RWNjBHVlNpVXo3Z1ZFakpGZ0UwODJhUW5kMGowb1VUU0crQXZrYTVQLzVpWmtxOE1KYjRQcG1mY1ZkUlY4enp0M2VjYTN4ZWpHVlJicC9ITENHbEQ1aUFzWFBaVFd2RmI2ck5hdHBoRExrOWlQWnVkZ25qeG1MNDFFbnRMb1ZHeTlleTJZZjRFZ0k2WXdqRDZJMVN0eERBOWpIaWNITHhVbGdnNmtFVEh0Ujgyb3U2b2dldDJLM3NwcnFOWGkyYmxlNFZ4eHdnZk5qY1ZTNnFWSklFVEdYOUJXUGpNSWNhRnd1ZE1ieGtHUTZaRW40QUhYdDVrSGRZR0NDOGZKMG4yZWtoTEE5MHdzTDkrNjVKNFpOajhQcnhRTnZQOU1MekJIaGNUaENVMzNnTjZVVWZwajJGZkxmd2g1ODlROE1aSU9OU2w1Z3RCRWlieVByQ1VNcSsrOFpuZDQ0MUsxb2JtbGFzYUZ4Qi8vY1BxQ3JMZzdmNzc5OVhPTjk4Uk16eHV1UURlSTZvN1pJLzZNNXRJRE9yMEFEcnRCaS9QZStkL1JJTUswVStnNDZWbE56K2RqTld4Y25kM0FaTXFtUEhyTS9wM2FMZnhnZ1BLVXdCM1J5cnNJQzRVazFVcTRhS3E0VU5aZkg0TjNKLzlCSWRpV0c4alJNaE12Qkp0OFdMTDlBb2FtaW80SnBFOWNaUjRPbnljOGNmM0szV0F4cWM5SnBYTG81Nm54UzBTVnJoRlhKbW5kakYveWhlOHh5TVJibjhJQjZtT3dYd2t6NXVPemo4d2J3L1FUNDJBdVJvQktPaVhtQlFSR1JRUkw4dGo0bTVtTi9SSkNFT3FPWmdoenp5UlJEODAvaURibUtPazVlTXViWW9GeGVKcUFXVFJHSld2ZmJOYXgwbW43aWtJc1RqbDJra2d2TDVoelRRY3VmUUVLYmE0blZRWlg2RTVlSEhoOC9pTm9SNHJ0NU1yNnhScHNFUlhOeHg0N0Y4ek1sNUlNU3FUbTdGbUpoRERSQkhRUkQ4dW9OTS9UUUR4S3BUVW5yWWlPMWluS2p4QzlpTlNHWUtlb2s0a21uaytlUFpIRkVJN24vV0J6OTBqUy9rOGpQTkUrU2l6Z2RvanJqV05oaldtQ09Cdm91ZXdQVWc1ZUxnMEN0VER5K3ZZaVg2ZzNUdGZZc1hyZTd4R0x4eXlGUlV6VlltWGJQZnRVdlpJK0tZTEF3OGx0S3hDUzI3OWpJb09uS2pZajYzNVk3eFVxY1gwRUp4SEpMb2U0YmpCZUR4QlRXckhXeWh1WHZXaTRFeVM5SFdMbkNmQ01JNFF4MHZFblZNcWhqWHdvS2tTMTZ4YlQzeDlwZ2I4c3B0SWZoMFFnTEwvNnVSSVJRZTdqTzFKVGh6SzZCRkp4SGFvUVk5eUNxSmZPaWhFTGJHTjZvU1FXNlZRRGIrbU5yb096dzEwbU94UnQxd3ErTDl2MUZ1QUhXcG9GZEdVM094ZUdkQzlyakw0dWYrUFpwd1lYemVrMmtKMk9LelJTOVdFbFQya2ZrNVNITDJkcnZ0OWtIZjhiUmgzMTBQZjlVcFg3VTRSdFJkM1h6V1gzclhLb0QyMjlBK0RnLzZkVFUvbm5kZENaWDYrNGliSUNna2VKLzd2Sk9yeEQvM09aaHdtbW00Y2tMMTlDYm5xeUZNOGFiYVl0a3V6L3NzY2FsT2dqUFdhUXhuZXZES2w4WTVUaW1nMGJ6d2ZZdmFLenhCSjM1TTdSQStheWVRV3JUZHZOMUdqNjNZTXlPR0hNVnZNZEhtd1RXd25mK2JVYXRjYm1OY1ZiQjl0K0RoRlJ4eFhFUmJQdXlMZVdyeWlaT2dxWXp5eXNCbkpQY0g4UXFaL0FHY3NYemFoeDZBaTJlcUdDSVhDRjhPWDdyN2twOVZ6cDJhWExFQk4zRTVMeDlTM0hJZStXSlByVTZIbDJScjV0eFpSbXRoS0E4ck5TWGwxZFNHcGtYR0JnWmVacEZJWEllM3Q5SjJHaHM3Q09pblNqdUliZ21remt2VmVDRTRvVHM5RlZydHVqdk1Fdm56VnMyVnhlWGtKNVhXWkYzWUx1Ky8xWnFXdktvRUcvdDRCT0JWeVVlV2N0VnUwWE5tcjF5bGJKbS9mQ2FYZE9OUlhTUkNKT05Rd1RFMHVOUksrb2VEU3VobFlBNGVyQTV4SWVKSHFJM0N3MFhmT3Bua0J2VzJrRmRZTUFKR0UybC9IQ05VTU1zbWI5Z1dScXVkWE9SSGxZOHFqVVZPLzNOYUZKTURZR1JHK0xtWmVDTXZjcEgxQlR0MkxocXZjUUR6Nk9waWxBY21zUGl6NlI4QnhZTG4wMmJyb255UDByNDEyb2wvSy9QTlJGbHkwRjNSUmdscnhYMml3ZksxaThXVVpic2E0QTh2SVVhUlNFZ0o3WjA0NGJWSzdDVzdyU1FvSUFGNmpGTTlkb1h4OEJlZXlyc3dHUy9xTWhRM09Fc1ZOOEFYUXpRQkplNWpJdkVsZjVSN0oyS2l5ekVRcWZxZGJpSW9EMGRWb3lMUklWSXZJY2NlbGVVT1htRFVCcTNOM0RlZ2o5NmFTV2w2N0FhNEloRkhtWTF3SUxRUTJZMVFEVFVmcjlZVXJadXNkaEphV3V4c1VrL3NST3FZd0IzQXpUR1ZWN3NKN1pWaEtYVmI1V0pBVzAvcVdBVmVBaFFEZlhlb25yUW9oVnFnZXExaDNxb211Rkg3ekJBeXpjdzZ3MjB4Rm05UHFrT3d3TEJHYWUxL0FRdG9kNGJuSCtXQmJSc2hWcWlla29TdnVTcUJNSWd1eWVURitHd2dLaTM3WUVHK3UxYm9FRGQvZzJpRWQzZUdha2xYdTYxeFFCT3lhVHgyV1ZobzRpcTdiRnozcjRzSWo4ZzBLSWxhRlk5d1BsdXpIOHh5Z0JKTDdKZmdOTUxSZTcrRHppOGVmMFBPTmFBNHh2TmtXZlFURjRrbE9lV2lWSDdLNlFPOWk1MytyMTZkZmY2UHpYZU45dzZldmR6bGVSMTZLTlFubGNtUnVKMFRmSXpkQTIxd3p5V3NSbTB3OFd3ZWw1dWxMK0U4ZmhHWVJVOUJRZDZZTzl5dDkvTG8yVTdDdlpLNFh0TERVZDFyKzVoaEY0MzNDWUZHc0xqOUFWeGdUc202ZHd3Y2oyUC9NeDg5VHpSNHJPdlRXUGhuN24zeFl2M1JUdm8ramRvL29hR2YydmM1V25HQ1VKSC9PVkdJV2kvNGprbGR3Y2FlL2pyZU92RGMrRzdQV2I3K3M2L0wxWXJCYjMrMW5TQmRmOHBrbU9OOHcyRVYrR2l2TXVWSFNzVHNhTHMxbzdsbmVGVkRDc1BiaWwyaDVlQnJIRzRvOWhaSnJaZ1E0dXViRmQ0T1VXVXo3VVF1OEhMWUJhK083SUR1NFdMWU9YS29qRStpYUxyT05iQk5VWUVMZWEwMjh3UU4yTStlNnhQckppaUlHMFR3NjdGS05zRXNwQ0ZNZnBzWVdFZlJ0aDZpZ2dDeHRjbW1PM215TUl3ZlAxTnZMejFBcWh2SkVqQXFTNUNxZER4SFlPa0k2RHhBcDN1MGJXYzBzUDYwYytweVBCSnMwYnJldlFydkIyaWgwNTAyVXNLR2VobDY1WnQzcTdkdW1MVGl2VVNiS0RMWDFBb2g3NWZmTHZvdnU3b3dia0orZnBEYjZqY2FhTXoraDFsMjd2ZnA1Zk5Xelp2bG5iMmlyUVY4eVcreCtLdmN2Qm5zaGFzcmdHcHlvTk13WkhKWHIxenpjNTE2aVNtL2RrQllIVnI5NTdWcTZSYTVxL0ZjWWtqZGVIaE8wL3JUekJnZmZNeWtMWGFUMlBQdUhVZVByU2xoRUtaOEZseEN4Y3VVOE15V0NvTWpKNFVIQ0pCQzZaeVcvcjJYUnRuaHVHNXg4aWtBY3J1azZCL0RsMmZ3aHE4YlQ0ejJncjNVVlhQbjZqc09aUXg4aU5VSnNna1VqSHRVR29iU0tVUVl5S2ZRaUw5QmlWU2wraDNrRXloWkliM0VGZFBZR0ZNbmlpUHh4THZGbzdnZ0RVa0hSemxGdDlRTTNrSU5LTjVLTVFaUmdBSFhSV0pXZlEyOFhlM0c2eXhHNDAyZmhOUVY1eW5LODNMVlgveXVGditHM1Q1TldlYitPL1FHK3l2b1phTTdqaWpPMjBhYkEvdXVBSjNYQ1FQRnhtWUovNkt3S21iYVdncEQ2SEErdHUvbmErTHY3clF2NzNrTXVFUmpqVU5VVVlGSGgydllPSENCTmE0NUJIN2U1empEeHFjbEpSVmpzWVIzOUFhUytrOEZuMDNOYTVnNWYwNFh5ekdISVl4TjhUMU52ejJyNGRqSG1zcHNzSHhsd2VOSG1QMEQzRkRrdWsyeHdWVVYyNU13VEthTjU3QkpXT0FBN2M4c1lsMTdUYXhDZXFEQzFwYXNkNnhpZlV4R20zQVNOMHdVamNheWZiL1JjRXJLSmJTL0srekdFVUVSdEVPV0dpUDBWQ2ZjUUV0THFEOTF1UlhiMGV3b3NGUlFiZldzUWwxblA2WHdBMTVnckVZYUJuSlF3Um9qLzN0YWJSTDhiZkQvbmEwYVNoR2I2dWdYNENwdHZvUDFZWjlFd3JFYjkvKzFXRnlOYUZOem5BTE53dEZVcGpPZjlPZzN5cWlnVFFQQ2lYQ01NVThITDhxTjVGSjVpeE5IWTBlM3dyRTc3U3BMODQyQ0dmcmlKSDJBZzRtQTZPUzhUMjVnQmcwR0UzR2pXNzh6Y1E1UWwzY2tMcU9jaFhPbXBZS2hQTWJPZmlmRGovc2pvR04zQlJzTlBuRzduai9SVGIwa0lVVHVpQTdIYUphM1FkbmNQOXlCMGhRbis3ZmE0TWViR0Eyc2hsR2E3WlZCSS9NN2FoRFBaQUxhb0RDVUFnNEl3RzhhODdtSHlyUmE2SUdndzNEdzJMY0hoL2dZRGMrcU5WL3hLS25XSGFGbTlEQUVlN1RPRUVFTlFTQ1Ayb01MT3F6VXQvWmhDZjZrRnNNV05YMFFrNm9lVWR2Uk9oNStSeEc0Z1ZxMlZBaXluVytDYTZ5RFEzalRURlVEUTBUNVZqS3hMbzR3dE52cUI3dVpiMXY2RENEUnBqQzBVZzVuRUpsamxBSFYxZkhFUjVoaWgvNmFRQ1h6OG9SQWhZOEY4REZPUFB6NzVuZ3lxQWxLSWppWTVHZDRWZC9uRGF0VmdWcmpHVUNpa1liS2VqMjI2Zlc2R05lR21kZkdhQjNMZlJKVnI3WGxRTGFDMGtVNnZQYno4bm9oM296ZkNScVl2ZzFBQ1BvL2htTGI3OExxTGV4ZDh2ZnZWRnZHcEpRQnNYTC9LWjA4ZnhwRVYxbmdJZTZjclpwMTgyYnBteDVGOVFCbnVJaEN5Y0RuQmFoRHVKTlNtSmZlUmRPckl2cVVuQ2Q0V1hySGVtaWNaTTk5cU82cUo1cGw1emR0NitDQk9IOHVQZ21uQXcvN1JGR0ptT2tmVEZxVXpiaUZmc1BYQnErdlRWM1BybVdOSVovVWNrdDVKTUNqS1FmblBIck8zRE1sSjU2OUsreURqQWhZQWtLcE1CRnRtS2d5ZHYzd0VLZHRtK1FxRWRqYVI0T1gyRGxyNWc2WlhCUkFGZTRhUXF0bFMrWlBCUVNMc1dsZUZod2dTM0U2VHA3T1JTK0kxY0dsa0Fnd3Y4VWNqVk5NRjNDemRoNVNaUWZZL284UGkyYVF0RjNDL1VETFpXNnloTmxKYytYUytJRG5DVkhkaFNRSy9vdWg3WTBYWkluL2tHSGE3bXd4bUNrYWtsNWI2M3FyUHhEa0tOTURaQUxqV3RhQkFHd0NOY2xwNWl1NHozQVBsbFJKWWZDeitDR1IrVU12RlBHZk1ubjMwdkF6VExtdnphWU5NS2Y5djMreThuNEY2NkRCMXY4M2RsZUM1MitrNG84OC9BUkZsYkp2d1VnN28xRTdsdjErNmFQeStta1EvVVI1NEZhSW5lbzB3MDBNT29OdElZSXVJUkdYVVQxUnZlWkd6WkVYOXFCeWpsemFrMnU3aXhLRjg1VkpRWGs2ZHRNZFVEVy9mc2Zlbkx2V0hXdHhJZUpNQklMeFQ0QXVWMkVYTHh2ZjhRNkRLWXRPU0tPeWpWOXdLSTh4VWhtRnFqSVVudDVOYWdRM2l0M1lrcHRnYjhvK0FBcTArcW1OR3hGeTlGV3RBTHJTTUFTTEtoZWZvTHR1OVZneEljcHVhZXhtYUpoZHV0M1MwWERiSmdJdy9BeElQMHphZlF6cGd1ZlVSQ0RadjBlZ3hjTlFTRmJHa2FaY2ltTVA5MllqZ2w4QjZ3L1FzZGE4dUJYZWVkWGxkd093b1grcDg5RlhOWDl2SC92eXhldiswMEhqUXdaT0ZKL2RjelFvb0c2WmoxNnRtanh3T3ZIMVpPRlY4N3JVWDl3RVNyenc2YVU2S2VGaEViNjZpWkdGRlJXNWhjZTB3TkNIUVhmc0lKRHdmckswdnlDQ3QzeHZMQnAweUxESitoNTFCVk4rV29jL1pVRUVoZ1ZrQW5DbExqcHdWSlE4NlAwejR0WGYrcmxzOHpoUGRrbDBvR3YwK2ltQXdjMjFmUFBTMWs1VlI0dFJDZkVwRWJwREROV3AwL1hUOEZDcURWWndURWJnM1RESm9zSk00cFlqVjlXU1BqR2NOMVFiRldWdHljM3ZVQzNmVm5tWDl2bkhaN2VTTEdxS3BoZnBLcyttWC91Z0o3L1hNM0tCZEJTZUljaW1SdGZLR2p4MXZNWWl3NjBoemk2WHdzS3RXbjNsQjdRV2pGbnZQcVI0Zy92WWMrSHNkaTlFQ2tPTThzMllNNXRZRzYvTm9zM09qMkgraStCZUtvYUlNS1RkQUdZYXFZME96RXNMQ0VwVUovUlczaHc3dXl0V3lQTzlkQWpEMFdXMFJUdks1MmkyTy8yeGpIR2liL0hLS0hsNytTTTkrVDNXbm41WjVYeG1MMFNuY1BXeWtaQlhtN0tNQzJuZVhpcjhMTDVyUEVoOXI5Wi9zNW9nLzBQYU9UOVRqRE5vMkc1M0p2aTMwU3g0QTQvQmRCQkttaFJLdEtpV1JUYUNyTUU4RWMvemRKS2YvaUovQUVvcE1abzdzLzZJQi84U0paK2xndS9xRUxGei9iUUZteUJoOWJRQmpqRW83YjRwOEEycURWUzR0dEt1QXhlaHpPU3lWQkZtclRXWUV4T0pzdmZRK3dubVA1SlpkeVdLWUl2NmdLZXlDL2JMT1ZCbnVBTGZvQmp3RTlxWlQ5dGJzQ01VQW1OZ2Y0VVJESmdsL2dPcVpDa05SWFpnL2dHVkdDM1MwSVJEQnFOK2xFekN1ZVZWV2poSnRvandCUzhLeUg3a05BcDhlUG5OMFp6YmdyUUJBUUtUV0hHYlppeU83Ull6Y3RUVnh1TXFYaUg5alEyRi9BZWVNVDBHc1hDZ3Q3OW9RemRvWGpZakZkSEFHWUoyaTRXYnQ1RXBWQU9SVkRhOXlZcVJLVUkrL3IwaFdMc0swYmxOL3JDQVNpbitIV3MvSFFiQyt0ZlEwSlRWdlpHZzhleDYxZ3cyNG05eGZHT1dCd0RiWnV5Y1Btb0EwNzRySmh0Z1RWTytPYzE2SEYwYU9mbUxNWUJJMjdEUXh4YlhnT2pjT3lvWnUyVTJFLzNnTHg4NUM0d09PVjVEYlJVOG5kb0thNWp2OTBCMWJWVGR6N2plUFk5MUhrTmpyanV1ZERiRWFmSjBqMncyY2JLVjNCVUJ2VHR5dUxzdDJIZXJjLzM3QTVpdHR0c0V3aU5uMnArejIwcXlxcGliS2Y5NzF3M1hPN3JuVk5Yd2ZyT0Y0eXp5U3VvOHdIc2NIWHpVRzlIRnZJc0d5cDRmMVpCUEo0aGdjb3U2aUkza0NOclRkZE5LY2dWVDhzUHFiVnlFYzR6K0xPYzkwVUZDNEFYWUJLa1VhZzlEYTNCRnYvYUhLNllrMVFxVmRaUU9lT0hiUjJzUTM2b0srcUMvSmZwa1NQOWkxb3FRRXNhVFlZME5CbWxVdENHeGpPSlE3YW85V1RmelRzRHBXbXVWR3pWK1ZtWGRPQUhYYUVMK0szUTgvS1UxSS95Z1ZyeThHZTVRUGtnS1BQWm1VWnRjTGs2dURTR1VBZmE0QituVkY5NWNHN3lBYW44TmJWbndxajBZZWJxOGM4ZitRR0dHS3MveG91aEhoeVVacVJTdkR2YlZmUVduVmtYRmpQbUF5RUhNei9Ccml3YUNhY1R4WlVzN3dDRldGSzRTcEVVN3NXU1FvM0N3Y0RwV0JGKzRNRkRKT1Jnem9oWE9LTzltRE95dzN3TW5NYWNVUk9GTTlxTE9hT2xDbWUwSjVpRmc1Z3pXaGd1d21DRk05cVJLTnA3aWJ6RDhoZ1JFakhxaFRQRUx3cmlIYkhpVFlVMVdoakR2c2M0RndheVlNUW9kMnhoWlN1TWNjRVVFV0l4d2dYQjdBWkgxalFHUzF0WHdyRkhNT1dSWXNINjdCWDBxbEZCcjFQc1FTWjZleEhtSmo5ZXZQL3R5Nmo3TGNjSEowMVAxWU92bTJrMUF4blFTeGdVSERwcGNsRFI1VXNsaFVlT0hnZ2JMUEdoY09RSlRQNmJ2SUF4TEpKdkMwZDJSY1dzMHovT29jNmtqai9yckhQcTRkWFU0YUhYNTljbno1N2VxdSsybDVxK0lDRmlrbTVTUU5IRnkyV0ZSN0RrRlk0OWhLbm1kbHg0RGQ0dlZiS3JzVXJvaUNiVG1mTmlkby9BK3NiZG5SeXY5L3g0dUdESDNtMzZXU3Rtcmx3b3ZhQ1hyVitTdlYrTHRvQ1ZjUEZBOGRHanhhRkRob1lFVHBvUVduSUI2MzNBa1hzUWlTM2xYNEg3S3hXMGtiY0krYXYyRmgvVm5jd09DMXVoMytBcVJNMU5TSmltbXh4VWVIaXBIcGJUSzFadVNkZUMxWkJyelRwNjlrVWtzdmw3d051bko0OVVaMHA0NXlwaEllditxNGNrc0xpSEpmSjE0WDZQVXFZa1orT09iUnVXTEZzdDNXTldMWnl4MnFEck5XbFNEMzNBeUo1blVWWU5aREY4RkhnOGZIZ2ZCanhZbEd4M3NRYTZ2c0lxTmxBaUROeDRjZVFiSFFqSG5yM1ZRM1VuZjZ6VHRIdDI1SzR4dXZhRHZUcTB2ZHIzOWJIOG5kbnArbGhtUUdUMDhHbFJPU1VMcGJldmhJbmhoYWRPRlJVZU9Wd1VObVpNZU5na1BUK3JpZ1ZuUEhTdm9TRnVWbDk1dFZDeUlqdTNWSGM0TXlwUWo2YldRQlJ6TDZEYVBTSjRibXlTQkdOZFRLdGZNenlLWENjK0FHdnlQUzR5N0JRTEgxelJCMll1VnI2UDNqMDlOM2YzbnYyNThidWpvdUxqbzNDL0IrUDJ5KzJTSCtMc0lMNVdnUWlGd3ZSNXFUR3o1NjFjOFpma3pTeGR2WDF4anU1SzJhRXJlcGx6WWVZQ2piSEVZeXk3OStkWnNFUksvS1IxZU43aVZ0YW9aSGVqcUZ5UElSNDFwT0N3cTJsMXpUOU1TZmxicEtWQVJTTUhtRXp4YUY0Sks2OVdPb1Y3ZEFwN2Nhc1pIc1pYc2ZoUzVWa05OS2dCelV2TlkraURtejZOS2NuT0xUK1lHUk1pb1lBYUhEeVFuVmQyTURNMkdBZGZRZ0x6ZWxqSmtHbkJxWDV4MG9FWndWbFRkY0crTThKVDlKcWpCenZoTHZPekxDZ1Y0bW51WStvdEU4cDM1WmNydEpQKzBDNnd1bk53d0t3UWc2U3ByT2lJUG1EaURXZFh3bGdEMUg4RWt4OHROTGVuOTB2TkIrZ0QzZ0owWnhLMkZhVWMwWDI0ZFAvcmw1SDNuY1lISmNiT3dwcFJGZTZtNlF4c084VU9DUTZaT0NuNHdBV3NJM1VCejlkakIwS0dTdnhDTXo1bDlpOUl0c09UdnhlZUkzSkhqRStlN3E1TWpCM3pJdmNOMTdVYVpGa0Fod3EzN2QycVJ6MFloQmVxZWRJZkNCbUNYMnFaTkNsWW1mUm9DcDZvRzErc09pSysxaFJEa1ZFU1ZpeGN1R0tCTG5yS3ZHa0d2ZWI2Q2FVWDBKRjVjQ2lyY3YyR1pVczNTSHdiT0hJZGtxK1J0LzcrOEZ4MUVSK1hnMWNYRC95aWUzWHd6TWxUL3FXRE4rdW5iYUJTVnMvZXRFMmJsYmx0VDFsNnJHR1ZkRzg3VmJ3NDhrSnJYWjh4RTRaTjNoOTRPVTEvZUI2MWQ5R20yVE8xTTFKblJnWVk5dVFzeGEzeGdxcEhNUExSMTJRU1NMd0dKeGtYQ3A2VDZLaVppYUhTakc0WFVSZDZZRm5RbFp6TXRTdlhTSGV4bXRXY3BYTjFzV21iOXVtaDlZMUgvUmgrR2h4OUF0bkplRmN4eisrS1Urd3pldG5HcFZsNVdpaDBSVk1aLzRSWS82a3BlU1VTVEhGRjBZejM0V0YvRjVXbTUyWkpzMWZNd2hzRTMzbWRTTXFOOEpSclIzZEdjenJCSEtvVkRVM1JCOHowOFdDTEUyRXJUdlJDaGtGZ29OclNZSVdUM3RBUFlmNFROQi9uQVFJK1VLNzBZR1RvaWRQNUhyaEEvaW4yQzcxeDIvRTdtN2JkUVVTakgzUmt4YkFYVVJWZ0N6MGFOYWQ5SE9adG0zaHozcmJHVFduQW5hZjR2akRLSUNmaTNnK0RIZ0pFeW9sVU85b2RCVGhEQU5XU2hwYm9wQ2ZxVC9HdWNQWUJETWQ3eThkVDdBUFVpNEdlTUlxNmgvWjFCdzhHZWFKaFZIZUc1eFhicGRmZ1VLUFlMc2tySHJHdEQ0dkk2bzZJZ1lQcmN6b0tPVkNPTHM4cTJZOTNXTEN5QU92WHpuUXVPRkNncXVsQW8yUlhBYXpNK1JSOTFvNEc0MC9sMFFMNlZzMU5vRlh3RnBIQ053WnN0MTErK2xMN2N2aHRwTVpHU3lzbzZNc2NUZGsrYlUzTWoveEdzeTlQZW9Ud1F6cmZYUjBaUktUMjZOWkcyL2JTc0c4V202VUJ6TUN0MGFjV24wWlcyR2FwODVVMjBHU211am5UUjc0akZPOHVQTHhaUXAyWVNSc1RjNHUwa0lZT0NpRkpZWlBtU2RDSk9acTJNd2JiTEMxNEFEWVBRWTNkQjNaWlQ0QitFcWM0bXQrWWRTMFVUQWIwaEhKbVpBTThva3pkN3drRnU3UHo4ck1Ud3NNU0VuYXk1eDdjRzN6ZTIzdndjQzlKZytDNVNTc1U3dDZGa3hQRHdoUGlkN0xuNzk4YlhJMlRoM2xKL0gvdGNlWitVaDFKRTlId2JIRGZoYytJSkF6L1d4aGZGSDRzWTkwcVBCR1hqWmc4ZnZ4YzlRRG0va1lncmtKSDdTMi9JOFBIQmdaTndVczFHeVNjZmV3ellVSlp3UEhqNVdYSGovdVhUNWdRNEQ5QjRsTXhpL21EekFOYnlEekNRanU0TDlTdWg4YUtxdmNHMU5pcDFYeWtRL1ZRL1FXZyt5UWhXL3RPRzkzTEIyTWJteHRCcjNTdmJwUmdHNXZ5U3h0ZllCdWJlYy85TDBtWC9QdVZ1T25jK2dWaUd4di93Zk02WVJ1YnN5SnN6QlBmZmhNY1paOXZxUDBxMW1KUGMvcVBQVTJmZnV4bE51ZVBPYzMwUWV3VkVUN2tpUVhnSU1CRml6WE5oeDl0RkZzYUd1MVZqR2t1Smdob0dnM1RGR09hQzJLRnhaYW1ZckJvTWFVUnZwUEZ1TzBycjdMeWptb1JUVE9iMHN4SHZsQzNIZWhBaXllVUFqbzhRdzA4UjRjRXh1dWgvcVlYajZHT3JySnN6dXk5ZW5UYllrcHo5WXBpU2pOcTZvREJ3eFJUbWorV05QbjRYbkdWZzB6Unk5SGNjK3grZUFGam9Nc3BiRWx6bnEzY0ljS0JUcXhpUi9NRkZueTF5d0VXbGwxakt3cHc4eUVOQWhEL0FUVkd1a3NzcUcrZlQyYW5EaDQ0cXVMZTdYT0hMbDA2TndWTEh0TjJRYU9kMEVseHNjd0pKc2d1UWpTV082SFgxdEVzWG8wN29kVk9FQTB3M0pMaEdZeC9LRXdxaURxVWZrb2M0enQ1OGp6MVVPYm1odG9MNEtTOUdsZ3hlbEp3bUMrMm8xa0Z6d1ZjZW85NGU3cjR4NHdtYTRtNFI1UVhUV2N0ZW9jWExIcUg3M3FMNThXdkZxM0RlcUR5VkxRT3F4V3R3MC9NcWprckZLMURmNHZXNFlXRFlvemZDQW0xcGsvbTdyc3NRcnQzYUJEV09weHQwVG9zelQxMnBqQnNvQVFxckhTNGRQSVgxRUdINm5Zekt4MXV4a3FIeDluYlpwM0QyMTNZY2hGbWxvanlSclBLWWJjNzBPMHBzbUxBR1RJb3hUUk5SS3RSc3o4cWgyNG9nM0xvREYxNm9TN1l2Y0lpL3cvRytBL2tJMURETUNBVWxjS1Z3cXVCaWtwaHl4Ti9WQW9QWTVYQzg0VkIvU1VnczZqdlMzcy9SQTEwaUhEcWcralJPUlAvcUJRTzE3cGU5cjBUTEgwWi8wZWxjR0pJOUhpc1VuaFZRa1F5aGF4VzNmYUdCam9nUHQwRyttVE1pZkhGK2dOWXAvQzhGcm1mRUpPd1RxRlQxUmx4bDZKVCtCOUZ2N2I0ZEw0bWsvMnZyaDFlcDJjajJEOWFPeE1DUlN3RjkvdG9sb0tIeXRGQ1VINTRTVWwrUVVsSlJGNlFXUnFPdWlnUzhOaVBwbGdhc0JkbmlNQVo4bkdHL0NDemlKdy9Ma0wzdml6UHo3djIvUm9NdmZyOU9pbm5ZSm1oYVNiNkg2bzlJOCtFZjdHTnpBWWhkOWVPZmZ0MkdLS2lERWt4TVlrN2M2Vys5Z05Pajd0NjVmU0phMWRIbnh3NFlQVFlBUkpRcHA3Q2dGUGpyaGJrcHUvYUlTWHUzSjlXcUx0eTVzUzFhNk9xQm9aSHBTWWw2WGNhb2pMQ2RRTkhqK3V2Qjc1SzJNaENML3VOTEovMjQrZC81QkhXUjlnS1JSenhra0g2SXlEMEFwM3VSTUdHelRuNnVJL1VvcFM0aFFHNm5uMExiNFhvb1ErOSt5V0ZrdWhsRzVadHlkQnV4K0tJdFJJc292ZThvTkFTTEk2NGhjVVJaVGtMRjI3WDUzeWlOa2ZGcmh0OWxIVjN2MEV2Vzdoc2RxbzJGWnRrelpWNDg5WE91aE5zS1NzbjRVdVBLUE1yTUFaREVaWmsvcm5nbUN5YWczNVp3UkViUTNYRHh1RlhaTEx6bEZka2xtVXV5WnBydnU5SUxpcVl0NXZscTFrNTAzelJFY3pjL0VLQjlMYlhNUlpWdG9jVXVtOExDcm0yKzRmdTM1cktZNi9oZTQ0OTdKMHdGanVSNG5XTHhlWVBBUVc4UU0yL09Valh6bEpPUUE4REJycHJvWHMxTUxXS3ZlWlp5dEhCSFRWSEFWcitPZ3VkUHFwZ015NERBZTdRM1BHNzFIOGtWWXZvYXNTZzdsclVmUmhpbkJSYnpaSFV0Kzh2b0RuZ01xZytWSmdmLzZoWUs5NFd6UVllVGtJTlVodWpMZllkelJqK3RtZ3g1bkFTZmpXejJISkVJelcrdER2SVlnVnBWU1djVWZTaisrbVJ6WG9XbXB2MW85T2xTeGxtL2VqbUcwVEVNbjNOK3RFNHV3MUdjMXR1cFNoQzM5UUR1NEZGemMySzBLblM0RFN6SW5UelRTTFlNRGZNaXRCbzhBNno2bkt0b3JvOFNWNGNJYTdhSXNKZWFET0p4WTArWlc3MHFiWG15QnBvTTVuZGxtYldyZHgvUzRUcDhoSlBFZXloRWt0OXIwTGxINm52UXlYOGF3a09XNlMrZmhaMFdNWm45dHBEbXpRVzlxYUNGYlQvZ1ltb0lzc1ZleDZuVkFIQ2dJWFdNR0NGZnN2eWRLd2piOUkyZ3l6YUxiWGJZS1JTYmlYcGwrQU4vWUI5RExaZ2MyV0F4eTQ5TUlVVTFJdEU5RGZVUjRlR28xNm9LWnFCWm9JM2Fnb2o5Zng0OXM5clZsR1RSTTAyQXp1ZXZhYThaOVpUUk4zbCtKRktjQmxyVHJlVkIySk5rRURVSHAxcUplSmkxN1AveEVOOFp4eWZnMDZibzA5WlZHV1VGTDhxakhKTmxiT29zU0ZRdVR4VEViL1RoQWVMZzkwdzRrZG1wWm1JNVdJWXpsdG5MdGhpblpFQWI5VE5WTGU1cUZubnJUUmxMeGIvOXhRTjhtVWZFZG5Ic1h2K0dBK01WblR4MWNyVEkvUUsvS21ZVmhoV2VhaXdzRkxTRkI4S0s1dzZMU3hzcXNURFJQd3hjdnI2MTFjWS9NWHVQUER1THhTSlZoRFk5SU02bXR0elpYdVlKL3k5aU82NGJNdzRkMTNycWVmTzZUV2x4THZIK1JlbHIzT1lnQkg3THA4OFhIajhWcUhmd0ZWNnNObEtmVm80NUQxeXd4UjI4WFR3T2pxbUdwL0k3OC90YmVnenNJVVc4Vjlkb1JQMGZBdldvRjBwclgzNEZSVXhmUEpaRVNibmllWEtaOS9yRzJxM2l1MFBSc05iSUgyVEFYT1VtdXY0amw1d2VPYngvZnZ6WjkrL2Qzcm00T0RoNFNBZHQzOVlmZkhCZ3d0RHVuY2ZPcVJIajJFWEgwclF0YTF3aGc2OVMrM1lsTDRqVzFzVXZTOVk2b3dtbktRMXhaZTNZSHVKMlJYQ3dXMU14cWFGYVdsekY2VHFlVXpwQXdZWW1VeUN6MmtSY1hRTUdrbGg2UWM2S2g4MVBBTTFua21DYXIreDB5MFdLeEZNWHhxVDdLK2J4cHk2cytmZGliQ2NvSkRvaERDTTRZWmNDT3FuV0NzRFo0Vk84aHVoSURFN1pQYTh4VXVYU3J0Vzdzc3UxMVV3WTNxRmVZdy9FRnRVa3BOZG9NYzNLZmdXeFh5YmdnYkoxVkNYekFRK0g4L1lUQ01saE8rSkt5ell1N2VnSUM0blBHeDZiTGdFSGV6RDk4YmxGMXJpOElPQU9JNUhuUSt4V1ZEdkVOUlRaV0VOVjF5bU1HY3YxbkRkRzJaUk1ldUpWY3h3M042OVdPY3NEa2Z3S09JUUN5NVllYmFmY1p0Wjd5QWJHZ01OalZUWmY0bXdmTFhJSTFmanRqY2szRFp1RTk2Z0ttZkdVbUlYMXJPOUtVTERIZ3JJbm9hek5UQXVmbkFTRjM4RHVqY3FHR3BjTEh3L2NmWHlLcjB6SGI4c0pRYWJXS2ZzMjcwVWh3YXRQakhndTQ1SGw1VDZtaXNxSzFlRklPVWRxdnk4a3JJSXJMSVNFUm1BbXhWbW5ISHI3UzBTdGhzL0M5ZEdIUjg0YU5TRS92M1BUTGg4NWN6eGE1S1hmYXdoWlhwY2NtWk9UbGJtM2owN1VtSnhpZnJHcGN0RWpSLzgrTVdhRmFyWDlNWWIrU0Rjc2pxNHZlTitNWXFLeW1oVWozcEl3MGFvcDRSOGNFZ1owbko1cndHbTRKRWVqa2Zham81Q1U2aG5PUG82aWphUGRCNElxcXkydDFpcytoRy9OQ2JSWCtmTG5MNjk3M1ZWU0U1SVNQVDBDRDJmbWlIUHlvQ1dHWWN5YU9TZndlQmdVZ2EwdzBFMUR0cDhZMEhOM2N1eHRhM1pZMXRIdnRvQTYwQWMxeERITE0vS2E0aHhSRHB4bFhoTi9DYWJrMDVrTDlLSEhFS0drd1p5TjFsRi9yRFNXN2xiamJLYWlaOXZRU3BDRmFoS3d3K3paNm55Vk1YV3RMVmczZGQ2aUhXNGRRV2xvb1pSVTZsSWFpMlZSVDJucmZIMklOSTlhQU9kUmkraDE5UEZkQTM5anY1RUd4bUNvUm1lc1djY0dXZW1JOU9EOFdFR00rT1lFQ2FWV2M1c1lES1lDdVlZOHpmemp2bWtKdFIxMUlKYXArNmk5bEpQVmdlcTU2b1hxTFBVdS9IN29hWHFTdngrNkZQMVcveUM2RTgxc3JHeXNiSFIyRFN4YVdyVHdzYlZ4dFBHRzc4ak90aG1wRTJnVGFMTlRKdDVOb3R0dHRqazJoeTFPV056MmVhMnpYMmJ0elpmYmNER3hMSXN6elpnSGRsMnJCdmJqZTNOK3JDRDJGSHNXSFlpTzVXTllKUE5UOG9zWnBlenE3R1NaUmE3bnkxblQ3Qm4yVXZzZGZZMis1Ujl4LzVnLytXc09UVm55OVhsR25PT1hIdXVNOWVMRzh5TjRDWnhRVndVRjhmTjRPWnp5N2tOM0hadUQ1ZkhGWEZsWENWM2pEdkpuZVV1UEZVMUZUbXNMTHNYcThLR1lFM1lScHl3ZFAyeVRXdTB1Vms3OHZLM0ppVVowbExpWmtuRFE2a2h3UWtUaG1qblFNRTkxSU5adVdIOWhvM3JiaDVzZERnbnAraXc5dExFVSs1dWswWVBtcjlpN3NwNUVpL016YzVmbEtjRDlkOFBvQmtRM3FlNnVRMFoyN1BIZWQrYmhZVVpPN2ZyQjg0YlAzMkVMc213ZGwyS0hucERWeUVzMWhBUkdic0RMMUZjYVk0aERLTVlzL0g0MkZlNk4yZFBYNzNzV3pKaXJmN3RkZW9XeXZPR0xveUxUOTR3YXZYR0RTczM2M0wzcDRYRUpTU0ZoTVR0emwrczU0VHVvdXhxN2NQKzBXT0UxazJCUkMzMW5DSXF3TCt1aXFnQWZCR0d5QmY1Y2tKSVRteFI4YjZjNHFLWWZTR2hzVEdoRWt5eFYrS0tMSEdoNWppdU5jdVBGTGNnamRDQlJYVVIzUUk1WXd3MmJiRWlIQ3R4bm13dmxwT3YycmNST1FFRzlxMjVlZUgyVUlodlJTTnZSUUE1TUZWb1RuK0YraFEzWGx5NmZVbHVxUnVMempQY1JSYXN5QXBSWll3ek9rV3lxRTY0aTRodEg4M1A5a2x0UmZBZElrTG9BVmFlaFI1ZVlyTEV5YlBNK3NZanErNHMwWU9NcnlaWGJzM1Vnbk5IckcvTXljT0QvL2NkTHMwbkdZeVVpMWlldm4raStQL2dZVFIvLzNrcU12UVN6cFFsQ2xVYkxwdzd2MzdJK1BFTGhnNGZNZi9DQ2F5QzVGYllFdXFEWGVIWEY2OUN2NkQ2cUc2SWs0dkVaN0ZJamNxWXdXSFRCdlNMUFg1ZWdoS2s1cm9naG5Zb2l2ZjZHZGJmOWNxVUsvL2NkTDUwMk9mMXo4TDRlODNDS0E1NldldzZsVmFwL2o4YVpMSDF6QkpsWGhpOHdyLzBwUFpvNmNFclY4cjhKbzMxRHh5MFRFS1YxcHF2UGZ3T1ZWVWRQUHpnNGNFcDQ4YjVUZTJ1YjJrTnJmOTVCTVNkOGRYOXMvWDR4bXpYd1FzWHRVQzB2WXZza1gwN2IwUU1QampzUXFLaytlNlRNR0ZZTHkwaS91bW12THlhdTNGelZzYVdoZk16cEkyTDhBdVFPL0VMa0djclNoN290M2t4bkh6SVhlUmdzUkN3S1doSHBOUzcxODErdCs5UXlma0g1cGJwU2c1c3pNelQzK3h6NDRiUERXcEgvcGJTZzlxRHM4dVM4cVVidC9yZTdOMkwyaDRWc2pGWUZ4ZzhGNzhqMit0ZW43NTN2Q2xEeEp3Z2YrMG4rMnZIamw2NWNuUlMvLzZUSmcwY09QSG9OVHlUMFdrdkdJMVpYSFhMV1dpazlKN2VCZ1BlLzEyNFI4My81eTFaTG1ydTdPVFUyZXMzcEVyejFsS2JrdzBiWTNRanA0WDAwUE9RaXZxQWlJWk5FQ1hPdUx3em5tTVBadzM2Z3JycFVDTkV0a1pjczF0OWdValMxeHFvNnRrRklWTzFZM3o5UEZxTXUzWm5vWVNzSTZrV20vNUdhaGlnQTQ5WDM4R3Fkc0JEVkgrM3ZzVU9hc3ptMklKSzdjbGpSMjY5S3g3a3UwN2kvOWd4Z0Myd0hzaUxlNkZZYlBaZGkrMCtGN0NhbzNLek1uYkozcVc1dVc3czc2NmdoaEhZWUhOQjFxNi9kdXZNTHozcWVhZCtBeEdwSDhBbHBNMmZPVHR0L1laWmxsN0ViNHJSalprVzJrdWZkSGNqd3dsajFwN3NBTTEwVU8vOGt6dTNKcC91a0tYdmxVRkZyMDNKM0tQZHYyOVAyZVVkMDJKWFN4OXpxQ01MZkYraUpycVdQZnA0REtnYy9UeEZmMnNXVmJKZ2UvSjBiWFQ4OU1sREkwb3EvcEw0YktGM211KzhLRjE4OHFyVnMvUXRtWVhaMnhaWDZPNC9yUHk1US85WWJrR0J3eWZFMDFzdVVYY3lLamJtNm5abUxsbThWZitaV1pjNGE0MmZybWVQYVUyVDlJYVdGS3JiNml2Tnk2MkZaWnVXYnQ2b3ZWcGNkZTkyMGVSeFUrS0RSb1pLVFFjZ3FsK1ErMUtrYWl5SC8wQjM2QTE1ZTNibFpvTGRnMFlQamh5Ky9sUUxLbzgzeUJFNWRXNkpyR2V2VEZXMHZQNW9WcU0yUHhFSkxiakt4NHFhLzVlSFIwcUxkMG1jY0RCM2YybnAvbWcvditpb3dNQ28zSU9TczcwcjF0bkRlbnF2YTd4dWRuVHo3dXNxY1ZCaHBBVHpUcUJ2SzNKd1dGaXpNV3R0cnU3VStVanZFYjRUdXZjWmV4eGJIU2l2SFNCaS9Tc3NxZEtCODZ2UG9JTDZiVzYwV2FtSHZ1Qk0xWnJHT2NBUkJ2Vkg3aFFQQ1dpaUFCZU4zcmkzTkdxSXFsRlRxRmF1QlNESTFBdlpvUFVVWno0ak5NZG5oRWFEUk0xcGJyUjRBK3AxVUo1dFhMaHlMclpkcmtCRHFUSzZFb1pTSzlldTJMaE9XeHE3THpBd05pWlE0dExneUdPWStrU1Iwdmk4VnNGaTJWYVk0bDk0NVdwNS91SEQ1UkVEQnZpSFQ5RkRrWFh6bmw3Tm10MzMrdnIxL3IwZlAzcmVhNjduVjg2VlFFVnp3anU2STdTaWtKN21CZFNheGtxY21FL2tCRlFGdGxERndDcTV2WEpuZ2J6UU1kUVRqbEhJZ2VhUVZSSFZMYUcvRitKMHFJN0NtM2lDTjlnOEF4dmdydmgwMnFFSDZvRENtelQ5Z1FaWW5xWFFvMW1jY2NnSWtST3drT3pMN0ZyM0YzRGxoZnRuL0ppZ1BPUWJ5V0V1YkdJeU4wK0VtL2JkUkY0WUxyYTFIeTd5SVRreEI0cmoyWkJnNVFWSjRiSFlYTkY1YVVWenY1aFJPQXdFT2tpaEtKcExvYnJNR1R6WlhjczlXeDdBY21BTkl5eUdZNXhGMkVxZVVpU3RLcWpsaklPRUg2Z0ZiaGo5QTFwUXJlbCtQZnZkcHppeitCVG5VbVNucWp0Y1llcHJyM3Z3OUIwSDFha0pJcmRVTkhsQ2QrVjEwS2JVSndaVnZvYktWOWhqOGtUTktGNTVFRkxpOE14dER6Nm93U2RvQUQ1dmtROElyWkRBSUIrVUliU1ZKNzluZUNHZ0lMeE1lZTk0anNoTlpFbHVja25na2FPbHBVZU9CcFppbVYzZ0pJbXp5SXRKMkt3OFNHcFJUSytMaVNMUFN1Ymd0WUJiRUVZaGF3Yk9JQ2QwQnVHaHNsTGVRQTJsK0gzNGJkaVkvUnpRSmlkR2RwQ1RLT3dyUUpSc3g1aEVVenlGV0lhUEtUNFF6d2FIY0RBS2pSSmdLUk95dXlyNmhnNmF2Z0lyYUFuTlBjRUtOZWVjUlQ2L1BGdVArRVc5dStKVjd6YzVmV3U4WGlQRE5iZ2o5QnJCb2RRNGxvTkFlOFhxTElmbEhxV3RaYmxNRWJweWQvSW4rMjNTZnp0QVBVanU4d1ExMUNGbDRSR29EU2VZbjluVndUamM3a0p4M2JNallLYzlGVjdFWVpYclpKS0xGMmVMRDFnTytVL0VhRzN1WTRNYkR0UXdCZFRjTEJIYlQyMVNIbE9keVg3Qi9PcEZrU3ZHMGZQRkhTeW5QQ3BXVm1wK1ZJekRMeTVoSmVteERJZnp4SWxjYWkxb25uSG44UmVPZzBJOHhUaTVUSG50YU5qNERzcHJSKzNSRzRaSEhlVTdOU1JVNC92dkdwU3I2QU9Oc2s4Uk9iUFZPS2J5L2RSN0hJTWFYQjhLckxUclZSSTlQSHJ2ZFQzSFFBT2ZDNGlWRXQxMjB1ZjN4L3JvdVgwN2t2QWxsQ0VtSmdtL3I3NXo1ejQ5ZHg4NE9BaTJYTVR3WVAybHNSUnUwY0Y3SlB6aXpLK3BhaGlvKzdrYm5pZGRXblJIZGZWY0NvdnRKZTRDdzkwakR6NVJHbytyZGhDZzBoVGZScTZqdk9xcWxSMDQvSlgyWkxtSXlQanNRdnlDY3MrTHcrL2R2Y1NoTWxCRE5mTVRGM0xFUFM3VVhUaWRmNjVZengxK0w3ZkJKQzNOWXZFanBBeEh4cktLL1MwM2l1VXBwT0tBcExsa1V1NWlEQk5NWFg2SFVkeE9JU24vVW1xVkR1TEFtaHNoOHVzMkdSUUZHeTZLZmNhWjdISEQ0S0dCKy80cDl2TWUvRytuMmNHZEhDOXkyMFZZRHJ3Sy9EblVxTlVydUZvTDExK1IzQitWeWlVMFQ0ZWhMc29yeEZDUDVFSmk4R0lGV3hXblExcGszeE0xbmF6bjZDdnZLRVRTQTl0UjNEckR3ZmN3KzhNaDNHUllnaC9mR04vVy9CTHM3c2RjSEl1anpncGNvTVNqQWNqSjhDc0k1MEZqa2V0cjQ5WWE3QnNZaS82VjhOcmxVai9EWkd6eStOR091Mjc0aU85LzMrRjhlSzJFMW9JcjlzbkR4NGtjSWpyZzJxV2YzYmpVcnhEOUNscC94d2lhZ3hxYTB6elV3V1RSSWhaWXpYY09qZkkwL0hMQXhSeEJ3Z3FGa2lObmZvM2l0Y3QzVGdqUFRpemFzbkVOUnk0Mkd3OXhkQ0hnWGo0VTdiaVFmVEhGbk4wVDVkeWl4S045bkxHSndFRWpnZnYvQWI2Y3BuVUFBQUFCQUFBQUFYZ0I3WjBKbEZYVm1lLy81NTRxYm5HcFcxREZoU3Fxc0JnRUJjRWhCZzA0b2NRNDRCakZBWWtEaW9veklpbzRwR1A2SmJHVGZtMjN6N3pWSnE0Mk9FV1RrQ2FTRGtwRVJTdE5Jall2ZEJvZlN6cVdyMkpKaXE2bVFvcFU2b3BWNS8zV2Y1MTExdVd1eSsxQ3BKUE9lL1ZmMzkzN25MUDN0Ny85N1c4UDN6NURLWkNVMFRSZHB0U3BwNTA5UnpVM3oxOXlxMGFyUXBLaVNDa0pTbzVJSDZyaW1rVjNMRktqZnh0dnVuYnhyUnJyMzdHUytmRUxVaHFrU3drRlZVRVpWWUtNVXRBRW5TanBpL3BiTmVvYitwWStvZGZCZFAwRXpOQjZjSngrcGpkMHZON1MvOWFKUVJpRW1objhRL0FQT3RrU1ZhaG16Rzh2cUpyL1BRWEJqeXpkVzZtM1UrK0ZWNmQrR3phRXg0VW5oMWVIaThMWHdwOVdwQ29tTlh5aDR1aUtseXBQcW54MlVNMmdGOUtIcGYreWFuSFZlMVhiQjQ4ZFBHdndvc0YvTmZqbmRjOFBIemJ5cWN4MVEyNGVuZ0xIRGxuc2NOaVFMMVQvejJ4MWR1VHdZN05YMVh5KzVxK0huanV5ZitnalE1OForcTlEZHpTT0hUWmgrTEJoUncrYlB1enQyak5xNzZsOXBQYUoybGRyMzZudEhEVzc5b082cXJyeGRWUHJqcTQ3dGU2Q3VrdnJGdGN0SGZsVTNmTWpud0pnZUtydWhicU5kYjhlUG94U2hpVm9IRDUxK0xFQWpIeGgrS25EMzg5TkJ5Zmx6c2g5ZjhTMEVTK1ArQmZ3OW9oM1J3NkN4L01qWHhqWlgxOWRYOWZRMEhCWXd3bng3NnlHT1EyM05ueWg0Y3NOS3h2V05MU0FqUTFiR3RvYU9odjZSMVdQYWh4MTFLaVRSczBlZFNwMC9xaUxSeTBhOWZDb0YwWnRITlhabUdxc2JoelpPTGJ4Mk1aTEcyOXRYTnI0NWNaSEd2K3U4WHVOLzl6NDY2Wk0wNlNtNDVwT2JwcmROS2Zwc3FZRlRWOXNlbVQwb3RGM05UM2Y5RjdUQjZPbkU1OE5jUVk4TW5yalFUcW84YURwQnkwKzZObUQycG9ibXB1YnB6V2YyL3hnODNlYVgyaCt1L205NXUxanBvN1pxSlNPVXFpaGttcFZwNnh5YXVLb1dRZXJYaE4xaEE3aStqRTZWSi9TVEIydVV6Ukx4K3BNTUYxbmd4azZEeHluT2VCNHpRVW5hQjQ0VVZkb3ZrN1NOYnFCSExlQ003VllkMmkybG1vWitlNEQ1K29CY0o0ZTFIS2RyKytDRzdWQ3orc20vUU80WGF2MUlubGFzTU03OVZPOXFidlZxbCtUNzkvQmw5VVRwUFNWWUZ4d2lCNEpKZ1ZINkJ2QjZjSHBXaDZjRTF5bEo0S3Jnd1g2VVhCZGNJTmVERzRPYnRiYTROYmdkcjBjM0JIY3E5ZUMrNFA3dFNINFp2Qk52Ums4SFR5dGZ3cStFM3hIRzRQdkJkL1Qvd3BXQml2MWMxdjRwbUJ0OEtyK0dSME5qcllFTDBkYkZLb1JXaDdsZzFlaWJnMVdMdXJSaUNpdmtWR0g2cU5XTlVTZGF1UzRpYXVqbzI1U3ZhTXFVdldSSXE5NnFBRnlDbWgwekNjZ1JaNTBJU1VRaTlQMnFNSHAralVqZWtWek9RNzFmVFZwSmZRREtLZWFhSU1zQVZkR1F2VlJteVVZRmJVajU4RXVZNFpxYVptc1prZGQ4Tml1ZVZFZjh2ZkNxUmxPYVRobDBPMHh3VVRLRHZRNktXdGlmbW40cllQUFJIamtkRHo1NXNKcm5xVkl4MUprOVRybjM0eTZxRWM3K3FpMlJLMnhUcnJWaUhUVWtocHNoc01PVW1GeHlOS3RjK0F4WG5YUkU3RU8zNk8wRlVqZlJZbE5TTjVPdms2NVpHV1F2RnZ6T0Y0T1BVRzZwNkxIOVhUMG5KNkpWdXJiMFdQNkRzY3JvTy9yTlAwOTVhMVVNOUpOMVBOYysySDBpRjZJSGtMU1hyVnc3YWZSSm0ySXRpQjFhL0NqYUQweWJkVllEYUxrS3E0T3BqN1ZTcU9ERERxb1ZBUFVTTHlKY0RTeWp5SE5XSzZQRTMyRXRMT0lYd25OaDY1UnFHWFFvOFJmalBxQ1ZOUVRURlE2T0FTYXJHd3dSYmxnS25RNHgwZHcvQXhFK3dldndyTlIxWERMa3JzT3lxbVMwbFBvcEp2U1FwYzJrL2dzVXN6bitEcG9NVkxkQVQycUxDVjFVMUpJU2JtNGxFeFN5djJjZnlicUQxNVJKZGFjMXFpa3JsbHkxeEhtME13STdLeFJWWEZwVFpwRnExenAwakphU0xpWW5IZEFyaHRwT3JEZEZIV2NTRW1IRUU1UnJVdjdaclNaT3ZYck1Ma0VTcW9oTlNYWTZzY29UUWs1bHpBKzZuT2Q1bk84a1BNMzB3NkxveDZYY2wvMFMxR3Z1S1QyUUpRUUtLVEUxMXhQYXhTYW92cTRycm5nQ09ocU5INGQ3WG85NFNKb01YcFpncVIzUnB1Q3UrQnh2eVZzRDFiQ0F5blJQUDFVU2J0RGRaekpSYnZkenkydE1raWJjMXZQaE5DTGRYSXphUlludXVoeEMxZ1hoT2dDcWRKSkMzeVQwbGU2cmZOdWdRWU5vcFJxaFc3dkdyaTUxeXVseHFURUxDWG1LVEZQaVYxeEs0UnhhZDJVbGkvUWZJWVNXckNta0ZJeTF2NE1WU2lrbEMxSnZiS3FaN3pZUlAzVzJycmN4MVdGaGYyY1hyZUxrcHZSUkJyN2JwVnRBSXducGFXd1BUeW5Lem1lVHl0ZEE3L3I0YmlRNDhXa3U0TTB5eGg3N2lQL0EvQi9rVjdhcnNQMVBodzYwSUVpSktaMXhoTk9VSWF4cGgzSlZ3ZVRSQ3RHbmNIVUtHODlYYzN4ZGFSYmhLWGVpUTd2cDNaL3BqUzFXeGY4bmRLMjRwVzJMMXFPc2tkVFE4Yk5xSTlhb2svaXRyVm9kOXgzK3RVQWpZWmNJMlhRNTl2VXBOdDk2RnBDOUduYlN2b1A4Ymoxa0NpTjNYUlMrZ1pLN3FQVXZBS1BXNTRsMFdDelJoS3JkNHZtMUdnOW9VVitaOEQvZUdndVpiNHViSTA4Vlc3bGVzNDJrS1BSbzJJbm8ySTNxVUtQbjBOSTBaV01uYVNNVTdXUmFpdGpZSjlIN3hhbjNnS1BITVFJNFJIVDQ3TThIbHZTWWZEcWd4ZTZpSHJqMmFUUFZ0MUVPQ05xSjhkN2xtOGV1bHJ1TVRORTFrcTFtRU9ISmxxck5YR2ZHRXVxY2FvbVp4ODUrOUZrRzVyTVc2b3JDT2NyWmJ1NG1aS1dFTjRKTFNQZGZWeDdJT3FnaEoyVWtOSVBJRFNpZHNMM29XMWM3eUx0YndoM1F0M281QU9rMjAzOHd5anZsdmtPcmJCUzFiUjVwVTVCcWc3a3lIbjBxa0ZmZGN4U1krQXdGcUxmYUR6bkQwYUtHYVErSHFKVnlKVVdGb3kwTzlEaFRpVHVqcTI1RTZuekh1RnVnQ3c5YWUrRWxuSzhESjczMnFwWDYxSFBuTnVaZDFyMWZiVGplY2F6NEdnc3ZsOXZZdm50OEh3ZjJnYi9McVdwVlo5Mkt0UnZvVzZPZHhIK2pyQW5XcS9mTXhmMlFubmlIMFFQVStNMTFIaUYrcGhEKytFVjBhZFRHaG84alJhWUtkQUM0NVpIa0ZvRmJxMFFPZXFKVlNGRFRwK3hadHpYclpsMjFTRTE4NVhITC9kbHQzdy83ZGZqa2NVYVVRcHRkRm9UTnlEWkV0ZThscHAzeFRWZjRURi9lYlNEMGpLVWRuQmM0N3grVEo2WG9MWFF5eENXdyt6YWpTYldGMmlpUzlZRXRCUDZMV1JOUU5aRXRBSk5yRUlUejZHSjFXamlJVFN4RWswOG96NWF0cC96VWZTYzU1cWJzQU5hSnJnTHVwdGV1aFJhaG1idVVTNjQxK05ESGkzMW9LVXVWbXQ5YUtwSkI2bkM0ME5lMWZGY05FYVplRHlvamZ2QkRyU3hCUnNKdmJwaGJMQWxQK3FWM2k1YkxlT0VyZlpOYXRkTytEN1VEYzhlMG4xZ0srMUV1ajRrY01ua1lMeEhUNVdxWTczeUZ1dVZON0diWCtnWnl2bDI5QnFhbklUOXZFMnFlbEpOUW9PdjZHWE9yOE1lWG92ZXNCWTMwTjZybzdYQkd1emd4MXcvWGF4Q1ZZM1VXYS85TnNmdDI0YmxkOUsrYWRxM0hhdlBlTVUwa3pTbmVMNXFpVmRQdmJxQ3RGZVNmejU1cnlHK2tQZ043ck41TFlIcm5iYjRWdG85UjcvdGo2MitCeTFzUS9xTnJMTFdJL2s0Vzc3cmh5NWZKRDJycXRqNmE5Rk1oamJmSEZ0L3Q2Mi9HMzY3U1A4N3dwN29VZHA3alhwcDh6emhCOUZqdFBlVCtwQ3dqL0w2bzY4cmlyN3UrUUtOMHM3MXdWSm9HWFNQSnRMT0dYcERMZTNjeldvOVRWdTNXK01WWWtXTFpMdVJyTlpydnlQUlY2ZXFLVGZMOVJwYXVVNFo5TldPdnJxOStqaVlFWENHZFpWQlYvUUhjczZscnZNMHRFQlhIYmFHaGNwNGRGaEtIQjNwUHVLUHdvZVIwenBoNXFYVW9laWp5LzFnR3lNMlk1cHR2UmY2QU5vTmZRajFrYmRmb1NMcWNGUFN1OXVvU3g5MXlYdFZVb3Zkck1GdTFtSXpyNkg1NTdRQ3N0M0FtZjdPMnZhN3JHMmYxK3JvS2IxQStOUG9MZXpsTmV6bHBlREhoQzlGTDZHVlVWRVB1WTZNMS9xMkhhVHk2dFplUnJjOEwwQk5TRDZERnZCNkc4M05JL1JzUXE2S2VOeG52RmZhY3hWOFNEK1NzL1ZZV0VQaTh6QmZjWHk4TmJrRkhrMnlkV2ltK1RCaVFTdWhIMEJCa0lMSEpOcXBoOTY1SFo3NG9QQm1ORTltYkk5YnlENFRpVHlLdzNXdWU2clgzWEhiNUR4MllTZTZUNVY2QUI3eEdsd3Q3clY1dFdNZDcwTTk1UDg5R3V5Rjh0QUhqREc3R1hFLzVId2Y3ZHBQR0VWYlBON1FIaDV0bXp3VEp1dHo1U3loZXh6SE04azFpelJveHVPSHJZYnIxeWp0TmR2TnhKY1NMcU9XRHlpMFZPaFA3MFBiaVBkRjNmWVU1a0N2VXVOcXQ5bXBXUElUMEpQUVU5RFQwRFBRdDZGbm9jSTJIYVJHWkxLbkIxa08xZHF6REdtTnZOdnRkYzZtRTMrMUVhdTJUMFk0ei9QOWVsLzFDa0ZlY1JEM2lzTmpmeDluWXkrV3RKMGNKVDRpRk5xelpSWGlhMGlqZE9KNzJwcVVzMlpTd29vc1YyRHJxK0I4cmVydHJVNzBxaVZNL045R0tJajU1WkN5MGRiWmlseXRTTnhqcnkxd1NUWGlPbm02WWcrOHA4QUQ3eUhQODlUamwxcE9IR3VPclRFWHIrWllWV0F2ZjZVVDlEY2FiNy9XdGtrNGlMTTUvYlVtY2FXcCtJcWF1RkxQbGV3ZVY4STlqbExKZW9kNnVsLzB4S3M5WDNPcU1Pa1JhUjlOa2kwTnFoR1d4cGc3Um1GQlg3REZ3YWtMVHUxWTNpYlBXclBRaFZzZHdsUFFNcy9icmZFTTFoM1BYaG0xb08wM2FmVjI0aDZuT2QrRFpMOUhMNzJreXlQaEIvU0YzY1EvUlBQOVhJdnMyN1F5czNWN25NM0ZIbkpXZFVvbjh5aTkwNTd3WE04bW5SNGQwWGlpQVNTZzlFcEs3NlBrMFBaT25UM1NCZVJlcXhTL0hRSG5OY3ErU3lVNnprRFZYdE9GMUoxU3dNblkvZG51WlJsZFJSeVBuMUltVWNvMC9SUXVyZVI1Vjhlb2pmQlhPaVpJS1J0Y28weHdIYVZkVC93R3dodnR2OGVsdUQ0dWliTlplejFUS0tlZWt0S1VWS2x6WEZxYTB0THhDdWhZU2pzdUxtMFNwWTFURytHdkNOdXhyQlFsNE1tNDFBWFF0UzQ5NjlJWEVvOGxzQWN6dm9RVUdhUm81c3JFV0lwYXBFamI3N0FVSEQ5dHF6bGFLNkVmVUZkTFF1bnZrcWVOOEZlRWpEQ3VleUtKMGtXU3BBc2txVldscmFrVnEza1hhb04rQlFXY2ZkSy95elZZSHZFaDkzYkkvWkhqMkRPeFYzS28xMXBacFdQN1NNZHI4aERMeldHbDlWanB5RDNYMklUM1F2ZVI1Z0dQMkduYmlhMlU5T1ZYajFndjFBdmxvUSt3dmRoelVCOWtDNDd5OFdxdzNucXJqbnRicGV1MXNleE0yekhRbWRhY2MvR3FLR3ZPYlltdjRoYU5WK1FiMUppc1FuclF6YVI0NWRhdG1jUm4wUVp6a1hrZXhNcEQzaGRSbU9qTEt6T09IMDNXL3F4MUNGK00ydEhaaW1SZTJXazlaUXYwOUFaNmFrZFBXOURUSnZTMEZqMjlvdzg1MzhlNS9xZ0ZQYjBSMjI1bVQ5dUZyb2RzdTlDTjBNM1FMZEN0MEczUUl1aDJhREYwQjdRRThrb0dpNjZ3TGxkcVhMd2o5NWJQb0N1dVdidG9QOUJzdE1JcXcvTlhNemJDYm9sQ0RmTDZMRDdqT2N6ZUw5cXFpT2V2cmJIbGJSUThPSjhKTG9tR0JaZEd4d1J6bytIQlpkSFVZRjUvZS9DNXFDRzRQQm9VWEJFZEgxd1oxUWRYUmZXZWpSNUYyNXNjVzBOc2kyTXJrdGhqeWRVbmszUEVLTGZDTWErSExJRm4ydWpyOGF5NUtUbksreWplYllIc3JhdldkUXVKTllHMFJrT0JaeVIrVmVzNDQyS3NnZXA0VnpqWlUzVjkyMVdWbkRWbkxNdTd6NW9VN3kzM3VjZHVJc1Y2OG0wbHhlT2thQ0YvTnlrMmtHSURmQjVTSmFtNlNjWHNEbkhWMm1RMW9HYmtIZ2YzS1dwUUZzNFhla3dlclp6ejVEMzNtNXV5bGlqbHM5VElNYy8wanNFUnlTbzlicDlEYnR1RGQyakhVb3QvcDczT0lmVzUyTXY1aEJkQUYwSnpvSXRZNlZTUzRzU0FVVGc0RDdvUW1nT2ZGR2VuQjU5RjRwQllJN243T1orT2o4NkwrdUhWNzFTVG5UNGtkbEJ3ZnB4N3NIdll2L2UzVS9LdTRGeUZjR3FqNUg1SzdpRkZMcmhZYVpmY1lObk9UMlRxdDhSaExIR3ZTMHFrdHNSOTlLRkxpRjFLZlM0ai9CeDBPWFFGZENYMXFRZ3VvYnk1ME9YUUZWNEhZOE5La2FPZlk3U0g3ZmFUdDU4clhPZjRzamdsbkpIM1VvWGthSU56UDV4N3VKSUxtSjFVNFhJdlM4cnJUeVRwTmNkRUdrdkNMQjVjVFd3QmRDMTBIYlFRV2dRdGh1NkM3b2FXUXN1Z2U4aFJ5ZGtlenVZTHp1WTExUHV1QzJqbmE2SHJvT3ZOQys4R3kxaEV1Qmd5UHlSYUNpMkQ3cUd2M211cHIzWnBMc21sRFBhWlFuN3dLdVJEUHJSR0xPODl1bGhXWkZpS1pNdWdlNGpmQzZjYU5lcG9PT1dEYTZIcklJOWtoSXVneFJDaktsSmxpcVd5YnZMN3BKdEJqSHBoUVEyejhBcmh4VnhZam85cTR0cjJrSUxkYThneUpqdllQY2dJWDJncFpCa2haRlRXT2N2WGpwek9GY2JTaEtyNUQzTWtMYlZIenF6THkrL1p6cVFxYkpzbGUzQndUZ1VCUEZUcDNjb1JrTDBHZXhvWkRlSW9qRDNJRHM0YzZkM0owVkNOUnlXblQrNXNkY2QzdHVybFZGeUw3Mjc1M3M2YmF2S0lVNlZUeWZFRTlDVDBGUFEwOUF6MGJlaFp5SjZMK2N3Z3JCSWx4ZXVaemZFSWpxL0ErUmI3dW5tdjFxdmpGUVBuTk14MzZyeFhTMDc3d0VvajMyNjQ5TVQ3cTF2ZzFCYlA1VjFhYmc4c1MrNmNWMG1UdkN1VjdGNUQzdEVrcGZkYnVUNENuaU9KZVJjYlRkbW44bHhSNjd0QjdLVjdsOVByRE85ZG5DQjduZEN0SEdNM1F1OTZnTFR0bkl1OVRkKzNrZjNicmNGNGpRc21ZVitUdmYvTy9obkVDb1pWZVh2Y1h2WEkycERzTUtPSktjK3FRcHI2MUpGZjFYMDZYSXAyMEc2MXdsdW12QkFOaE1TSVI5MlVWUm4xUjQ2WituVEEvaWg3WDFKdmpCNk8za2FMbFNBYi9USnFSYnA4MUltVWJjVGZabFdRaVhaR2IxRzM3WktvRmZYb2MvdFFFMnJFVWJUYnZpb2VWZFJkd1BrZm94dFpXWWtjUFhEc2dCc2pWTlJPcm02WDgzbWxLYWRUVWpvbW1WdmVkVWdEY2RSTCtTMVFucmJQS0s2aDlZdEUyR2hLY3U0dzFpckhVUmR5bUpmUGhKQjh0c3NoK2xkY25tU0xsaXJqbzYzUjE2SmUrSFpSKzE1Vk9WMXRYQ0dzTTJvVlo1REUwaUZQQ09DWTFEc3VTM0p0czBSeWlUYnVpckI0WllBNDJoUnRSc0oxaEZ1aUZ2Q3dzdVRaQXE5ZFRyOHQyaVpSZGkwcFdwQXJiemJpK0VtMHNVTklqbVk3clkwMndpcHpUbHZUTFVpNk10b0EvM2VwQ1hPd1czUzdPU3A2anhUOTNnbk1rNmJOV2xIU0NxSGs5bW9kZ08yOHNWK0dHa1pycU5kM2lhbDBmMEJLVzdOdHFHOWdkazE5Tmtob29CM2FYblN0cjZpZlpId3VWWTZ6clhIZmUydnRQdlhCVmxvL0xpMDVtU21SMEswRFpRYk11VE5hdys5YXduWEZ0VWhzdGJCRWEyUXZXbk43SlBISG93dFlHV1BQWEtjYzIwdFdpZTBudFFsdFYvdWdRL3JBQ3F4Mkd6dzNFZmJGWEdRcndPWmxTVHdhMENQaHpsRVo3a2t0RDZnOXA0VWVvdlZvZXBXb2NkUzFSeHRZRys2eFhmUkN0RU1kMjZPMmNqSVgyWHN0WUxRcGEzSFp2VjdMRk1kaWFkbzlkaEZHM1IvckRKUjNyekY5ZkR3TERuSWZSUnZsYllOV2FVSHVWWVFyYWFYOC9zdDc0SzN1d01oellHVkd2MjBlZWRNRitzK1VHSjhucXQ1aENFcVBnNDRsN2VnZVE4eDJVWFNkNDRGeExwSFRLNFo0cGJROTJsQnVIUE42SXk3OTQxL2hSUjEvd3JaUlppMXJyY1p5eGpIUEJZVmFMOWtTZTlUUUt5VXNid0RybW94c0cxSC93SFNYU09XanNucTFaS1dQaXMvNkYyS04xQlc5VnN3dEtkTnpYMEg2N2lJKzQ4cVVQbkFyZFlsRlBNSS9wRzJVOTNyS3RweGJyTXpWRGRGNmgrMGVxOWJUNjUvVEpIc3ZlK2FxdDBmUm1SeUxWR3MwOGFQcUp0cjZzZlpoNUM4NzU0VkpMbXBSeGhvUFhBdW1pa3BMeFdmelJYMDNXNmFIeE8zTXVQeSt4K2NPMWwvZDVjYm5BVnMrdlBkOURYamdSdEUvS3M3L1h4c0gzcHR3MzNSWVc5N3I0SHJJYjdwY0t2Q2YzWUlaLzQ1UzZMQlNZZFR0c3lubFFOR0lCQXBLZGNwY1ROay9HbnZPbEI5WlM0NVBiWXhsYlFvSDRJR0UvKy8yN2lMNXV3Nll6T0VmNmJoUnBNMm90MkF1cjBwaVdWS0ZrQWErMW94WE1WMkp4ZkpNVUluMHRmR3VUeG9vWGt2VkY2MGsxKzZiTmo2ZS9ZUjRkZlhIT3ZMbkRvUW5GblZITzVVMXhPalJrZWlTdG95Nll2dm9pVHBJaDNZSU94SlBZRXZNNUlUQ05ZeDN6SlMwcXpsNzdWVkd6d1djeS9aNk9CK1FkanJ3dG9JdU4vTzdrWEJkZWU4MzhYYlEzaC9VNzZhR3JITGxIZnYxMkVqNWxXdUkzS0V0cUwxTW1RZThweUR6U3BlSUpPWDNNNXpDTlBBZGRtejdRVmI4WDZXMitHZVN0ZUo5VFpkcHJ4Ky9yY3U5WlROVTdHTWQ2WFJOdHZkKzM0dEs5cEdpcmVScVVYb0FQYmJ2djliY0hUMitUNmxiSEdRRzNqWi9jRzBra2c1WVp1K2lmTVN5TmtFL2o5cmpvd2RWWDJwRXNuVnR4dHJDWkNaZW9YRUQ2NVBZYldzY2F6dEF1MzhsOTBGQkNpcWRramkwS3JvbCtqcjF5SG0yZWpSYW4vVEJEZEdYb2hXT1BSZTk3ZjYzSmVxRnRwUzdFdzMxN2YvNkR6NS84dnVpeVh3ZWgwWDM2SXJiTEZQWXJ2dTFydXY4dzYrUnl2ZjYvVWtWdFJ5QVZlNkJ0bzFtNVdqL3pkR21hSTE3WVVkaUY4VGRtK3hWMGZlMk1nYjFFYllWOXpHZFVHZ2R5VHB6NVFIUXhnSDJKcUtXLzRLY245ZzdUelRGYjlFWXVXa0FUQTl3NzQ1K2RDREhEYXowNjlIcTZJSHkrK1hvd25PaWJYN2d2QjlqMWY4MWxYK0NaSXZETHFoN256aXZpYjZrOGs4MmJIYlkvaEU0UDZ6eWQxVTNKekwzN1lPZUg0cWVLeSt6UjVaM2JIVmxXekhLZndSdGJFcTAwVk4rbG9ON0llZFZBK1RjV2w3UFhDdm0zQko5ZlVCVzE3WFBNcTh1MzRKWTVjQmw3aXZTeGtQbFd6Q1d1V1BBMmlpMmtwMEVkYkZQdFpQWlprVjhxV2cvS3ZhZHNzbXBMSFZTc29zZC9pbnM4MGY5MW1IV3Y5Wkc3TG51VmdpS3ZObG9SOUZ1UFpwd2pHdC8rdmVBWE1jL3ZNeUIzeEtxMENBLzN6eFlRL3hkbnpybE5FSWpWYThHamZJenZXTTAxbSs4SGF5Sm1xeFBhcHBtNkhqTjlIZWU1bXFlcnRSVm1xOXJ0RURYNm5vdDFBMWFvanY5RGFkN0tlRUJQYXB2YWJsZVZJdmVWTHZlMXpaMXFFdS8wVTc5VnQzYXBkK3BSNzlYci9MNlFMdjFvZnJVcnloUWtBb21Cb2NFazRMSndaUmdhbkI0Y0VRd0o3ZzZ1Q1pZRUZ3YlhCZGNIeXdNYmdodURHNEtiZzV1Q1c0TmJnc1dCYmNIaTRNN2dpWEJuY0Zkd2QzQjBtQlpjRTl3YjNBL1gzRjZPbmdtK0M3ZmJsb1p2Qnk4RXJ5cUZMS0ZZSzRxd0hnTkFpY29EWnBWQmM3UVlHTUkrSXl5b01ZNFMzWGdVdVhBVEkwQVYyb2srSnpxd1dRMWdFTTBDbHlpUm5DUm1zQllqUUhUQ05Ha01WWGp3VGs2R0F6VlpKRFNKMEdvYVlBM2g4QWdIUS9TbWdscWRRcW8xaXh3dGVhQ0pab0g3dGFWb0U1WGdlR2FEN0s2Qmh5c0JhQkIxNExMZEQyNFJ3dkJDTjBBNW1nSnVFcDNnc3UxRkp5cVplQk0zUXRPMFgxZ2xoNEE1K3BSTUVQZkFwVmFEcWJvUlRCYUxlQll2UWtPVlR0bzFQdWdTZHZBU0hXQTJlb0MxK2czWUlGMmdtdjFXM0NkdXNIMTJnVVc2bmZnQnZXQUcvVjdjSk42d2MzS2cxdjBBYmhWdThGdCtoQXNVaCs0WGYxZ3NTSndCNVlpQlZoTFNsZGdNUk0xSGFzNVJBZGhPWlAwV2F4bnNvN0NncVpvQ0ZZMFZjZGpTWWZyR0t6cENCMk9SYzNSeFZqVjFhckNzcTdSTUt4cmdlcXhzR3MxQ2l1N1RtT3d0T3MxRVd0YnFNT3d1QnQwQkZaM280N0U4bTdTSi96bHNLT3h3RnYwU2F6d1ZuMEtTN3hOeDJHTmkzUVNGbm03UG8xVkx0YlpXT1lkT2gvclhLSUxzZEE3TlE4cnZVdnpzZFM3ZFNmV3VsUjNZYkhMdEJTcnZVZkxzRnhhdzk4aE85SGZJWnZrNzVDZGhpVS9vOU94NXU4cTU2K1JUZkRYeU03RHNsOVdCdXQrUlNjSHIyTGpGeWlGSGl2QlJHWEFSQTBGdFJvR3hxaldHQTdxYmEvMU9rak5ZQUlJTk5GOS9SRGI4cUcyejhQQUtGcC9LdkhEUWFnajlBbmlSNE5Sd25hSlk3dkVqd0dUZFN5WW9rK0JDazBIVFRvT1ZPb0VNRWduZ3JST0JxTjFLcWpTWjhBRW5hWXprUEZNTUVTendWQ2RCU2JvYkVCL2NZODVWK2R4NW54OVZqVzZBQXpWaGFCR2M4QlFYUVJxZERFWXJrdkFZYm9VNUhRWkdLSFBnWkc2SEV4eW54bXRtOEJVM1FLcWRSc1lvMFZncXU0SFkvVkZmVVdCSGdRcC9RVVlwYS9xYjZqZHc2QkIvd05NMWlQNlc4NS9BelRxbS9vN2F2bzRHT1ErTTFsUDZGbHF4L3VpeVBaOS9ZQmFQQStHYWhXbzBRLzFBdkUxWUpoK3JKZVI4eFV3VXErQ0NWb0hSdW8xTUY0L0FhUDBqMkNvMW9NcCtpa1lycCtCUVhvRHBMVUJUTkl2OVE2MWFBV0g2bDFRcC84RERsRWJPRlMvQW5WNkR4eWlYNE5hYlFmVitqY3dOamdxT0VwVGcyT0Q2ZndlSDN5YTM5T0RzK2c1M3c2K2pXMDlGenhIdjhMeStGMFJyRkEyK1B2Zzd6VXUrRUh3UEZkWEJhczQ4OFBnaDV6aHkzajBueDhGTDJsd3NEWllTMDFUUTRaaENScHlWL1ZwR2thTCtGbFU3MnVkRUwzcloyNnIrQ1drQnFtUFovZlliMno0ZmcwbFFXcnlmbU8zeXlUa0tpRFdNNURTRW5rVnZlZGpqaHcySld2YjlQNUtITXU3VzVZWDdNVnZKazN2QU80eHRNYXJ6MWliMXE2dktPVE0va3ZiWmk3SnVqNXFqYVVNUzl3ZFMwY3J5ci9mRTIwcVdtVm40bWZjdlNyOG1PeWhMdzUvRnUybS9WOHEyTjNKbDNyT3NQek9CLzVEdkxwUE5QNnF2RStFUmUzUWxLaGY0Nkl0SDNuZkZVNUp1NjFENWxaODBsaktndEEyNHhxc2lyYVNxcnVNdjlNUzlTVGVPNy93MytSV2ZNY0pjdnQ3dnhMK1c1UzJIbDR6MzFWbG4rVC9Vbm5OVUp1Mm9qZE5haTE1eHQ5Z2lDMUUrdWpXUWE2TSs3N3d5ZnVJYlU3OHMvNllaN3BRZi85aDMrMHFmcjRvc3J6Z1kvbURXOXJ2ZU5reWlMV1gwT3VBbjR2R3BsYTY3bHVoM2RaaXV5MmFYaHdCYXo2N1gvSzJKdDd2MTN5bjQ3R1NmZEl0UU95VmFGdDhaNzZ2OVBnQWZDWHFTdkp1a3UwNEdZLzNUNytiRTN0NkRxNnQwWXJ5OXd1cFg1bTdJZEhEOGZnbGF0N25lcTFLZHVaV0ZEMlh2Qjg2anRyUjROZnBiVTlHbi9mOEZEKzlhdjRkbExxWjJuUmFxK1g5ejFxbFk2azJ4aWx5M3N1cDl6Y291UWJ0bjZ4ckU0dHRndUNKbGp0OGhLU095ZWZwMXdQWXBYMHk3dm4xbnVGdElaSTVkUlBMQ0huMzgwNVZQZnpmUkpQZGFQQVh6RjlmcysxUkFwcnA1bG8vTGJzYi9mSzhoRFdWVWxqbWZuMVcxaS95clZPc2NjdFh2eDk2TGJJNGJLRGJQSnZqOWNwVzkrNCtwWHkzc1VlVnJCdkMyRUxPVHA0dUpxUk9KZVRGc2pyQkt2TVV4NTJXTjNrYmt1TWtkYlRsSThpNzNxdXcvZ0o1V3lSelg0dHVmMGJZNzZQdHBMcTN5TzQzbGVDNE85Rjh4azhFN1M1OHB0bWpTK2NlcThNdVNzMGdPVTlLRUxaNDU4Nkl1bHh6cjJtaUhjU1lLd2YrL0Z5cHZrWjllaWluejF6ekN2UUpmMTk5cUliWkR4dHQvK3NrWGFHYmRBdCt5Q0xkNzVVODM5cGg5ZDdHcXYwOVZ1dmI5VytzMFk4TlBoVk1aMzErUW5CaWNGSXdNemc1T0NXWUZYeWFWZnF6ZktWNkJhdHlWdVNzeDMrb2xNYXJFZ3hSQmd6UlVKRFJNRkFSdnpzM0hBelZhRERVRW9UMmlGTDJpQWJaSTZxd1I1U3lSMVJsbVNyVUNyTDJMbXJzWFZTckRXVHRYZFRZdTZpMmQ1R3hkekhJM2tXVnZZdVV2WXVVdll1VS9ZcEtwSDVXZ2IrdkhkaXZTTnV2R0d5L290SitSZHAreFdDa2VFZ2hHS0VLTU5KMW02TkJZSktxd0dFYURCcGQyem1xQmpuVmdHclgvTE91K1ltaTVzVHJ3RlRYLzNUbFFFWWpRSjFHZ2hyVmcwRnFBQlVhQlU1WEk4Q0hBS0gxTmJoZ1ArZGdqUWNOOXA2UDFrUndqcjNuYWNKN0pvNzNUQnp2bWZqaDRKUENleVorTkpobTcva2NRaUM4WitMSEdwOHlwaHN6UUdBZm10MDNrTEluZlp3OTZkbWFDWnJ0VDUrdFdlQkllOVhIMjZzKzExNzF5ZmFxVDdKWGZiSzk2blB0Vlo5bnIzb21SK2RCZU5YUUJlQms0VlVUeDZzbWpsZE4vR0l3eTE3MXArMVZuNnE1WUtoOTY4OW9IaGhtRC9zMGU5aG4yY00rVy9QQlFiYWtFL1VBR0dXdittaDcxV2ZhcTU1bXIvb2NlOVZuMktzK3gxNzFOSHZWeDlpcm5tNnYramg3MWVkb09VamJ0ejdldnZYSjlxM1BFNzQxOFZYZ2ZPRmJFMzhSakxHSGZZbzk3RlB0WVo5bUQvdGM0V0VUZncyY3A5ZEJyVnJBY0h2YjAreHRuMnh2KzFoNzI3UHNiUjluYjN1Mk5vQ3o5Q2FvZEs4NDBiM2lZdmVLUzl3ckxuS3Z1Tmk5NGhMM2lvdmNLejZyRGpCRjNlQW9mUUErNGYyckk0SUp3UVFkN2wyc0t1OWlqZlgrMVVUdlg0MzIvdFdoM3I4NnhQdFhFK3lkbitUZG9mSGVGNXJzSG5XaFBmVUw3S2xmNEQyaWV2ZWxDKzJYVDdOZmZvTDk4dk85YTlUa1hhTWhTazMrRnRhdXd5cW10R0c3ZituMzhma3FsUDJaVnNhdHh4bWZOMFdyN1RsMGMrWU4wQnJoY3hEbUFWK2w5Vm9uN1RmMnVWOElPcm5XQjdXUSs0bG9wYy9uUGVxM2MrMUhyRGliT1BlbzEzWTUwajFHdW1jWWE1dWpoNGcvYVR3R3RrWWJRQ3U1Vy9keGpaK08ycndPZW9WeGZITzBXcFhSYnI4LzNRYTFJeGVTY0o1YVFEMWMyMENPaDBGSHRIMXZwWkYydTJTOTVKTW5ROXU4YWk3amp5dTlseXRJcytlYmZZNjFKMzVGbTVMM25vdEw4Tm5DR1NhRFZqMnplVlhTVGd3WlMrOFdlSDcwZXB2VTcxbU9IVjVSeWRybzVSakp3QzdPZDR1eWZPUWRFNjV2dzR2dUFWMEZiNDZsZ0pJak9NWXJzczdTYnpYNDZzN1NYb2JMUzJwWGRHOG9ISUN2OUpHOXJNVDM4NHJPcTZDZHlpaGVNMEJlR1hERWVhN0VkZ2J0QWk2MytOMStkTlR2MzhMdmJyZ2ZsSDNQc1hiZ1QvSVJacE9qc0VBRG1mSzlvM1JjcWIyMGlhM0dPbnEzdVB6RVB2YmdpWjVxaTk1VFRUVGdkZDEyUzJxNzhGVVY5YmpRSUhRWnBaL0xDMHZVcHN2bmszNlVjRWJ2UldlTGZJVGsrU0JMN3hVZ0ZoNzdHaWwvQWJKWXZwUlgwRmdDZG9GSGtKUXZwVUdsRk9kV0hPOTB2RDRwYlhYVWxZd1BxU0x0SlRJNlgyY1pmM08zMHZ2eUxHN1NKei9pKzM0ZXY5dmMvOHM5WFZIKzdlTjg4WE9tNVV1TmVxeXZUUzZiSjlUdHFhWVp2VGRJbkkxOVNJLzNXK1FTaWJVcFEwak12K3M5YW5mRnoxNjJFdSsySHhOeXROVStVaTJwUEtzNTFxVVFrdXJoMnVJNWpieUVQeXVvMVR1azZTbldlV25OZThUY2dQeTdzSmhlNStLTFBmWkExblBsQlhhaXRsT3p0ZEY3M3FIR2E0dHo5UkgvR1UvVXZnSlB5dHR6N0kvV1FTMjJqczNSTy9EWXlkRktPTFI3MUdrQnRtQkM1eUhjZ0dRWlg5bmtYMnFIREMzR1d1Qm5SYnpqbERjSDVtbCtuN1IvTnRHcEhvSmFOSTYwanpsSGkwRmJHSnRpZnlsdGxIeGJZczhkYnRWUjV5NmxrTDZIZXI2a2pFSzNicGRiRkEvYjlVbnNKVnFOUktzb3R4UDUzcWEwYk13N28wcmczczhjOVV0YmFsNlpaTGN3dG96aThTWFpIZTR0ZWk0MEdVLzNtR3M3bkM4WlQyVE84WlAxM1k1M2cwN1FEblVXdlV0TnEzcGNhWWRXdXdWNEN0KzFxeXo1WFJpT1BWSnVKMjFQN0s4N0hiOVY4VnprOC9Fek0xaDFNcjYwb2RFT05OYXErTHI1SUVIQi9PTjB4ZU5hMFZpOVl5RFBPTUUzMFVaaHpLa2NMN2ZqRzB2VlozU2JQQWFYbS9Famo1M1JXL1NtdnNMeW5TTlpOMG5GTXd2VzlvekxLemdiajkwOXRyczh0Q3Qrc3FmVDVjUTJXL3k5SkRTZDFNL1hNaVhXSUdHaEpFb3NyTXlaTkJEbHllTkxYS2F0S2c5MW1udmFFaGV2WDNZWHpMZzlTdkViVzR0bnNoUy81TFdPR2N1U1BsbEpUVDFLY0RVc2ZucmFWM3kxWUpaRWtzSWFGcTFmdHFtMnhGcWxxQ2VWK2thRXJ5WWo2TjVucldoVG9WWEVPcEcxUTYwVkZ1c3pXZHYyVVorZGNZdWs0elA1WlBVaTd6WWw5ODFJdThOamZnOWpQdnBPZUJBcXB5cTVKM3UvTWtlZHBYRWN0M0s4eWx6cVZSdHRqTmZ3N2ViWnVrY3ROeVU5TDVlTWl2NGwxd2JDV2orLzNPd3pLOFd4bWlEbVBOS0h5c2pIbEx5TzBDRGRZMUE3ZThLUEdmaFJDVHhIaVBRRnE2YlYxTGZMNWFlZ0hMeS9HMUZtUkgyWmlWNkQwOWZZLzF4RHVEWmFIajNQcVBzYzhqU2prV2M1czQ0WjZXNGtURkhlR285NithSnZsUFVwdGh6YXAyUFBIYmc0WFhkQmIwbHlGYThiaXU4WHhGcExZdkhacmhJOUs0WlhDNlNPa0lNVzNjUjRzOW0rYkZjcE8weldJS21DWHVEVzk2OGxCc2pHTVVqR052UHkrTEk2THE5L0QxbWN6M3JJUUtMdDJxMlg5dVNMZmR1dGhjUjdLcHdSeU9GWThXNjhXN3l0OE9sbXg5S3hYYVd4cytJeDI3WmllMm1CMnBCMlk3UUc0SFhUM2h1aVZhRGZaZFdDUkFkY1lmYWdUcm00UGlrL0daeDF2MnNsM2grdnEzcUlvMkd1ckJBYzBOTzduTnVGemgra1hGRktKMW9yMEl0OWNkL3JSTnFrUnF4anJDL1BtNVFnNjVuWUx3cEdXZGZhcWJzdFNWNkpYdUMzM3ZwK0RQS1Y2SEdsQmF5WE5jNlQ5RHU0cG8wYzhXZmNDeC9BL3IvRWZzQ1h3T2V4OG9mcFVhM21aS21UZTdRcnNLaTNvcDJKWGtJMCtsMWxTZnRTM0g4ZUk4MW12MXU1SE43c01uZzIyVUVQZWpQNkJhbXY1cWlmTWw3eVNpSnBaWHM4c1ljbEZYM1RKdkdiU25pRW50R1NucDVUOFR6UjYydkYzNFVLSFdhTC9ZQjR2eGdxNDF1WDlQRnA1NTIySWw4cnZLZnI1NFlyMFVocktVK0ZvOTE3THd2NXV4Sy9pUFZPY3VlZ1ArNlhzWTVjbGkzSUlia2dueGNFM3ZIeEhuZjlrMUZzbzBNZk14SjZQRS95MFVhV3NCUDBPY2QrUDBPYmpJbkZWeUlvYjMxMVVyOWV5dHMxa0NlV3piR2x2TysvVjdtVGNhN3NQWFprMnIvdnhPejdlNGl4OWZoOHdUcUhJN0M3bkY2UzFpUjN0UG9qdjd1N0sxbS9GUFJJU3hBL0JlOFcyRnh5L2RKcksxTDVMelVOekpZODgrU0x0ZTBSWXpmb29heDRSVVNzZCs5M2Y2T2tIMGtsOVJJTzVMa1krMkdkUmZPdzkvNFN2YmczbTMvYyt4eDdwNmoyUmZVM3ArVDhRTytWbGgwM2V1aEhXNlJrWnhTK0pYS01nMEwzOTBtcTFEZ1F5K0Q0a1p5Vno5VXFqSzlPZEZndkgwRTVDSEE5emUvRStNNTNhQTVOVVp2UE5mdWJFaHdiNDZKMmZndFJUVW1HeS9OVEpxQURjT2ZmYXhsKzQvdnp6VTVUdjllYVl4RmM5ZGR3M1Z0NmtpL2JzbytwbzVsMXA4Q2pPdjdTdE9KYzYwbFJLNW1VOUorQ1ZYaVo3N1IxbHh0bm1QbjZpMXU4Y0czbi9NVithVEt5Zlh4ZmkvYjNVMk91SlNWMTczWTZVS1lmN1pFditwY3kzN0g3cU85bmhnUFBkK0RmV3hpb0JJbG5IRk9SbHp0K3dQdVk1UHhQckg4NFFFMmtTa29TbHBjK3NXNnZIT3c5dEZsUGhmc01QVVU3WmxPSzlsbXlwYjZPQmNmaW5mOWN3WTczdVBKZlJUZWZRdmg0UU44M3NnZnU4bnVqTnV1bDFYcXd0SzViYlh5MHUxZ3Z4ZS9UbDlGYkNBYjJuQ1o4aXU5Ri9JSDZUWDg1U3hpNGZTZWpsTU5vYlZHdktmQ3B5ejZYMWw2NFZrMVNkeFYvSXlCYVg1VHZuYmljZmE4LzVaVmR4ZlNYUGg4LzVVTk55cTNyNE81MWg4S28xVWVQSzdrQytoUXFYaEVEbi9HVkdNUk5ZRXUwM2V1bFdFc3hCN1FGTmpsVmgrUHIvT3Q0QVhhU3NsMEo1OEl2ckxxOWtudWRBN3NEWTE3NVV0YmdrcmNBMzVtTnRpY2pTVmVTcXZRejQ2dkxqMmJXbE1PQmZZY3M2bkVOaXZmck9vclM3eXBabW5NVjdNZjFLdnhvNnpwelMrd2dYbTMyK3o1c2tjUkZZMTRXbXFUNmd1dVdRT05BUm9McWt4V1BReVdwaXNiREtYSHRReURsa3UvMDFaZGV4ZnFzZVJicHZ4M3AyL2pkNm5WZGwrMnB5UWxZSTVZZGUwTS9xZHRzdWVXMFdlZE1XY09zS1JWeTFzOXhXakw1MmdvZnAwQ2haS0hyM3N6UnR2aDB6QlVVUE1mb2NTTXNPOTQ1bjU4emN5N2JTamJSQmFVVnQyZXhYbUs3YXZPODB1WDdlMXZkeWwyeFh0SURHSGt6b3M2RWNMYWVzOEJYTEZHYW96cmlCVHRjMWt1NnhEeGllVXI1MHdOZXYxQ0xKTjRiOHl5ODU1MHV2WjR1SHMxTDN3OForT2ljZkV1Mm1IZThFNDV0ZE1mcjNXSmZOVlZ5blpNcFAyNGtzbVlIOExVLy81cG5uS3ZJbzJuK1NGOWNyQi93aWk5ZC9OM05wUDFEK1Y2b0hFTytaSHdqUGhMTmhDWDB1YnZzSGEveWJlWjloTktwb3M0RC9mM3pNbk4weWphUzJFdHl4MHhRZVM1ZHlRNWpkYkhjdE92RW9wM0xmcVgzdWtxc2pEbVppMlZMZThhdWpjL0ZPVXBvUHl6ZVIySk1hWVcyK24vT2JJZzYrZDBjcDZvRjViV3l5Mk9JT2FuV3RoQmJCZkdzK2RoM0xpeVhzNWEvcURWdGU2RFkzMlhjTGRhTE1tWDdRSG9QSHozai9ibU1aNG1PTWwrRENsVTg3cTVuamJISmJ3KzBST3VJYnlTUHJPc3NLS2VYbmF5a3VpbHZ0MHZNSmxZc3p1OUFvcld4Wkx2MzBNdWpVZTlleHJ6UVIyOFhYQ290UTNxQS9seFlkRng0eDcxWXQ2bFNYUFo2cnpZc0w4RWVOY3drUjlacXdyc0tTb0VpS2Z3N1RCT0FkSWdtS2RCaE9sb1ZPa2JUS2ZrNFVLc1RkS0xxZEdyeXh1dGtmVTZYays2TCtsdE4xVGYwdUQ2dEovU0N6dFFhdmE2cjlCTnQwSTEraXZSMm5nMWRxN3NvNHp3ZEFnSWRDcW8wQ2FSMEdBajkvSEtsRGdkWkhRRUc2VWlRMWxGK2x2MW9VS1ZqUUViSGdpSDZGS2pXOUVTK0dwMEFodXBFTUV5bmdscDlCb3pXYVlEbnNFR2p6Z0E1blFsR2FEWVlxYk5Bazg0RzlUb0hOT2hjTUVybmdVWS9zOXlrQzNRaGZPYUFlbDBFbW5VeEdLdEx3RGhkQ3NaYkl3ZnJjMkNDTGdjVEM5N3NEZlJWL1hmaWY2Vy9vUzRQZ3lvL2lWenBKNUdyOUEwdzJFOGlaL1U0R0lvZXY0Mzh6NEtjbmdQRDlSMnRJTTZUeU1qd1BCaXRWYUJKUElsTWZBMDR5TThnajljcllJSmVCYU8xRGt6UWE2QmVyNE8wZmdKU2Z2bzRwL1ZnaUg0S3h1cG5ZS2plQU1PMEFVeWs1VTdYaU9DTTRBelZCMmNHWjZveG1CM01KbjRXTGRyb3AzMHIvTFJ2blovMkhRUFg5MVFCNmxVSjd0VWdXOXRnVUtFTXVGZER3RlJWZ3lPVUJWV3FBVWRwS1BpS2hvSGJ4YmhJdkE1TTk1c0w4cHNEaXpRR2pOZFlNRkxqd0dpTkIwZnJZRERZbHZ2bm1naGtDMXZnWitObDIxcGcyNUp0NnhvL0d5L2Iwd0o5RWtqVHdBTGJsbXhiMTltMnJyZHRMU3g0TnY2R2dtZmpiN1NkM2FTVHdCV2FDWWJvWkhDclRnR0ROQXVjcEU4RDJSWnZ0aTErMlUvTEw3UDkzV0g3VzJiNys3THQ3NnUydjYvNWFma3YyL0tXNmdLd1RCZUNwYmEvWmJhL3BiYS9CMjEvZjJiNys0TG1ndE5zaFE5b0hwaHJXL3lpYmZFdmRBV28xcFhnYzdvSzNLcjVJSzJyZ1hRTmFOQUM2aXd0QkpmckJ2QXAzUWlrbThCdHVobE0waTFnaVc0RjBtM2dkaTBDaE5SSFdnSk8wSjNnT0hyNzNaS1dnaWxhQm83VVBVQzZGeHlxKzhCazNRL3UwdWVSWG5vQWZOSlA3Lys1ZTg1L2M4OVo0S2YzNVQ1enRmdU0zR2NXNkZFd3dUM25XdmVjaGU0NU4rcGJRRm9PbXZ3TS84MStobitaZTg1WDNYT1d1ZWNzRlQySCtJc2c1LzV6ai92UEY5eC92dWorODJYM255KzYvM3pWL1dlZVdzQmw3a1VMM0l1V3VSZGQ1MTcwb0h2UmplNUZON2tYL1lYZUJHZnJuL1N2a3Ava3YxMnQ0SDY5Q3o3dkovbnZVeHU0WDc4Q245ZDc0RDYxZ3pxOUQ0WnJHeGlxWDRPdnFBTkkyOEVTL1J1NFM1M2FJYWtMek5SdndNbmFDVTdSYjhFc2RZTlBheGM0VmI4RG4xRVBPRSsvQitlckYzeFdlWENCUGdBWGFqZVlvdy9CUmVvREY2c2ZYS0lJWEJvb0NDUy9UWEI4RUFaSFNuN3I1cmJnRThFeHhIbjNodmlNNERqaXZJRkQvTlRnTk1rendCM0IyY0Y1eE04UHp0Zjg0TFBCaFpLL2ozRlZjRkV3WC9KWE1rSi9KU1BqcjJRTTgxY3lhdjJWakJIK1NzWW9meVdqMFYvSk9NaGZ5V2oyVnpMRytDc1pZLzJWakhIK1NzYkIva3JHUkg4bDR4Qi9KZU13ZnlYakUvNUt4alIvSmVOWWZ5VmpocitTY2FLL2tuRzZ2NUp4aHIrU2NhYS9rakhiWDhrNEs3Z3ZlRXJ5OXpFTzkzc1E1L2c5aU1WK3M2akdiME44eWU4WFpmMU94SmY4VHNTVmZ0Zm96dUQ3d2ZjbHYzRjB0NytrY2E3ZmxWanM5NDd1OUh0SGQzc2tYZUNSOUJhUHBFdjkza1NsMzV1UXY3Wnh6UDhGdmlucTQzZ0JoWlpyY0pSWEhjWi92L2ZkZmJPRUZFSUlFRUlJSVEwUkVCa0V4QmtKQVVLc3BVSzRoUUFCVXNLMWFBaElRc1ZDYXkrVVVrQ3R0eFlxVnFXMDFONnMxV0xyQlR1TzFuN3dVei80b1k3OVVMOVlOZmF1OVZZOHM3dGROelF6empQdjd6blo4ei9uM1RrNTgvd1hnVkp1anNZU3RWNjFySjBSUGQzOXZiU1FBcmgwaVRGQVJJcUVES1dVTVlKeUtxaGtMRlZVVTBNdGRkVFRRQ05UaTlaSVRKb1NoakdjS3hqSktFWXpobkdNWndJVG1jUmtybVFLSDJBYTA3dTdlL3A1TjhkdGdTYnZzVytIWlRsdTc5Mjd4NG9jZCs3djNtWlZqajI3ZDNVN0w4ZmVzTXFtUEEvczJXOUxqbnYzYisvMTZoejd3cXh0ZWU3dTNXbDdubjJ6UG14bmdiUGRVdUFjZHhZNDE1NENQK0wrQXVkNXNNQ1BlbE9lQjdiMmVlUTk3dXZ6ZUk3OTRXdDVWNDVBQkFpWUgxVUJrZ0d1WUJpbERLY3NqRVl3a25KR1VjRm9LaGtEeUhoQUpnQlNBc2hZUUtvQlNRTlNBOGhFUUdvQm1RUklIU0NUQVlrQlNRR1NBREtPQnE3eG9laDQ5RUxjR3JRNjdvL1B4aytrcHFaYVVsMnB3Nmt6cVl1cGw5T1o5S3gwWi9waytrTDZMMGxkOHR1U3FTWFBsZlNFNThWTWtxbk96TXkwWkRveTV4Q1FEQkdQc3NZYnZjblBlOUVIZk5DYnZjWHozc3FBWC9DTGZzbTcvTEpQT2N1SC9LN2IzTzRPZDdyTDY5enRwL3kwUGU2eDE3M3U4elB1dDk4RFh1OW5QZWpudk1GRFB1d2pQdXBYL0twZjgrdmU3V1BlNCtNKzZ5bS81eE9lOWtjKzdUUCsySi80VSsvMUc1N3htMzdmSjczUEgvaERCdnlXM3c3OGptZTkzM1BJR2hKS3lHVHZiMW5SNlUra2xrblVNWm5wektHWlJYeWNxL2dFVjdPVWEvZ2t5MWhPR3l0WXlTcFdzNFoyT2xqSGVqYlF5VVkyc1prdXRyQ043ZXhnSjd2WXpSNTYyY3MrK3JpUld6ak5XZTduSEEvd0lPZDVodC93SXIvajk3ekVLL3lKUHpNZ1RySFJEenJERHptVEdKQU1jcEVycUtPUjJiU3draTU2dUlGajNNMDVudVJwSXJzOVROcmxydU5WYitOdmxOam1lZzU1aEw4NzM1K1R1TUlOOUhzNzc5aEU0a283T2VCUi91RUNFbGU1a2RlOGczL2FUT0pxTi9HNngvaVhDMGxjNDJiZThFNys3U0lTMiszaVRZL3pIeGVUdU5acmVjc1R2R3NMaVIxdTRXMVBjc2tsUkc3MVFtQ2ZQeU1pUlJ3RW82bEJXb09Hc3phb2pBU0lLS1dXR09ObVpFYmVvWjZZaU5wNE9sSlZHRUU5SWhzeHUrL1c3Qm1tQ2llMVBldkRxS1NHQm1Zd2x5WmFXVWE3ODRtcHBNeW00R09DTHdnK05uaHo4SEhCRndhdkNyNG8rUGpnaTROWEIyOEpQaUg0a3VBMWxDRXl2SER6alk3eWg4SmZVWFNRVWw3bEVQMGM0RFZlNXczZTVDM2VwbEJCRGNNWmNMbHRybkNscTF6dEd0dGRhd2NSVWtFTkZPMCsxVllTSUUwNTljeWxsVTVpUUZxSm80cW9JampFWVV3RXN6RThRTDZtanNpL0JrSk01RXVVWTNnQVJDcUkwZWVSeXJ4RFBSSlR3WUNOSklCa2lBRTlpM2JrYXdiUEhDUHlsRTFEenZVUWV6aW9ic2paTmxKMlpSVU5PVCtUdE0wNThmS1FGV1VrMXBnWHp3NVZ3eDhwNFowaW5SbXk2aGRrZUdHUXJoK3k3bDZHOGZCbGFodXljaCtoOTc1UERVVzNlS0JvaFZRZ3pZREFsVVJCQTBHNHppMDRxTElTcWNYQ1hoRXltaHBBSkNaQ2w5c0I3OXUvdm5qLzNCcTNlb2hTSXFTVnpWQjBWOWN6emNQNVhBK0o3cTNlNWhGdjk2aDNlTXc3UGU0SlR4WWwvUDh5K2g1UGVicVF4dmNaTXJnb2dhY1I1ek00cEMrajhuMXZMT09vWWp6VlRLQ0dRaG9YNVdrdmZad3VKT2NyNHBSQ1doYStOWTJVWjN2UWVVTzN5WGVQeDN3ODJ5MUNYOGgyQlNrbnBIOWd5UGw4YnU5aEx5R25zNGtjOHJnb1ZlWmxQVTFaTmxmcW1lcXZpRm5LTXAvTCtncC9TY1JTZngyNHpPY0RWeUN5dENqRFd5aWxtbHJxYVdRNk01bk5QRDVHTXpvZmJVSVhvTTNvUW5RUnVoaHRRWmVnczRpQ3d0dUJPVUhEc0xCejRnbEVwaGVkUVNVbFhpanVqRVJCclVGd2x2TTRhUDExaUt3ZDlObFRpSmU5NXhGRUtnZDl0aEtSZlVYdmJtQ2szUXlkY2FjWkNKS1J4RlFNK1gvZlNNaWVvdDNhYUhDZDY5MWdweHZkNUdhN3ZOWXRidjIvdnlQNkx2OGxRZUhPWjI5NjZYOEJRR2FldUFBQUFBPT1cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3N0eWxlcy9DaXJjdWxhclN0ZC1NZWRpdW0ud29mZlxuLy8gbW9kdWxlIGlkID0gNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///59\n");

/***/ }),
/* 60 */
/***/ (function(module, exports) {

eval("module.exports = \"data:application/font-woff;base64,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\"//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc3R5bGVzL0NpcmN1bGFyU3RkLU1lZGl1bUl0YWxpYy53b2ZmPzk0NjciXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6YXBwbGljYXRpb24vZm9udC13b2ZmO2Jhc2U2NCxkMDlHUms5VVZFOEFBSzUwQUF3QUFBQUJINEFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkRSa1lnQUFBTmNBQUFZQndBQUhBMnNINkhva1JUU1VjQUFHMk1BQUFBQ0FBQUFBZ0FBQUFDUjFCUFV3QUFiWlFBQUR0WkFBQ091b0RDM2p4SFUxVkNBQUNvOEFBQUJZRUFBQXE2RUp3UTMwOVRMeklBQUFGOEFBQUFZQUFBQUdCUGIwK3ZZMjFoY0FBQUJjd0FBQUxvQUFBRVhod1UzTlpvWldGa0FBQUJIQUFBQURRQUFBQTIvOU1zakdob1pXRUFBQUZRQUFBQUpBQUFBQ1FLWVFuWWFHMTBlQUFBQ0xRQUFBU2lBQUFIUk50aEY2ZHRZWGh3QUFBQmRBQUFBQVlBQUFBR0FkRlFBRzVoYldVQUFBSGNBQUFEN3dBQUNIT3FTWFBHY0c5emRBQUFEVmdBQUFBVkFBQUFJUDljQUZCNEFXTmdaR0FBWXFmcHpMeTc0dmx0dmpJd003OWdBSUt6UGRVdUVEclg4bi9WZnpFMlRlYkxRQzQ3QXhOSUZBQklwUXZtQUFFQUFBUGwvdlFBQUFZVi8zci9ZZ1lwQStnQTFmKzBBQUFBQUFBQUFBQUFBQUhSQUFCUUFBSFJBQUFBQkFJaUFmUUFCUUFFQW9vQ1dQL3dBRXNDaWdKWUFFb0JYZ0JRQVNRQUFBSUxCZ1FDQVFFQkFRS0FBQUF2VUFEa2V3QUFBQWdBQUFBQVRFNVVUd0NBQUFEKy93TXAvMEVBeUFQbEFRd2dBQUFCQUFBQUFBSG5Bc1VBQUFBZ0FBdDRBWldVelc0ZE5SVEgvNU9tU2RNbUJSYXRTaGZWZ2JKQXBKbmNwS3pTYnZxaFZoVzNFdXJYRXNrejl0eHIxV09QL0pHYjJ5ZUFCUXRlZ0RVdndwNTNZY2tHNTlRYWJtZ3F4TXptNTNOOHp2bmJQamFBTDZ0ZlVRSDgzYTkrS2x4aEc2OExyMkVIVGVFTCtCcS9GVjdIelhIT1JYeU8rNFUzY0FOZkZkN0VGL2k1OENWc2pMRmIrQVRYQ2wvSjlFZmhiZHdlZWFkNmZHR3I4Rlhzcjk4cWZHMmw3blZzc3FwcWZRdkF5ZG92aFN0OFc3MHV2SmFqTnd0ZndQZlZYNFhYTWNHZmhTL2lzTHBkZUdQRnZvbUgxZStGTDJGN2pOM0NMYmpDVi9ETjJuZUZ0L0ZrNUoyMUg5ZWZGNzZLSHpZV2hUL0ZqVkhiWjdoWnVjTFhWalJmUjliOFFzMlNFUjR2b0RCRGdvR0FuNHJrbFgxSEQzMnlWdmxIMnJlbmsxNUd1ZmRjU1ozNloxRVkzYjVSUG1objZhQ2VUQTd1VVpPMGtUU1pUQTVMZ0tjY1FlOGo2SDBJcGhCSThGQ3dlQWZDdzh3cHM0WENXSWgwSUVIUkM2bDY0ZCtTNjJpcXJZcnVpRlpUNzUxSmZVU0hrNE83OHhpSG8vMzl4V0pSR3c2cFc5ZnZ2NXFyM2NjcTZKbk5rdkVJR2g0dHltcnhFaEVTZTNnT0JRbU5oQjdQRUNGZ29OSGlEUlE4UW1ZSEM4SUJha3p5ZjRCN0lEUkkwRENRbVNmOEgzNVFnVW9OT2xPRFZxczhWVm1iaUVxU3Ryd1NhcGIweE5rNEZVMWViSkxhMWZUSURVdXZaL09ZSjNXT0JtV2x0clA2bkhvYUFaU1pFT0VoSUtIUXMrOHRDQTRkQ0ZObzN2Y0loeVBRUjFYdmZWdzF4eDN5WHR6RkhCRVJRN2J0NTMvQmZ3MnpVcVZHQzRjK2UxOWhEb1ZkUEliaW5aM0JsbDErQ2xWWUlISmQ0Z3hqSGQ3ekpRaFArRHdpOTFSVDFDYldtU3Z4ZWh3R0xPRTVmMVpYTW5Wd21RYXVJOWt5UXowVml5NFpTa0dkdGx1Y0srcWNqWUdjNTRFVVVWQ2JMVUpiSldtaDQxemJjUnAxMnFoQTZxUTFTV2JvbmRUZE1oL05IZkpLaEtENnhwU1JGVDFUaU01bklHZHBTTm5ibWlXSlk2R05hSXlpb1B5eDh1RTBRT29RZFpNaXp4WldacDh4bVd0NllKZVVyUG1YY0Iwb0xnYzM4MktZNjVhQzYrSkNlSlVsRzBPTm9zRzdvTm9VbGF4emYza1NVdXFvblJXR204cjM0blNVcTZpZHkrZmZwdWsvZU5xZ3UxUGRLaHV5SkQ2SkJUcnVJRUpDZ0JxN0xXTE9vNjZjV21DUFgvRklQbkdScVMxelJPa2RDY0lDbW1kbXk0ZlptRFFNRk9kVk9FRUxnd1JaTEQwY24zV0haVG54T3lCNEtBZ0UxdG1qZ1Rucnl5elFyOWdDZDdFdkZpcnZ3WUJVWW5OTjdreUJZd2pXSTlpak9GYkJaenQzK1ZoQlFuTld6ZTlJWE1rdFlDRkxuQm1WMVNBOGdPVXFDUmJtUDNaY0l6QXRNY0JoeHJkcVlIc0xRdUNaRVF1Kzc2cnNzdUZjRFk4SGVEak8yaUtWKzFpWHUrZFpwZVExeFBJNkNwaVZXK2I1elNtK3NoYUZIVnorWDIvRjlEenJlUHQzMmQveWFRWHdMdjBOZDN1L0hnQjRBYzNPNjIrVFZRQ0E4ZWU4Nyt5d0UzQjBVemJyT09ld3R3VUdGVlFVNXBVNlphaFRCL09HdDZJUWhLS0NHQVFEV09ZTjhNWUU4WW9CeEVzUkZRUXZDQnBkMHBJaFhoQk5oTHFlby9OdTlKdUpDZWxlbThiMEgvQ0xUL0o4L3dIdXY0Y1JBRTRITGdJSVUrRk1BRmFUSWtBUUdNaHlmREZPeE1VME1VTXNGc3ZGRTg0K3A4ZnBkZGU1YVhldis1RWNJS3RramF5WERWTExpQndybTJWY3RzaDJPVjh1a2F2a05oVlNXa1hVSEhXSFdxdWVVV20xUzJXMW93TjZzQjZpYTNXOWJ0Qk51bFVuOUN5ZGFjeDRtN3lkM2lmZTU1RllOQlN0amE2MHp0R0tmdC8zb1dTUmJDeGFKb21wSWxHMExDdGFza1hMTjJWTFpkRVNra05sV01xU1pXTFpjcGRNbFMwSk5VK3RVZXVMbHUxbFMzWFJVbGUyekN4Wk5ucHZlZnZMbHBUbEtDV0w4UC95Ky94dXY4dnY5QmY2cy8xMnY4MXY3cS9zRHhUK0xzUUxzVUs0VUdjUDJZTjJ2OTFuc3paanUrMXV1OE51dFdtN3dkNXJsOXBGdHNQOGFhenBOVnZNWnROcFVtYUJTWnJwWnBnSm14b1RNdFZta0tuSysvbSsvSUY4VDM3dXQ4bGNWMjVGTHBtN05SYzhFam5pSGQ2aldnS1RuVFlFLzU4Q1RoQkE4SjlWTGhVY1E0QktCbkFzUWFvNGpvRU1ZakRIVTgwUVF0UlF5d21jeUZEcXFPY2t3cHhNQThPUUtEVERhY1FqUXBRUmpHUVVUWXhtRERGT1lTempPSlhUT0ozeG5NR1pUR0Fpelp6RjJaekR1WnpIK1V3aXpnVzBjQ0VYTVpsV3BuQXhsM0FwYlZ6RzVWeEJPMU9aUmdkWGNoVlhjdzNYTXAzcnVKNGJ1SkdiU0RBRGVKQ0hXTVhEck9WcFh1QkZOck9GbDNtSlYwanpHbHZaeHV1OHlSdHNad2M3ZVp0ZHZNTjd2TXRlOXZBQkgvSWpkektUV2N6aFp4YXppZmtraGNNaTVvclJyT1JaTVpLRllveUlNWnU3aFJLTllqaUh4U2ptc1ZTNHZNcjdyT0FXYmhjak9DQ2FoT1kybHZFTE45UEpBenhGaGl5OTVQbWVQZ3lXM1dJOEg5UERId0orNDNmUktxYndFMHY0amgvNGxmdDVoUHQ0bE5VOHpocTZlSXduV1ErczQzazI4QnpkZk1wWExPQUxEdklsOS9BMWgvanNIMUI3QWhoNEFZV1VmV2lWWlJqR3IvdCt6ckYxNXBxeU9XM3F5Yk8xNDl4cHV2TTZYZWV3cytuVUxFZW1odmlIUlJTV3NDMmpJc1FvaGNKV29RWXJpUFdoWlFucFJEUkNXZ3Ira1ZnZ09zMlB4S05OejhpUFNBMjFUZWZIM2NYTEdGT0VEdnk0bitkOXJ1ZDU3K2UrM3Z0b0FncitKTmhIRlFya1M4elR3NGhvRWcrNEhCVHJkd2poTk9aSkhHUEVzN1d5RTdVNkJURUoyMGxwUUs0TUFlU2diZFhuTUVvV0lheGo3SlNHN1pyT3NXNHR0QnM2bVdmMklsL0xvZXJaWHhKRlVLSjJYQzVodURhZ2hqRXMxMUhseXJqM0MvdVI1NFMwZysvZndWaEhQSEtCODMwSXljTWNseUNvR3hpTEVISWJHYytScTF5Znpkak51SVJ4SmxSbllLcXV3MFI5Ry9YdUFCYm9TdHV0all5dldrYml6R003cXFYU1dqVU9UKyszWFpKblBWcURMSjFoMThUNGppa2NGeUJMbnNWSVRWbUhzbFl5R0pCc2UxTWpISWNBTngrcUNUTFczN2VmKzRPeWdtczc3SXE4eVB1Vm8xQ1ltOHRIVkc3WVQrcnNEK215VTZ6YkNCbkNISnJzTTIyR3g5b0Raci9vT0VSMVBtdTJnUGRZaUloUW8wbTdLU3ZzalBOUUxIdFJKZi95ZnE4d3N2YitzOGQ1NW9lOHd6T1lLc3N4WHRyd21PVGJVWDBTU2YyQXVnSjQ5S3BkeWpCTjJqbnZ0V091QkRrdVJkN2oycysyMDYvN1BRamsybmJmQy9vd0VQcHdCN29IZy90OXVKdnhpREZtKzE0TWhGNHd4NURXMjIyLzd2ZkF6YkZlM3d2Nk1CRDZnSUZvRklGK0grNm1Gc1U2MWpxVlh0d0J2ZEM1ZGx3WkpSdlFtRjJVQ3Zzek1JMSt2Yzk5TStINzJQL04wRGM1Yi92a0hUdEtldnk2TDhaSTdMSXVHV1puY2R4K2s2VVFlY01PNmFlV2NSRjR2Z2ZMVWNwdkd1d1QvNmZMVUJ4SW9adzlOUTIvSTRGTzJ5MmYwNXNXSk9Samp0ZlRveC80RFVUWkV5L2hQbmNkUlZMQ09oZlJ0M0tBUGRVbTMwTmtIWFhiOENqM1ZVb3phYUx2YTFBdHJaakF0WHo2blNmTCtSMjJjZThXdXk0dHBKazBJWWM2UjUxamIrZEtKMHBkSTFLTytjbzV5K2d0eTlEM2pQdUhCQ3p0TGxzNm1HUHBRY000UDh6MWM1YldwWXo3ZWE4ejFHYVJBcnNoUjNpdklveVdnOWJMODZyMXB1MXp6N01HVjFCS0g2KzQ0WWpwS1hweDI2NjYyWmp0b2tnR1hxZXVCWFhLZXVrV3pOTXFycGVpbEhYWUtnWGMrelhLM0NUTzYreWlmb0lhYlNUVjdHc2lYSGY4L3QxcldPQlRaN3NjMFZrSXUxckVmRHlVdUFycmNqblVjZnkvWkNFMzhBVHpiY2NFWGNXK1gwUmV3RWkzbXJUUWEvNVlXMC9LV1BlVnpLdU45ZDdDZVF0cEprMUl5UnJHVnBSVEY2YXVrRDBKNnZLcEMxSVhvaTVFWFI1MUllcENxQVQ4dmo2THViSUprK1ZYanI5QlhKN0NRdW5BZU01VEVxUzN1UWpJVmlUUWpaUzJvcGJQcC92OTNJbHhySDFDSXBna3k1alhaTlRMWnU1NWk3cDY1cmVXbm55RVIvaXV1Q1lCVGRvdHhpRmtCQ2trTDVQVkpKc000bnFHOUpETG5HZVJZU1JHT0xhVGpPK1NSU1JGUnZmRlNmbzBQZUs1UkVtQVJNazRVa2FHOTcwWGZRd2wyV1FzbjNjeGppRTF4Sk1LNWh1M3pkS0FCeG03cGRJMmNQeVFOTnEzTXBFMTVQOGY1Nk9rMTlMU3d6eVhJY3ArcXVqcmtiU2VSNFIzVjkySUFtbW41aXQ0MkdPSDJhY25zSW41cityM3M5OWZpVk0zM1U3SVVQdGIxdHRwbVdWSE9ENGdhK3dRdVNTTDdRSzJzZC96cUdtd1k3TEVPbmptWHB3RS9nTXRadHd4QUFCNEFXTmdabUQ0L3dXSVV4a0NHTEFBQUYyb0E2c0FBQUI0QVpYOGQxd1VTOUF3ak02eTlDek00S2lzZzdycjdDS1lBd3JtTElvNW94aEJRSEtXdEFzQzVvaGl3aXdDaW1RRUJFUlVVTXhaTVlkakZqM21kTlFhN1BXOHQyZlg4NzNQYzMvM2ovdjlGcm82Vm5WWHA2bnE2cFpSNW1hVVRDWnJPVHdveWljMjFEdHFhb3h2MXdsK3ZrR3hZV05pdkVPRGZLVEUzbUlUcWtGaDFxQ1FpODNORjFtWjRSbFc4citzekxFS0x4UW9pdTc0S3dBUmFQTzE4UWtDdkV1c2lkdkN2eW4xa1dDbWFLb1IxWXhTVTNaVVI2bzcxWWZxUncybFJsRVRLVGZLbmZLaGdxbElLbzVhUksya1VxZ3QxRzVxSDVWUGxWS0hxZVBVV2VvS2RZdTZSejJoWGxMdnFLK1VTUDBmR1MxckpHc21VOHZzWkIxbDNXVjlaSU5sSTJRVFpXNHlUMW1nTEVLbWt5WEpsc3ZXeWpiTGRzb3laYm15WXRraFdhM3NyT3lLN0k3c2tleWw3SjNzbSt5WEdUSnJaR1pqWm1mVzBheTdXVCt6SVdZanpTYVlUVE9iYmVabEZtQVdiaFpybG1pMnpDelpiSlBaRHJNTXN4eXpBMllWWnNmTVRwbGROS3N6dTJmMnhPeVYyU2V6bjJiL3lpM2tUZVVxdVoyOGk3eTNmSWg4dEh5eWZLWjhuanhFSGlOUGxLK1ViNVR2bEdmSjgrVWw4a1B5WS9LVDh2UHlxL0piOGdmeXAvSlg4dmZ5cjNLUS96YVhtMXVhTnpibnpkWG1yYzNibTNjMTcySGV6M3lJK1NqemFlWWU1Z0htNGVZNjgwWG1LODNYbVc4MjMyVysxenpQdk5pODB2eTQrVm56cStZUHpKK1p2ekgvWnQ2QXpGRmp4Q010Nm9MNm91Rm9QSEpEbmlnSTZkRkN0Qkp0UVJtb0VCMUZGOUE5OUFKOW8rVjBVOXFXN2tZNzB4Tm9MenFTVHFSWDBUdnBJcnFNcnFMUDBkZm94L1JyK2l2OWkvNnRNRk1vRkl5aWthS1Z3a0hSVytHc0dLdHdWWGdxQWhRUmlnVEZVa1d5WXFjaVczRkljZDBoUERZME5EWThxSHYzN2k1RzROemRCSXdocCtIOUpOQ2pYMDhqY0RhRmhnMmZIMFE4VHQyNzl6R0J2aVl3ekFoNk9obEJMMGNqNk5QZEJIcWFRQzhUNkcwQ2ZVeWdyd24wTTRLKzNVM0EwUVNjVEtDSENmUTBnVjRtME5zRStwaEFYeFBvTnlJMktrTHlPanIybUJUbUYrQnQ5UGZ1YmdLT0p1QmtBajFNb0tjSjlES0IzaWJReHdUNm1rQS9FeGh1QWk0bU1NSUVSbnBIUlVYb1EvMzhZNHllMlBsR0VCVVVFR2lLOEkzUWh4dHo5dXR0QW4xTW9LOEptRkE3bThDdzdpYmdhQUpPSnREREJFejFITjZiRUlnSjhnNzFEZkwzZC9FTGpmR2VIeFhoRytzVEV4MGJGdVlkRXhSaEpPYmsyTXNFK2tWNSt3YjVrRFVnM0Q4b1BDZ21QaWc4eGk4Z3lqdlVlejRwRnVjWEdlc2RHaDRSWTRTaGZ0SFJSazlBbEo5M2pGK1UwZThiRVVPd0JrckllZzd2NVI5RWN2bk9pNGdiN1VSNnJFZE1WSkIzUU94OEtiSFhzQjZoRVF2OHdnUDhmTWdhRk9vMzJyRnZyeDdHaXZkMk1qS3FqMk1QRStobEJGSS9TOERSQkp4TW9JY0o5RFNCUHpsN20wQWZFNURZTm9JTVZ4TlBlcGxDVXZHUnc2UklDZlF3Z1o0U0dERnk1QUsvcUFneXpzT2lJc0w5akRCR0gyR0NnVkYrcGhqL2lOZ29reWRJWjRxSkRvb3pRVCtkWDdqUjV5ZjFxTkVYSHZRSGtSR3piM2hFbUlSWmdoSm1DWm93U3o0SnM4a2pZWlk4RW1ZSm1qQkxQaE5teVNkaE5pWE85L2J4Yy9DUDh2Ynhkb2lJOGcyZlozUjlqSzZ2MGZVenV2NUdOOERvQmhyZElLTWJiSFJEakc2bzBRMHp1dUZHTjhMb3pqZTZrVVkzeXVoR0c5MFlveHRyZEhWR1YyOTA0NHh1dk5GZFlIUk50WXp4Sjd5WTUwZFlGaEJPQXI0Um9XUUhJcDc1ZmxFK2ZnUWI4WVhHUmhQZ0UwRkdxQ2toS01LWGVDVCtFVUM0UjF6Q084bVZPRWVneERjQ0pLNFJRSGdtdVJMSENEVHlpMENKVzBhMG9SSGh4dVN3b1AvODBsZ213RGlFQ2Z3em9vbnZUNDJpU1lqTWlRQXBKallxeWkvY0o1NTQ0LzFNZUh4aWdreFlJZ0trdVJNZThWOGp3b0xDalMwSml3Mk5DWm9mS3BYeERkSUYrVXJWSUxtamdxUlNmOWJHLzhmWDE5VGttTUNJMkdqdmNLbmQwaHBGd0gvWS9zZGNKS0gvcHVPZlZ2eC9OZUcvNEh4dlVtbHAwWEh3OFk3Mk00YWtKY2NVREl5ZkgwaWFJbm5ua1NFVTRoY2o1ZnlmNFQ5NS8wVDQvYTlrdi8rYjZCZm5FK29kSnExZ3htQkFyRFQvd3lMK0w3by9tOFgvVHYydnZGUjN2MmlKbC84UEJyOXdYKy9vUUpNMzdJL1hWREthOUVhb2hQZC94L3hmWEtNY29xTzdPMFpKYmcvdk1NSlFpWmxTcUNjWlB4THNGZVVYRUJRdDhjZ1kzZHZITzRyMG9uZG9qSEhjZWZ1UXJqZDVZMktqd3YwOS9jbWZaNURraEJvaFdWQkowZWlnYUlkdzA3cjlYekRXNTA4TVdUZDFmaVQ0UDFMQ3ZIMElFZUx4OW9tTmtkS2sxUzgyalBSY25CVHdOaVhPaS9JekZZeUlNVldEK0tOSTZ3aUlDUXIxbFpMSUNodmdIUlViRnVvZEs2WCtWM2ZKSHh2dTZ4ZjFQOXJ3MzBlZUxmbktzelY5NWRuKytjdzdJMzJzTmFOc3FRSGtjMnc3VlVmOWxuR3lTYkk1c3ZteWZObEIyU25aQmRrTDJVY3pNek9GV1ZNenRWa0hNMGV6cldaRjVOUG92Um5JbThuYnkwZklwNUdQbm0vbVE4MVR6UFBOajVuWG1sODB2Mm4rMVB5anVXaitHd21vSStxT3hxTVphQTd5UnlGb1BvcEhpOUFtdEIyZFFYK2hWM1JqdWc4OW5wNUhCOUJSZEJLZFRWK20zOUxmYUt3d1YxZ29yQlZPaW1tS1dNVml4V2J5OGJGSHNVOVJxM2lzZUtQNHBQaXV3QmJtRmhZV2pTeXNMVHBaT0ZqMHNSaG9NZHpDMWNMZEl0cGlrY1ZhaXd5TFBJc1Npd3FMV292VEZ2Y3RIbGw4dHNDVzVwYVdsbzBzZWN0V2xxMHR1MWdPdHB4czZXVVphRG5mTXRZeTNuS2g1VkxMbFpaYkxIZFlabGp1czh5eExMUXNzenhpZWR6eXRPVWx5L3VXOVpaZkxMOWJpZ3hpckJrVlk4ZDBZTG95VGt4dlpnQXpoQm5PVEdMbU1INU1DQlBKNkpra1pobXpodG5BN0dLeW1TS21uRG5NSEdQT010ZVpCOHhMNWlQems2VllobTNHdG1CYnNXMVpCN1lQTzRnZHpvNWl4N05UV0RkMkZ1dFJXc1owWkxBbjdvUDdZMC9OWTVzMkF1c3VCREVEQlBIeTE0NEN4OWNsSDNJZnJCckZhQ0FPTitLaDZZRFAySGFVRUNob1dINzk1dFNVcmVxY3JBWGgvbEY2djhDWW5MeVV0ZXZYYmRUMlc0R1NWeVV2WDZrYWNXNzI0Nzh2WEx4K1BPamduSzBhb002bFBVTjRQNTNnaktBUGplVVRFQXY5b0FrMGc1N1FveWVEZStDZVdBcjFKN2lIQk0rYnNuS0FCUlRRdSs4ZEU5YXQzN3dyWTh1OW9oWVhjOHJMejZ2T3pUM2VvK2NrdDk2YXA2dFIxYjZzMG9LZE1YRlJDZkVCQ1JxT2g2RjBvak9xcDdjZTI3Ui9uZW9pdmZzMkdrOGZoUWpVanNaZWVDYUNnVEY4QnhxVXdDRTJrUUYvb0pSWmtDbmEyVE5LSzVaUG0rKy9lWjRhOHgwNzRKYWRyMHkvOStqdXFWZFhQQThQanc1ZHNTQmVXNU54UFB1bytzQys1VXYyYUhFN083NGdVeC9oSGFJTEM0M0pLQ2d0MkZlazVYZzhZRTE3M0FwMzZDcXdMd1hNYkJHd21qYjArVDFyQ2pOSnRBMFNXTjdsekl6SEx5OWZmbkRObzJ4VVFzenFwWW1hM0lzSXV0Rzc3eUljUVR2amdiZjkwWlp0dXplbnEvT3lGb1Q0aE1hRkJjVHR6OWR5blJuYzZmY3N4RjBWQmo2QUZ0cUpEQ2dlRHNJdHRLd1lhZE5KWUZlc1hibHVLV0V4bmJ4dGJlcEdWZUdHL0UzNW1vZWlBckVudGhXbUhWUm43NW9rc0dyY3RqVnVnWHRqN29ZRE5MbFFWVlNTcTJVUENnNEM2OFo4MVVFSGZYdUIzYkE4WXB1ZjJybHZ1TlEzL2NFTFBER0JMSCt0MkgzTU1FYkx3clcxSUJOVHdFeFdBNDNGbVM4WjBWNzh4WU01MEFOeEc2enMwcjlibkJiM2hUTWd3eE1Vbjh0ZWY0TzJLdkRDL2FFSkhrZCsvWEVUMGcxdFg3ZjU3S3ZCRTdDTVpPeExkMHZ2OGdpVUttZ0Q5RU13MTNEaUVmNzUvZHJCNkIwOUJPd1Jia3hqRGJaSDdFUFJEQTJnRXdOOVFxYXRXVFM1eFRONk9sNktXR2g4UUFDZDJKd0g5ekhDZFhSaVczNUd1VHA3OXlSQldkZFR3RTBqdFhGT3F4bXdwRG1ZakRtd3hwT25TMk1YMTlDSlE1NHlpVXV4YldzdlBOemlIWDBDbk1Ic3lmRVNDKzRkbm9USFBCZUFwV0VZVE8wQU14RWJ1bUxod2poMTRxTFVMVW5hWldRbGlZL2VGcTZlTWoydzh4THRBNXA5TERaSE1IRWNBd3o5NkRuRGlrUDVaNWVQWHIxMDFHdk1FRGUzb2FNOUt5OXI4Q1NEaXZjL2VpUGhpaHJpd0I1R1FpcjA2dkFVTnllRHBWRTMzQVV6THdlQjRscDFkbG1lRmpONngwRzRrZHJEZld1dXQ1WnJRUHkrd0FuYng2cnhjdHdaZStBNDNPMWJkN0FHTFRUNkF0M0FmTWg5YkQxeFJuUndpQllVQjk3ZUFFdDE1YUdsQ3c1bzhVYnN3ZGRWZW8vdE5XN1dxREh1UjYvY1AzdnlMaG1pcXp6MWdSNlJzOEpiREp3N1pVSTdWWThidlVFRDdUOStCdFY2RFpidlFNUG1qZXc1S3VMUTRVT1pKVlg3TlNjTG5sWHZ2N0grWnN0eTZNeVh6cy8xbWVjYk1EY2dPN3lpcXJqMHNJWUROeDViL04wTjFORGxLeUJvQmN6QW03aFJRT0N5QlJHYTY5QVdRUmE5OXp2Q0RUUVdjTzIzcVNnanEyRG5JZldWS3Q4eFBjZDdqQjdvZis1OHl0cE42elpwTVIyTHVQQVZDeE4xNm9TRlc3WXMxSzdZZ0xZdGlONFJwcDdzNXQ5eHNaYmx6NlFkT1g1YmZXZi9URy90eXVSbGExVHNYYVlidzdvenVPblRkaUN3MkF2SUVnYWU3R1ltWHBpSmx5RHNUdTlpZnpIOElGclpackNnYk9IQ2tGN3ZTdVBHdUVraXlkNHBpWVRINFZNSUd0RVg0VGhjRTdzaDNJYkdBYmdLbTBFVndrcWFoUlkyMElsTVljNVZZSmV1MDJhK1J5d3ZqbTNvdDEzQXczSEZVS2lReGlZZ1EyY1MzRWZTWGdqWUVuZEFuMm1XSGk4UWFqTGE4UDUzcTZNTXE2eWRLTEMvRk9NSTNjbDRLdTZFYzlsTVhjTXNQUnVXR1hQZ3dJR2Nzb0tZckdDLzhKQUFEUXZGZkQrQnpmQVAzQnFrbmpndFpLSy85cEliS3RoZnNLdEl2U2RqNVpKMDdiRklwTXpVbHhRdEtWWmZQRk4wcmtUTFBvWVJhT08yamJ1M3E0b2o5L3Q1aG9WNGFqWThsK2hQZ2laWUNaUFk0endNZ0NFd0FBK3BxOE1EWWFnVUdsbEg1dUlRM0ovNFJrb3BlQ0FlaXJpN1RHaFdUR0ZKWVc1Rlh1eitZRC95cGFPQm9UYWgrMklLUzZXNG1QMGh2bUVram1zWXkvY2VQUDArNmtyZndXMkxCQkJJVjVNRzh0M0hUcnFDMnRQMU5RTHdOTFNGSm9odFdPdk5zR0FPazBGRy9zM1plVUhqMUtQbkhLdmJzSmJsSjA2WVBYenFVYTl6bDgrZXVuTEdvM0t5MWczVGZHNVdlbGJXN2dXeEViRnhrZEVKdTdJMEhMaXNCYm40VGk4VFkwRE80L2MwREJIOUVINXR1TTAzOUtkeER1a2lHNXFEemdRMm9qRmwySVM5eFUwSTIrb0ZRR0lCaEJzS0VQZVBtSkFxMk44WFdPZ09DSnBETDVhdnhBY1I5cWJaR1lLTUxZM0k4L0h5Q2ZEUXNGbUFrRUZKaTdGaTNGckJrRUZIWTNNa1VyUWh3aEFiaFMwUXgvZWxzZHF3Q29FOURhb0dMVjhhUWVhRW4zRk9sRmVWU0hQaUtDLzJmMi9vVDhOQWM3RS90a1dmRkxqcU5WVFZFNCtoUDI2Tk9CVTJwMWNsQnkwaDFLb09sbFNWek0rZjUrSHY1eG1ZRTFhaFpZc1ljVEp3YkdhMHdPckVCRDJiK1JYaFRUU2NoNE43UHlNRFQ4ZTJRN0NJeHFkeGFXeGJ4TUZyM3RBZkFoRTJWOEJwM0o1RWQwRFlUQ0gyaHdCUzFjeHZDQitnWTlzZ01vTEJpbWJCd2laQVlNR2hJVEJKWUx2MEhkeCt3SVZ4ejFoOUlzTWlvR2tXWVFVWnV0REtCcWJTdUNuV29HRHN6Ri9FUE1KamFJNE1TMjQ2ODdPaEZWL05zUEEwOFI0cmJadTlCWFk2ODB5czRLRjVGSU5iSEdIWTE1N1BiOVdQclZlK1k5c2k3TmpsYjNwVVJ3UXkrdnBIQkRudnNCL05IcDNQWEh2TXBJTDhNc1BpcHJEaW13eHFZSVZPS0UvTlBsQ2hMdG1qQzFtUnZEeDV1ZGJydWNCdDJTYk1uUk13ZHdWN09mRWZ1UGdQNlJ4enhDWUwxeDRKc0JVc2xkM1pRUUlIVTJFeXRJVWNHSVl0d0FKUDBtSlBtdVVIa3VrZGtCTmVYbEZXY3FRa01tL2UzRUEvVHcxSEIrSytaRnNwaHI2SWZUWmFkK1I1aXQ2YU5OdUNaaHRtSWRhTHFia2lLSnV3VzFKU1VqU0xTWHdMbW8xbmJsd1Jqb09WMHBiMUxRb3VMeXNzS2lzTEtmTDFDUTcyMWJEb05RMk43bzdFbHRnVHQycVBXUzJidDNCN25GNFZFUnZoUGptczhyaUd1M2ZpR3FEYk1sWjM1elpFNkdVcy9TWkRZTVh4aUhURkt6bWJ3dWpaVkxCZ2FTeURZUEFGSGZxZUxQV0ZnbzBRZWh2YUkzYWN3RmxIQ2l3MDJpdXdpL2JzVzVTblptLzhmZlhKVFd1Vy9wc2dRdENVWnFjeUh6WlZNYXlxQjcweU9YWjVpR1l5R2RiczhaamRJWUVxVjNjZlp3MG5qdWRoRFkyOURTMFJaNjE4UnByS2srVUgrcjZBamkrZ0Y2blVDMmovWXJIZSt0amZZUHMzeTJkK1FZWnRSNFJjUEVqWDBFL1BpbGVQTVRKV2I2MnNaV2xkTzhUUnBQc1JIa0t6OEZESFlqTEJ2MytLK0pKTi9xMlZtYXoxd3MvendLd2VhTGN2TEt6bXhSbnZEVE5vN2g1RTNaVlFaQVBEM29XWU96TDJDVFFpemRkQjVUM0NtZ1lmVW9lR3RkQkV4dUorUDhTcG42RERkOElwNkFxS3Y2RURtTEhZRFhmRVdld21YWU9lNUlRbTFxd2FLMGdRSEQrTEFTUW04UnVzK2dUTnZzcElzOFNBeitCSTR2anN1RzM2YUpWZkpJa0R1eDlpR3hKM2hha0NQNVN5blYzN0QzeDlBSllrNnVoN0dQZ1dlT0s3cm9OWjcyQUc4V0dlWmcwSmlDVU1nQkhmNEJ4cmt3VTB3blhTL0xuNTl6MVo4V05TOHc0SkFxbTVGOG1PbEcvWWRLaEtZNTkrZnkxbnNUc3AySlprYlV5ek10a3FHU1dqcVVDS3N1eERKVkxVTUVHMmhxSzh6S2dBaXZLbHFFeUs4cWVvWlJSVlFGRnJLYUtnSnNLUUxKbWlzaWxxTVVYdHBhZzBpdHBQRVRVMWxVUlJPeWdxbXFLaUtHb0ZSVzJqcUEwVVVXWlQ2UlJSWkZOWkZKVkFVY1VVVlNnakdtM3FBRVdWVUJUQmM1Q2lEbEZVbVJsMWhLSXF6YWhkRkhXVUl1cHU2cGlNT2tGUk5SU1ZSeEZkT0hXR29rNmFFU1U0dFllaXRsTFVaWXE2SUtPdVV0UWxpdWpGcVkwVWRZMmlibExVZFRQcUxrWGRNcU55S2FJcnAvNmlxUHN5NmhGRlBhU29ESXBLcGFqbkZQWEVqSHBCRWMwNlVhUlRteWhxSFVWdHBxajFGTkczVTdVVTlaaWl6c21vZW9yeW82aUZGTFdha3BGV0w1RlJ5eWxxRlVWRVFhS2FsNjJqcVFpS0lseHlwaWdMaW9xbHFDQ0swbE9VanFMbXk2Z1lpb3FYVVNFeUdTRkhqZ3UyS0ttZGxDeXZOWlZEeVM2MXBzSmtzZzhyWlRjazZkS2Vha2NPQWJwUUk0anF2MXcyWGJiTXJJMVpMN01vczRObXo4emV5N1h5MXZMQmNsZjVYdmxSK1JYNUU2SWV0ekZ2WXo3UWZLUzVtM21rZWJuNUVmTXo1cGVSR3AxR0Yra3U5RFJhVHkraEN4U05GVU1WSXhYckZKV0t5NHAvTFJSRURoeG5zYzdpcHNWYnl5YVdnbVYveXdqTGJNdFN5eXJMWjVaZm1lYk1RR1lzTTQwSlp5NHhIOWgrN0ZnMmpuMXYxY3FxaDFXTVZaWlZXU1BiUms2TmhqZEtiZlNlYTg4TjVuWnhwZHlWeG1hTmh6WWUwOWl0OGUzR241cUVOVG5hcEtiSnhhYWRtdlpxT3F6cHNxWUYxdk9zbzZ3UFdSKzJyclYrYlAxVTJVYlpUamxBT1VycHB2UlZoaWtqbFBuS1F1VWw1VjNsZldWOU02Wlp6MlkremVLYkxXMlcyaXl0MmRGbWYvRlcvQlIrTTcrWHIrQlA4OEQvYTlQWXhzYW1vMDJBVGFKTnNzMWVteEtiaXpZZmJjVG1vYzBYTkYvZmZIZnpvODF2dHJCcFVkR2l1c1hwRm85YjJyUWMyWEtheWx3MVFEVlI1YWxhb0VwWEhWQlZxK3BVOWVycDZ1WHFMZXA5Nm1yMTYxWm1yWVJXTzFybHRhcHFkYVhWMzYwTXduREJVd2dRVW9WSzRaZG1vaVpDczFsVG9UbXZlYTc1Vy9OTjgzKzBNbTBmN1hTdGp6Wk5lMVQ3VVB0SSswVDd6TmJldHAxdFI5c3V0bjF0WFd4amJiTnRiN1Z1MVhwSTY4aldHYTNyN1JnN083dEV1MVYyRyt4SzdHcnM3dGk5c1B0b2grMFpleHY3TnZhTzlnUHRSOXE3Mm52YUI5ckgyQysxVDdIZlpaL2RSdDFtWTV1WGJWNjErZDNXcnUzRXRsRnR0N2E5MHE1WnU0QjJLOXZsdER2ZnZsdjc2UFkxN1IrMS85MUI2RENvZzN1SHhBNjdPeHp0OEc5SGJVZm5qbjRkVjNRODBMRyswK1JPcnAxMG5iSTZGWFk2MitsOHA2K2R2VHR2Nmx6YitVN252enEvNkZ6ZlJkT2xTNWZKWGVaMVdkS2x1Q3ZkdFdmWGlxNjNIR2lIamc1YkhaNTI0N3JON1hhczIrdnVzN3BYZG4vb09NbXgyUEdPNHozSEI0NS9PVEZPalp4VVRtMmRlamdOYzVyZ05NY3AyRW5udE54cGs5TWVwenluUTA2bm5hNDRQWEQ2MittYjAvL3B3ZlJvMUtOeGp6azlkdlM0MmxQVjA3dm41WjYvZW5YcHBldTF2MWROYjY3MzRONURlNmYzL3R5bmQ1OE5mVjczSGRSM1Z0OTFmYy8wZmQ5UDJhOVpQN2QrUC9vSDk0L3BuOWYveklER0Ezb1BHRFZnNW9DbEE5WVAyRDJnZE1DUkFlY0hpQVBIRHB3MGNPYkF1UU5yQmw0WWVHdFF5MEUzQm4wWTlITXdOYmpsWU8xZzI4R3RCMThaTW5USXFDRVJRNVlPV1RVa1pjaTVvZktoallmMkdEcGo2QzNuS2M3dXp2N09VYzRMblZPZE01d0xuUTg3bnhqV2ZKanJzUHZEdmczM0dxNGZuai84cFF2all1VXl3R1dReXhDWFNTNWVMb0V1UzF5MnVleDNLWFFwZDNrN3dtS0Vka1NmRWROR0JJL0llcnoydmJqenZTemx2V2o1WHA1aUkxNXNtR1c0U0w4M05QRGlUdEhTc0ZQQkdSSTRyRFArdWV4OExQd0YvdnhUR2xUaUtvVHRhZHp5dDNhajRDeDIwRUdlM2hxYWlVcCtqcUNzaFdpYk9RSUhTOHFGSjJJYkhwclNJYmdqeWQ0VG1oZzMvdmZHalI5YWJSS2cwd3ZjbkM2RWpnZzZFbDhsRTRoN0lkeUtwUGRDbldrU2tJaEFaRThlV3RIQkVnNDF6WFhXL1ZMb3JYY0NGUXNJSE1CQ2VSODZZa3YrSFUyKzBFQzE0ZW5yTDZvNzNxY2REMnVXcnkrSGFlaElkT3FjV05YUERIUW1xTjR1WHlOdElWMmxUekZzdGJKclAwem0wK0hwRC93MDIxZjRZTmNud3F5OXNUWFZxazJTS0tUQlZEeEtYcnQ0MmFBalhRR0ZhcFgzeThWb3ZxS2c1TmdXVFJDcFdOaWV4S3dpRlRqZzAzeXlaM2pvcktWRjBMMUZvWDVYVExpS2c2UExYMHpXZ2Y1RlZvVlFMdTNtU2pVRmM4VkJJeGhsWnExb2diY1Jqd3NGRXhyc3B3b2N1QzM3WjZpdWdmNW92UldZdGNZMklXV00rTTdHRnJvQTkwOFJPT0lBUExvcnFITjNvMnVsdDQ2L1ViMFlmUXZMTzlwUHhFM2NjanozaFdpMkpTWXVROTFtRDUvVVdxV3M2SEtuRDNEM1R1WFZuTk5zMjBJUW5SNkE4RXNZeVovYVgzQzZRRk9jL2hOM1hiWUNLU3RDL0x6bWU2bmQvQThlMW9JVFpQTDZQS1FzV3JoblVWYTI2dnlSZmNXSDh5SjlnK0tEWGNNMEhONWw2bC9abi83bDhGamNTdmZMVFM4ci9DUXZCQzhldHptQm0xN3NwbmxZamFhOENRQUtMRld3RWhnWVJCb2cxMHkvaGJBUGJvMWwyQitucURnOEJ0dnFmazBqMkp3L3lXRy9PSm9IdXpuUVpPd0h6Y0RaNkd5M1lreGhoUXF2eGxaNEFPNk1hVTJ0Q3dKUGFBczB6SU5rRmVjRldDY3FTT242TXFFRHJjTTIyTHg4WGw5QXZ1M3RycnA5K25HaDljUGFTWitoV2ZtaWw5amFCM0gxZHdWSUlIU2VMR0t3QjI2amd6RTZjTkRMTmx6aWZmSWl5cmRzVFVuWm9GazhmYXIzekdVTEo3YUFScHZmZkNLVlB4VllNbXVXVDhBc0RiZEt3Q0c3ZE5CYkw3dTdncSt1S0s4cGl5anltRFZ2M2h6Zi9LQXFMUmQ3V1JDUE5nVHltS1lOTzM3ckVTQ2FBNnZFbjZMdlQxa3VzSEFhV0RtMGgyVThXQjREZDJqMXNtQnlIMnd4QjN2alZuMENMenpYZ0RuZXpFUFlHMWdENDBBNUFScmpRVGk2Sjk2QWgySCtLbTRDL2JRY2JrNitwV1laUDVKZ21nMElEYTJ5bUU0R29vQTZzL2FIT09zZldSM1FFQXRXOHBDaHpLbkVmOFRaMzJYTHdCSld2MkRBejVuNWZsTllBblk4WEM1bndJTGUreU5KZUM2U2tkK1J4djhhR0FUbkkzazhsNGFka0lXNDQ5ZVlsWUFnK1FXemNyanc4THF3RnhyQkdxSlZ1dVVzcEpNYWxIK1hpVWVJekdIUTA3RjJDTjR2WVN5NEczVk15bjRHcW5vemQ2OHpoMG4rNVdBdGgzNURCZXhHZU5ZNkhlWklMdmxnZmJnaW5GRjJ2d092d3hrT3UyRkJEODc2Wnd3a1NNa0hoZVFMdkYvdS9JT3BwcjZZT2QxbjluS2lWUUxGNXZwM0lGZlZCaGZQbWVNWE9FZWpiQUVPa0Uwd3BPWXgrMklZYUE3dDNuMTlLN3U0a1NFUjRzeFlZYzlPTW9tK3kwNkJIR0tna1J3MmdoKy80ZkRla3NQWk5ia3RIbGFkdi9SWlZUL2lLZGJnOWtTcnFGcXRBWGtTdWxOeC9jWFZmRzh2NzVpQXVaRWF0OUQrN3VIRFY3dTA5TUdkTndwd3ovM1IxMGV3K09uM3g3TDhOMysvRlp1OWtJdkQzZm5IWHdwUG5OSjZYa0NlVTBicVI2dnhkRXhETXhnTUU0bmJCSVpBTHpCcmcrMDd6Qnd3STNwSjJwN1VkWnZYYmRIV3dqclVnMTQyRjVVbHVLZjdxbHQzNjRSYnRMMDg0dVhoWTN2TGM3UUIyNHFqcTlYZjE3MzlDWjFWTUFrN2dDMFpJa0Y0Sk82Qms3QWVCdUF1c0ZCelVlekI5MXp0TldHaTJsVmZlZnBHNVpXcngzSkNwbXU1eVl6TVFTRERidTFYbVBjRlpuKzFGcnRCby82UCtrTWo1UnZvV1NhTUY2Q0FCdnN2ZjBQVFd4NjEwOU8weXZySCs4NDhlS3A2TytFbWJxTEJRM0F0ZndobUUzSHNhbEhJckZIVDUvVFhrcWwzbmo4TTh4SUY1WmRiQlFHelhDYlA3cS9sSURFeGdwRVZrVUhSVXhyenJwY0VQQkdzY1VzWUF3Ti9mQVRMYW0zclN1VEhjQkFvcVFtU1FDWVR5MTh3MGhyQS95TW03UkxXWURtL1hzQWRreGpPaTVFMWV5Wk9zZWtpM0NWaVFSbklZUTRnR2RqWVhJQXlCS1gwUHBBalhQcUlnUnUwVVE4d3BwU0JYUVJqbDNmUTR6dHNBblBySXVDVVZXSVhVZVNCUGp0aXlHMm1POGp3R0RVWlh0TWtJUVZQaCthWTlNYkxhd2RPSDlFcTQxWU9RWC9UOXdBai9NRTRnQlBvVHBHOUpyUlRZODc1T2RqQTBKL0FRenZTeEFXa09xY0J3Ukc5VER4cDBqbzFvaWZnSXdpZm95OENBVlo2NFRLY1JuQ09Ib2RQSTI0UEk1c29jQmVUd0V4czBNczJna0l1RGkwVGJBMXIwZWlrQUsvSjZnbGhoMDV2WDc4clpidDIyMG5NeHErTVJxdjBxeU4xS214MnF4K2gyK1R4VTFEbWFFQW1ia0VjdUFZTDRrd2IwTkxZWDlTQUNOY1I3azlqakc5ZGgxdEd5b2ZCSCtndmlEdTNGbWp4YjFKRjE0Y0NXSXQvazhSU1Jwd2VMRFNrMlJqVkx3Tm8vTlJRaEp1SVJRaTNkUlhBZ3BaSUFHUFlndDdRY0VmY2dXV0dIWVRpVmtMeEx4dC9JWmlSUlFyeUlqalJXdmhHT0ZEMEhTTEloQTk5eWZ3WlFGYjBPU2hDb0xrbzlIK0lyYlhSZHZ5dEV2OXAycjdKRXozN1hCWG9ZeEJCa0dWTjBWMk8rQStSdTNEeTFJNnNHczN0ZHEvT0RmMkdIdHlxQlRPaWdoNGdRSTAvL3dPM1I0dm5SNndJN1Nvazl3Z2ZPR2RxVzdCdndZR2FrQzc1RHFHRTlId3l5dHJZUURNYUk2aEdQM1B2UHdVcjFiZmhEM0F6RFY2bUY4NURDUUtLN3ZXZFB3S2hDQ3pwNjBVQjB3ZE5tZDFieTcxUC9DRm0vY2hteU9CUGUrM0RLRzk3RUcrSjhKWXNZbS9CWENiK0gvRXRUeFJLeDQwS0pZaWtzYlhoTFNJTkJLWDRGbkh4akl3b0dlUmtWWi9WbG9GT3dRTE1LaE1PTWorU0dHaEVpeEpybTlQNHZLRWFjV0lTU1RRSG1WeGNYaWJnYllaZHdlS3VUS2JtOTZ3aUFUTEVvbk1Hd2krV2h1Y05zNTR3ZUxFaGZiS1lqamh3SW9WT3dYb2U1SGc5Z2xZMDdnVmY0U29ZRU81RTQyQzhDU1BZSkgzbFFHLzhIVi9HRFFnNjBSeTBJS1dTNGRRRWdidkJ5TVFOTnFFQ0hvc2RYelhzcVNlYkFuYmswMThoVEdqMWE5aURnS0hUNnhFT29ySG52NU1STi91eUFEbUovQmNhQnpYb1VWdWF3NlArSzJoR0NvTG5yOGtJQjlOeFRsSmxjYi9mZXpLWk9FZkUzUkV0ZGZCTEw0UGtodGs4bm9sL0pRcGdBNnVCeDZ1bFRRN1BoRitJTzlENXZXeHNaMTVNZlc5SUpZZ0REd3V2eEtwNURPZkdXQk5saXZGSXAyaXBvRXlMWkpSRm5SaWx1NTU1dS9EYlNKMW85d1ZpOWRhaUExZ3E0LzZ4SVFkRHlpcjNqTk8rZDlUUTZTYzBCMmRRakgrRHJWMW54Z1dIYWM5Q1BzSTByWXpEWFg0SElqZ3IydkUzS3IwR2FwVlYyR3JRR0pjeFhqVzN3ZXpxM1ljYUxvdG9waTU4TjAxQlBiem45ekhZcHI0VGFFRngrK2JkRXUxQ2hxdGYra21pL2hWaUVnU3lkanlRRmpHRmNYSVh4bnVXOW5VVWtwY21MMHBTS2VOV3JGMUNEbkYrMHNtYjErNWNyOXE3UGorMVhJUEhRN0h4OElXUUhzWm9PS0k5a3hsMVozSm9DVFd0R1E1cnBqTGZaUENjbklCa2ZrYTI5SzcvZVFieXYwNUFIajludU9mWSt6TTBmdzg1WDVib3JXZC85d0FMWmIyb2dFcmVmc3E0Z1M3KzFWYy9uci93OEdieEREZU44cjZoTDc3S085VTVRRnNZY2c4YVFiTWN6ZC9pcENSaDBTU2tyQytQbVprL1RJM2J0TUVNN29RVmQzcEFrN09WKzNNenRNc0NrSU51OXJSZWF1VWIxeGxGdDdUYzQwelMrRzhRVFphTlJzREt4Y0UyVitBa1dyODlKWE9QcW43cStTNHo1aVQ0Qld2T1FYNnFnTHYrRHB6RXJHRWdrd3lCUnY3TWl0K3RlYUs0VFpJVXR4eWVqNzIvaWkvMFV1SXlMOTV6YVh5Q256cHV3Y2FVRlZveWRGWnR6RXM4b241dzd1akxkQzB3NGttcDk5S2dQKytmRzFaZWNhajRXSWpBblkwU1lDdEIvTlE0djIzaElLeUF1UWozcFhFb0h2OUs3SmRrcEo4bzVJSDIrUzNFNGNoTERDaHM0Z1hzUUlZQUo1cVJkdGkvN1BIVnVxRWpzTXBTMGNubUlsU2lpenRLanA1VDEyYUZlQzVOWHJwbWlYWThQcGJLWElGemFQM09sRjE3VksvSG51azNlV0w4bExtYUtwMW53U1MxcTRmT08waXJyRnVmdm03ZjVsMk1oT0h5enBJcUNVT28xOUxreFFUREJId01jWDh4MW1JamlReGgxM3BHV1RlRFNSWmsrNHhhVHpuc0UrM3NCTzd0QStGMTkyK204WHdmVG9pMi9MWEQzb093MWVBeEk4WjRIbjRJWnRkdVA5VGFIK1NWYndpeDNFMFJBbGx4WGlVS0oyRUw4c2crZTVIUmtsSVdFLy9HMWxPbUVsTW9EZmRDMG5lTitRVG52eTdTVzVQaHJMd3Y1b2dKUEViMElpS2hGTVRQUGRoYmpkdTF4czF4Yjh6YzZnVGM4WXFNdkR6dGJMd2dsU0Y2aHplNGtmaVV2MUhzTVFLakNZTUdqdkN0dmxGLy9OTmJMV2RQK01ZQXM3SktBSU9JK1AxZ2hWS1dMRnEzVU8wK1BtR3F2MWFadVRFOTVjRE9YVXcxeENFbFdhMnpMcFpjVisvWXVXYjFUaTNubWZnYTZsK2RFSlJ2RmtMbmRXUlI5U1dMNm00QjI2ejRESlhmb0tOZWRnWVkrUmt3NDRkWGV6N015OWkwWVlzbS9RMWFzMmhKOGlLMXo4STkremF0UzAxSjFSNERQUkgrOW41RG5lZ2k2SWpzNk1RUmFQYmlzTENwNm5oSkpIdEplK0FRdENKeWpXNlJpbHZBU0hwS1pla2JNYUVQbzV6dlJMd2pHVzVIbENBVGR4RjIzQlB3RlB4bERueVJWcjduaG9SRWdZT1RKQkgrSVlsNEdINFJBUzhRbHRQSDdrdTdGNHlCTDRmeEZ5UnRoSnZGQkhTUXdmM3d5M253RW5FWlVxRlE2TVUveHIwUVdOTmhKNGVET3Z6VThWcFFRcXZqSnkya3d5Z0JkOU9YK3Y0VmQ3QWx0cVpCaVpmaWhUaEZPbm5nS2dYWk8rdzZXZUJXa2MrdjBpOHkwZHdtaHN4MTNQVWx2UG9DcitxdGIzK2MvRkg1Smd2MjgwY09KY3hZWmh5YjRWaU5sRjlXNnRib0Y2aWNhdWQ4MWV5bDAxOGlQVDF6ZnVheHJldTJyOStwTFlCT1Q0U1ViU25idHFtT2h4Vjc3TkRjMkZaNWJPZlZFdWpmNHNhdXdweXJhbEtpSGdYVHVQR1lPYmgxdUZiNUpSemJvUkZKVTZPbXFqa2NnbHZvZm8zWHkrN2hyanpNL1RVZWRhVHgzSC9ISXc0M2xpcFcvd1ZlMTF1RDlxUHJSK1VYZUNCYThMTjkwMnRTMTIxSjJhb3RoRFpQaEEwWktlbHBaRTA0MUZVVElXME5XZlNKZmZIZWk1TVhyazdTQnVFK3BPNXJsaVF2V2FweXp3Mm9XYVFabGVUdXVYQjhJTzdmWW15U245ODR0WTZPNjRIMjA5RDR6bGxvbnF2Tmg5Ym96dTZ6R1NmVUhQUUUzMDhobjZ5Vmk4VTFZT0Q5b2tNUy9kVUpjWnUyTE5CNjdFZktvZW1Cd2FuQjZyR3VBZVA4dFZlbm93UDdDek9LMVdscHE4Z3gvOUVvcEZ3Y1YxeTR0Rmg5K2N5Qks2VmFvMElpRWJzOUZxQVhIQXdUcnBLRHZGWjYyVUV3bDBOUG0xZDAyc09mNit1dUZ0VzFkQ2lKRDQ0SW1iMnM1Vm5JelU5TWk5d1Uzdkpid2NMVGZwZjY3bTJaL2hvNTB2RjlFRzYrR0p1MXhnNnFMaWNIdllqUWhJTW4vNjc2MU5uZG1xazRIWVhzaVNzK3F1TEE3QllEMmhybVRDOEd6Qzh3ZHo1QndtZjVuYjRNV0J4bnJzRXBIZ1lUZzRkalFueHZCRU1xR0hDbTA1OGhQSnplZlFmQk1IclBrMHdHZkdFM3dpMXBQQWx2N0FrYjBUM2hLOTZkSkVqZDFWTDNhNEplQnRPSnN1U3BhRSs2cTQvQkh1a054L2xueGxCdkVpTDc2NGVHQlIrc1Y0SGNIY3hkZ1RrSHJDdVl6d0drL0ppOGlsK2R0RFpwa2NyaDJsQm9Dbkl3dnd0TkRzY2REamlnVWI2clNUOS85SW5xeHF6S3FlVWF4OHNvT20xaFpyYXE5a2h4alViNThVeGh5QXd5UTFjdjBnSjZ3THdlY3c4M3d6S01obUp1emg3dmcwRWE1WjJaY1pNOCs2bEdWSHVjOGRHOEhvZjJKdXlJaVZLNWVvVE1JWmduaHhTZDJFa0c2Ull0eklPcUcwSkVXSkxHNlRKUzNvbE1YNXlScFRxWW5adS9VOFBaaXc5MFlLT1hSUll3OHNnT0RMZEVlUDBJMXZ6MVN0TGZ2NnNYZVFkR0RIN0FuMXZrY2RYK3F0Q3hPeFpzNzd0OGZIbTJxdTZBMXJrQWhTd0lENW1wbnVwNzhNS0g4OVZuVCtRRUJxUnF1WDdNemp6QkdzSSt6MlNnRmZUUndZd1BNdEhsaTF6TWw0VGRLa05VSjdFUm5xRWcwdnNTQVpiZStFc1FsYysrT0REd0NNL21YOUJUb0NPNnN2dEk3WFhWZVkvYUVScHNTL2piQmoyajg4RWVGZE82RzN3MldLQXF1alI5UWJoSFVMU0hsbHZKT01BNzZXeEdWaVBwY3VUZ0pUcVBZRGl3dkNQQVNxSmJlQnZLMk1IN2s4eTdad0lNRkxlMUZTWkIvV25oeGhrQlpvdWI3RWtIQnh3V1lQNHNoaHZFUUcvc29tczQrVVltQ3FLQmYwdmpvYjlQRXNFTGhqYWNSQjlwc21JYXpHamNDdHYxeDEyNzNuTDVvTjBpSGFOdUlEbTQ4WkwrWXE0T0Z1dGxILytTdjlyQkR4K3p6d090MjV5Nk5tVU1jK2NLNHZBVWtUck5nQ3U4WHlTTVpkSUpnNVl4WkJtblZqRndNMU02OXVxdWU2cUhVK1FBcVFPNHpTSldHWkNMZmRzSnl0WEFpNDBsTmRTN3RmZW02YUQyOWdpZGFFWSt6MkxKTVlxeWhUSHJhUExSYkRaVlVPYUl3MkZJVzBIc1ljVFg3TzV1UGNUZFdhdTNycEdPa1pTZFlhUTR6VjVDZk04d2xpQmVEalpHeEFFNC9uc0RyWmVOZ2tZUUEzSTVUSUd5WWNJRUJ1ekZZRytHaUsrdmRkQkU3MFJNQThUMjR1c2NLWVVXZy90TEtkZE5aNE5Tb3BYSWlHOGxJd0xyd1NUZ0lxVytPTS9BUEdnSnc2R2xVZ1B6Umdwd3dhWWJvM3ptLy9zVTMwa2dHUURka29rcThXYVFBRFBGclN1WWlHMHhhWEVhZzkzdlhsT1lIRHdTdlJTd3ZLRXpLc3JhVzNwSVZjdUkxV3ZCL01xM0ROTUJ1VXpFWU02WHcrUkNadDhBSWpqUmhuK1RHSENnb1RPTVFGQkErK0VSU0J4RkUxRUNZQ0FQeGZCa0JINkNPRWlVZXNrUHpNV3RnR1JGRFBUNlN5N0trM2pvc3ZYRG02TWdiMTNad284eHlzNzl2K0FtMENsYTYrNUZPbklUdlc3akJxa3J1YTBDTkhnTHltZmcvcStDN3lKNE1UZlRHY0thaDI0a2J2L3Z0U1NLNUxneW1DRTVWa2hCa3VPNkRwcnJ5WHlBRnErZ0JXRkYyRjNtRGhPVEhUZ3ZPTmhIQTFFMmQ1am83RUFmS2FCOHRva3dwNHNRemNCb2I0SGJZK0s5OVRSQjJWMGM3eVp3Skw3ZFlJYkUzNFRHMXErZ3lURm9RdEw2L2pWWGdHZ2kxSVAzRzVncXlmVW5YakRib1k2L1I0L0JkUWp5NlBYQ2VGeUxCdFBRRWgvbks4RWJRV2RwTk9OT2RBVk0zU1Z3c0hXR2NIMHo2ZUtHVm1PSmZuanN2d3p2THl4bnhIYWtwZmZ4VnNPajFrUUVQUzNWSlpkVXBjR09OUGFLd2RQZzFWcktKQnZNa0V3eEpFUXlGZjBaRXJrU3NpWUUyV25EWjhOVEtlWEVlYWFJT1FjdHdSTmE5Z0ZPMlJ0Q3lKQ29sNGJFUmNNdXcvYld3czFiT2pGV0x3TnpEd0gySnVveUk1aTlFcDVxSXE3eXp1bmppbWRxaHZTN09lN1dmUlJRYzBWL1Z4M0UzSXEvRkh4Yys5ZHpsOHREKzZQU09TUDNEbEZQRjdUUWVBcy9rYWtxV3hSVHFNV2ZEQXEwTUcvNWdYS1ZPUGtOcjB6OHovQk03ZW0zTFROVUN4OUZHbTBQM3hUc3IrSjJDQ0x2TGMyUGZEeXNMUlBQdkU1bmlLeEpPQStrdVJlK0VJRnpod0R2QmpNa1J4MEp4Sk1CTG1XNERTM2ZRRXZTbk5Xa09UcXBPUmYrc212TFFJc1pndFI3Vlg5RVE0Sm5KUXpMRWI0U0licjlkd2ovQVMzMU1uSGFTd2JlaU1FbWNiMmZKSzZyTVVNZmhYRFV6aERNRjBKN0JLMHZDdjBlNHFaYWJFN25RVXVFRzVVeW54TmV1K2thNUYrc1llU25STERJQlBrWVVDaURSUTZlOEh0M2JVdmZvc25lams1blh6bjJVZlZpMkNPc3duTDdDYmhEcUFaVGhtMnB6RC9pTXZRKzQzUmhyZnBhd2J4QWIyTEZxdE5HSktGNU9pL2ZrYW81Slg1bDRacjljVVFEblJXL1kxR1VLbVpCcU5mc2hTVzVST21lc2xIVFlURmFzMnp0c21XcUlSY212Z2ZyNm5kWFRnUWY4aTdTUkdZUTdYVDhqb1ZiMGxSY0R3SG5YWmpIRUJnQmZpV01HL1B0UHBNZ0dPVk5LMGpzS3lpelFJczcyMHVDNlBQWGMrdFQvcVR0WFV5RTBVMkxJeG5pSStMb2xNWGRCS1U1aGE5ZG44TW9HU3BmQ215U2ZDNENLUWcwMmJRU2hCeG9mZ0tvSHRCYzJXZ29kTzdBS1BjdDdvWG45eGFVbXlVOCt5UThyb3YxcEFvM3J6Mi8xbDdBM3BEbEs4RHZwSStEZEtDL1Bld1p5TjlhcndBTHNRN01sY1V3QUE3eUhWY1BIZDlOTmZqU09MQjRlKzVZZGJGR0dUNnU5SHJRUXpWUWQ4NWNMdEwyckViS1luLzl2S0R4NnFFK3RYZTE4SWtPWkp5Zll0WEV5VEZlSHBxRDRkTnpCNmx0KzA0Y0ZLMzlFSUtxZGxRVW5sYlg3ZmNQakVpSUQwdlc0cW5ZZ1Q5MmNHOVppb1ljcjZCMkM0ZjVUMWZQQzg0czA0cGhzSTgzV20wcDA0MTJXM2doZlNhdDZ2Z2ROWmRsWExHKy9aR2VILzBsaDBiVCtYM3VhTjNHamVzMmoyRXFEMzdmZk8zYWdac3RGekxmaTlBK0Jzc3U5Zm9hUmJaRlFmbmFKUHVTYmFJOTFNOWpwS2dXNHFKWmpQSTFub2szdEdZa0tmbjZmVVp2TFVuS1VyYUV2cVRRUnJ6UmxQU1E4TmlZdHErQXdSUWc2WlRFampDNWZqRU94SGRJbmdOa0I0c2pJeHVhU1lvRktkaGRiREtMUkxZMVZPVVErZlNiaEZ2Wi9UdkJXZ3UwNFlnVTl4RWFXUitEeGtXbW9uMlB6V1V1Slg2Qnd2ZVFRZFQrWUFHcDBGd3U3aGQvODJHM3NlV2NLVFdqYzkxU1cvcDFMMTFla2xTb2I5bk5MMjg0OExXRmZudm5iSjdhc2pSNmVzNFlJbXkxd1piWURqT1BPa0JyR0FqbTBCRkNQa1RjOHo2cm5ZaWY4Smh5bmpwaXVPL3BDeit1bjc1MTdaalhjQTJSR2s5SUEwOXZraDB0SUY0OFFRWlpNekxHTERZUjZDSW85MEdlNFFSUEpNcFRNNWgxQXV5VzJxZTg4Z01mSndMbE9rRmNPNHVFWEhBbkVrb1dDQWNUL3RqWndCTFMxQ3ZRQ25jMnBoeVhxUHhKTzJjU1I1Vk5jRFVVRUdvZDhvbC9FNEV1VXM2SHh1Rzh2NEJwUzdMMmhvNkV5eGY3NGZrRXk4dXJETXdXdy9pZERQN1hmS2VBKzBBTFhnei9hQWluT1dMczAwRW5PditUOW9kRWFHWW9mL1VTVXFhRmx4NkxQNk1PRkE0dnFkQVhhMjljY3pzMWRqeFNodVlGekVselZic3pudHM4MDBPMUxxT1E2QVFwdkxJSU4zSWVQend5WnZQT2VBMzRnVHRhdjNEZDRvVmswWUNtZkhieXZ1VnBDN0V2bnROaTliYms3VHRWSUw5KzY0R0cyOEVvOXhQSnJ3MFpOQmVsdWI2RGVJeGMyWS9YVFd6RGNBdWt2ajlGaGh1c0lSelpQM3VDRkdlYXRhZUU5QUpHcVlZK0hhVGMyYmc1U2FvVUpMdmFLc0VvcTVGQmxQS0xLV0YrUEJDK0Fka1B4SDdBeVAyd0t3ODBmUkpTMGR6OTV5NHlScEZjNlRZOTFqOVlleDVLa3dSd3dJLzR1a09TWkQ5MHpQQ3hmeVQ3QjFxQ0cyampRQVpyUW5jZ1dCTzZ0WGpoNytySmtxNkVTSmR4QW5mOVA0V3QrMFBoR01SQnYrdVpuM0hmMGFjaEhXRXJlaFMrM2NGSDErNVQrVVJjZ1RnODdoSURqV3p1d0pldmgvWitidU45RHZLU2hCSDRyeTYrc2UzZmw0M0hOWWdUdnlRQzZ2aXg0enloSXlCck10U25peC9FdGgwRitHVm95eXY3ZDJaaXNCbFNibnZvM2Y4SVZxaW5TM3I2eHJnWmpMMTlJL3ZvU2EyeS82SXBCRWV2K1l4SmswRVJKWmI0TVpFSDZxNjBBdldvUnY1NkgySDl1ZzFhK0V5N01pTkhoRTZkcGFrTm1ueWduM3FVOE9EcWdkcWoycW5sVjBQdnFqdkNsUkVDRnFQNVVVemRvZGxETkg5MHI4WFFoS2hmYmNWZ0wwRjVHOS84WFVTMHNKYzhpTktnUkREcEVhN3JvSzMraERTdlJVOUJlY2tRWmlnbk9vV3p2aVRiYmtIYTE2UXZ1MUJvU1hZK3dzL1FrUUxNazdhOVd1eGkyQ0xwUUNYek1JSi9HY0ZmMjU1OEpZVUtKdW43aVlUWG1uUXY4aVFwZHIvSDhqRkN5Z1hoMDNDbW5YaU5MQld5QzMwRmpuaWxiREtJOWhUSXB6MXVKaDUrZmxFdnkza2tCeWZ4TVAvanpPMjdhZG9lOVB5bDBZR3oxSE9UY3JOVDFxWVFWZ3lrMXl4UFhyeFVOYjVxeW5NTmg2c2xMTzMwc25EeGwyVGVWbFpaV25La2VINmU3OXhBbjNrazJWOHNKQnVDN0dQREtsOEI3OFh6NzBOZnZjemp0ZncwbnMvdjNiNSt3dzd0cmx0b3plSTFpZXFvZGZydDJhcmo1NG9QNzlHTXpVUXo0d1o1OWxLNUhnNDhTN0NZaXpXbVpVUTU5Qy9qQ3BKSjV2VFFUUVNTT1kzcHd3TDBhaGpQSDJUNjRBN29MeHBLb0FPUEc5T2RqU0hPVCtnakRHS2c4N0pQSTFLWXo5YlFHQlRRSGhUS09IRTFVVkgrOWRsUTJ2NkpvVGtveE9iUUh1K2lsVlhPaHlhL0tzbmN1ajVWODBxeGV1bXk1Q1QxL09qdEpWb09ySWlJS2xrQlFEdFlTVFFjUjJEbElVRjhKL2wvUlJNL2czZUpaQU1wSWl5TkViZnpCNkt5L1pjdVdaMjhSck85NnNqQjZrM2J6N1N3WGRtclcxdVZlMzdRa1NQRnhaV2tZZnYvRlBpN1Fja0g3WThzM2JKMS9UcGk2VGQzdHAvN2lzV3VMWDVzZlBIM1Y5WFIwQU56UFFJQ3ZVaitOTnhVSjhsNWdsNFdmWW9Qem9vczNicE44Smp0NTdGaTBkUVdQemM4Zi9ORmRTeXN5TU1qTUlqWUZnNFIvWFd3bjh5MWJtSWFYeFM5MzMvcDBqV2tOdHNPSFgzSTlISHFTT29SY3Zob1VkRWhEWjVxUTVJRGxoaVR0eDg2OHBEcEt5WG5oVlFka1pLNTNxSXZRV1NxWlJnRFUyMkNzNkpLMXdpTHByWDRuc0Y0QkFXVG12WEJqWFRRUXdjcXZTenFKRS9TUzBqRjVzNE84RndoNWRydzVOVW4xWkh3b3JsenBjd3d3U2FNNFViQ09CMWNlR3NjZ1FsbFFnaHVpM0FUV3QrMVNCaURMNkJQOUJXNFVDUmt2SDNDRkFBeEs1MlpTVWJaRzBoNEk0MDFtR1JUQU8wUU5LRXozanhocWlHQlpDUWVLYTRqSFlyYlNZaDBEa1hDYkp6d2hJbHprREtHa1ZqdUVsQTZzYWRlZGdxTzhoaTlJZVo4UUw5NUN3Z3NITjVnR2lzY0hMQ0ZoaE9WTzNUUW5oeDBMK1BuQzNEVWhqakhpTU9KT1N0ZVROSkIzSXQ5RlVJRmtYOWZTK1lNeDU0MUZLelFNUjVlOFdFaFdtSXBrRDVYdlVDb1BMd252MGdibGwwV2YwUnRlQU1mcGpGSy9UT3hDaTVORlVnQmNjQ2pJWXhCQmgrR01PSWJURndPVDg4VFpFU0szeUJ3ZUJieExtTTRlTGo0cVhENXFTQk40bTBOc3h5bFNiOEI1enN5NGdoUU9ETGNjWk9XcDBIZTBJcElsdE9YUEJVdUdUUERDMVBtRVRpUDVCb09MODh4cDg0eXA4VEk3b3liU08wUlRvdTkyZ2xjYjZnL0taeDRsaW1jRUQwN0M1M2haUnJacHpNRnNWbkQ2QTRDYml4U1p3VlIwekJyb09BRUx3dUU4OHNGY0JNLzJER0RTRWJoOFJubXFDaHZ6d3p2ZjQ3Sk9NdGtYT2pPNENralR6Tmc1N2hJc0hNOHlaUThFMEQyaUFqL25VOExXODhJb0xsUFJIL1hrWHVFNVFrUzZVNG5oZVdFOHZKc1FyaFRHck9jMElVSHNFT2lPL0tzQUs4Z2o1RHRXQ0NzSjFSYndRQkN0Vk9hY1BBTXMzNXNld2JjaUdXbC9NV2RaNkQ0SnFzR0EzK2ZYaG05SmpwUzFadU82NWtvWU5VQnNCb0FndnJxaFQxNVI3WCtyMUJNNEx6Rkh1bytJdzdlRHRmQ0lQck1DNFJYMERucnN6YnUwMEF1ZmVZWndpZm9oOVdQUzI2cno1eU1EeTNVWG5tT3lyMUdaZmRVNDVhNGpUTnVNMTdiaCthV0xmOHFydmdxK3d4bTBBbGtjbkpjd2ZjN1B2WG5rWnkwalpzMG1aL1E2aFhSQ1Y3cVVNL1VrNXZYN3laS29KM1hFYlM5OFE1c3dGeDExNk9tejlCeDA3dm9OUjQ0UEdwWjFJcVkxUzExYmZhblpHM00ydGd5ZWRXaXlaRXFtQ0oyNWl0U2QrOUlWNmR2V2F3ZjVUNXgyand0SjdZUVpUcW91QytEM3cxVy9PNzdDTmZTQ1lNUlVMUzBOejZqTDBBRkV0TnhCWDlmbEVsYkoyNk5FMmRCSXNJVVBkZ2dRMC9wWTZDdnhucDBtUVl0eE0zQmNZanJJNnhiTEVEcktBYmJIV0hFdGdrTXRrMFh3QzZCNGFDQUpHaElndllJMDlBL21jRUNTZEFrTUlZaVF3VlBESVNoWHhURGlkWFRtUWFYZjA0d0JndkRlT0xta2JSZjQ2WE1oUUpvRTVoL3h4LzlnNFRteEQzTGhGOTlDWVZ0TkN3ajVSRko3a09EM3A1L2VJckJzVFFjTFJYZzRIUW04UisrbW1tWVRESnVKQm5GOFFqTUVwamZia2VGSDZlWXVsSkJ6SmpPUEpSc3VTbFNLdldvOEtzM0lkZWMxSzE1TXZOdmIxcThhODgvSWdUMU5PYi8yQlRQazJ5S0c0NU9aK0FyZE9OOXhaWUlrbWt3TTR6blNTNVluaUU4cEdHOEZISWlsZTVCUTJ2U2lNeC9FRzVWYUd4d0t6ejhDQU15RXpYdTE2ay9wdVF5K3ZoMkJtOCt3clJDeDBsZFc1SWFxSktaVnIrRzBXS2RQZitZVkVGSGkyT2tLblFsL3E2MFNFbitMc1RmaGY0ZEwvbVgwWGl1VkRWeENXR01tclJDbmlYOHE2YkZnZmd4anoxeENPcVpManhaS01CV1V2TmpjTXNVWjN0VWFPaE42SmxsQ2I5N0gyRytrdlEycEtNYUU3eE5TQThlSVlPZ1BGWHd4ZU1RbmlaVlNlckpoTVFmM1YrTGZuOTMrMmxkRGhiS1BQRTdNVlpaTUFncGQ1d01uVlJtcThaRDhGaHNpOWRoWjJpR0xhSHIzVlA1NVNWYVplRGlhYWxNRFNRaGJFbXZUa0t1Q1ROY01GTGJEN2dCTEV3Rjd0a1BvQzQ1RDErdkJRdjZPQ3hGSEtST1o4UnpZQ1dINTRSQjErbDNWOTNzOENTczdJcXR0U05vdk5lZWg0ODBUSUdSb0lWTjBNZitEZTZ1eFhXMDNoNkJrdTVHbUdsREJza2gwdGdyLy9DTzlFUFI4cDBoSE5YVFVDTkdEalJZb2U1a0tEMmc5NUtPc1NBZHd4QWVIS1Z4bVNISVVReENPSmVPdFU4VXVobkdrMVRTVzNjSXB0TS9kZEQ5aTJSbkRjdWU4OUM5WWNHWDN3dkFVWUZYWTEvRXhXTnIzYTlSSkczdVp6bHNiS2pnY1JqZWltREE3NUdmRzBaQ1AxTCtlcjBPaG4yRzRYclpydzFReGVNY2lFVjQrRyt2OWcxZWVKaUNpNVhNdkVZVEJBT0piblhTZHg0UGF4alc3dmN3UEl5R1dMd0xrY202N1p4d3ZrekFkUXJnb0xHWVpkaDM4NlloUzl3SGpZQkRIT1NUWklBeUFScGh6aUFsdW9qN1NHSmozQmhCbllJVHVjeHpRc00yRytLWGJnTVo5b2xaTGk0U0VrenlrK0taSkJsKzJtQ0NUQ1JJWFFocVF4Ym1vQW5DcERUOGZtdHN2UDZ6ckNIb3ExeHNLNTdrWVFyOTRJeVh5eGhYZDJjdC9qL2dSRXVNZ05YWUIwRjMwVXdCTFQrOElWVnIxUGtORnJUWWplYmdUSjBnZmlQY3FZQkxQRGpDVFVQQVovR3lvYmZFd2pXa0ZBY3BkVUl4U1ZmYmlBSHdIVHNxWURYNFlQS1BzS05ocHVFeXFVYmhOVUY4UlBqenFFd3dCT0R2SnU3N21JZzZpck5FS1ErK0pqd2dXWEpGZXg0NzR1OWlRRHZEWlhHV0NaMUU1ZFpHWFFQNkxCTnpQc3ZQaWo5NE1kVFFESGVuQ2FVVk1BOVdFRnBpbktHTzVocHM5Wkt0UFJSL0FTZlNLMmZnbmRUbnE3LzhYZzFPcGo3L3RjV2c1UC9VNy9lcTlnMnJDQTBPaGlUK2dMMmZ3T203N0NwWXdqRmc1WkJMQk9DZmQxMXh0ejNhbkhEWG5JRnEzQVJiOWNSdGNTOW8zQithZ3VzYjZBakJjSmxvS25HVHFjTVhCNDdYbG5kRHVXZE9iU3hRbjhWYitiT25ZbndLdFVPU3c3QU5icVllTmVySTAvczFGejlyT1Q4QjVwQnp4Zzhna3owR0t5Z0FSazRzR1J0bUVmTzRXV0JGNGdzTUh4VGNYNUtCVUFMSVpjVTI0Z2FRNHg4MDdDVWMyd0dyRUh3QXVXR0RMUTI3OFZxOEc2OUQzQlZZL1Y1V1hpdjAyYTFySUY5Qm9sVkRhOTdnL3JzZEFqa3R1amUwUTBRM0RoUEpoOEhPTDJRa05Pemt2MkJmQlU3OFBVM2EwYVU5QWx3TkJZaVEyTm13RTNId0Fzdy9Rby9Qc3ZKdjR0NXY4bktvNU52ZUgvTHo2dW5TcTJjMUkwOWRDTHFtL25uLzN0ZXZnKy9ianB2aVA5cFZlMzNxaEpJeGF0dkJnOXRxWWVKRHZxb28wTDFNTzljL0lNUlRQVFBrUUZWVllmRnhMV0RjZy9jTVBIREVUMXRWVm5TZ1NuMjhNSER1M0pDZ21Wb085OFB1M3hxbWZwTTlCd3Y1ODJqZWZYNmtuOGEzVFRYOTgvSzFuMXJ4ck9Mby9xd3l6Y0Z2YzJuYk1XTnN0Unc0SHhmRUhlSlVQaXc2TERGRXJZL2R0RjFuUEIzYk9GdVlnTnZ5b1llWi8ySzhaZ3NjdExqSlhJVDNQT2pwRVN1RUcxOFJhSGN6ei9LWksrRUNjY1dFRUdZOHMwU0F4YmZJSVVqTDUyOGRHTmk5azk4UEZ1Z0lYU0lkY0FTVEE0NWR3L25ubDY4OE91OWVPMEtMdGNiVGtLZDBIclFtRTF3YkxMd2d2ZGN3Ni9jc21vVFd2aE4zdlplOStDUnUraUp2S0xVaDBlU24rQ1EyOE9JbW9tTGRSSFB3K1JJRFFDd3JESDNKWVgzRFF5bG03YnNHWXIwNDFxYmhBVzNvMVJDSWt2RWNIdFlaaGlIRFNwcjdGQ3pBRVdqTVl4VWtnQW9TUVlVVDBSRDhrd2R2K0ltOUFWSUY3STBCdlBGUHhNR0hoQTlpNVVkWjVXZXhsTlJnUDBqWnBIdXgySnY4K21NakpLRis0RTErL1lCQVRUc2IzQmxiWVE1M3hKMmtwUVE2azU4RU8wRkhrT0k3YXdoZU1nSGo5YkpLZ2hDVGduOFE5QWNKRXNSL0NQVERCSkxjVHk4THBlOGg0aE5FZnBJM2JDOWp3QlAzSlZtOFJqT2pCZkFDNGdjdlRRY2J6eVh6RWdJMGVBYU1SQkNpQU91WWQxaU9OU3BEaVEwSWI0Rm9QN0kwT0VTQjNmQUl0S0JrYVVXbENtN2lIQjdtS0VDRG0va0h6SW1hdnFRbFhueWJCd0dzRVo2dG1MN1ZmYjkvcVFVSGp6Zm9HaExKbXMwMHRPR0gzelFjTTd6R0ViQnMyQ2lvd0hjUUIwZkpSUEhXeTc2djVPRWdISUl5Zk9qR0RWeE9mS1ZRNFhJRGwrQnlYQUxsTGlQZ0lLN0FCL0VoeEMwUnhLZDdHZGp3R25TMkRMekRZM25Scko5aXVYOVFnR3V5eGFSNm5LZ2dXWUM5QjdHMzM1SjhiWjUrZVEwZG5zckY5cVNqUnpNZEdTMHVOU0MralFEeGkvbngvbEd6SnFnUzRjQTlQRWlSc25YTGxxMmJibGEyT0pLYlYzcFVkV25tcVo0OVprMGR1M1RkNHBTbG1xZjBtaTNKMnphcDh0ZGxaQmFxaTNiRjZHS1Q0aUlUdElUV2wzc1FjeGZraE5icjE2QWxkV3JXbDUrNjliaGJ2ZnJOMlRQWHJuZ2VuTHhaKy9ZNnVvMExoMEpmUmRjUmhSUFJocTNiVTdhckMvS1QvT2RINi96OTUyY1ZyWlF3d2VUYjhKRGdxWGdGcnJiTXo5WThqSEY1ZGZQaTdRa1ExWkhHenRnZndaaEZmRWVhcUEwbFBueStDN0lyMVhlQkprV2V2WUoyRXVsdXZOdTJNM1B1cTkvWG5ydDVaMWJWa1BrUnkrTVhhTlB2SUhDNmk0TnBkeno1VGhUYXVUTmphNWE2ZUgrOFgxQjBYR0R3L0l5aUZSTDVmKzRRaGRhcE8xOElPdVk5V1AwTmRyYU02QUREK0czUkladEQxTmlpUnovY0FzdnZ1ajU2Y2FYMndjTnBsVU1EZ3hKajQ3U1hkbGJublZIdjI3dHFXYm9XajhRRCtPSzh6SUtDUEYxZ1lMZytORFE4bzFnamRacjJIbGpzWmNRckJPY29HTUhqMDBOZ0tyMFdXN1JMeEs2YTkzUWFqSDczcERqYlFxckhiVmh5NjhzOTY5TEgwS2IrUzczVEYyajVWUGw3c2EwQXBhVjhTRng2VnVhZTlLS2l0RGhkZEh4Y2lCWTdtTS9UWjJSblpXYVVsMmZvb3lQajlQTzB3OHcvbkR4NnVUVDhnUGRPcmZMZnhRZDNaaFlkVUYxd085eTc5elRQaVVHWndXVkpHcStraUNCZjFmaFRIdStsMm4yN2Mrb2FtTi81U3BxdXJvZEdIOENhTU5NQkQrTVhaeFd1S0ZTRDVaTjcwQnFvb1djR09JMTNHenpvbk9ldDR1S2QrL1pveHl5WkdUbEZIUk83TVRWT0M4T2dIeDhZb1FzT2ljZ3NMczdOTEN6SzFRVnFPRGhrMmpCaDZCYzVSQ1h3NENQdGt0M0ZabUxJWjBPZElRNDcwcHo0TS9HeldFTHlqUHNpRm42Vnd6TGdlSmd0ZmVwMXBhV1pUMzZkamg1ZUZGdXVxWHFGY21kTTNEMU9qYjNJRk8rTHZaTzEySjcraFpKNWFFZmpPWkNJNStCRXlSQVBkOFFzdHNJZDUzaHUzK3VqbWV1SUltclBKMXhXZzVkeHFmRmFwK1ZFLzhTUDRzSFBzcU5meEFQU2hpOHRVQTQwN2tUS05TS2xDWVJHMEluOFdJbDhWZVZpL1VITm9kY29lNmJyem9sRzh1VG5qYjJBUUlMVjI0UlhDM2JHYWlBTytobHR6TnJZREJGKzBzVEtyRFc5cXgyREo5RzcyekY5YVYxNzlKanVaMmlPdUI1TWY2RUxJdzQ1SUJpemdzY1k0U2JxVGs2ZXVob3ozMFRLWjhiUS95cEVGRHpESWVjY1UzT1dxUkY3U3RJdG5EN053S2haQXRjUmlrOHk5YzhFNkMzT2trNjNjMDhMNTgrUW1TVk9rMFJjT0wxSHFBSFJLRi9ubmhScWlKUmJJOXBKOG5WT0dsTWp5ZGZXRGF3azU4SnBJbC96RGEwaytUcW5RS2haTHNBNHNVU1NyN1BUaEwvT01GVndsc2pYeTg0eCtXZVpmRkJKVmNna05laG8wMC9nN05hZVpLcEpEVGdZUW1xdzRyU1FRU3JRQVFaSUZjamNJMnk4STVGZmZsTFlTcWh2QlF0Q2ZYa2FzNVVRaDNmd1RTS2VlVmFBOTZJWm9iMnNRTmhLU052RFZrSjZXWnBRZFliWm10V2VNWXdpZGdWcm9lWWhlRHlFN25xWmFQRmFEZ092TUZ1clVmak8wb2lUNm4vdXZRTHJoeDZYZS9vRUp1bml0T1V3RlRuUnJjbnBQSVRCZnI0cUwzTDZnQm5lSHQ3aEJUVjFoNDdYYXJtSmNQUXhlRHlXbmF5WGkxb2lMWnhhNG5uZVFkMm0rd0RjcFBQTnNYL2ZQbE41TVUvcm5JY2lrNklqdmRVZXdma25IaDR2UDNwNFgwVDRKaTBYQ2lmdWc4ZGYwSTJvYmVwQjgwVHV5UnpHQy9qa2hXdVhyMUt0WHJ0aTNkS3R6R3R4R0hLa3ZaOEw2WXZDczZmRU10d29PSFlYUXU3SXFwOUIzMmR5c0JkMzhLWGI4d3FQcWF2VGdpSkpvV1R0L2ZIOHhyUU5XWm1xcDlQUGQzYm9OaEFyTzk2YTlQekJpWXFxZlpxUnhTaDY0ZnhZSDdXdlg5WTVMWWU3VkF1UWNmL2xYeks0S3RieGFmZVJNNzJsSEJWdHp0aVZxOTZ4YmZYcXpWcGkyN0p4YWV6bWFQWGtxWkc5NDdVTFhkRVVlc0ZnZEpaMnhSbm9OWDBhTWhBWERiM3ZQN3NMSXg4dTExc2YrY3YzdGJJZVhvc2IrTkUrODJaNVJCZFVYaXFyT0hGNGY3QS9NWFBFVlRpRUgxODkrZ2RZbkgzMGQ3cm1LbHdqREY0Nmp4ZzU3azhLM3VlbWJ1L2N4NjVmN2NRWFpYbHA2VHUweEpSNndzTEFRRGRpM3pnanBxaUVzSXpVTi9zdjZYWUgzSDByRitXM2hKVHQyMVdYL0twR0JnWXRqb3pWU0IzbVNOdVNEbnYxaUZrdFlOMDI1aEdZeWFDYlpETFVyV0V0UHo4ek5yOGdmMzlKam41dldIQjRaS0JtZzJFMmZ3YytrRkxEOEFmRTRWRG8vVkRzb2plV0drOUt2WUVEZk1US3BFVXg4UXMzSmFzVFhkRHFqZnNXRjZsUEh5NjZzbFA3V0d4SnFyOGR6Q1M4ZVlVU1h0M2U4S0FJZ3BlYnRvMkJjYVNlNVZlWXozUkhtQU9Eb1MzQzFqUzJ4WTBsQzNoVE5ldnBqTGNuanhDNks2b0ZjUVBKM3VrS0E1UzRnYUExV29Wd01KSTBPZWZoVW5MT3RQK3RzZzcrenhXbUVqeFJ4UmJtRlYwRkFVaXl6ZG1wdXVSWk5USFFmZm5jQUUxQlltaW1wOW8vS0Nrc1Jxc3NUZG01YnMvNllxR2VQZ3h6a2JMdTBCYm1Ed3NKUG5qOFJsa25NcmVFZFR1MnFTNzVWNDBLOEZzWUdxTWhoWGFzMjdPaFdDQWNWTmF0RnNZeXk4Qk5CMDJsT1VQNkYvNTlyWHdERmVJZHZySmcvZ3d5RytaNmhlZldHbWZEbUdKZWVUOWx4OXJNOWFxZTlNcTEwdjFvSjBOdjBzUlNjRUVSYVFkampxdC8zbjRMbGxybG15ZWVWNXptK2NkSDZqVmNQRXpUUWJQN0p1eG5YaEZMeU9FTkF0K1RYdXJ6UkVoZkhKNDdRZDEraUJPMjZITmkxTlBpbkIzcDZkb2czQk85b2lVclNDZXhFMzg0Szh4OWlQZWMyWjd6ODZ2UEZsMitRQWIxYk5MQ0xhL1dWQWx3aWNpTHhQNHJaZG1TZFl2VndYNUxBaUtKQ2VTR25jUWNWTlhqVHcwbjRZT2toZ2VnQjdHSHZMLzdjTVpoOWRhdHlhdTNFalJtY093NnhGMlh2WHQ2OHFYOHROaU45OWs3Qk16ckQ1MC9maWltZU1ZK2pXYzZTdHEwZE9zdVZYcmE3dXl5bmVFNnpmMGRxQ3c1Nm1vNzljQ1picFBtWlliVXhHckw0MUhHMHMyTEZxbmlrK0pEL2VKekQyZzRQQUpPM29lcGYzM1R5NzRRUXlPZGVKVy9ScWY5aFVaTFJwUDk2Y1Z6VU5BeXZjNVhuVVF2R0lBdTBDSFlBVW1tZU10VTAwdUR6KzdidFpHY29KT0RoZVNWUzVLWHFtT1NVak0zck50SUhnTGlKa3ZMV2pZNS95QTRaWVNEbm5ndVdyMHdtWkFlV3pibmRtSEpycngwVGZLU3RhdFdxZGFzWFU1TW41L1RtOWZ1SjBiUHAyRS9HV3plMkFQNUxvc005bFg3SjJRV2tBc3RSTmwzQ0dZaHpuWWJRN1RzQkY5N0dsdmpwRkJJUWc3MEJUSlZYdExjWjVJR0IwZ2F0c0F4Q3lBRzlhQVBrSlEzTkhDd0pCOHZJWXlGRWZDQkZNQVVqcDBQc1lnYkpoVkpGQjM0V2p2MGtlNEdRN0t6d1F5czl1ZTB4R2EwWTlzbGUwS3VMRTF2MllIZU9mOFNWdXlJeEgyd1N3dVEwVndQTWdiRlNEM1pGMkVvRDJmRlNPbU5JUWJQZEllWnFETjlIeC9DVnBpWXdnK0NzdzlnOGdNWlBML0NwRDA0Sm9BUFRKRVVqTGwwd2lBRWpqU2VpeWNTcm5KY3VYQ0VHT0k5TjE1YWJOUHo2U1lCS1BKdjlxSzc2YUtpN0VYM1AvY1VxVW9taUVBN0dzYjA1SUV5RnNBVXFaQ3U0YWZlZXZlUFdKQkRaMERLKzlBQnkvZzMwbzROelRjOHJ2K2t1ajN2Vkk5S2NrR3hEQ2FqcXVoVWQ1M3Flem82SGZ5aVRiNW1INWlqYnJTdTNUMW1aYmYrV0tZYVdEbmp2cjltMndwZlBQR0pNSHV2cnZxWWFxUHhmbUxyQmNicmlVT3FIRUFlUm95SXk4UWd2aUsvK09nV1RUQjJJdGNUay9ZVnFxQXpycGF1SjRiTlhsb0VYVnNVNkhmRlJxaTRsWGVCdTBmTTE2RHhQWms0OGk4NUxCVnplTStRK2NFaCtxeThRNFc1UllVWnVsRE5YR2pHRDNBWjAzdmtpZW0zN3QyNytLTE83WlNMRnI1akJXOVlqUi9vT29xcjRUNXl4R2Q0TDZsazNONkNDcWxrT2luNTF3YStidm9wbC80anh2UVpjV0w2emZ0M0w1RWpzN3NDQkgrU3c5VkZESjZVQlk1WjBHeWZEQnh1OG5NTFE0NXMzYmFlak55Rms4YlBtYkkwY1dRTEVGSi9nRG0wVkYzMHFaanFPbmVlcTRaYm5nVUN5YTlienA4K2N1VDA0WkNETTF3OTNOMDhEL2dlMTNMa3ZwM2ZEOWsyWUtCRVVtM3dFTWZmellYTjBPNWw1dmdSV09hSm83Rk56OWdyTnpWZjhTb2VRcDdCRmhnUHpVYURHZTZLWTRmaUhEd0E4OWRzb1d1eWxyc3Q1UHpENit5UjZKUE00TkUwS01RS1pFOUhqQm5rMFcvbGdrRXRvQk05Rkg5Rm5PbnEzYzAvVisvQ2hqS21tM2RMLzl5ODgzVm1iZ3BKa2kzaXlYTG1FN2wzaHpyUUwvNWN2UHR1WUJEVVJQTFlqWWFOMHNXN2EweXE2ZDVkNm5EaHVwRDU1OXJkVFdmQmRPdXVVaXpuUmJTRTJmdTloU1JmMXpHcCt4azQzcHU1emhUOGQrT3V5MUJobTA1TUlSUEFmd2wvL0hEbGljclFBKzV1M3A0ejV4VUVITlBlaEJmOGljcER0WWZDRHN4eDgvYWE2VjBRZUV6TDRTRjdvZTFlME9qQWRTOTAwaDBVd1BZYTc1MGZmbWpMTnVrYTNxSnBVenluTDFzNHJnVTBUZjN3RFJxcHpnYVV6cGpoN1Q5RG95Uk1nRzM4aWNPSFRsYUVGYytlN3VrMVkxNGhJY1BsTVJkaUdOT2R2THlOVEI0ajZtTkpFeG9FdmF3V3pPUXdoTmprN25uMmZmMzF5MFhYVzNZckpUYTVRWE1rbTl6c3ZLUzArWnNqV240dVdIVFM5MUwvdlMwejNrZzJ1YjBrbTl6VzlyaXJxdXVKb2MvRE5SSGd6citwUG5VNlRUTVZwNkhROVBqaUtoVUgxQzBHckd1WXc3MllDOHdabzBIdW1iN01jYVpFTXNmdEs3MXZodnZRY2IwUjlLdGdZSURSSUhlUTBTQjNFSjMyQkdGekdyd2trMXdWamNmaGpmMWdJOExONlBkNHQzRU9ZKy8zRFRIdnJUZUFtUWZJWGNIeUhEQ3VSdE5iNWNmTjYvNlkyM2E3Nmd4TlFBNXlNcE1PeDFYK01iYzlkL1N4cW02MlpHN3JkT21QdWUySkk4WFZKblBibVgvTWJjMGZNSy9HM01WS1RHRnpaOXhvenA1NWY4eHRKM3YyVjQwOEpwbmJ2aHIveDl4MnFzbmNka3BJMGZFLzVyWmVVSGxEbUIrZUpGR1F6RzJYU09hMiszTWtjOXYvekdFMVJQeFlaaktIOWVnRW9tUU9lMGVBY0RJRGI0UXlmK3pnNUI3Q1ZXWWZyUHBqN3dGOThBSitwd0RFRElUaExnalFmampEY2N2cXZ0NkFDWFZmNjJRdzdEdC9JRHNycDJDN2JuNXd1QzQ2Y2tINmZnMVdpZjM1aVZWekx0ZGRPblh2Z3NleGNTNlRYSjAxTU5oUXlCY1Y3TmlYcFkxTnkwMHFVVis3Zk9yK0JmZGo0d05EazJKaXRmc1d6TjhacEhhWk1ObDU0aEgzUzFwNEtMN21EU3Z4WlYxN2NTVmNRZ01OTXQ0L01uWitaTUtlL2NtYWRlVDhQVVZWa0pLMU4xdWRzenMrU291enhDQmlONUsySUVybFAxL0tsYjVmcXBhR1Mvcng4K1d0RjBEL0k2c0N6RittVjBXdmpvNVdEWmZNMGIvUVdGVU1qUVpDSzNWKzlzWk5tZG9WWDlEcXBQalYwZXErTHNXM1FyVmt0QngraVhBMG5VME95ZlpxSUptdWVvSHdOdnJoc1VmRk45UzFCeGFTQjU5cTNxSGR3UUc3QjZ0eEo5ekVFVGVib2gxR2M1SnVzcXhXSURxN3diQmVVczV0M3FiVHVodVZjOHhFRWhObVV0ZTVHeFY0REhlVEtaU1VkWEcweXdyaDVsY0VtdDFNUG5NeFhDQ3F1dEFRQm8vcnFmdGxyNWZsdlpmbndWb2UyNS9DL1BtK21ydTF5UFdGLzNjd1UwSENQMkFQUFlEV1RMK09zQ2RXdHNIa3NGZkY0YkdtZ2pEcXZhVGFuY2FEL1RUZ0p6M1JESjJPenZRc3RjTm1LcHlBNVZnclBYQ21xUjJGWURZMEJ3cW1nMVM0S1J3bVF1VjVPS3dUOE5qMnJ4ckNYOG5BcXoyLzUxV1NRTDZMd3hGWTBIdGVHYStVdWYxcmh6Zzg2azhlcmowUGJyL3NqUGZISEtWY3VOdnY4RlFoM2hFUm5CM3FvZTR6WEsyM2Z2Rnh6R2ZsbXdJNHgxZVg2V1l1VzdNb2VZVTJCcHNqNVpmVkMxZEhKNmdjejg1NHA4bVVyalBvYWZlSTlLTmJVN2FUZXdqWllFMHVRR3hOMlVrdVFFU1d6OXF1dWJudGNNM09xd1hRcGtYZHJvTTVaMHdYSUtKb3pBejJ4TzNDdEZIWUVya2tUb3QyVlhPNENhRjk5VFBVMVZ1RC9lY3gwaDJIcDJKN2NzY2g4M2pxdWxTQ20reXc1STVEZXNxZTNhcFhVMDUwMWNSS2R4d3k2S081Y1I1TDFpU3RXYXFOeE5aUzlSWWxMMTZzbXBualU3MVFNMktKNTh5a01hRzRUUXVYUk44b1Y3V3h5SDRhTEI4ZWhuYjUyaXl3UkRkM25zazZUYWlQem53c1FMUzRLa3pZbWN0SVJybWRaaktFeGFjSWl5L0JLWjJRVG1LWFNwYlpzbFhNN2lTalpmVFMveXlqMTRscmhnblFEcXFJbVVVMVZFbG1GcEwvbDQ3NEdUdzlsNUZKK0l6bjVjUy9sT0ZnV3lLWVErY2ZzQlZvV2RFTFJ1emRFTVRqYWNtWEJCV2VBQzJ4Q3NaQ0ZEU0IvdUM1UldOQWRHeHJCQnZwUHJGRFIyTnpOVzQ4K0Jud01QQWZhQUVkZ0Q0M1p0QnRwaXZJOEVnMVp4c2xaRmNKRUNKNjh5bGIxbTNkck1JVzlLcTF5MVluYWpvWnZGS1pGNklEV3E3d3pRK3VxaUYzNGpYS3pESmk1T0FUR0JtNFNNUEI5TVNmMFBScnpqY1krczE2THpSZUJaWXdEaXlWdnhvSU0zanBGYTFxV3RjV3ZhRUg2U2U0RDFjN2VKMDVCZWhiM2xsdGx2U05xL3c1eXpPNzlsejFnU1BuY3dQZGx5VXZKS01GTEZNUnVVV2R2bG4xZHVoOXJNU3kxb093WW1xaCt4RWlrUHpxdlJpYmo4RzJLbXoyMmdGNlFxZC92Z0dmcmVFOGJndkdRMWJSTVpuQlRzYU5QSXN4N3QwdTBLQjdCekl2UFN3amhqVjFOZUkrM3U1WjcrL2Zuei83L3IzWE16dTczcjN0Tk1kdEhsNjQ5T0RCeGZFREIwNFlQMmpReEVzUE5kQzVDMytTanJtRGNsSXpzNHRVK2JIN2ZUWE85RHc4RTlYU3l0S2RWOUZPV2xtM3NwTGZXb2wyMExzM0wxK1l0SERwQWkySEQ0a0hkVENGVE0zMlpRSnVUSS9DVTlBVFdySWZPcUY3QkxRc1FDemtremR0WHJ0SmZldFN6ZjNEWVZsK2ZxR1IvaEhwTWNXcFc4aEdyQTFOQ2xrV29WNUtTdHdRUzhIaWtWNzJWZnpHWjhkbkJTeFpzV2JOU3MyK1RZVnBCOVRyTnF4TjNxVGRVb1hXTFZ1NWRwVjY0aEJmcDZDY3dJcXkvUHdTN2YrL1NxUC8xd29qU2N1RXg0b1hvWkhNSHhxVGErSCtjeG5jcDJFZE5KWUZHQzNINVFGekJSeDhYdmpiVytCR05xVHBKSU5rWXRVRkNGcktKYU91WkdMVXhXSEhoclEzTXRqU2tNYVRuUitmb1BVT2lNUEJEWm1TTWJnTTRvaFJ1dE41NGRKZ1JnS3cwRXZnY0xPR2xYL1Y2bVZ4TCtYQU5hemt2NTY3Zm1XUDFvR09YQkUxZjdiYUsySHZQcFBGVmsrYXZINjZiTGxxOUNsM3lXTHJVc051bzhWV1VNTkYzajhuckt6eVlHbFZjVVNlcjJlQXZ6ZEpEbXlJdi8zbWx1elZMKzBLWmxLTk85blB6dDJzSlJPM1lRMHhXL2VDRzZZWEREY09KZ0VYVXV0R3BESmR5RU43QjVtQk5jSWp5ZmFxQ2ZGM3F4R2t6ajBrNXVqQS9VK2ZONmRIUGhkZWt0aDBIR1RzOHQxdCtZak1tT0t0cVpMTlUraWlDTksveVV2WHJsdWxYVElYSlcvYW1yeEpmZkZtMll2S3NHdy9uOUQ1QWVUemxseDMyd1h0ZGgzWlJXUHZYUW9Tak4wRlhValFnZ1F0LzJGZXMvZHlyYXllYnQ2LzJhcVJlSzJabU1DZlVKcWU5cVVwQjJvTnRZUEtvaDVTejJWMnNuR3lhYko1TXIwc1YzWlFkbGYyeG93MzYyTTIwMnlYV2E2OGlUeFd2a24rM2J3amVYeHB2TG1YZVFWNWV1a0tVcU5BcEVNbjBXTlVqeHBvQzdvcDNaT09wSFgwVmpxRHpxZlAwSFgwUS9vNS9ZYitSRGNvS0VVemhVWmhyNWlzOEZZRUs3WXFNaFdIRmRXSzg0bzZ4UzhMZTR1eEZwTXM1bGo0V29TUlIzcTNXaHkydUVnZTVuMXA4Y0hpdTBXRHBkelMxdExSY2dCNWxuY1VlWmgzaHFVN2VaelgxektKUE1tYlpsbGhlZFN5bGp6RSs5enlwMlVESTJjc21FWk1VNlk5MDVrWnlyZ3dNeGd2eHA4SlpoWWFIOTVOWmRLWVlxYUNPY05jWVc0dzk1am56Q3ZtSGZPTFpkaVdiQWUyTTl1ZDdjTU9abDNZTWV3RWRpbzduWjNGdXJOZXJDOGJ5U2F5eTlsMTdCWjJCN3VIM2NmbXNBVnNKWHVTdmNUZVpoK3lUOWxYN0h2Mkt3dnNieXNMSzZXVnlrcHJaVy9WMWFxUGxiUFZPQ3MzSzArcklLc29xMFNyeFZiTHJWWmJiYkxhUlo2VnlyYzZZRlZtZGRqcW1OVUpxOU5XNTUvS2JRVjJoUEM1TisvSzRKYTRPWmJqY2JqMTEzN1F5R1J4cVhFaUZwZHhQa0lLRWRWWlBqc2pvN0JnUjF4ODJQeUVpT2dGYVJrYTVYZHY3TURuWkdXVmx1N1c2OEppZEg0UlVidXlOU2V3bkg5MjlkaU5ndWlpc0sxYTVidnEzWGtIeTFXbjNDc0c5Smc2ZTl6ODlKQzh4YVNvNjBJL1h3K1Y2ekhQZDhTZVRWQ21FcXYxTEdLMFByV2J3UFpobEw1T3hFUjJKTVB5SFF5aHlDbHUrcHlCYWllZkl6ZDNwK3plc0VmN1dweVl5WFEzakVBcm8xYkhScWx3cS9kOW9TMW9manlCTG9XYWIySVM0cVExb2lzcEhaZGJzYkJTRFMyZXZZZldieWZVRE80N2ZGclBNVFZ6YjJibGJkbXpSK3VXTkQxcXJqb2tQSFZYckJiczMvUGh1b3o4OHJ4OWhUbjc5R0grOHlPRHRKejRMeCtTRlZsVVdwcGZVUkNkUzk2VkRmTFRnS2NOaVR0UThpZk9ONWpFc2FNRjhPd2xZRSsySU1HcnZLZWpzQ1oyN1lwRktsWVNtZkYxdWdJbUl5aWxzd1lRWFM3Tml2Mm5Na0RKR3RiN000Wi95ZjNsSVFMTW9QdkdNZmppLysvMXI2ZUFtODNYRXNHRGZTb3ZMak9lNUJGU1hvc1phQXJOb0FmMDdNbmducmdIYm1wNkdUbG9mMVR4d2VMOHc0WFJPWUhlSVVFK0dwYnZkV0hxRStEUGtQd1c5OTB2ZDhJdHAyT2hqZVpGQ2wrVkFSWjNqKzRNQ1pvd3Y4TW9yL2hDb3VnaFNxdzRyT2hRRXVEOE9jako0ZHljRjI5UGRyMXhkUHBMUUNWTEhtRHpBTVF1WExkazNRb05tRXN2Q1cvY3BDclltRXRlRW40Z1dpRk0wNU53S1dLaEtWblhOMVl4Zng3ZHBmdVJ0dFg5ejJ2bjVLbFVaVjNtZTdKNC82L3I1M0FuZ05FbzYwSUVEcHJpWnNaRFRRSlp5T2EvMEN0ZDVvNXkxTVZnMUFJKzBqOGUzZ0N6ZEcyYkREUjlXWURuQkRVZVQ5OHVPSFIxNDIwTGNLQXozaUVTVm41Zm1iMHlaNy9xNGVHRFowN24rSGtTWGRTYTVScWdkcUtVRFNrN2RxamVUTGhGa0xmcTF4NWJSV3lJM2hpamNhRTUwWW9mRzFKUmVlYlFzZnNYaStaNVRaenRPVXFyL0k2SFlBLytVdTJ4ZS9lS3ZXWk5jSnN6YkxSSHlXa04vTnJHbnc4Nk55V1R5RC8xV2JYWEhxcitIbm9YQzdnRitRUmdwNVJQcjR3alk3eURidUtvUHFyV0w0YURRSDRXOTZBcDRlOUVmQkN0aWxzVHYwRGxjR2JNMTZvVG1aVzVHckxNa3YyQWhaWDh2RzIrbVNHYVljNDNSOXkrZy9SRkJ4ZFhxTXRLdDZZWGFtOE52M0ZqNUEyVVdiU2p2RkpWdWJBaXRraHo0NWJMeldIT2FFK28vMVkvdFkvZlluSSs1bnh2dU11ZG9VZ1h2TWpYVy9YSjVucE45ZFdyMWJOSGpabzllOHlZV2RYWE5WeUVTWDFQdmpCTzFTdnJQQmxsNmRkYi9GSWZvbVpOWHhxUk56NldTVjY4ZHZrSzFjcTFhOVl0M2twU2phcHkvdFhseStQUVo3b2JORUgzQk55NlJtQkJodkJCdWx3YTJOZm90UUxiRlNiQmFIQkhtS1h4TUR6MUU1NkoySy9TZlhHWGZ4eGZpYTMxMW1mQkFxVEhCS3JQWWxlZStGMXA1YU9sR2Z0V1pxdHJ6KzA5bXExVlZzZWxSS1lzMFlDY1RrNWRWVktsRXUyd0JhNVFqQXVjTzNwRXhQSHpHaWpEbGdxdVlXMS9NcTk5WTdKTGF3NGVLQ3ZMaXZLZjdodmlxMlZ0eEZCNjN3K0VYOURwaHc3bUZ1NEMyOHN0dmgyN1Z2ZGQ5WFhVVTl3T2QzR3d4UzAxS3hSQUwwYXBpdnFqcHgvY3lQZjBHT01hTUNOYWc2Mm1ZZXNwa3gxak1XcTVZblZpOGdvTmQ0Vlp2MjNuK2gzcUV5ZkRSd3liTnN2WmVkNnBpNXZKcDE2cUZsc3VSR3VXcmwyK1hHWDNxQzEwQW9lUGdNRHEwOGpML2Jab3dBdGFaa05UWkpoTzYrd1ExTkk0Rk5zaURsdU1HemhvdFAreG15OXJ2cnhscy9oaFNaNUxRdFZSK3ZVYkVyVHRGTXV6MGxZZVZ0OS9XUFZ6ci9ZdnNTMEN1MDhIbVIyWDBhMWRWZHNMMUZtN1Y2OU0wMzVSYklyVGIvSlVEeDQwMXpaV3EydUhjT01PMzJpdVlPUE83ZW5xWFR1V0xkMnBUVjJKRnFWbmtmYy96MVlkK0xoYnl3NWhsdldjeHJBVEYvcE5uNkIyalNrNnNqMWxCN20vZlI2S0VHdTg5akJtYnZWOTQ1MEc5ci9IM1ZuMTNqMkw5VHI5a3BpNStzS2R5N1Z1UGloMlc2WDdIZldEeXFQVnBaR0Y3cHUwckFjY2V5U2RIWjE2QlFOZnlXRTVVYWxYNVliTkhEREx4OE03ck9CNDNhR2FXaTMwR2N5L25IS3pZK3RleEFyWjZjS0k5MkQrOEkzMGJEZmRieTNEWWo5WW9aUE9zV3Fna3ZmTEM2azhVbDVhVXhwUjZEWEhkOTVjRFRlWnVRRk5uS1JIVm1IZ3VpK2doZzVxTnBXNUFDWG8zSTZEcDYrcWEvT0l5cEFZcUMvV1RwRHVKTUNZVEIyTUJMbllWODhpVU5OZllXUWh3d1l5UTU5aUZadEo3TXZCbHRVeEN3UXQrK0xQSXhzTDllUjFUM0g4UHpKMlEvcTY3RTMvOTZsZDhwN3FKR2FEZEdHbnptWWd3eldNbnlJOXN4eTBOVkE5MFMxa29wLzJzdW1aNVVKMXV2R1o1YU9tWjVZUExEbnczelBMZk1HbVhjUm9ORzNic3FXN3BQNWdjU2RzaFJ2aHdXekE3dWpjUTZwVGg2dnVnR0pYcnhBTm9BeDBmeW9vOFJnc1lKa0R0bmFzbnZ6TVQxUHZnMWl5NWN3VW9Mdk5USUdEcGRLQlJWYTR4eUR2T2JPOEl2T3J6eFJkdWFCbFg2K2RKN0JrU1J3cTJadHBhSlovUmJ0Q2grMGt6dDc3OXEzTmE4azQxV0lMUFZxUnZHS0ZxczB0M0J5bVFxZDMvNEQ4a2RmVmRsVWFwM0xFNnJZczNKV2x5dCsvditKeW1rZFlpdVpMSnFwZDdmODMxcWl4M0dWSUg5Zjh1VmZEdFJmbkk3YTMzK2hKN2RSa3ZEeVY1TEZ2Sm5uczdQREJ1N1dnS040dnhQWUFjenhlelFZd0lRTGIwTnI0bHNhaGl1Smo3T2E5bXc4VXFjQ1NoY25nQ3AwZ2w0VzlpUkVNQy9hOG9YOW5zVDhOdjgwTi9hRTFhcStBS2tkYzVZZzZTazhTazhrQ2wza1krUmFQQkw0RDV2R0lyakFDTi90RTR6emNpaGRudnpmTXBqbkptSDJOc0hoYWkzOHlHS1A5T3N0WGw1ZFhsODB2OUpnOXoyZU9YMzdRWVMwTFNMcm15aVorZ21iUGdQckFRcWQ2ZnVFVXhOSU8yeGwyai9Sa0w3aythbXQ4Z3JZL0RrQWdWK0JUcEcybm9MM2tOL1RIZ1loVHR4dnFTTTV3YWtZOVBWSkFIcHdtSFZ4ZmYrZnJvd21YKzdEZEJNN1FYTHBRbUlCWUdKOElDdkdIbnIyeCtQT29hSUdsaWYwcWE3MVBZTWxyL0d6bk11U2pDNWczVnUweTU5aDk0TzVldUgzMWdQZmNyVnFKTWt4NWg2ZkFqQTU0QnA3Y0JTYmpXWjlvYmpTamVXd0QvVmc2ZWdIZWdKMjc0UjhXWUUxL2dwY1FEdjB1VjdMVjRvRU5ESHRFVENCdU1GTU1UWEtsWnZEWmV4WkVoVWJwNTBmRzc4N096ODdNMW1McnlUeUxlNGgzWHNsZ2xYakgrQkJQdnFRTjRXeFNCR1Q2dkJqSHNEZ2lpbFI0TDZrdytkSmcrU2tsbUlJdTBPejBpeHRuZzJwY0NqVGpjaEZMZG5IMk1sU2pEV2twbWJ2SjR3c1h1N3ROaTNjUEpHd2ZKTER3bmhjajNob2lhSHpZWEl4NFJ6emMyV01sbjNacEI5SHNPQVlVTkx0Zm9Oa3QrL0xMMUFmU1lpT1dKNitRSG03R1hvalZQTmxENzByWnR5RlR3MVlMOEVIUEV2dFJkZ0VqWFljNkpiQytSVUhrS1dXeXdvY1VrcWVVUTN3MWJMWUFOTTIrZGFhdnZrTllSby9wZ25BVnpkMEJlVjN0SFJtTFo4d1FXT09WWVhiRFUrbHlRMWlSSjN1UG9kbDdzdExIN0oyRUtjOXdTelZ1aDV0aUN6eU1OYXJPUi8xUm5kdlNMTERlWUFIOWdSa0JWc3AzckhVS1dNUUFCd09oNlZ3Z2JDbG1ZTWhlZ1QycEUzY2FYd1FXT3hFQXpXOUJjeGJCUVpvdGdzYnNHdWJyWTRZTkVMZ3BBdWNxY0pnaldJRm42UWhzaDRDaGM4RU9zWFFZdGs5bHBPdjh4a2VVL3gxNVJEQStLTm1GWm8wMmRUb2RxejlJK2tOSE1pQXdvMW5kTTRhTkpRRXdkd0FFZlVHbS9NQm0zbWVlM1hrQ3Uwa1ZlTnl6VUlCZU5IdGg5dEZ4SThkTkhhcmhpSG5TYlJsTDE1SlJyaFBOU0o1WElIOGpaMTlBOXhkeTlnSG83OHRZU2R5MVpqZnJLdC9Ed2c5SFNKYmdHMnJvK0VONjRFaDZkRDZReEVBS0VLSm5lZmE4RHJ3K2dxZnBDZVdsSDhEcU8vSDloT1lmWWRrMzRpTkpyMkRLUjJzV05Hc0JpWEZnenRicFBoSk4renRTWXUwM0dQd09abnkyWnNscVlYR0FyQmJrMnpTNitPQ0IvTXBDdHVFVXp5Sk1LZ24yN0JhMGZzYzY4azNHSGp5eWVmdXBGbllyV09PTFFQVk8zMWo2RU14QjdESEdtbVJ1U3JNSUp0SXNkTkN6SWhtdHdNbFphQ3huL3o4Y1ZnWUZBQUFBQVFBQUFBRjRBY1c4RFhoVjFibnYrNTlyRVZaWVpCR0Npd1JNREN4Q0lJSmZ0V3BCVkFTdHRYNjNXaFZ0VlVSQkZCWHhFOUhkMHQxMnU4Kyt0KzN1MlQxSHJFK3R0YVZpeFoycVd6Nk90R0xab3NMbGtkdml5U2xYdzAyTjdOaHNzbVBvYXBZeG1mZjMvSi81ekdjdFlpaGI5SjcxZjk0NXhoempuZVBqSGU5NHh4anZuSWtDU1dtZHBLdVVPUHVjQ3k3VHFDWHo3N3BOZFJvbWZtR29oQVRGZC9Bbk5XekIwanVYNmtpdVhHKzVjZGx0bXNpVnErVHl1SUtFaHV0S1FrSGxVRnBsSUswRU5GbW5TL3FtSHRhUmVrUS8wV2YwV3pCRC93cG1haXM0VmEvcGRjM1NtL3FmT2oxSUJrbk5EdjRsK0JlZDZSYVZhWFRUQnhlZWU4MjUxL3lUZ3VDbmJ0LzJaSGx5VFBMNTVPVGszT1FOeWU4USsvV3d1bUVYRFh0bzJIZkw2c3J1R1Q1cytIOUxuWjE2cG56eWlJdEd2SlFlbmo0bWZYUDZuOUwvOTdnZlRMaHM1SWZqSzhBbG1adTVWbVFlenZ5NGN0am9FeWRjUC9yTThaZU0vc0dZMFdQbVRsZzI0Y1hxNjQ3NHlSRnZIL0Zody9jYmxtWFB5VjdTOFAzc1ZkbHZqZjJiNnV1cS82YjY0ZXJWMWUvVVRLbzV0K2JtbXYrajVwbWFsMnBlcjJtcGVhK21kOXlvM0xSeFowKzRiQnoxQUREdTBYSFBqSHQxM0h2VVZUMytFZ0FtTEJ0L3paRVAxeDVYZTFMdHFiVm4xbDVmVjFmMzlsRS9PZXJkb3pwTjd4L1ZXeit0L3FUNmt4cStVWDhxWlZ3L1lja0VXalRoOVFsdlRIeGs0dnFKcjA5c2lhNXRFenNuZnBDYm1KdVdPeUYzVlc1cDdwdTVmOHF0enEzUHZaSnJ5YjJiNjUyVW5uVENwUE1tWFRKcDJhU0hKejA3NlkxSitZYlJEZlVOWnpkYzNuQkR3N0tHYjlDMzcwQS9ibmlwWWQvazBaUFBtTHhrOGlPVHQweHVheHpkZUdyamxZM2ZiUHhKNCt1Tis2ZlVUemw3eWpWVEhwcnl6SlRucDJ5Yzh0S1UxNmY4ZnNvZnB1eVptcGg2MnRSendHVlRyNTk2MzlTZlRuMXk2dHROcnlyQk9DWTFVbEpHbFJxaE1hQkNXZFZ5UDBFTkdxdEdUVUVUbW5RMG1qZGR4NmxlSjJpMkptbU81dXBFZlFHY3BDK0NrM1dCTHRRcHVoak0wR1ZncHVhQlUzVTFtS1ZyTkYrbmFZRVdveWUzZ1M5b21lN1V1Ym9YbktmbDRIdzlDQzdRU25DaEh0SS82aUw5VjNDbFZvRjUrcEVlWnk3OFVzOVMwdlBhU0VrdmdxWDZOYmhETDRObDJvS1czb21PYnRmZCtsOWdoVnExVncrb0EzeGJmd0xmMGIrRHYxTStTT2loWUZJd1NUOE1KZ2RUOU4rQ3B1QTRyUXErRUp5dm53UVhCdGZwNThFTndRM2FFQ3dNRm1samNHZHdwMTRNSGd3ZTFLYmdiNE52NmRmQmo0SWY2YVhnNThGcWJRNmVESjdVYjRPbmdxZTFKV2dPbXJYVk0rTFZZRjJ3Z2RtUzBJaXdKVmdYdGpBYmFzSUM4eW1sN1dFaFdCLzJFOHVHWFJwTHJEcnNVUTNoT0tnMjdDSzN3T3pNS2tGdUw3a0ZjdlBrOXVsSWMvaDVPTVlxcldxb2hqRWJSM2lrVWg2L09pV0Q5WVFqbFF4YmVMNlQ1M3Q0TnE5YW5wc1pydE04d3F1VnBEMFpKRmREbTNxb3JWbFYrcFV5M0k4S2Q5RzZBV3JnTHR4TjNRVktieEIxVTNvVkk5ekl5Tll6Zm1uSzZ0SjNTZnUram1ma2F2VTRQTTlvTnFYVlUxcVQrN3lGY3JZckZUVFNIclRNcGJaVDZnQ2xWb24yYWxhNFQvTW83V3JvY2FXaXAycHBXWmRHcVlMbnNpRXlVSkorOU5DT1B2cXhWYk5JbjBmNjFmVHhjZmNucXkzUWRxUytIcjVBRjFKK0E4LzJJOHUza0ZZWk5mK01tdmRTY3lQbHRLcU81MmVxaWY3a0tLdEhMb3YrLzVSKy95emNxWjlEdndoMzZNbHdtNTRLbS9WMCtMVFdoaS9ReDNQb1k4NTlmRFpzMDNQaHkzbyszS1FYd2pWYUYyN1VldUwwVzYrRzNkb1d0dE9tbmJRcFR4dUcwNmNNVWhyRjNWaTNxRURQVXBaRkxmYzV3dGxoaCthU05wKzhoZkF0b3djYmtHQVE5Z1NKc0QrWVFudzY4UitGcmNIVHhOZkIxNkF4eUNEckVyc3QzVHJpRTVTZ3hFcHlFNVRhUXFtMW1nL2ZBcVVvdWFEYmlDK0Q3b1JXS3MyTVMxQlRrcG82cUtrcm1FeThVUWxxcktmR1FuQ01Nc0d4U2pGbjBzRkNsUVZMeVh1UXRCL0J2NDZXclNkdkEyVk1wcDg5S21lOFIxQlRocEpIVVZ1V1dxenJoTzR2ZVhYazVaQWlyWEZMN3VYcDVjUlhFdjlmMEx2a2R5anFPN1UyMEtMSnRHWktPQkJNc3h3S3RLUThXRXI2MTVXeFRINnNMSEpKTWlOVHRDaE5pekthcm1HVW1nTGxZYjliVlVHWVliekhLR0g5cWliMEhLUFdIRzJkUkE4YWVNWnlJMzJCMGg2TlJjU1hNSXJMU0grQThGMjNMbys4ZHJsbGpkVGNSR3VQSWYxNjBoZUd1NE5GalA4dHRPUzJzRE80SFZvYXRnVjNRdytxaGhhM0JLdVJuVnZNL1FiYWRLU0djeDFCUzl4S3dsRVFtdXhXb2pQUmZFOUUrbEp3QzY5MUMvdTBqRHpMa1BCZFpKS3d6TVlIUjRjRmFtdHpiYzJrYllEL0tJL1VDRXFwRUxWRU5YaUVsTFZHMWxIS0JDaW4rcmltR3lCR1RJc2kvWGxYRmNpZ1FFMHBhc295T24ydWpkR2hqMWxxN1hHdEhnM0tPZytibUhUTktkdTdlbzFBWXl1SVoxUnJDelFtZkl6NjY1bTVmZEhNL1kzR3dVK3JyRE1UNEprSWY0NzVPd2srOUFLN2s2VjFxeXlIK2N6WUJlVGZ3RE0zaGwyMHRwUFdablFUZEp0MXJWRjNrcmVjY2xieXpBYlNPbFFiQ0UwTzBLR0VUZzRtTVFPd2UvVG9MS3pYVG5xMU5taFNscDV0Q2FhUlBwMjBZK2poc1l6b2NjajVlalVHTjBBM1FnczFQVmdFNzFMaWQ4SjdGM1MzY3NFOU9qNjRsN1Q3MUdUSmZGMU5TS2M5K0RIaGF1cHJEdDlsSm1IbEdhOE45S3ZPbW1ESmhGaERRa3NFcW1GOXNCV0ZhcUdjMHVoc2I2eXZDNkZGSVQxRU1xc28wWE9hbnVVWWk2T2hoWjY3S1dyZlJzMEZhdDJQN3ZXcnl2T1VQUUJ5cjFRTnBZNURadFlHN3V0SW1Sa1d2QUxNZy9kcVp0YmpoTGErcEcxWEdXMXZRcVBRVm5oVHRLK05KN1pocnp2aWRjZHJBdmVWMFRwWVVMVzUwNUdWNzZTdVZQUlVLMWE1SjFvWGFxTjE0VzFiK0RSMXBxTFprTFNlemlJK1Q5T3BKK3Q2eksyVTZ4bUlKSWU5aGJ3aWtqWXovQjFQdGZOVXlxMTdQT3pueVNxZWJLU2VQdXJwRXRxS1hORlF4bUMvUmtGaktDbEgrWk1Jc1JHVTB1NVZiSGI0cHVhRWVlUlBPOGk3aHRMbWM3L0FOcU5IZDBGMzArL2xsTEdDK0FQUVN1aHhxRmtKSWY5bzlTdFRPL0c5VUJkbC9RY1M2WWJuZmVJOVBMOGYralAzZWRhcHY1RFhTLzBGNGgrd0x2WVJmc2g5UHpTQUxvVGhMc1o5TDdhb0oxaUFyYm1COEVab0VkcDJFN1FZdWhrTnZvVzBKY1J2aFc2RGJ1ZCtLWFFuOC9ZdTdOamRwTjFEL0Q1b09icDBQN1NDdEtlUTBqcnltVUZJY0FUWENtVkF0ZGU0TWVFbTVtbS9iZndralZFRDhabGlwRHhmeDJ1T1VranJPYVMxajNGdTA3WHd6RWZtQzZDYmlDOG0veTdvYnFWMW4rMWF0MWFvQnFtOWlOVHkraW1TK0JuMGM1NWZIYjZuWnlqem4rRnBwdjVmOGZ3NjB0ZERHeGk5TFR6L0tpUFpqblRmaGZaU1I1ZXlTRGV2YnZMZVo5eDd1TjlQNi85TW1BOGZSYnByMUV0WWdENEk3MEM2VHlEZDFVajNKUTBRaHVFVDJJcGE1bjRxb00zTS8weHdJN1FRV2tUYVRkalp4WVEzSzQyRUM4RVM0cmRDdDBHM1EwdDU5ZzdDWmNwaUo2cXdFMm5zUkExMkloZllUaEF1Si8xKzBsYVExeHptdmRKdW9IMGpkVjY0RlFuc292ZHZhalhoV3U2ZjBUZ2swRUh2SzlpYjdFQUNyMmc5Rk5ELzZackhDUFh6WkJxYlFqOVZHNDNTZXU4VkpwTHVrU0s5Z2JobnV2VzZqNUZLTUZJYktXR01kMnJYS3NsSTlXZ0I0VTNRWW1nSlJBOFlyUlNqVldYYlE2djFBT0ZLMnJKS1pkNGpQa2w1ejVEZXJQRzBzMXpzT1NLOXIxSTdQWHVYT3ZaU1g1ZnE5Ui9jZDlPZTk2RWVhRC8wWnlnZjNzWG9QTUhvL0pEUmVZalJXYW8rNGgrR0R6TTZ6WXpPRHhpZEg2RDdCVVludytnVUJvOE9kRE9FN24vMHFNQjNKNkd0TjNTUHNveEtmWEFmeEFyTHFLUThLajhuWEIzdVl5NHdNdlRoL0dnOTYxRUc2WTVTbXY1VWFnTGh4TWhLTjlpK3ZXSGJNeHVwemdsWldkV0lkQk5JdHd6cHByempvSVZZamtKa09UcTFuUHNWaEE5NGZhL1JobmpuTzgwV280czhXd3ZvZmFpSDh2Y1QvaG5LaHgyUnRlaFNnZkFEeXV3TDMwZGlCZlh6N0FEcG9WZUpON0FXQlNTMks3aUI4RVpvSWJTSWRlb21KTFVZdWhteVBoUGVDdDBHMldJZ2dUc0kyUlVFZDVKUG00TjdvZVU4ZXorRTFZdjJINm5BZWt3Ymt1aENTdXg5ckF0Wk5Ib3JjL3BGdFBwbHRMcFZUeEYvT253TjdYNFR6aFBoYkl4MjN1K3c2OTZ1RjdBeDY5RCs5ZGp5LzhFKzRkZWtiVVpyWDhVZWJHTzNmeTJqMGEwS3IyTlo5UDB0alVFM0p0RGJpZFNlMDdIb2U0MHQweXlrTWh1ZFl6UnNsWHhXOHM0cWk2NjNhQUVsM2tUY1ZrbTF1aHU2ai92bHRISUZMVnZKK1dvVmZXQVZvUmR2MHZLZHRQd05XcjZUbGpkRmxxbUIxay9VczVUMVBPa3ZRT3RvK1hyNE56QW5mOHV6Mkg5YTM2WjIydlV1NWUrbFhWMXFLcG9IT2VaQktySlNQMlJVVjBmejRERkc5WHVNNnVySVNxMWhWRmN4cW85aHBVNWtIdFFFTjBBM1FndFY3eDBLTzZKZ01lSE5wTjFDZkFuVzVsYnVieU84SFZwSy9BN0NaZVRmU2Y1ZHhPOW10M0lQZEs5T1ppNmNGaXduL1g3S1d3SHZhckdQRFR1OWk5bEEreXVRd200OURhMkZMSVd3SzVKQ0hWTFlpd1IySTRFOVNPQXRldDJwS3pTQ1dJV3FsR0VXalVLMlk0aFBJSndJc1E5bHZKSnFRSll6NFo3RkdNNm1IcSs3eU9QejVNMWpySzdsR2U4Q2JaK3F2UDR1cHliYUtLKzdwSzBLZXhtckRscTRpeFppUDZGbmxLTjFGYlF1Uyt0b0dXa2VHNTdaRXZaYnE5cTlzMDR4THYrVGNVa3o0MW9abDZSNlNOdFBXTEl1ay9jQllSLzFmRWdaL1l6ckFQa2g1d0pPSHRHNjNCT3Z5d3VoUmRCTllVZlJUT3NjUE5NZ3p6VG9MdWdlWlJpUG1zZzI5VWUyS1JsNFBMaGZCOCtHYUMvVW9iRkl6TjRGeVB0cWV4YzREYVAxczFTRkJIZGloK3E5NzlwaXowWGVmb1VVSEszSWZBZHlHN0RsaVU3cTdKUTRTMUgyTHNwT1V2Wk95bjVDNHdpOW4yTkU2cWpYNVN2THl2VnZZcFJjaDB1aUhWdW9mN3N5cmllaEN0dUVKTEZudUcrRzBsaktabDFJemhKYndCNjFNbjU3R0k4MndqK0c3Mkc1MWdRYmFOOFpYdVVxMERPZlBZbVBZUlo2aFlOeU9sV1RxS3RCTlpTNFZYTVpqV3ZobkU4N0ZxamNaNFRGa1BjZDBIMDh0WUp3SlNPM0NwM2RZSmxVcXAyMnZ3dDFxWlpWS2wwME96UGF6LzJmNGN1SG05R0VYZXBGRGdXMDhRTm1aUi9oaDFBLzlRNWd1OEp3SXkzdllIYW1neHVnRzZHRjBGSm9HY1RwUE5vWEpCbmxxdUJlNHZkQnJLNGU0YWNWMlZMcW5lRWQyQ2hvakJvMUlkcDVOWkF6RzJzNlYvaHRtRGZ6a092VlhyL2J2TXF3d2tSMkxCK3ZMS3RJWjNaNmhkbEN2QjE2Ri9LZVZCbDZuSXgyVFdsWjd5SDMyTHJmSWVzK1pOMW5yS3o3MEFCMWhtRnIxT09VMStWQnZZNTdpMDdEdzg0dnNpY3BjQjQxZjVmd2U3VGkrNXFPNXltSGpwek1qSzNTOE9nOHdONkYvc3dpbkFmWDFWQlMzczFBbkF3OEMzWnJMRlFkL29Gbk90SFVMalIxTTVyYUUybnFScmkzb3FXOVltZHFtKzVaQUU4bE9wNVNOVlJERGJIL2piRE9NK1FkelNLOFZGZ2llSyttWFMvRko1K3N6MGFkMU4xRjNkM1JET3ltN282bzd1N0lDMmpQRlRycHN4RWhQc0pvbnZiRE1XQ092T3dKSkhRNTltSGtJeTlnS2k2akwvWWIySk5JRzF3R2VjTXNKODk0dHk2bEJPM3ZkUXlQZ3kxRE81dzljTnAvUTR6emsxdkluVTlTM1BGc21ldHlXNkdvcmFTN0JjNmhkcFdSMmtVTnV6VUxta2ZhMWJUWGtxRU4yMTFYcDQ3Z3FUYWUyRTFaMnpTT2tGTWtiWDRMNlhUeWRMTmJmQjRTdnhCY3FtcEsyaGJaa2xhOUZOdVRIbUZQN04xTW94MHArbEJoVzVMZ0xoR3NKajVjWjlLdjY1U05VOWVvTnZpbGF1MjlPcDdjNmVST0wzcW1DWTdwY0V3M1J5MGNPVGh5UlJ5MWNEVEIwVVJLbEtwUjlxZFdRNXlKTlE2cXRmY3pGWjBkKzZNVGFGWGt5L1JZSU5lc2QwZloyRDk3a1VZcVpYK0ExMGEwYXd3bmtRa2FyNG5FN2JleVphdUtUclk3bWZmYk5RZTV6OFhhZnBsODE4UDlOWVRYMG9QNUtvOTNtbmY1bEpYVWNzS1ZTSHVWT0VQd3pBYU5vVTExdE9sRXRkT2JkM2xtTDlRRjcvdlFuNzNtdFVaclhrZTB1OXlrUGtidFE2aWYrd0h5dzdDRmVmODdXenJXdkpKNXZ3Zzk0aHhoUDFucFhyeUsvVWN5c29TcElrdVlpbTBEN1dXOVN4YnR4VHVDcHdpUldyQ09NZG1BVEJvNXhlUDVRLy90VTROR29ZbXh4RUoyRVZpQ09iUjBMajJiaDNTdklXMCs5MHZvRWFkZW45b2ZJSTVmVGF2STk1bVNudS8xU2Z4dDBYdDYxMmFMaHBjd1dBd3RnVzZGYm9OdWgrNkJuaUxmSjJiS0RxajFhVitmOEhVTmRVOVNpdGl1YUhYcmpsYTNibnR2TmxEL2NlaHhsWDNGYVFndHBUZnY4MVFENEVsd0ptbnNnM1ErZEFGcEYxcHprcm9ZdXBiNzY4aS9oWEFwOUl4cTljK0U5dGtyWjB1MW1mdVhJOTg5WG5MdHdXYTBFZjVSUndaNGtvTVRrTzBwME9lZ0dkQXM2RFRvZE9nTWFEWjBKalFIbWd1ZEJXMWdCRTZnNVdsYTNxUTBsS0VWT1oxTXk4OVFBekYyM3JTOGlqRVlpRnNmdHhxNmpyeGI0RnVpR2kwbGZJQVNIcWNrencrZkNXcmwxc2N0bjZJOThMVVIvcEd3WFZXUlA3U2VIdVNDVTZEUFFUT2dXZEJwME9uUUdkQnM2RXhvRGpRWE9ndmFvQlBkZzVUS3FDME5WZGdMbEFQSDA0dHA5Q0tyMmFTZjZmMW9QNzFJNkh6b0l1aGl5TDBnN3haYXVnUmV6cG4wSXUwNTczMG41RjdBdTVsMHl4NUpXZmFFUGh1N0I4ZlRnOXJnRk9oejBBeG9GblFhZERwMEJqUWJPaE9hQTgyRnpvSTJLT2RkOVM1MGZwdjNQbWRUMHhYbzEwOEpuNEIrQnYwY1dnMzlBbm9TYW9WL0Q5YWpqZkNQbnNFZDF0VlZ2cTcyOVRGVmVGOVpZLzlkVzJTblgvSDVscmxrSDU3OWF2Yjh0UVhyNFUzUWlnS2xiWFVKbTNTT1J2SzBUODNpeE15c3pHa1NxQkJlV0RqNnNXRjdaUDhEWk4rRFVwSFBJYU83b1h0dHYyb2p2d095SmZTdURiN0h2Wk5NcWhuNkZiU0ZNcXdSMEY3eXUxUVQrUnJxOVQ3eEhtZy85R2NvVHkvK0FwWHNhYURZendhRlliczk3U1ZuTEFpdmMrQXpGblF6dEpTMDByTlV5dDRlK3hYVVdHVExNdGd4Nytxc0hSVzB2RXkvZ3VnSHhJN1ljc01ieVZsekN5Zm1sL1Z6WkxrYXFUL05MbnN0NU5OVytHYTAvbzNYczFpNDV6aE52MERlT3NMMW5KWTNJZmxmaDVzNTE3d1dhMkhXV2hnd05ydlIrV0hZU2Q1bGFpUVM5NTQ2TEVRKytyV2FnSFFuMm83aU1XTEV6Z2c1UWNNM0IvSUpPdXp6Q2ZvYUpEU2ZQZmdDZEcyeFQySjdHSm1OUG9GdElLK2RNdCtGOW9adkllMlYrZ3ZVQ3hXZ0Q2QSs2TVB3ZnZVVERrQmh1REpJMkVmUmlaVHg1QkJmNmxVaUZlK1BuMmFGYVdaVTFuRXkyRUFiVXhxcm1hcFdUYlFHWjdGcWVNQzRxeE9yZzZVVit4YmdSeHBlK2RsWk1yOFRQck04U1hvQ0hjemFCK1k5SlhkVnZodkIzU1kwL25mUmU4bCtkaU45a1Y4cmpkWjNvdldzbnQ3OWpTTTFZRzB0cDUxWGhNY0ZWNFpYQi9QQ0djRlY0WmVDcThQUndWZkQwNE92aFo4SnJnbHZEYTROVHc2dUMwOVdXYlR6U1VlN25ZeDlhY1BrbmFwUHZhMmtwa2d4SHpGT1dISEttb2huVzV6eVJKU3lpWlNrKy9Jb2QxdDhWMXpxempoL0UzZnRjZjdxb2hMVGNvbFJyVnU5a3hsUnRJUHRVdzI2Tnk3c3NLOGV6M3U4UngyT0xCa1p5Tyt6NDNjOHlNZTJvSnk4NmVSVk1VNWwwYnZTV2pBR251bVVNRk1qb2pjVzU4QlZEMWNXcmthNDBFazF3VFVUcnRPb2h6Zkp4VGFLM0lSM215bGxnZHRKR2p0T25qMG5lanVaY1MvV2t0dE1MOWFSK3dONnNUSGFyYS9Iem0zeWlZQmVoRjNSTy91QnFBWmJPZStTOHo2UjFOR1hFZEc1b3hPK3JtaEgzZ3Z2VGtycnB6UjI1ZVFQczRiNmJiZVFrbjFrM2ovQ1Q5a2dTMndzSVR6VzAybHFodEJjQmRHcGVYYVlkNHhjeUJhQXNGei9qclpkeUd5NW1Mb3VnUzVseGx4RytCWG9jdG93RW80WmNPd1BMZ3A3NFNyQWxRKyt4UDJYaVY4S1hRWjlCYm84TExpOHo4T2RoOXZsd2RsM1lIbXU4UjA0T2ltdkE2NVd1Rm9wYngvbDljQ2RoN3NIN201emZ4YnVQUkYzTjl6NzRHNlB1UE1SZHg3dWZTVmw3NE43UDl4dGNIZkEzUVUzTFFsNzRlNkd1MGZwcUdjOWNQZkEzUWQzYjFIUCt1QWNjSnRUK3ZlQkVNNU9PSkVVcWJRZ3loMklhMzJQM0s3QXRVSXVoM1pkQ3RkbExxc1g3bDdYT3RWbHVWWlNZMjdpbGhSUHdjazRYRUZ0ODBpNUN2b2E5OWNRWGd0ZFI1dXdFenh6SmM5d2FvSWpIMXpOL1ZlSmZ3MjZCcm9XdWk0c3VKdzhuQzRIcnI1QjVieERiaWZsZE1EUkNrY3I1ZXlqbkI0NDgzRDJ3Tmx0emowUlp6ZWMrK0JzanpqekVXY2V6bjF4bWZ2ZzNBOW5HNXdkY0hiQlNlMWhMNXpkY1BLbUdjNGVPSHZnN0lPenQ2Z1hmWEFOdUkzRDRlcUVDMm1RUXExUnpvQnJlbytjcnNBMVFYNmVkbndOam10Y1JpK2N2YTZwTTZxcHQ0aXpONUpHM2x3QmMrcHRybU45cmNIQ2NZTEdZaXowdVJHNzRsTnNFTEJYOS9VRm42bDN3YitWSjkvaWlUV1JqNnVMR2Z5bVBRZWo0cE93djUveDdLOGtsL2VFU3R0K2Y1ZVN2NjhtZnpQak40N3diS0YzaWRnL1lROEhQRlh3WkcxNysrTzhNczkrbitMSnFZdmVuYVJsYndBNXNhL0EvcndkZm02ZTkxOXBuL2xaZDN3T1RtSVBiYlVnV3l4N1BkNkN2eTMyZlA4V3E4S3BML3B5YWI5T3hUWnhhbVlWS0tkVWYwZWhqSGVVbyt6L214bWRjNU9SSlUvWXJ2a2JBa3IzRzN2eUp2RjhBL2QrOCtIdlVzN3lXM3Y3bytpWDM5cnp6Q0xDbSt5ZldxdmJlR1laWjlubFBQY0E5eXRaazNtdmJiOXNPM25zaTMwUzY2Q2xRbU1TdkpuTEVmSjFRTkJBMm1RMG9SRzlhU0x0YURSak9scDZEUEZqaWE5V0ZWNjBUTkFNMlpQRzZETE95dG5HZWwyaUJxOG90dU0xUHBrbkpnaHBhTUx6dVpkMXBZNlZ3a0w0VHRnWDlvZHZoZnZEUGVHT3NBL3dWb1h4U0pMYXoxMkIrMjVtVE1KNXBPbFQrMzE2WllkN0Q0bHJVN2lJNnl0S280Y3BwY0lPZGdGQ0dubkxxWk54SEIvK0VubVdXMkw3a010dTh2T0E4em44UGZEdEk1NGcvMXZoL3FLU3Q0YTNvcm1ibWI5SmVEcTlEbkdxNTVxQnQwQjlWZXc5S3p4VHVsWHB1U3pHa1RGRFE1aWR4S1NreTNxQSt2T2t5bmNGWWluSzJFTDhkNVJSS1ZGT3VVTnhUVk5YRlgxb2Rabis5aFZLeWM4U2psRVpveTJsWFg3R0htZzV0elZjUjgzdm8vRmxsTHpHWDl6VWtWdERtUEJka25JN3FiK2ErcGpQa0NpdndtVjVsaEVyQXdvN2FjTWZxVTh1dVRuOEI5cjluS3FpKzExSTdyVndZN2d0M0EyMk0yZHFPWit4TDZKZmJkYkQ5eVI0T3BCVExWTC9EU203M0dxRjMyWU1Vb3ArdE9mdHNKZjlVTnBTN2duZmdITTE5YTJoN1Bad1o5Z1IxN2szZkROc29YUktJV3doWnh3MTgwYWUrSUJUKzBpVEluNWxyQkc4cndvN0tlZjdjQXoxUy9KOE5FL2cvNnM2VFN0NTgwRFpUMHEwOFZscUxQNWxRVnl5RWk3VGRidlhnMzhaZERiNjBlZC80SDRYdGs3MGRQT0I3U3lLcCtRVXR6WVQzUTJxdy9MZzUzWnVjY2gzT0VoajFVRm1NZmYwc0hOUWFxSGtyajJLQ1BuT2tHaXJhMGJQTzR2clJ5Y0xCL1FoNVpKVGc5dU1sSXBiUXgzV2kzNjBvY0FZci9WY1VNeGJkS2NLU0U1eHlVT01XMWNjUFY1Tjd1WEc4QS9oSm1UU2M0RFVZa25Ubno3a3RVTnBlcklSaW5vWGpWazZha3RtOEtoRzQzTFFYOHd4bUsvc2dQRzAzWERZNlRqWHcvdTV0Q0tMSkVKNTdBK3hnSlFPL1ZkMXlOSndlQWpTNkFxM09WeGp5N0xxb0d1VWUwVVkzY2Y5Sng3ZkZRNUxsdDM2bEg2SDFpNjArSHRjMy81b0NTT3IvZ1BrbkIwMGdxa2hkS09mMlJEL0RxNTFjY25KMHBMLy85NXZNTlp0RHA4TEM4ell0VVBvVW14VHc0SkRVSlFLZlhvaitMKzNaTS96THE1SnhYWVJlOTllYkYyTE9QdUhxSmN3a3ZNMmFIZTRwbGhpeEV2dlBIcU9wYUhTc1NqbE5hZHJoajV4aWFhc3BleVZvRzdXMmRKZitRSHhERWdaQjY0MVRVT1ZUaStUbithb2wwZ3NIWTlYU2tuV3BQam5lQ3h6S0ZVaThkU1FNMmV2UEo2TzgzWlRpWEF0ZTJCcTRMNlBhNzdFcm00TTg2UVhqSFh3SFo0K2IvbTQra3c3aTZYUnlmNjNxMlFmMGh1M09kS0FVcjBjc2x5a0dPL2I2WDIwbHV3blJzNGc3djB1ZmFnV3NyZW1oMGxXcXpWS2wraE11dWllY1l6MG4zVGltUkxOZE9tVTAzTllHblpvbHUxNGtLT3VUcmVvcTJoWEszK1RNQ2ErcTZXVlZlUTN3bGswbS8xRXZTRkthakxuUi8wNGl4VDFKd0ZxOE4ybktMTlNTWHRob3hMTlZVdCt2SmRnSGxmb3NINngxclIvNHZZNWYwaHM5WkhkYUxNVjNsYWlRY25TZmJMdjNmZVM5S3p2Z1RVN2Q1aVc1VlA2aFYwZjIySW5mVjR2U3NIbWRBM2Q1cGozcis0M09XOTFjTXI0TUxZL1RlSHJYQWZ2ZzZvWW1SMUZaOHVjcnpYL205Zi9IaDMrcit5VGJqTzJLNjgwNjBpVGtraW92blJlSWUzaWMwYytaRzlLaUtlR1dNR3BMUTZ6dWtScDl6RlRQSzd3dHRzbkNjajdxNUtudmpidzBmM0pESDRpdm41Q1p5RDZ4WXltbnp2REFUeFNtdzZ5M3lnK0xUR1hpODRwUTUzYVdqdzNObEp5VzdpMmRCWU0zbFBSaGw3UzBnQ3BET0pNRnEzc2JlUm5MQVhmSFRDNlhRZElzQWw0QjhKZG5ENkVqdVlvTjg4SXI4YS90ajc4NzJGclNjazdpcndLYjlHS044SzhkNWJib0QvRVZocE84WGFwdEd5bnBpVEs3ZUhaalRyNHorVkV2ckJQWVo3eW5mU245YXV5L2YvVUxjV2g3ekE4ZDdHajhSNG14MWswcCtyQnRWTmVObXdtekVmM0srSjFJWE1RYTFJb1hROUxjdysyYXNVejZNbnc4akJQemRPdHJiWE15R0lQOHFQeHJCUWEwV1pydEJ0MGdMN1N2WUc5aksyZm9KN3MrRVRYZzk3RFdVbnNFWTlYWEZQeGVmQVFkZ2l4YjZ6d243S1ZxWStsb2ZpeUR5aXpjbEE3RDZITk9sRk5qRGkrVnJBMWZLNTBSTUt0UmZFVy9NK2RhR3NWNTZLTjZFZDdpVzdNZHB4Y0hkYnZZK3hDYVZuSjNic2Z5ZE42U0NYajFmWmE4RVA2dHlsOGFNaTlJZTIwYjhXZS9QQXRxREJZazhqTGxtb0R6elF6eDNiWVBoNUVpK0s5d0w3aVowdjJYTWs0SlJ0cDBHcDdhTDhYOWgzVTV1K096ak90Qit6VGsvSFpKQjJYbkl6T3dRK3hlamVYU0lObmlqV1cvQjZveFNYdktwSkdwK1BlcWZqTmd0dmdPcHhMeVp2Q0o3aDJsTWlvdGFSa3ZPQm9KZTF3eWUxRkplZVZpZGRCcDBRMWs4SUl0cnJrbmlIYjNFTDlteW0vSU9KRlZ0cHRpVXJPeHlXVEVyWHVlNVRNKzZDaFBYUFdqZDIwMXZFaWFUZ3Nzakt1TTA1SlUzTGV1cEV0MGJsTXlVZ2w3YUZPeGF0aFhMdTFMZW5TMGxHS1NIRzlTS01OL2ZoMjJEZlV5a0orTnhMWlJRbkUvWHp4cWFWcVVKdHJvcEtmb0tlUEl1ZkNVT3N0SmVjNTgrOTB5YnVqeE1FbHAwdWZLbjNUNFprUWV5R1U0b3lTQVZYdWI2S2t6SHBrbEFYeS9ZdmtIbnhYRUxjcGZNOGV3YVQxTkVVdEpXdUF4MmNQOTlsUGJMWHFPd1NtUUZmNlM3RGh0R1dFUnRMblVScERHOGI2Rzd0eEd1OHZ0U1pvb25MK09ybFJSK3V6T2trek5VdXovYjlrNXVscVhhdnJORjhMZElOdTFFSXQwazFhckNWYXBudDFuNWJyQWEzVUt2MUVqMnVEdG1pN2VNK3Z2ZXBXai9MNmkzcFYwQWZxMDRmcTE0RENRRUVpbUJRMEJsT0NwdURvNEpqZ1J3SC9xU1g0WmZCMDBCeXNDOWI3ZjFOY29TUTRTOFBBQkEwSHh5c0Y2alRDR0FsT1ZzWVlCV1pxREpqcmNUdEJZOEVYVkEwK3J4clFxSEZna3NhRE9Ub1M4TTB0T0VvVHdOR2FDT3FWQTFNMUNaeXFCakJLUjRPa1BndUc2U1JRUmozK3UyaFFydG1nVW5QQVNNMEY1Mm9lK0lxdUJwZnJXakJhMTRFcXpRY1ZXZ0FtNmdZd1ZqZUNzN1VRVkdzUnVFSTNnU08wR016V0VuQ2lsb0h4dWhjY28vdkFTVm9PWnVnQjhGbXRCTE8wQ2h5cm40RGhlaHhNMFFad3BMYUFhZG9PR2hnTi80VWlHS2U5SUt0dThFWDFnUE9VQitmckwrQUM5WUlMVlFBWDZRTndzZnJBSmZvUWZFbjk0TXNhQUpjcUJKY3hrbElpQURySC82OG5ZRlFiTloyUm5hSmFScmRKcHpQQ1I2dUpVVDVHeC9uLzhreG10SCt1VXhqeDFmb2NvLzVMaldIa24xYk8vNTNuTkRSZ25kSm93WHA5SnRpQUxweWhCTklvQTJPVUJtTlVDYVpxTk1pcENrelZFYUJXaks3SHRCNnV5U0JRSTVpdUthQU9ycU9KVHdOMWhNZEF4NEpoT2s2ZklYNGlxQk1qVFp5UkpuNHltSzVUUUwwK0I4bzBBd3pYcVNDbDAwQzVUZ2RINjB3d1FXZURFZm84bUtKemRDNnQreUtZcFBQQWFKMFBwdWdDTUZrWGdrWWtmREVwbHlEWFNuMFpqTmFsb0ZLWGdkSDZDcWpVNWFCSlY0QnFYUWxxZEJVWXA2K0M4Zm9hT05JYU5rRzNnSW02RlZUb2RwRFRVakJSRDRJR2ZWTi9wMEFQZ1lUK0h0VHB2K2dmNmQwUFFGTC9GVXpYUCtsaDBoOEJSK2xIK2pFOWZReVVXN2VtNjZkNmt0NnQwVnJhOW94K1JTK2VCYVAxSEtqVTgxcFBmQ09vMHYvUXIybm5iOEI0dlFTbWFETVlyNWZCWlAwcnFOTXJZTFMyZ25xOUNwcjBHaWpYNitCb2JRTkg2aTI5VFM5YVFWWjd3Rmo5ditBSXRZR3MvZ2pHNmgxd2hQNE5UTlY3b0VKL0FnMyt6MmZIQkNjRUoyaGljRW93Zyt1czRDeXUvQWNwVFFwK0VmeENJNE0xd1JwTkM5QS9ybXVEdGNvRS94ejhzMFlGdndxZUpmZTU0RGxTbmcrZUo0WC9GNlc2NElYZ0JYcWFHTGtVbmRISU55dFcwNE9ySlRXeVhoUkFHOVk0eFVvMjRPKzErc1YzSXAva1d6dnZnZHJETGxDUS9VSWdZOThiZm02ZFJRdmE0emNKZUlUQXdlcm5lZmg2dzdhaTFYKzhyNktVZ1UrcTFWQWhiblhrYzZMVlBRZno5aHdrNzdsd2k4dUVWR3RlS095Ty9Jdjc2WDNuSjlEcUZzNHM4Y2tvWEVlcG04S1Z0TGxvSCtCNFdiVFQ3enUwODBqa2swTytSZWZCbEVQeVBoRlBaZ3BLK0s3WmUrUEhQdkpkTERGZkQxN2VzK0ZhV2xlQTlsdldyWUtvaFhKVjUrK00ydGxwdGtDN0RxUFZlNmlGbjcvSVlvL3BmZDVEMFI2eW14UVFlZGV5eE1UODJvditvT2xEbFBjYjlxZzhFOS92ZzE2SzltZlZ0Ti92dFE5YjFyVFJ1NzR5VmJDYlhFWDhOWGJlTHgvY1UzNVFqV3NwOFNObjR5K2VxcXdoWmZIVE5ZZlI2Z0ZHemo1Ung5ZlpROGpWS1ZtekVQZGRsWW16QUhjSGEvVTJlNTc3aTF2dE8vdENQNmwzSHN6QUF0Y0M0SytXaWYwaGJCNWMrcUg2b0htMk9iNlo3cE1LaEdTNFlnRTdiY25SNk1QelVtR1ZubERrYTZQRWYvQjczcnNZNWJJaXBqSVE5ZEYrQUIyMDFhdHMxWHVpKzg0aWYwUW01TnhCL0xCL25HVlhLK1cvNW1EbWhBL2I0bjRkSGZtWWIyakNiMHYrbnJZOTBycHQ4Umwrb3l3WjJ0NFN6WTZQLzh2Wmp1YlJ4aDZ1MzZNWGo0VzNxc29XcTBPUnZDSS9lQmNlcU44b1RhMEg2WXQ5VkVpajlFd2UxVkp3bi9ZZDdyZTcrTzd2b0xSMTBUbk8vZzM3Z1F0RksyY1BWT1NmUGVqYXVBb0wyUW5hSXdtL0RPRi90WCsyMjMrSFhIdjROa1FUa1VHWDUyUUwwbHlOdlgwaVhFUWEydWUyVDhHeS9NSDE3L0xiaHpaa3ZmTWdKOVdhSWk5dVZYUmZINzJGNVFxeFd6amNiNkR3WGk5VWlobVppdW9zcHg5cEpTMXJRcVc5bXRueVVSdDF4bDk5RE4zcWRPUTF6RVQzMDBVS2xQSTltaEtOMnVHMGVvVlNzWit2RGhydlZ1ZGRBN2FGVm5mWVJwZEhyYmFVckNsdkQ3VUdLQWxKN2pmeERuUjVkK3hMU01VK3NINVFVQm02VXpCZmw1L2NHZm0xdVJkamJrOXVONjNvZ2lKdC9WZ3JZSUtTK0xrL1pmQlZ1dFEyWm5DZ3o1Q1NWcVZHcTBwSHFNN251ek4wRGVlZFd6bm5MTldEUGltMGFnK25nelpPQmU5d0duaFBmd3BPWU9mL3VXQUdPLy9UZ3RPRE00TFp3Wm5CbkdCdWNCYjcveWVEcDRLMTdQZlo2N1BUZjE0SlRWSVpHRWxOYWE2VklLM1JZSmlxUU5vbnpFclZnVXEzSU9rVFY4SW5ydUhpeEFYblVwRHdpYXRjdEltVVZwRFJIakRLcDVjS3RZR01UeStqZkhxcDhPa2w3ZFBMY0o5ZXluMXVTZmpja3ZDNUplRVRTNW4vazIxQXk1OVM0Qk5MeWllV0VUNnhsUG5Fa3ZLSlpZVDgvMEhCV0EwRGN0K3UwSEF3VlNrd1VlVndTZlNXOUpHZ1NSVWdxd3dZcjFFQW1RUE9wV0NPa0FMeE1lQjR5K0lpWmNFSWpRV2pWUTBxVkFQS05BNE1FMmR4ZUk0RUkxVUxrcFpkbFdVblRRQ05tZ2h5Um9NbWdXTUlHM2hpTWpoSmplQkxtZ0ptaUxNN2NjN3V4RG03RXo4V2ZFNmMzWWx6ZGllZHN6dHh6dTdFT2JzVFB3V2M2clA3TE0wQXAya21DSHlDUDEyelFNTG4rRE44anArdE00QTBHOVQ2VEgreDVnQnBMamhCWndINWxIK21UL21YaUZNK3hDbWZmRTc1eERubGs4NHBIOTRMd2RrKzVWOEN2c1FUblBMaDRaUlBuRk0rY1U3NXhEbmxVeEtuZkVyaWxFOUo4OEFvY2RhbnZLdEJ0VS84Ri9qRWZ5RzZmNjBrenYyVVBWODNFbDhJNnJRSWZGWTM2V2JKMm5tWmxnQlpSeS9YYlVEVzFEbENVOG05US9kSldnNm02MzU5Zy9oS2NLeTlCU2ZwSVhDeXZRVXo3QzM0a3IwRnB3aHZBWEc4QmFTdkFyTFBZS1o5QnFmcE1YQ0c4Qm5BOHpnWWJzL0JtZlljbkdQUHdWbkNjMEQ4T2ZCNTRUa2d2Z0hVYXlQNGd2MEg1OWwvY0lGZUFwY0kvd0h4bDhGWitpMm8xQmFRc2k5aGhuMEo1MFQvL2Z4VmNLNWVBMmZZbHpCYjI4Q0YyZzZPMFArbC8wZnl6SnpqbVRuUE0vTXF6OHdyeGN3a2habEpDak9UbEhZZ3ZRdU8wbDRnejlVdnF3UElNL1p5NW11QitBZmdNK29MaUFiOGRLSjlZaG44RUJOSnlRVTVUYk4vckNab0NDWkw5cEtWMjBzMklaZ2FORW4ya2swT3BnWFRKZnZLcGdUSEJzZEx0Z1dYQlo4SlRpYU9SU0ErTXppVk9IYUIrTm5CT1pLOUduT0RDNEpISkh2WUpnV1A0bUdUUFd4SDIzWjh4YlpEOW5sY2FndWlBTThIY1h5dWtpM0lWMndKWlcvSERIczdQbTlmM0RqNzRzYllGM2VjRWpyU0ZtV2kvV3RseEpKK24xN0xYUkFreVJjMDNIWmhtTzJDUFJXUzdVSmdENTFzQ3hKS1ROMFBqNXF1bkhhQ0d0RXhWaWRPblYzczMvTCtjcktkcnh2ZTROdkpSOWpwYmdic0s4SThZWmU5Njgzc3FQdTVQaDMrUG13R1hhWTE0VHFlV0FlMjhCUXJDTEh0YXVMNktQditFOGgvRER6SENmOUVkaTgvSmIwWi90V1V4Um9XcjJRRnh6czVIejFOam5FbzN2aXc0TDhvZTRkVnRabG50MUJ1THkzZHltcjJIdnVoZ3QveTkvb2MwODlaQXc4WmZYdVNaL2J4MUh0RDdCV1M5SHUzVDRIK1N3b2xmRjU0MmQ5cStBbkg1Qml0VmxYVWoyaE5scUNpYzV6UEVEenBVM0tLSzF5MHJ0T2NUb2xLSXAyZXNDSWp3eDNrRStPK2pid1BsUTdiQVYrelVtN0dKUjNrK3oyNHpFRS91dGw5Yi9TZFcrSlRUQzg4VWhxdWdVZ0NaZFlFMnFPRVc5Smk3MUhpd0wvRGMyNGZ0Tjk1WGVZZG9EejR1UFpHZGFCTEdoT05xSGNvSmpqcGExL1VCdmI3OEplNVhhbW9WUVdsSVRuRmUyckNQSEo3MDk5RGNXSjN5TGtOZEh1ZittOXd1YjkvOWUxTXZNdVMzSjYrb3RZT2NPMzBLTW10c2p6azNuUGZUUTNGNXkxaTVoSDF2MllwOHp6bHVWVGF1Q24rV3oxeVhLTnI5N2dSdHk0V3pFUGR2Z2V4ajRBNkl4MkIzek5pcC9scVNRT2d5MmlEOW5GdGorNDcwS2dCNTNlQXZPdHRSS2I3WFdKbXlDOFkzRXJtU3g5UGJWS2wrMXJtazRCYjcyc2xvTzNRUGs1aEtmZ2ovNGpIbFJGU0N2Z1oxWVRNcTFoV1NaZS8yekxwS1hvL25WYjhEWTFua0Z4dmxjdmpUaXJTOEhSOGdqVmZmSFp4ZlBDYlFVcG85ZE11WTVCZnRkWW50cjVJQXV6bmh6b3ZJTnQrZi91V2RybTBUaFdlTDFWK01oMDk1N0ZXaFJLUnRQYWpBWDMyWENhaDFJSDFjeCsvYlI2Y0ttdEY4ZmNIWVc5eDd1RHpiOXdLN0VpSlhNa2hMZWwzNVZ2QmxuQUhzZDJFbTRYVWl6M0M4VGdmZ20vWjExTGVlS3lzRngvVjEvM2tEN0pTUHI4eXE2Mjd6L0RzRHY4bnMzVWVuenhsdmtYT1c1RmwzSzFzdEQ3MGtMTU4yZzFoVmEzdFBXQW5vRWUySUdsaWxjUmxLMVNnMUg3NjNXbCtydFNFSDRlYW1UM2c5LzVXNzVYb1A3SWhOVnVadkxWanI3Mlg1UUNwRnRrNGJJWnJ4Q0s1QmUxZ0oveXZrZk40K0dPZSt4NS9lL29tTlczQkJzZFdpWnBlRGw4aHJaOG5kMHF5YjVEV2RFWjJhYlhrTmJYSGYwbDZPYnpONFgrblZLK3VmbjRkT3NtNE9xVWZlaUY4aWV2RzhIZGMyNzFDYi9MYXpDcEw3UzhUL2t3VHVkNk0zd1Bwa3JzQzJraWNiemk0ajBDZG5uc2VxYVRYR2J3NzhFU3dGMWlrQXZQNEpDc1J0NDVHc1c3YXVwUHhmb1MxOTE5b2VSNnVyY3lOZFVpbGs3UW5KV3gyS3hLcEN0ZGlLeGFFZjhNZE9lSDI0cjlyamVZeElUeHYwQS9tc2RmY0ZDV1c4OFJHWXZaVGs0YlZpUFFlVFZBdGJZOUFUaWQ2M21scm1nZjIxd3Z0b0lXN28vNjJlZnpRSGU2Nm83Lzk5VGVXYmxVN2ZMc1lpeGJxelB0YkdUbW5CL0o2b25xZWFITkxWZnBYR3ZFOVZ5RDJIa0lqMXZqL202U1VFUDUzLzZlOFNzdXptbmIxdTJicVVoWDUvakhhTzZpaGk1NEt5bmhscXFMR25VckhNekp2YWJSRnAwdGt3aFhFdm9uYW9yYlllcGxzdWFLY3RGZm1EcGVZcGlUQ2FFNTNIL2lWVFBUVnMrZVE1MkZMVkc4cS9ubzNhNW40S2EvUzdNZ0d5OFIxN0hTSnZ4UDk5dk1Wb01oYkc2L1hwZDhBN2ZYbzhVU1JCU3hEUDRsN0hlNWpmQWNBSlZ0cmtIYlJubzN4OTNxYWovU0Nma2JrdjVtUDUyS2ZTMDVIZVJYazVlbHpMN2s1ODNuUDZpdCtOL0NXclFFYUE5Y2IwUjZnQmI3dVdGTlpEWWJ3VDluVFNJdUJwYnJQYzhScnNHdjBPUEFqak9US1dzUW9rS3ZZZzNyZzN5UWorZDBlaDlpN0JPMW1mY2JLZ1pMWjVqWk85VldlTzBudjdBaHB0WjkxVzhpM0xEM2pmTi9qbldMR2ZFaURhNWNseTZ4bW5EcW83eDE2OUI2MXRsQVRNcUJ2K3ozYmVpM1RvZjFYSG9PbzNlMWVEN2E2WnNVV3VNOTNDVnNLOXdVdDhIb0p1Z250WVl4c2g2VUNGZXh4eVNrQlI4bzJrVlJOWVVkUkM1b1kyMDdTL0piVEhyK1RsU1ZNY2MweUw3RTFuay9UTGNHTW11alZOdTZQNVZxdkUxV0RsYzdCUDFPTjVPMkVMMFdNT0ttTnZHVjdncFBRRHdsL0dHTW52T2NveTlNNXl5SkRiSnozV3IrbjNHeThtc3Z4QXJRV0NYWXE1ZFpsYWRHTG1xUTY3UDVxMEJ0K2p4Z3JBZlJpK0FPZGpMMlpTS3ZhdWRzSjNtQlYrS0ZTcmtGSTlMV2k3L1d6bG85SE90YWlHdUJmSEdZZ0pBZ1VYeUh5TFhmZkVmTjlKM2UwTVh3bnRqcFYxaWpGSkZxN0s5ektTck9PSzEvU2M5MU1UajJvQXRuNHkxNW05a2YvaFpKYjNUMW9INWdjdEV2cDg3WEYzQWw0RXVZcXR4eGVkUHlBdlk0MWdka0gybFR0ZHRSelpxd0ZhYS9jdFJDbFdUK090NTZreFJVSlZpbmwxdWRrbSt2M1JlMnFKZTgxN2lnaGZNNVBUSWVhd2wzMFZxUTJjbCtQbmp5QkZOWXdtbXNCS3prNjh5aTF6QVMxUXNlaWNVajdCT1k0S1AzcXRCKzhqRDUxMCt0cy9FNmNQWjlQT3U5dzNZcm12a1dzaGJTMXlqRVRKZ0tSMHNzNHZrZitvM0xaVHNNMnhiSmxodHR1TmtkN3lCcEdMR3FGNTAycjY3TDBsSXAzNVp1Y1lqMk8xaDJGdTZJOTBHckpuSHdaSS9tcERHVnk0aTA2SzZ4Z3J2d0QxeFhlV2YyUTY5OGdTL1RUNXc5NzZLMWYvVWhUOXBxek55ejVKclViZXNUL2plTWR5aTlFcldJdHRhZmlNU3pWeXZCbjdGcGVDSCtKM0Zlb2x2YVVLMDN2MTRldk1YTmVJZlV1S2JJby9JZEFsK0VXS2h2cFlXZTA0OHh5UXM0QzY0bXlrQ1ZFbUNQTmNQL0loNnFVaTlkSzdLbjl3UlhpTHBwdHRWQ1ZtcUNjZFl0NzhaVDN6cDFoRzJUL2c2MXRQM3pIazFzYjYwa0traWtGUHVKdmpRRHRjMHU5V3pldjdMRVI1NGN0WGczMjJsdlFhRXVJdEwxRGpEd05MbjNRNmNTNnhnckJkU2ZVNHU4ak9La2VjTjdwakx3SUVSd2ZpTzd5d1B4Ty9ZT3Z1ODNUQmJaeDUyZExzTnNyY1R2b05OakxsNWJ2Y2VqOEdGOEQ5UXo5ZnhPb3A4WFcyOXB4a0ZLNjRwVjRSL1RHbWpUZ3ZVelVWL1NXR0hjbE1pbEVNZTgrWTVuc1Fvc3NDU1Y0cWhETk1wL01TKzJoNjNRYW9YYyt3TmVvdERycS9NLzlsVmdaVHc3YTAwVmZHeFhJWmU4VDFkWTFxTlNrdy9qcm84ajNzdFhlQyt3T1YrQjA3OGFjUW1uUmFZK3I0M0FEVG5LQU0yUEUxK0xyWnUrbjJzQkc4dHFVTVdlSC9VZVVCZlc3YmV6akFQVTdEc2poR3AwZXU2SVRlUDdRdjUyd3p5SFdrdEorWWx0MlJXZXIvY3l6b1grbnlTc0lmYS9YRlA4dllOSkFFL2NaUWxaVmtGT3RacXNwaHRTb0xIU2ExeFZpL29KWDNCOGY3dVh1Uk1JOGFVMmtRR0VYZkRsaTB3RzdGUFNvRmRvQnNNeGhDN1NEMnM0QlRab0pqMldpS29lc2JrYjhnek01eFB0UGJGZVVWMmJaMkZxQ3pYaUVPOG1ib29wb0QyR3VlTTB2bFovMTFWNno3WjRIdjR6bXRXZWR3K2dNT01pZWRFRXg0dkV1ZUkvYkV2TnZnb3FmYmZkMWwzV3NNL1FkTWZzR0hIZTVyclhjZHJUdjBQK0MybmFSZGJiSXgwTTVSWGR2VXhNOUhid3JPY0JMNDEyWCs5TWUyOThhNEhqSm5pM244U0VPNUxObVdqV09pNWpEaUwrcWFKZFhCZFU3RFI3ZmM3WG5wTlZndHRCVzdpVHZYakorU3RHNTZmQitwVDNIb3Fqc2tON3cxM3hVR2lqTnJSVWFESkVUclpWWlUyUEpYd0Y1SHh2OVYxRmljS0tsVUpONTA1REJUTjFsSGJGTWpEWjJpdktzUkhhUUl0bi9aMytaZy9qK2ZIS1BQZk1IKzZXd04xM2V5ZTJWZkFya3BBYXFiR01pbTB3c0dmWFhGR3QwdXFnKzdKcjVxeVh2dkhKRjMyMTV2d2VsaXY0S2FMZTF4WGJWZXVMOGVPZXFrcitITGp1MHJ5NkxmTUFKNjMyYXU3MCt5U2VCQ0tuQk5SMDQ2d2JOekVQNlQ0TzFRNzU5UWtKRGptblZFTjh4b2lYZXBiUkZzWjM2aEg5b2JhbStXQ3BLL0hVOW9TMUNqaDMybHhaWVE1OGd0aE4wVTZZSTJRTUMxb2dvdlFYYTZaeUM3em0vQWU3Q0FYTnNjMTZ6ZWZEdnNxZEVJeVN1TFpEZkZsb0cyRlYwYzAra0o2MmVUVHNqdEpYK1pkZWgvL3l1eExLSTltWlFkTjhKdlVqLzlublZiei9vZTZOZGtPMXJ1Tkhyd1NyNjFncmFyQUZ0MFg0T3J4MVhlNVNKUlYvdVFpMEFuenM1ZmhOR0NwNW9yaHVoRHYrTitGcVhWdkJNMlEzc1FlTHF2YXRsMmtHOHpXbS9CMXlqYitrNDEwZTllaS9xMVNIOHBhYlhIYy91VXB0aVg4bGFnSXhkWDdRL2llVTJ5T3NmUDQ5azRwM21vWDJCNUgxc1VlbXZPOVlXbDdmNVkzK2hYZjB4OXZaZHBhdEtGUE11R3RwemlOOHYxNnM4OHNsV2FocmhtMTQ3NjcyK1ZEbjBDa280Qy9JcDEwaVJCNUdUQWxsaXRqbitUdFA4WWQ0clRKNTRsclFha1FyOGRQeCtaNlAzYlR1aHJkUmZDK0wzUVpRUXZhOGtKM3NvWC9WNUxhaUoxdkFhNHJiMzBVaFhlMWZJR1pXU3hwU1Vsd1pTK1JBMWpQRmNLamxiRkhFMjZtQS9aQk5aNjVab1ZEcDh6eDNYcmFYTXRrcllIbVN5RGJSQVcyaFY2UzhiL3VtUVZzNVNqYStKL0tYbFhqL3RBNFdhWFNlcmovdnZONk1IK3h0a3FOZldZS3ZYZzU5NU50aFBMTVhuSFdhOU1rNDM1SnpvN2crQU8xdlpUa1lqeVpWVE92enRZTFBQeFR4TDNLZEZvNFZZQjlnZGVXK3d1SVNjTkVGck5HZktQOTUvWExBTUIrMTdmUWJjSHI0VHJiejdoL3pMZkkrRzF3dmdzdWhyMFQ0aUU0VkphK1B4SDIxZm90TnROclpXMUJhbEtQYU4xWmMrNnJOa0o4Z1RSdS9WaStwTlJpMXplYVJWSE5ydXpiM0lLZ0c4bXo5Z0w1WHc2Q2lhTDZtRG5iZ3RrenpVQ3hWaUcxc29saC9wMUViYTBEYldaeTIzeERiMjRQKzN6UHJodlpxMXBFQnNzRDB0LzArdHcwV3RqblM3Mi9leDlmVis5TTFES2ladHI1TWd2UEIrcDBZYXFBSlNwc2dMY2Z3QjhoeFRMTy9JdHFmcDRUYmI0WlJEUEM5Y2E3aGlZMTF1MHFucmJHTzM0SlBkQ25iNS9XbjhEUUFVK3dxaU50Q2FRNUJJTDAva0ZIL2w3dWY4YllsdDNPOG9IeHlDaFVwSGI0aTY0TXNTYm90a2tnVlJuMDNGY3ljNktaYklwTXI3WS9zbC9VVFNmeE5rbVpDM0JlNHFjM3MvYVZrODUvK3cvQnp5MmNIOW1xakZsa21KbjQwMDUxRHJYOSt4MGVxVTUyczVOVnNtOXRFODZUZkoxQThVWFEveS9ZSjNPVkY5OW92eEszMk9XZ3BEbjY4aXIxV21PTlc5TVgrMC82b2N0TzcwRlBsam1UdEljdEJvSGZMLytTcWU0VEZ2N0EvZEgvVTNIWGxNQi9zSzdKbTE5b3pXWkNCTlVaTUNUZE9KR3FhVE5ZTytuQXFxZEpwT1ozNmNyU3VSL1ZYZ2FIMVZYNFB2bTNwWXgrZ1JQYWF6OUZPdDF4ZTFVYi9WZGZwWGJkUE4vZ2J5RHI1ZGZFSDNVTWRGbWdJQ1RRWGxhZ0lKVFFOSmZ6MWNwbU5CUnNjQi9xNGNwSFNDdnpNL0VaVHJaSkRXS1dDa1BnY3FOQ051M3lpZEJpcDFPaGl0czBHVlBnOXFkUTRZb3krQThUb1hIS0V2Z3F6T0EyTjFQamhTRjRCcVhRaHFkQkVZcDR2QmVQRjlNTGxmMXFXVWN4bW8xbGZBVWJvY1ROQVZZS0t1QkRsTFpKSytDaHIwTlRDNTZLOTZBLzBYL1ovRXY2dC9wQzgvQU9YaWExM2lmSzFML0JFd3d0L3BadlFZcUVTT3Y2RDlUNElqdEFhTTBWTmFTNXp2ZEduRHM2Qld6NEVqeFhlNnhEZUNPbitobTlOdlFJTmVBclhhREJyME1xaldiNEcvemFVbHI0QWp0QldNMUt0Z2dsNERsWG9kak5ZMk1KbVIrNEt5d2JuQnVhb092aGg4VWVPRDg0THppSi9QaUk3MzE2akQvRFZxUGVYdDBUQXdWbVhnUGczM1Btb0VLRk1hM0tlUjRLdXFBRjlXQm96UUtEQk5sZUJlalFhM0NYdElmQXo0alArZVFQNG0vVlpOTUNZQ2ZKbGdmTkUzNlducjdFbzFndm5XclFYaW0zVGlhQlZ4dElyNHNlQjY4VTA2Y1RTSmRMNUpKMzRTV0dDdG1tK3R1dEZhdGRCYXRVZ3pRY0s2ZFpObWdhUTFiTEUxN0crTHZrbXYwSm5nRnMwQktjMEZueXY2SnYxbWErRjMvRTM2M2RhOHBVTHppS041cEY4QXZtM04rM3Qvay80ZDY5emY2Y3ZnYnZGTk9uRTBqemlhUi94eThKQTE3d0ZyM29PYUI3NW8vZnViNkQ4Y2ZCVjgzVnI0RFYwREx0YTE0QXBkQjI3UmZGQ3U2NEcwQUZUckJub3IzUVN1MUdMd0ZkMGNmNnUreEdqVXJlQU94ZCtxRXk0RlMwaTdVOUpkNEdUZERUNnJlNEIwTDdoVzk0RW1MUWRINjM0Z3JRQ1Q5UUNZb2dmQm5iUzY1QXQzUW1ZT3NiOEhDL3lGKzN6UG1ldkVuQ0hPbkNGOUZjaDU1dHpnbWJQSU0yZXhmZ0xtNjNGd21iOXd2OWxmdU4vdG1mTnRNWE9JTTNPb2g1bERmQU1ZNC9semorZlBnNTQvWC9mOCtZNllQOFJmQnQvMi9BbTBCWHpKczJpQlo5SGRua1UzZWhZOTVGbTAyTFBvYnoyTHZxSHRZRjdSRis2M3FSWGNyejFnaGI5d1g2NDJjTC8rQ0Zib0hiQmM3V0MwM2dWVjJnc3kramR3YjlFWDduZm9UK0JPZFdxZnBDNHdRLzhCWnFvYm5LcjN3U3oxZ05PMEg1eXVQNE16bEFlejlSZHdwbnJCSEJYQVhIMEF6bElmT0ZzZmdzK3JINXlqQWZBRmhlRGNRRUVnK1F2Nms0SmsvQlg4a3FLdjRKY1VmUVcvcE9ncitLVjhCVCtmK1BYQjlWaU5CY0VDalF4dUNHN1FxT0RHNEVaVkJndURoVG9pV0JRc1VrMXdVM0NUeGdXTGc4VTZNcmc1dUZtMXdTM0JMYW9MbGdSTGRGUndhM0NyNm9QYmd0czBNYmc5dUYyVGdxWEJValVFZHdSM2FHcXdMRmltNmNHZHdaMDZMcmdydUVzbkJIY0hkK3ZFNEo3Z0hwMFMzQnZjcS9PQys0TDdkSDZ3UEZpdUM0TDdnL3QxWWJBaVdLR0xnZ2NDemxqK0h4aGY4eGY2bC9vTC9kdjloZjdWL2tML1cvNUMveEovb2Y4dC8yK01hL3ozUHN1Q1o0Sm5KUC9WejEzK2J4bFgrY3Y5Mi8yM1A4djh0ejkzMldJdXNNWDhPMysvUDl6Zjc4dmY3eC8vL3dIVTNTSTNBQUFBZUFHTmxWdHdWVmNkeG4rL3ZjOGxoRk1JSWR4RENHbEFpc2hnUVp3cElRU0lGUlFPdDNDL05JRVFTczNOWEdvVWlyMVNXdkNHMVFMV3F2RlNyUlpyVmJRUDF1cFR4L0hKUngxNVVCK3NUbXhMVzYyMWltdk9PVTFPN0hsd3Z0bmZ0MmV0LzFwbnp6ci8rUzBFeWprWlFkUjg2NllXSm5XMkRYVFRSQUxnK25XcWdJZ0VLY29vSjhNa0txaWtpdW5NWkRiVjFGQkxIZlVzTEZvaE1VblNUR0FpTnpDWktVeGxHak9ZeFJ6bU1vLzUzTWdDM3NXaXRyYk9BYTdsL1VodzNuemIrNDlLM3R1N2U3cE01YjJqcisySW1ieDNIai9XNXVLOGQ0ZFZMaXY0WUZlZksvUGUwOWZlYlVQZSs4T3M2d3Ardkx2RERRWHZYL1plczZPKzNKWlJYK0crVVgrZnJhTyswbzVSZjcrZEJSODgzRy9mMjk3YjcxRGVCOEtuZUNydlFBUUlXSGliQ1VnWmNBTVRLR2NpbWZBMmljbFVNSVZLcGxMRk5FQm1BVElIa0RRZzB3R1pEVWdTa0dwQTVnSlNBOGc4UUdvQmlRRkpBSklDWkFZM3NzSHpVVWQwT2E0TldocHZqVS9GNXhLSlJFM2lsc1NleEZEaVV1SzV4SitTbWVUSzVPM0o4OGtYa20rbG5ra24wc1BwRGVHNWt2NVYrbXI2V2xtcXJBVUJLU05pbUt4M2VjcFAraE8vNmJlODIzdDh3bnNaOFZOKzJzLzRXVC9uajEzbXQvMk9oejFpdTBmdDhKaTNlOXc3L0lpZGR0bHRqNzErMUQ0SEhQUk9QK2FRSC9jVG52Qkp2K3YzUE8vbmZjUXYrRVdmOGxFdis2d1gvTDVQZTlGTGZzbkgvTEkvOEJrZjk0ZitpQkcvNGxlRGY4MWh2KzQza0N3cDBwVGwrak5UZE5aenFXRWV0Y3huTWN0cHBJbG1Qc0N0ZkpBTmJPUkRmSmhOYkNiTEZyYXlqZTNzb0lWZDdHWVBlOW5IZmc1d2tFTzBjb1IyanRMQk1ZN1RSVGM5OU5MUFhkekRSWjdsMS95VzMvRjdydklpZitHdmpJZ0xYT2k3WGVKN1hFcGNPRW01UW9ZYTZsbEdFMWtPY0FkRG5PWVJobm1heURaUGtuU3p1M25KKy9nN2FiUHU0WVQzOHc5WCtWTlNibkV2QXo3QUd6YVFjcXY3R1BRMC8zUTFLYmU1bjVkOWtEZHRKT1YyRC9DS1ovaVhhMGk1dzROYzh5SGVzb21VTFI3aVZSL20zNjRsNVU1djR6WFA4aC9Ya1hLWHJienVPYTY3bnNoK3J4QVI1d1JUcVVaMkJrMGtCVVNVVTBPTWNTT3lwSkF3bjVpSW1uZ3hNalAvVmhnWDJZOGtpRG1jTzdYRTZObTA1M0lDVlZSVHp4SlcwRUF6bTJoeEZURlZaR3dJT1MzazZwRFRRemFHbkJGeVRjaVpJWnRDemdxNU51VHNrT3RDemdtNVBtUTFHVVFtanZhMTBXbitPTmJsMFJEbHZNUUpCaGprWlY3aEdxL3lHcStQVlZETlJFYmNiTll0Ym5XYjI5MWhpenZkUllSVVVnMUZ1eSt5bVJTUXBJSTZWdERNUG1KQW1vbWp5cWd5Sk1UaG5RaHV4dkFBaFpwYUl2OFdIR0lpcjFLQjRRRVFxU1JHWDBDcUNway8zWmhLUmx4SXF2QVZNYURENks1Q3pmaVpNMFJlc0tIa1hDZXhKNE5xUzg1bVNYZ29wNmprL0ZLU051YkZIMHBXWkVoWmJVRThYNnFHUDVQbWpTSTlWckxxbDVUeG0zRzZzMlRkSlNidzVIaVJMVm5aU3psM3YwUDFSVjA4VXJSQ0twRkdRS0NPS0dna0NIZmJpdU1xcTVBYUhOMHJRcVlXT2tkaUluU3p1K0FkKzljVjc1OWY0MkZQVUU2RU5ITVFpbnAxRHpkNXNrRHR3R3Z2OVQ3djl3RlArNkJuZk1pSFBldTVNWDRYOGZkUkx4UlI5M0VEYTR0SWV4TnhnYldCc2t3cDNHYlRtY0ZNWmpHYk9WU1BVYmVJbXQzMEY3SHlSWEhCS0IvSHZub2hGYmtiNWduRFhWSzRHWjd5Y3U0bUNQelAwVjhxQ0pRUEhuaGVvSE1YUFRrYUJ3WVRDRnhFbFpXNVRKTEpjYVdPUlQ1SHpFWTIrZk5jYnZGblJHejArZUNiL0VYd0xZaHNMS0wyT3NxWlRRMTFMR1F4UzdtWmxkeENJN29LYlVCWG80M29HclFKWFl1dVE5ZWp5NGlJY3I4T3k0TW1qREdDbEdjUldUeHVyQTJSbmVQR0xpT09YNXY3UDZScTNOaEdSSHFMenJTZXliYVY1aFlYR1FtU3ljUlVsdnd2OXhONFVyUmJsbnAzdThlOTduTy9CenpvSVcrejlmKzQ5L3YvOStZZjYrTmM5NWIvRnljM2lEWUFBQUE9XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9zdHlsZXMvQ2lyY3VsYXJTdGQtTWVkaXVtSXRhbGljLndvZmZcbi8vIG1vZHVsZSBpZCA9IDYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///60\n");

/***/ }),
/* 61 */
/***/ (function(module, exports) {

eval("module.exports = \"data:application/font-woff;base64,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\"//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc3R5bGVzL0NpcmN1bGFyU3RkLUJsYWNrLndvZmY/YTM3ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTphcHBsaWNhdGlvbi9mb250LXdvZmY7YmFzZTY0LGQwOUdSazlVVkU4QUFLRnNBQXdBQUFBQkllQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCRFJrWWdBQUFNd0FBQVhCWUFBRzJWaEg5TnJVUlRTVWNBQUdqWUFBQUFDQUFBQUFnQUFBQUNSMUJQVXdBQWFPQUFBRExJQUFDVGdPa2NxWHRIVTFWQ0FBQ2JxQUFBQmNFQUFBc2d5c0hRMkU5VEx6SUFBQUY0QUFBQVdRQUFBR0JSQkZPWFkyMWhjQUFBQmFnQUFBTG9BQUFFWGh3VTNOWm9aV0ZrQUFBQkhBQUFBRFFBQUFBMkFCNHNCR2hvWldFQUFBRlFBQUFBSUFBQUFDUUoxZ2J1YUcxMGVBQUFDSkFBQUFRWkFBQUhZQlN6Uk41dFlYaHdBQUFCY0FBQUFBWUFBQUFHQWRoUUFHNWhiV1VBQUFIVUFBQUQxQUFBQ0M3MDFPNHJjRzl6ZEFBQURLd0FBQUFUQUFBQUlQOW9BRkI0QVdOZ1pHQUFZcWY1NWJKUzhmdzJYeG1ZbVY4d0FNSFpucXAvRURybjgvOGovNzZ3YVRIL0JITFpHWmhBb2dCN0lBNlNlQUZqWUdSZ1lINzY3d3NEQTF2dy95UC96N0ZwQVVWUUFPTU5BTE5XQjg4QUFGQUFBZGdBQUhnQlkyQmhzbUp1WVdBRjBsMU1FUXdNRE40UW1qR09JWUJSaTRHQmladUxoWWtSQ0pnYUdCajBBeGllVkFQVmNEQUFnWTlmaUQ4RFVQRGZmMmJOLzQ0TUo1aWZNdklvQURXQzVCZy9NaDBGVWdvTTNBQ0FUQTh6QUFBQWVBR1ZsRDF2WkxVWHhwK1p6ZnNtKy84dlVsYlFvRU9nSXJzM2sxblJaQ25ZSkVxYXFYYWpMUkdlYTk4Wks3NzJsVjh5bVMyb0tXbHArQjcwaUo0UzhWMFF6cEYxR1cwaUljYk56OGZIajU4NVByNEFEZ1kvWXdEdzcrdkJWZUVCZHZGVjRTSFdNU3I4Q0lTZkNxL2hvejVuSFovZ3N2QUdudUtMd3B2NEROOFgzc0pHdjNjYi84Tis0Y2VaL2l5OGk4OTczaHVjRDM4dC9BUkhqLzRvdkw5eTdqTnNzcXZCMmphQTIrR2s4Q0E3K0t2d01PL2VMUHdJM3d4K0s3eUdBL3hTZUIzandVSGhqWlg0Sms0SFB4YmV3bTYvZHh1ZjRydkNqL0hsY0tQd0xpNTYzaHYrc0xaVitBbSszUmdYL2o4KzdyMDl4UTUrTDd5LzR2a1pzdWMzYXBhTThIZ0RoUmtTREFUOFJDU3Y3SHM2OWNsYTVjKzByKytTM2tiNTR0U0krcm9FUE9VSWNlU2Q4a0U3UzhmVmFIVDhpcVpKRzBtajBXaU1DUVFTUEJRczNvTndtamxsdGxEb2xVa0hFaFM5a0tvVi9wcGNReE50VlhRbjFLZjBwNS9RZUhUOEVtZlE4S2hSUE9NdElpUmU0SlRuTmE3bk1YWW5SMGVMeGFJeUxGYlZyajI2bXF2RGN4WDB6R2JMOTBTb3lCQjZHYnlEZ2tlQWhvTUY0UmdWUm5rYzR4VUlVeVJvR040ejRqRytWRmxiUkNWSlcvWksweVZkT0Jzbllwci9ScExhVlhUbXVxWFhzM25NU1kyalRsbXA3YXg2d0pGR0FHVW1SSGdJU0NpMHZIWU5na01Ed2dTYUt4cmhjQUs2cjNLL1BKdzM1di94RW5QRVBMb2NPOHBqd2FPQ1dWR3RVTU9oemF0WG1FUGhFT2RRWEpVWmJLblFKVlJoZ1FnRkNXS0YvaHl1MXhLRUM2NWw1TzZZRm5jSmttdGNzWCtIRGt0NDFzL3VpbElEbDZuamN5UkhacWdtWXRFa1F5bW91OGFKYzBXTnN6R1E4enlSSWdxcWMwUm9xeVF0ZEp4cjI2ZFJvNDBLcEc1cmsyU0cxa25kTFBOVlBDZXZSQWlxblpveXM2SmxDdEg1RE9Rc2RTbXYxbVpKNGtab0k2WkdVVkQrUnZsd3QwSHFFUFUwUmM0V1Z1WTFZekpYOU5vdUtWbnpnWEVkS0M0N04vT2ltK3VhZ212aVFuaVZMUnREVTBXZGQwSFZLU3BaNVg3eUpLVFVVVHNyRERlUmI4WGRqSUpTZXpzUGQvL2tIN3hyeU1PSnJwVU4yUkxmeEFJTmR3d2hJVUQxM1JVeDUxbFRiaTN3aWw5WmtYempJbE5kY2tUcEhRbkNBcG96YytTK0dwT0dnV0pkaFZ2VU1FaVFKZExDOFYwM1dKWWJmdzZDaDRKQVlKOHRwakFmckZrSXRDdXh3RjNzUzRUS1crNlF5dDRhaGp0VDRBYUMvUWhlVWJ4WHdlYzRkM2wvZ29SbVZjM2ZnTGlpTFdBaHl6N1RPNnRBZUEzTHB5UlltSCtwdUVaZ1dxS0R3NHhmVmNmeEdvVEFtUkVMZnQrcVZObXcxcFRuSFR3Y3E5Wkk1VDFXNWUxNWRpbjVQOFR5WlJNd0s2L01vNFhvMTRoMUZQYXc4NSsrRlpPSG92M3JQK1QxbW04cmdLdjBON2Z0clgxNEFjM082MitUVlFDQThlZTg3K3l3RTNCMFV6YnJPT2V3dHdVR0ZWUVU1cFU2WmFoVEIvT0d0NklRaEtLQ0dBUURXT1lOOE1ZRThZb0J4RXNSRlFRdkNCcGQwcEloWGhCTmhMcWVvL051OUp1SkNlbGVtOGIwSC9DTFQvSjgvd0h1djRjUkFFNEhMZ0lJVStGTUFGYVRJa0FRR01oeWZERk94TVUwTVVNc0ZzdkZFODQrcDhmcGRkZTVhWGV2KzVFY0lLdGtqYXlYRFZMTGlCd3JtMlZjdHNoMk9WOHVrYXZrTmhWU1drWFVISFdIV3F1ZVVXbTFTMlcxb3dONnNCNmlhM1c5YnRCTnVsVW45Q3lkYWN4NG03eWQzaWZlNTVGWU5CU3RqYTYwenRHS2Z0LzNvV1NSYkN4YUpvbXBJbEcwTEN0YXNrWExOMlZMWmRFU2trTmxXTXFTWldMWmNwZE1sUzBKTlUrdFVldUxsdTFsUzNYUlVsZTJ6Q3haTm5wdmVmdkxscFRsS0NXTDhQL3krL3h1djh2djlCZjZzLzEydjgxdjdxL3NEeFQrTHNRTHNVSzRVR2NQMllOMnY5MW5zelpqdSsxdXU4TnV0V203d2Q1cmw5cEZ0c1A4YWF6cE5Wdk1adE5wVW1hQlNacnBacGdKbXhvVE10Vm1rS25LKy9tKy9JRjhUMzd1dDhsY1YyNUZMcG03TlJjOEVqbmlIZDZqV2dLVG5UWUUvNThDVGhCQThKOVZMaFVjUTRCS0JuQXNRYW80am9FTVlqREhVODBRUXRSUXl3bWN5RkRxcU9ja3dweE1BOE9RS0RURGFjUWpRcFFSakdRVVRZeG1EREZPWVN6ak9KWFRPSjN4bk1HWlRHQWl6WnpGMlp6RHVaekgrVXdpemdXMGNDRVhNWmxXcG5BeGwzQXBiVnpHNVZ4Qk8xT1pSZ2RYY2hWWGN3M1hNcDNydUo0YnVKR2JTREFEZUpDSFdNWERyT1ZwWHVCRk5yT0ZsM21KVjBqekdsdlp4dXU4eVJ0c1p3YzdlWnRkdk1ON3ZNdGU5dkFCSC9JamR6S1RXY3poWnhhemlma2toY01pNW9yUnJPUlpNWktGWW95SU1adTdoUktOWWppSHhTam1zVlM0dk1yN3JPQVdiaGNqT0NDYWhPWTJsdkVMTjlQSkF6eEZoaXk5NVBtZVBneVczV0k4SDlQREh3Sis0M2ZSS3Fid0UwdjRqaC80bGZ0NWhQdDRsTlU4emhxNmVJd25XUStzNDNrMjhCemRmTXBYTE9BTER2SWw5L0ExaC9qc0gxQjdBaGg0QVoyVmE0aVVaUlRILytlOHM2THJvcU91cys3VTdnek9idHZNTnF1amt6dWJqdGpPNU5qYWlMcUsyRTB0akM1VW9KSUVJa2phQmFLZzdFdEJxRUVVb29GRjBvZENNUWdMTTVTTUxuU3hJQ01sVnFGN1REOWZaa3NYSmVqRGovOXpmNTQ1LzNQZThVR1ZKRWsvQTloS0xiVWRTdmdwZGZveXBZTzcxZVdmcUYvZktHRXIxQW15bzJyMkZlcXg2OVZuanlwckZSWHRKOGszTUw5VFU3MkwvU21OOXRWb1ZuRmZ3Rm11QmkrcXcyL2tuSDdXbCtBM3BYeVZDbWpDNDBvRXM1bi9VbzErajZwQmhQWUpWYjBDQmZyTjlJZFV0VDdSNS83RDZDekczd2FETlBOcjY3cUJ1VFhjKzdBbStRRlYvQjAxUnNacnJPK252NVB6dDZyREZuTFdrSVEyZUl1YTNPU1cxMlNmeWxzZlVNbHp2R2tkVE9POTk3RjNsWkpPckt4TnM2eTk5cTNQbzkydVVyQ050WU93aUxYc2c0UTl5OXd4eFcweis1WnBMdTlzREFacFh3MzlHbVUvY1A4VzR0YWlLdHJnVmNYQzJNOVd2NmU1ZjdFS2pDVjhveVliYTd4YjE5a3V4WUlzKzE3V0RMOUtjVi9CZm1JZmpnMG9aZzlwb3Q5R1RKL1VkSHRCMDJ5R1luNjd5cjZYdVU1ODZ1YXNtVXJhU2ZXeVB4ck1VaVpZQXR0WWU0NTNFZmRMRWNtck1mUUNIeTdFK21vZldsK29uOE1wLzBYamgzMFlpWmZyaWhjWEVucHhCK2ZkcVZJWTkwc1EzSVhtaEE4WFkyMjFEL0NpaEo2QXIzd2g0OE0rakdTNWVrTEZpNHZBaTlBejFOclFwUnBudDJoYzVGYmUreXJyeVNIRHgzOXlCdDk4UXUya3ZhaFl5QUJzVWt5SDFXVE42QmVhWkU5cGdqMVBuaDJVZ2xIS2hoNDhvU1E1S2F0SWt1U2JWWXpNVUVWRFNneGpoK0JBbmQxcXQrUDQzS2g4c0YzbENEVm9KY1VoR2xTb0w4Nnh2VXJaZnJ4N0U1NkRsK3I2aW1hRzdmMlFWN0tlRDVkZDU3dFVaRzA4MktEVStmZmFHWEtpVlpsSU4xeExPNFBtbEdrb0t6TnFrUGFWakUxU3hyZkQ5L0FqWXhPaFVEdHJ2K3FLeU0zazJlbmEyZUIrM2VCbmF1OEdTMW56blpMQnZiV3ZBL0xQLytTZU1iV2hZQ1cxTTBYekludFl0NDV4NHVWN1ZQWFp0SmVveHo2U2pMejE5NVVJRmlsdDY5UkFEU2FnNENubG9XRE1uODkvY25oTlNFVUs1a3YrT0wrblE4bVFhNWpmUVgyZkMzTSsvVi80ZTdVemtiWHNPMEI3SDNYeENHelYyT0FJSE5WWVNRcGpXeHdSMjJmK3Z3ZktTVVpkMis5YWJFZlVhMy9CSWZyTDRUanQwNHduWVlubTIyZG9WSXY5RUhvYXFPZHczeDlvTC9vMHVrQXBPNEh1VnJOdlVpdmF5dDJUdWJPWE9oRTBRaGUwMVBWMWVBUGFZQUNtUVd1OW40TU9tQUxka0lDMzZsUWdDMVVvd2h4b2h5YnE3U1kwQ1hub2dqUUVvRG90MEFQZDBBeFpXQWdEVmxZbktQeHY0V3hvQ0wrWFc5QzVLanZmUDJNT2pmcG94ZmlOY3lMVGljMXdqWXpodmV1VnVCejJta3ArVEhrN1MwM3ZVVXlmd3Nkd2tIZnYrOWZyWWU5dE5XeWt4clBjZjFSUld5VGFqTzNRK0pBSEZRMi9BVGxZRDQrcGlUUEQ4LzRHbkhNd3pRQUFBSGdCWTJCbUFJUC9xUXdCREZnQUFDZ0lBYmdBZUFHZHZIZGNGTW56TUR6TE1qUFFnNk95em9LN3pveVl5QWlJZ2pubm5BRlJRVElTSk8wYVVGSFBMT1ljUVVWUmxLUWlpaWptbk1ONXAyYzZQWE04dlJwcy9QN2VubDN2KzN1ZTk2LzM4MzZVcmc1Vk5kM1ZOYk5kM1ZXdG9XeHRLSTFHNDlnOVBpMHlNekVpYlhoR2xIZTN4SWpJaVdxdHYxS1BxdUZ0YW5pdG9yUEZveDIwRHh4c0IrTmNrYUlZais4NU5JSE80WFhQRURBdXk1R2tEZS9XcDc0U2RoUkQxYUVhVUVhcUNlVk8rVktCVkZ1cUM5V2JHa1NOcE1Lb1NDcUJTcVVtVXpPcGVWUU90WnJhUkcybjlsQWwxR0hxT0hXV3VrTGRwbjZsSGxGL1VtK296NVJDL1krRzBkVFJOTkFZTlUwMDdocGZUYUNtazZhblpwQm1wR2E4Sms2VG9qRnBwbXQrMFN6V3JOUnMwT1JxZG11S05JYzAxWnF6bWl1YXU1cUhtajgxYnpSZk5OOXRhSnM2Tm5xYkpqYnVOcjQyYlcwNjIvU3lHV2d6d2liVUp0d20xaWJaSnRNbXkyYU96U0tiRlRicmJiYlo3TExaYjNQUXB0TG1sTTFGbXhzMnY5bzhzbmxoODhIbUg1di9hTzIwOWJVR2JST3RsN2FOdHJPMmozYUlObGc3UVR0Um02SE4wczdUTHRkdTBPN1E3dEVXYXc5cEs3VW50ZWUxVjdXM3RiOXBIMnRmYU45cVAydEIrOE5XYTJ0dlc5ZFdzRFhhdXRpNjJucmJ0ckp0YTl2WnRyZnRDTnV4dHJHMnliWW0yNW0yODJ5WDJLNjAzV2liWjF0Z1cyUmJibnZjOXF6dFZkdmZiSi9ZdnJMOVlsdEQyOUoxYVlHV2FTODZpTzVPRDZCSDB1UHBlTnBNejZEbjBhdnBiWFFoZlpTK1FQOUtQNk8vTUZxbVB0T1lhY2wwWlFZeTRVd3FrOFhNWnpZdys1Z3lwb0k1elZ4akhqR3ZHV0ExTE1zS3JNaDZzYTNaTG14ZmRnQTdsQjNGaHJCaDdFUjJPanVYWGM1dVlQUFlJcmFjUGM1ZVltK3l2N0d2Mks5MnRuWjZuK1RNeE1UTTVIaGZYOThlRnREVjF3b3NKZi91YlZYUXFtMkFCWFMxbHJwMW54UlBNdjYrdm9GV0VHUUYzU3dnd044Q1d2dFpRS0N2RlFSWVFXc3JhR01GZ1ZZUVpBVnRMU0RJMXdyOHJNRGZDbHBaUVlBVnRMYUNObFlRYUFWQlZ0QzJaMlphaXByMTgyczFPQ2s2TnNLU2IrTnJCWDVXNEc4RnJhd2d3QXBhVzBFYkt3aTBnaUFyYUdzRjNhMmdoeFgwdElKZUVXbHBLZWJFNkpnTVN5WnprZ1dreGNmR1dTdWlVc3pKRnN5MmJhd2cwQXFDck1ES3Vxc1ZkUE8xQWo4cjhMZUNWbFpnN1dmM051UUJHZkVSaVZIeE1URTlvaE16SWlhbHBVUmxSbWFrWnlZbFJXVEVwMWdlNXUvWDJncmFwa1ZFeFVkR0pNWW54OFFueDJkTWlVL09pSTVOaTBpTW1FVElKa2VuWmtZa0pxZGtXR0JpZEhxNkpST2JGaDJSRVoxbXlVZWxaQkN1Y1NxemdPNnRZK0lKVnRTRWxNbDkvTW1NdGNwSWk0K0l6WnlrTnJidTFpb3haV3AwY214MEpQa01KVWIzOFF0cTNjclM4VGIrRmtFRityV3lndFlXUU9iWkF2eXN3TjhLV2xsQmdCWDh4R3hqQllGV29JcXRKMUZYcTB4YVcwc3FlYTl1cE5JQ1dsbEJnQXA2OXVvMU5Ub3RoZWg1VWxwS2NyUUZacGhUckRBdUxkcGFFNU9TbVdiTnhKdXNOZW54azYwdzJoU2RiTWxGcXpOcXlTWEgvMlJrNFJ5Vm5KSkVPRnNnNFd5RmhMTzFSdVZzelJET2xnemhiSVVXem1yT3lsbk5xWnl0alpNaUlxTjlZdElpSWlOOFV0S2lraWRZMGtoTEdtVkpveTFwakNXTnRhUnhsalRla2laWTBvbVdOTkdTSmxuU1pFdWFZa2tuV2RKVVM1cG1TZE10YVlZbHpiU2tKa3RxdHFTVExla1VTenJWa2xwN21SRkRaREVobW9nc05wa1VvbElTeVk4UXlVeUtUb3VNSnR4SUxqRXpuWURJRktLaDFvYjRsQ2lTVWVWSEFKRWVTWW5zU0dxUkhJRVd1UkZBcEVZQWtSbEpMUklqMENJdkFpM1NVdGttcGlSYm1wUGkvODJydWt5QVJZVUovS25SSlBlelIrbWtSTjZKV0xVbU15MHRPamx5Q3NsT2liYnlpY3lJdDNKSmlZMlB0THdnUHdlUkZKOXNHVWxTWm1KRy9LUkVsU1lxM2hRZnBYYURZS2ZGcTFRL3Y0My96UVZaaDV3Umw1S1pIcEdzamx2OVJoSHdMN2YvNDEwa3BYOWZ4NStqK0g4TjRkL2lwQWpTYWZXajR4TVprUjV0S2FtZkhHc3hic3FrT0RJVU5UdUJxTkRFNkF3cjV2K1dmK0wrcklqK3Y1cWovN2N4ZW5Ka1lrU1MrZ1d6RkdNejFmYy9LZVYvMmYzOHNmaS9XLzlMVHpvYm5hN0s4cjhjb3BPakl0TGpyTm1rbjFrclpUcVpqVVNWNy85ZDg3KzhldnVrcC92NlJhaXBmd1Q1aEptaXJkbUl5TXlNbjFuMTA1T1pSTVEyMlZyT2lFK00rdGtVRlU5a2x4NmZiaTJsRWRhV1hKcWF0b3BJSXZOam1SdFNDaURxcU1MV2FkR3g4ZW1xeUMzVmJTSWowb2hTUkNSbXFHcE1ua28weVpyTnlFeExqaGtmUS82UGoxZVRSQXRNL084VGs2MC9BLzhXTXlOLzFsakdRSXIvUjB0U1JDUjVDTWxZQmtYZy80NUlMVVJZR3lla1JWc0pVektzM1NCNWRVUUVXRVpNSVBsZ3gwYWtaU1lsUm1TcXJmL3RPOGxuSmtlUkYvTi94L0R2c3JFeFdUYzJ0cTRiYjZrcndJNVVCaldMV2tmOXBySFZkTlQwMW9Sb3pHU2xkazV6azZ6SVBtbitZMk5qNDJEVDBLYU56V2Fid3paWGJlN1pmTFpSdElpc3JWeTFNN1EzdEU5c3ZjaWFhQnRaQVgyeS9VNTNva2ZUa1hRQ2JhSUw2R3F5dHZtTi9vdCtUMlBHbnRFeHpjanFwZ05aMy9SbUpqTlp6RnhtTWJPVDJjTWNaYzR3VjVsZm1lZk1lK1p2cG9adHpEWmwvZGxBdGh2Ym42eHR6T3dXZGdkYnlwNWdmMmVmcy8rdzMrMDBkclJkVTdzdWRuM3NCdG9OczB1Mm0ySzMwRzZuWGFIZEFic0t1MU4ybCsxdTJiMngrMmIzUC9hMHZZTjlmWHRuK3hiMnZ2WkI5ajNzQjlvUHR3KzJUN1RQc0o5aC80djlJdnMxOXB2czgreno3US9aVjltZnRiOXFmOXYrVi90WDlsL3N3UjRqRGhtUkoycUpPcUZlYURBS1JoRW9EcVVnRTVxR1pxSWN0Qnl0UXV0UlBpcERKOUFWOUJ0Nmp0NmhyNmdHL2VBMEhNM3huSUZyenZseEhibSszR0J1QkJmS2plUGl1UXh1SnJlUVc4bHQ0SEs1M1Z3aGQ0Zzd3VjNrYm5OL2NFKzVGOXdIRGh3b0Izc0hSd2VqUXpNSGI0YzJEcDBkZWprTWNCam1FT3d3MW1HQ1F3d0k4eEhVaFFiUUN2ejlSZXlQVytHNm9JUFdVcXZmRUxURjdTQUN3cUVkdENOcE9DbTF4K0U0QXJmRkJFcGMvTElwUytaTElES0xscy9iVjJhQStlem5JUzl3YTl5aXIzZVB1Ukk0VDZKTGxoWVVWeHNyZDZZbFQ1MDlZOUo4R2R0SGlGeExFUWN0RWlKUW90Z084Y0t3RVFjZkRVUnlLelFSZ1E5bVFZUGRaVTZZdldmdjNEMUdjSGo5RzhoZmVsMzNkaDAwckVPbmExRlhDdmV1MlpJckQ4c2FsUlZpek1oWXRuS2FEQjNBVzBnMVQwMU5OVy9PMzdGdFMzNyt0aW5wRWk4OFBWWng1ZUx4Y2EwRFI0OFpOQ0M0Nmc4Skp1TmhnaWxuVWs2Mk5GMWN1NkR3aUVIeHdxN0RXRTdvcy9MaXFLZkdUNmN1M0xrWGNyaDlhc292TTZiSzYwN1EwUFlGbnNhTXg4TmVwdExyMW01ZXRkVllrRHQ5WXRya3JFbko2VnQyTFpUNU9hS3VwQW5TM1pndGh1OUxLQy9mdjYrOFBINS9lSGhDUEpHTkFOMTZnUGJXdVNkRElCN1hZWEFRSGtSRHQwbUNML1BYWjVwVGp1bmRFS2NreElqUUhieGdFSGpyUHNDK21rbkNMd2dHMWRMZ3JjekZMOHZadHFoNFhjRjFKRUhkaitMeU5LTXlJVWdJUFJCNXJLcnN3REZKOTZncXFpd2tORElxUk9KeG5iNWlCOXpnOTc2SWcrZ0pRc1RVbmZsRk96WVdMcGRmYjZRejJVNWpNOGRKbktQdWlZZkk5VVBZemFXdnU1dkxWWENUT0tPWHlBMUhOOEhaUjlUVjQ2QXVib0JiazM5MXNZNXIxb1R4S0p6by9UNWhTTkNESVJjZlh3eDhjRzd3b3cvN0VsNTdUQ1RkZHhhR0w1bFVYR2JZWDFCODhtUkJiSHhVYXV5d1JSTGViYXY3TWlEaFVObUJQZVZYciswSmo0eEtpT2d2NHdhMjRQYmxQakRYd2kvMzNpWHIzbDNiVVhqdHVBRTA3cjlqRjl6WXZRUFdCTy90Y3kxZDBuM3RQU21pZng4RFpyNTBBbGN5aGZpS0QvUm1GbVBiRnRtNHV3UU96RVpvKyt6Ui9nSTdYamh6NVd3L0dsd1lYQStjYWR5Y3dmd1prVXNTRTVhbEdYOUJYUEtpbVZtWnhpbFQxNnd6eStzeU05WW1HZ2VFVEdndFp6eGxPUmdBT2MxRkR1cE5CeWRNWGtuWUJQWUVPbk43bHF4ZnY4MjRkWFAyckczeXpPM2JzL2NZcnh3OTlLZk0xeXh1STNMQ282dyszM0JQSTI2RWtUYzJOTG5USGh3eTVIZFQ2S096QzFKakRlT2prd1o2akQ5elphNkVtOGZScm1zZVl4MEVHNkhqSzZCQis2bm5NMnpjS1h0dG9VTlhtM2J1TjVTVmxweDd1bXQ0d25LSjN5TU1teG1lbldGTVRWKzYzQ3hqSjNaVzRaWjVWY1kvWGxVQ3UxMityK2hvYUFTTzJJWlpWVWFmWFZlK1pyc3hmOXVDZWJreTZObTFFN09XaHhpRFdvWmlKa09lMnBiR0NEdStZdmdTRUlVT2w3cUQ1bXJsN2tQNUVxYzBGT2F2WDdoaHZlSGtua01YemhiRVRnZzNUd3BPa2x3RzBwanJGZStPT1lNeUM1eHhOYk42NjZiMVc5ZEIzVHZPajQ1VjNIaHNBTHVXNzdBNzlnMW9pdTNNUzFPWHpwSDRwYXZXTGxsbHpGcy9jOGJVNmJQVFk5TzJiOHlTdzRiUTZWc3FFODhhUCt5dnJxaUtMaDZTUTE3ZUVjdXFXb0N2RVJwZWVmVGtUc2pGWnJseTMvVjA1cktwNjNJTitUczNGeHpKVFVsWUpvSGpkdnJzdkpBWHVKa1JhOXQzOWUxNWFQQzNEUG5NRExwa3pycXNLWWJNeWFZb2lWc01Ub29UT0drNEdDZzBYL1hCRFpvWm9jMUxvS0FPTlBhOWp4dkdqSm1SbVNibkEwOURMampYMW1HNjRSZExGNEl4Zk9taWh0czI3YzA3YkR4eExMSGZrUEZ4by9wSEg2MWFJUE81Sm9XR0JsOUJ6MEdSc0dwajNzcGM0NUhLMUlGallpY01HalNoNHN4Q0dYdWwwRmk3NXEwSGVCb2g0TTNmd0lLMjdRUFhsVElFUUQwYStObzQ3QXc3V0J5QW5XaCsyL3JWNnpkc25KMjlSVnErZ0o2Umx6OXpyL0hVc1pJN01wZHF4QTU5UmR5OW5LM2llblhFakJ6T0NiZ1QweEo3MGxDSDRVeFEvaG5hZmQ2RllLN1NTSWlPMlhYNlRFbCs2U3NrUTY1dDA3YWRNSVUxZjNUKysrOC9mZ1VOVUczdk41VjVhQTI4NVNQZHlsL0VyY2cvM3ZLUjVvUVVoRjBpRWZkZEp3Uk1aM1ROZWlLZGMyOVJkNW9UMmpBNlJ5cEkxRGxRN1VXb2hQcE5pUmFYTEMwOGV0bDRPMzlzTkprbVpVeU5TR09CcVEzOUlkS2tlMzJacHRoNWpjamhZY0hpelozaWZRalEzWmdyNmhwelE1QnVYMnVrUzV5SE9NY1M4Q0QvM0hBamFNUlZqRVBqdUZ4VFRZaVp3NTdsZFBEMDBMYTRydEhGL1Q0MEJQZC9ycitCK2hWQm9XdGxjRDlLZjg3d0JoSEhHM0VvN29BOWNDb25kRWI4K1AxaFlud2MrVFFsSEI0dGp1ZHFSZ3RBcXdKcXpvQXRlTktZWm5wMjczR2I1cjdYSFM1eWI4am9XL3E5Y0lTWllLdTdBVDRjczJScHp2WmNBd1J3VStpMk0vdUZ0REp3azhRaWNDNUZwTXNQRnBOZU5nSVpqT0RPUVpCMjd4MmhGK0o2aW5PdWlTUmRRVktsbjREclFVOXNSL2phUVMrb2gzdUJQVzZBN1ZuY0UrOGliWW9aNnJGOEM4VFBVNlZ4Qy94aEVmZ1Qxby9SR0pGN0RoRi9hWTRlRktHV2d6SFFFWnBEQmtmUVYwN25oUDI1dVhzS2NrM3hFMDJaeVVtbTNIMlN0NzdqNVlFUGZyOXkvc0dEZmhjN2R1ZzdzTDNFUVdQTlh2RFV3akhGVGppM0p6YWFTS25SUWZwNVp2dkhXRFRpRnRnT2EzQkxEczVsWlNIT2RPc0p4SnMxa0FwYTdWRU9PMzFnb0Y2dEU0M1RzUk1IS1ZBcVZCV1dWSjNLandtVmRvbkRuK1A2d1lNeXdpWkozUGg5Q1JXanhYRnJFRGYwV01pNWMxVlZaOCtGSEJzeUpEUjBpTVE5bTRPNFF3ak00TXJsVGtiY1RpRi8rcW9wR1lZcE03Tm16SlNhbjZSVE4veXlhYWRoODVxTkc5WkxQQ3dRbFA0NGpZYkdMRDRJTWh3RWtRYUpyZTJQTTJoK0I4SXlIa1h6NWVKbXhFRUxaaEVIbnZnZkZyNG92alMwcUQySVBlRUJpOS9VZXREWWkrVmZ3WWdYR2xoeVRqeEtlbzZIQ1RDRlRkbGVtWGw1RnFHdFZlZGpHQjRORFdBMERDWHpNUlJHay9rWXpmSnpjckp6eU9kSFdKU3pjTVZxQTRlVEo0c2N6TkxYaE9DQWNrSTRkaHI0S2xmTlJLYXdHQnB6ck1JcC9ZV2dVUk1HRHhsMTZJOUgxUWZPbmErT0RDTERlTGtLS1hQdzJGV0lWMzlFSzZzT0hEakdtUlRack9HNml6VlR3STg3aU1DTEF5OElKT0J3U3VFbWNWZlJNcnZyYk45NUhLWmgrbFVScGk5RTA5RGhmV0llZVQ2SE81cWdOelNDeGR5YjlxYkt0MHZOamh4NFh3ZHZqZ1lqdzBFQ05BVWpwSkJoTm9WR09GN0dhemlUZUJnOGl4RlhGVmtXTXNieXU5MUhMRnVYejhGKzhqWndJYk5telYrMFVGcDZSSldOZmpiaXpvcncyY3dKUTVBNmxZY3I5dTg3WEJGZk5HNDhtVkM1TXBYVzVacTR2ZUFHNDhnY21xRGdsUVl3Rnh3WEZ5Rng0T3pJL1lZTmU2U0FyWFRVYW5QdUxrUGhiZzZYZ1JkY1lVSER3ZTNsSnU0YUdlSW5xRDhjNnE4QlI1STY2bkk1akRBTE5GUkNQVGdLdElaN1NiQ2Y5OGROY0JQL0FWZ2prNGwxNU5pQmtlWVlLUWJUQnhpbzh6djNpL2c3ZUo1R0hFUkFXL0l2Z3Z2YXhuVDQyeElpQ3ZJOU8xQldranFNQTl1WDRLRGx3T1lCMUNFQXZRSkd5OVVzM29LNEJRdFhjZUFnSFFBNmhvbUoyblpSNXZxSmZEbml5OWs3SWdkRFRGRC9JN1Q3T0pzd0kxOGRoQkhJd0VKVGJvWHBPTlNCZmxEbk9KazUzSTc4aThBUjBBNjM1UmFEbmdqZEJ2eWduaU0zd21PUlhSTm9nUSt6L0QzY3lWVFR3OHhobGtuQVhqVDNJd1Q4T2V4TWMzRFhSRHFtNVM2WjNsNUZmNnJzdW1BRWRqVmoxZUZQQndQMC9BWU02ZWtrNmJtSlBqQTdiM0t5UVVYcFRGQ1dBNlBodGgvWUpXTjJWcXR4YmtZT1JBMjg1OHlPWjhnTFd4Tk5lQUdySlI5SE1JS3o0cWl5ZGdMbldpZnNURjVhSTI2SzZ3ZGhwMUNacXlwZHR5dHZZN21vcmhlZC85TVdPN004T0VFZkZkKzFkcTZxam5XQXdYVzRZZ2dpWkRZdW5iSER5TzBjdUN3R1Q4VVRQTG1vU1pQaTRsTHlEMGdjRHNCdFROOFhFVXFoZEhkK1VkR3UxR2dPbkxRY2RtRTQ2SXBiZzZ2dUJuZmpiUFd0bTBOUDllTFlRZnZETGsrV0JuQkNiUk53Vkpxd1JCNllBZzA0YytCaGd0RlFuL1NnZDNQVDl5SHFTSnpCMnZRdEN4b3I0OGs3QmhLV3dBdnFjMnoveVBUaEVtL1dQQUJianRrSFhqUmg1SUkxSFBrVUpuQW04RFJ6TlNFQ3A5SE0xMUFhaG9xaktQdEFLb3VpdW9tYWhSUVZia1BGVWxRVVJlVlNWQXhGemFHb3ZSUzFtS0lTS0dJemFoWlJWRDVGWlZOVUhrVnRwcWlkRkxXSG9xWlQxSHFLU3Flb05JcWFTMUZyS1dvWlJZNFJxSzBVT1VLZ2RsRFVOSW9xb3FoQ0RWVkNVZnNwcXBpaUNKOVNpanBFVVdVMjFCR0tLcmVoTmxMVVVZb2NORkNWR3VvRVJWVlJWQUZGNVZEVUdZbzZhVU9PSDZndEZMV0dvaTVUMUFVTmRaV2lMbEhrUklKYVRsSFhLT29XUlYyM29lNVIxRzBiYWpkRlRpbW9CeFIxWDBNOXBLamZLV29iUmEyaXFLY1U5Y2lHZWtaUjJ5bHloRUd0b0tnbEZMV1NvcFpTNUtTRHFxYW9QeWpxbklaNlRsSFJGRFdEb2haUUdqTHFXUnJxRjRxYVQ1RXpFWElvb2xuQ1VDa1VSYVRVbGFMc0tDcVRvdUlweWt4UkpvcWFwQ0YyTlRWRlEwM1VhTWpqSWluTmFoMjFnZElVdUZDN0tNMGxGeXBKbzNtWG83bXZtdUJ1bENmbFEvbFJvd2pKTFkwWE1jSC9zVUUyM1cybTJ4eXdPVzd6MGVhemx0YzIwMjdWbmlJRzl3TnlNS0czbldhNzA3YUladWlteE55T3A5UHBxZlJUY21DUXczeG05V3g3dGhlYndGNW5zUjFqMThrdTNtNFdNWTB2Mk4yeDE5bUgyT2ZhbHhKVDl4bXlSWjFRT3BxTkZxR2RxQkxkSThaclBXSzRlbklwM0FMdUh2ZW5BKzJRN2xEZ1VPM3dyVTd6T20zcnJLcXp1MDVKblN1OEE5K0pIOGl2NC9meGwrdHE2Z2JVYlZlM1c5MVpkVGZXdlYrdlVUMjVubCs5bWZWTzFMdGF2MTU5dC9yaDlaUHJWOVUvVWY5OC9kdjE3enJxSFowZHZSd0RIYnM0OW5NYzdqalNjYW5qY3NlOWpnY2R5eDJQTzc3VnVlaUc2NkoxU2JwTTNYVGRadDN4Qm5VYUJEZVkzMkJ0Zy93R0J4dmNiL0Nvd1lzR2I0VUdRbjhoUmtnWFpnbExoVjNDVmVHK3ZyZCtwSDZDZnBKK21YNnYvb05UanROcXA4MU9lNTJ1T1gxM3RuZmU3M3pkK2Fuemw0WjJEWnMzOUcvWXZXRm93eTBHUjRPL29aTmhrQ0hLTU5ldzNYRFoyTUU0MERqT09OMjQzWGpBZU1QNDNQaWhVWk5HUXh1dGEvUmVaRVZaN0NLT0VHUEZaSEdLbUMzT0ZnK0pWOFNIVWoycGhkUlQ2aTMxbGZwTDY2Vk4wbFlwVDlvdkhaR2V5TFNza3p2SVUrU2w4bUg1UStNR2pRYzFmdFQ0VmVQUExvMWNtcnQwZGVubk1zSmxyRXVNUzRyTFpKZFpMZ3RkVnJwc2RObmhVdWh5d09XWXl4bVhLeTUzbXd4b2NxUkpUUlBjVkdyYXJXbGkwNjFOanpmOXJabTJXZDltYzVwVk5IdlV2RmZ6eGMxdk5mL1lvbjZMVmkxR3RNaG9zYWJGb1JaM1haMWRPN2xHdVM1dzNlTjZ5NDEzeTNLYjRiYk43YXJicjI3djNUNjZOM0pmNTM3VFk2REhDSTlRajNDUENSNHJQTFo1blBmNHcxUGo2ZXM1empQYTh3OVB4Y3ZEcTUzWE9DK1QxMkt2N1Y1Vlh0ZThYbmxydmQyOUYzbWY5LzdvL2RuN2IrOXZQdTQrWGo2dGZUcjU5UFlaNmpQR0o4b255Y2ZrTTlObmdjOXludzArZVQ1N2ZjcDhqdnFjOHJua2M4dm5ONStIUG85YTZsc0d0OHhyK2NyWHhYZTJiN252YlQ5N3YxWitmZjJXK0ozeU8rUDMzYityL3hUL0c2M3F0aHJSS3EzVjdsWjNXdFVHdUFRMENaZ1FVQm53WjhENzFvMWJkMmk5cG5WSjY2clc1MXQvYlVPMWlXeXp1TTNxTnU4QzdRSjdCdzRJSEJrNEpyQWc4R1hnMTZDQW9NUWdjOUNzb01WQnQ0TitDL285NkVIYlVXMXZ0WDNRcm5lN2dlMkd0UnZkYm5HNzArMnV0bnZaM3FaOTEvWXoyeTl2djZIOWp2YjcybGUxdjlqK2J2c243ZDkwR05naHRFTnFoOFVkdG5XNDBPRnRSOXVPZmgyUGRyelhxV3VuNEU2ck85M3VoRHY5Nk96WHVWWG4xcDJUT3Evc3ZLbHphZWV6bmE5MXZ0ZjVqeTROdS9oMm1kQmxXcGNOWFVxNi9QMXlNZFJUSXFDZTVoclVnM2lvcDcybVZ5SnFRbW9qMUVYZkh3SnBpcStOWVBuYXhUeGVZL252djlaVUUybDJmQXBkY1lENmpZZk5uMFhjanltcW5VYURMYU43Z3BzdVJnR0trd21PbWgzM1F1QnVDTlE5MmF2Y0ZRWWpnanRjUHhqeE1EZlhCTDdmUVA4VnZNeWFwOFFnQVo1SndYb2FOM1VCQnlZQis5TEFNUHVBQU1jbENKcC93enl6Ry9RME5QK0s2NzRYVDRuWThiMklHY3R2SzI3R1FIWVRBUnl0REJ3Wi9wV242VHRyMWx3RzcySmdkNE9QVnJIRjlnSm9XTERMdmZyMHBlSEZxSHh4MytuZk40OU9YQ0dCWERMOWVzaFIxR1JLWUNkc2EvQzYwUnRzTDRsUnNla2hyU05QbkowbllTbHhaZHZMVGNFbG8yRmpsbGZvR1IvN21pRHA4NXI5Q0xnRFNHZWt3RldaMHczcGNxdVZpL2dOeWZTZ2NCcjJGb2FKUEdSTUI3MlhTZmtJdk9OVmNNVTI0QUk4dU9nU2xVSTlqR0J3SytqdzhSTU5nMWc4RkkvMCtyaDlNMzJpdFBMVUxjTS9yZTloZTdmbWZYQ2QvZ2VDOThkSWE3SnAzY0hPSThZRkJ4amNmL2VBeHZjdTdxc2llekVadW9PNDMxRmhiRkp4U1ZuZXpuMDc1T1hMd0FZak9pazVhV3FjVWJkdm5OSkpPTFJuNng3eXN4eWZNVE05MlNTbG1LZHVvYWR1bWJ4OXQ0SEhlNjBUcENFVHBMVk9EditIV0FJNmJRbmNGL0NNZDdnbDFNVklldnFReGhwZ2VvSWUraG1nLzAwUWdCU2wxcVM2THJiM3dMNTRob0VRUXAvZENNNFJTcGpoQWI2WUIzc3BvQjBOR3N6Y3dnTHViOEQ5ZW1BOUprWHBHYW5tQWIyRGxrQW9JK0dSU1dsbTFrQm5jTkRDWWFKSERyZ3VnNW1TR0d3RGJIUlBqOWU5YnIrLzQvNzZSczkzd0paR2t3RXlNVFQvOWphQ2JHaWdQVEtMNkIzMk5zRklFL1EzYTg3OEtZUVVSWjVhdC9ZZEdqd2lNbnlPWFEvMndXcXd1UW90RFZlanovVWNGaDQ1U3VLWGk3akhPaE5FbURVWFhnc2pqb3c1ZmZwbzVhblRZVWVHRHg4N2xpd3I1cXcwMVdTYU5jcWNtbGdCTjJJdy9wRzVSdVNoL2pTUWxSWWdhMHJBSCtZVUlCaE54bnBpeGZFdHBWTHhsb0lkbGNaanU5Tmp0OGhibzFjRWp6YU1uaHM4T1ZxS25aS1NIbW9jazd5amVJbzhwWFR1OFJNRzdLOXZ2NjVkUlcrcGYvbnRzSy9HYjdlUFhpNlhLNjZ2ZS9qQThHRG13M0hYcFN2aDNZKzRHSnQwSDlzdlhCN1hlMmE3OWdhK05kazlhUGNWZUNLaW9ZVUlQdWhyUkd4a3MvdjJzaTQyVzlhMlkvbktGNmdJM0tBWDZkYlFMdUxoaXlMOCtJUWd1cGY0OWFZSWp3dlFYakFLVUkyTnBPdkd2OEc1cWVLSWh6QjRPLzZIaHVvVUFRY3lFQWdKTkgveUhNcUhGakN1RU9YM0VCOW1nVE1NQmQwN01KQXh0NFB4NEt0VkR0WFVGemFtamxrM3lJZ3pzUnYyeEZQeElHQ3hMZmlBNTljUDBCQWMyN3pBenAxSEpNWmt5R0M3OVhIMVA4Ymk0bG5aZTJSY2pZOExaeXRLVHA4K0VqTjAyTmlZNGNQSGxaMlMrTFZrY0J1MklHWEZXVlM3QkR2RExXWXhqc0I5SitIbkVnU1JGLzRPOUlXZ2lqSTcvdVl4Vkx3VFFWbUErRWNXR04rQkV3ellRb2JsQWFPZ3EvYjRWc0c4Lzl6MHMwWkloN29nd2xTSXhPeFgwait2NWg3WUdlcy90SUw2WjA5ZkVjZUdiVnhya3FFY2pncWpJcUpHaklnb1BYbnlVT21wVTRlaVIwbzg3a3VVSXN3TXZtcnFxS3UrOEplUWdYUytjTjAyQS9HNEQzWTFFdzJEbGx2Qno0cnc1UElmd3BoOTBkVnIxN3hEdzBaSFQ1aGoxNGY5ZGRYWFMrQnF1QlI3dXMvSUNkRWhrczU1QWRFU1FwOVRob3FtaW4rRGRCVnBsTXFGSWlrckNWTlIwVnFUOG1HbnVCZGNGa0ZYN0FOMUQ0QVBFZmhWU0JNcWR1UVg1VXVsdStuekZTV25IaGcrdG51SDIrQVdBVzdZZnNhU3JLWFRKV2c4ajE2MGJPR2E3WWFqKzQrZVBWOFFIWlU2TzMyU1dRcU9wb2VGVHc0T00weGJNcDJnNmU1a0xFWndmOHk3Ris4aDlNUExENXBpME40RlJxczhBQmZoUzg2M2orQnRnQ0hZQzF4d0ZFN0N2WEZyUEFPYm9SUDJoQm4zM3UwNWNrSUt2a05Ianh3d2ZiZ1JFNE1NZUdnRFBZaVE3U0VRM1A3eHdaSlgySUN3cWRrYk5pNWJ2R3pKTXZrRXpLZWJNWE1pNmVLc0NadmpqRTE4ZmJDK3hiVWVqNDhjMlhaZ3U1eXlxaURwbE5FSE1vUXVpNkpIaFJySFQ5NS83SExKOFZPbHVTa1JNajhjYVR4RUhwakZJRUE3MElNM09EbmVCeC9vQ1MyeEVmeDBYKzkvRm9rVlZjYUM0YzhuWVBkeTRMbitHMldkY25icmtmTjNES0JwOXhBM2xyQVdsd2pnL1ppOXVEZHA3SmpZNUJGeWEzeU1zUHZBNnI1ZUxJNFBEWTZaT0VqbUlTOEwvSlhPNEtQNVRkUXFibGtDVEhvTkh1KzN5eUVpVG9VZzdBcmhCQ2w5TWJnckxjRmRjeC84b1J6YWFtRW11QXRLeTBKeEJYWVgxcEsrTUh5a3FMbGZnSlFkK3Zib1NxNEp0a0F6ZGF0S2M1KzhmZGw2VXR3SXpmQW1VblVDUEdySEhoR2hOSXRVQ0NDQUhSZ2dCTndjaXlGQVYxRXpTYS9VeFQrd0FlTFp5Tm1obmJHOUViUHU5OEdOUEppKy9CYlEwZmJqMThyZ1ZVMS9TUFFHQnp6ZWlNTndSK3lLMDNFR3RNSE5JZVRUdFVNVmUyWGQ1RFhkYVI2V2twNFVnVHZzTlZ1Nlh2d0oxYlJWTnk1YTRiMjRHUFppLzlNaWFTL0dSU3lQaHlXaSt4Q2duU3Z5VjdMQVE3bGwxbXdqM2UxWWdMWkJpb0JkM3ZsQVkzRDVBQlFJa2pJTis5ZWEyVkdKMGFQSFJoWmNrcTZ3MkNPVlBDNkdzQ0F5V0txSEVBYnZVVnBBQVp5bmNSU0QxK0hqTkJ5M1BHNFkrK0E1elY5U0xjaFRab3ZJU3ZYZ2ljOHBwN0QvRVZFSkpTekkwK2RCUysxM1c3V3JTU3dlV0p1T1J5dnBOSjd3STRTMFJURXdzRGFLaGdZRUtnbDBiUUxMdzFhVnpBOU9GcUNhdnZwc05FblVtSkVXd2dDYWlHQkRoTEFLR2tGZkVDMVNHRlZBcGtReEN0RDNKWHYrWVB5d0VSUGlCc3ViY0NNQm1uMTRCUVp3ZG51RG04bDRHK25zS29hSGMrTk5WVmxJNVZlOEhrV2dxNWMzN1RrcFBmUDgrOCtBTjNUVmhUMFAzaGphSVFoYTBnK05uUlV6TlZGcUNreVRWbjlqaHA2VG5qNC8zV2c1NlpCNXFFODZzWmwwb3N2UFRvd2tvbGJhNktFYmc1dkJBZnJaM3VvN2J3M2c2UGRXVmQzOTVOR2JUelBEZ2ZTcHl5djJTbEhDcUpDNDJINHkvMXJVbkFCZmlGR0pMeXFGSFVYUWs4L21LZkRVd0N3aXllL0tLUUU4YTE5aVQwaXVQVVVVK3hUTHp4TTFsczFETXVpdjA5d1JqRWxFQUJBajRNN0tmQnAzWTJEOWp4QWFBaGxZVnhOQzR3NE1yK3hMUkRXL3dFb0J1eXBqYU55R3dhNjFvZGhlQ1ZWYllhU0szWTRCTHlXQlBDbkJRam1TVUJJOEhrWVF5amFmUlR5UXdZM3hWTndZcHRKNEdBTlQ4RDk0Q2dZYUJqRWd3MVFnYmJTNjZKa0szMmdlT3BFT3JTNGdmM0JzQk9JZmlCcmxyWDZHZUZtOHZ4dkI3N2l6QUhhNGJzMXlxQXNNenZtUGllWG5XbitWb1hhNkFDS0RjVTBtalNXR3Z5eUNRQ2hXRVlydkpyd1VNMUR2eDNKY0Q5dXhmS0hDbWdDYk5jbzIrQ0xnTU1BMHRtWHdHSXhwYU15QVBTU1JSeVRSL0JwY0QrcHBsTlc0bmdEMWFsZGlzdjJLUjE5REVLaFVEMENqMENpUnJMeEUzV1FYVVZmaExmTEFIVWJYd0IzU3dVdVhCUW42MDZ6dVdQVDI0OGxYWjZIZUkxSVNUVExzd3U2c0x1dEhIS3ZZUVk2Z08wYjJCSWNNR1hub2o4Y255ODZkcTQ0S2xQaXpXZXFtWVlxSWZZRERHbkNEaG44OGZaWW5MME5ROXpEYUM5NlFCaDY2WTBwMVRaeUFQZkJXWnV2TW1NSTJSdXppaXJYWURYdC93eFEwUGwrMWMvOTJXWmRsWHBxNVpLN2xaSEZmaGFIV0RnTCtRSkx1V050UkVXL1JOS1RKRTdYUUR5NDBRenh1M0ZQVW5FRmErS0xRQWpUQVZDbDdpdXdDN1ZpZkpVNWFsdWdyc3Z6Zk9BS2NYNE16VElLR1pQdXJFTHdnanZUallXR0s0TC9ocjFiUTFBaURIa0E5YUNvcnZYSHpVYXp1WGY3MDhPSjJSdHpJQzl0aUp5eDlhQXJPdDhzTGRtMlJNMWkvc0pqT3d5S0xLbWRKVUIrYUNvUEdIcnArdmVyUW1UUEhJbnIzSGg4eFVPWmZFZ1cyQXdrU3pKcHJTMGt2VTZCQ09MSjA3LzVLbzdxbkxPOFNoejdIK3ZHanB5Y21TckFPZS8ySUF5K1cvMFdFRGF1UmRyTTRvMFpjSkI2TFBFQTJOQ05ESlI0bmtiNGJsQ3RtUy9NMXM1QTR6UnlYa2JVczV4Y0pPN0lMVnU3SXJqWit1blRqbzZ6c3dWN3NEUEJhSks0WDcwd1dZVEZCVnk0cmN3VWN3bUJQM0o1V0pPdXpnR2VQVllNOTdxNXFMdzZGZ3pSNUNEbDBpQ01Fa0tLdmlWUFJXRjVwVW9LZzhXa0ViY0NEL0xucUhwSkdLR01yQ2c1V245b1pFeWJoZzZUaEFIdTQ0T0RKa3ovTHJuQ1A2QXdZL1U1NTl4bVRPVHhLT3BZV1hORERPTEoveXZnMFdmZndERzVlTzVmbFh4TEdraU1SamE0aVhkVGRQL01ybVNHVHFNa1J0VU5FZmdOUlFTOUlCM2ZkdzJ5eHg4akVpU1p5dm5rY3UvN292a0RjUURUSUI5SkkyenVsR2c4VGFycmo1cUdzN21GdTlvUURyWXk0aWJ0Rmlieit4aHBvY3ZISXRyMTVNcDdLNGpTbC94K0lhT3BiNUpwcmdxL1FmUGtIWXFrcE9pSWFYY25TV1ZrNVdjYklBZE9HcDhxNkc5ZCtGU0dKL1hDcStNTEdUWXZtYjViNDErZ1k2V0UrdUhRVGRhL2VJRnhuTmhoaE5qU0U1bVpIb0tHUkUrVFU2QVhjcUQ4ek5pMXV0SlNHR3pLNlQzL2llTWJ0MHFBdmxUdlhMaVVtbUNPN2NIYldnbW5HaE15MUIyVVk5QTRhZXJCOEduSzhTQVF3V1hIV0QwRzZpdFpJTjNrUnV2UXJVcXJWR1F0Z1hQQkZ6TUpGR3JkbElMeDJMZzNlREErZmZrWHdoYlM3NDZOQmNKVEcvZ3o0cW0wK3pEZTRDeFMrUzRNbkF6N0tYQnE3TTBHNDBnTXFhZjdZcjJpREh0b3p1dzZXbk50MTRDVnU3QXk5bUdFUCtyMGUvZ0M2d0h4bjNJa0p3STM4b1JHTmV6UFFEZWVRcGJLbzZZUDRQNUZHQ2RIUFFIc1F1T3hHRlpBbm5ENlExbC9HTFZocytIM2dZUkU2c1Jkamp3N1lLbDNlV25UMGdrRXRsbTB0a1VxQWlXU3dRNGNCMkNEajVtOUZuSUZkVE4rVHpCcjE2emNldHhHK0oySEgveVN4UE9ITGthcFhpaWdNajlweFdZYm1MQmc2WE1KMXBFak1sREFsQnlZUGxIR25QOFhKY1dFRERialRmdkVpR0dSb3dWNHUyM2xhNHA5Q0dOUzM3TE5uUXlsTUZjd2xwYk9LamJjdWxkMHFrZHRmb1JNeUU2ZE8zSVIwWGJiRnhLeU9NM1lmRU5ValJ2NmpINzB2YjgvbWZjWk5tK2ZQM2lSYnJQMGhlS0NwWm9MWjhkWlRFZUpoZnpLcXVvZEtvRm5GRFJGZTZ4K3k3N1pjdUw3bEptNVE0aHcvS3pGK21IRnd5TUhiZDQ4ZFBIZG1kM3pjV2htRTBpazNoMTd6Mk5Md0w4ejZzRmlUMXQ0WDF6Rmc3b0VmYUZLbFFKWi9ma0w4QXMxYmdRdXhUSHpBV2ZmbTNDT1Vjd25CczIwSU8wMUhKVHNQbk5nVk4ycUpCTTViNlVlTFJvSU5Kb3JjdUwyYmU4THlTYXZTWmY1cGxYZ2Y2c01ncUsrOTN3WkJnd3NJNWtJTHJYSVY2Z3ZmY0w5TDBJOThNbGx3aHh6TDc1cUFzN0VBMlRUdXlFQUxNcFh1THRCbEFPNUNVbHdmV2tCOWhpZlQwY1QwUGRreUhmZHJMajhYc1dQdGsrY2lmd0pQQUgyTlArZ2RMNzBSd1J2TElPdnVLTE5oamZDNlQwV1hzclVJbXViUllEc3Y2RmVzLzEwTUNVYi83RVc0MHhTeGpWSU4zcHE4MWFJMnp3UHhjR201Q2JwOWdiNWZvQTk1UTVKQXExdmVIZW5pRk81UDRYQmVhc29xK2NNZStzcTBvUmRiR0J1M2FZOFpURDlyRDVwMzV5OWQzaXk3N2FFbnpVbWZGRzRNaXk0OGU2Nms4SWpNKzZPajJ4R2MreHlDM3Y0bEttMUFyMVVxOHRGeUVTN2xJQ1gycTdwODZZK2U2d2VJOEJjT0VZQmhPb01YZlNpM29QeTQ0YzdnczUwazNMNjJ5ZDlnMk1Na1BSYmVsck9GMjZZa0pac25UNVQ1alFnTDhPUWo2RDlydGh4QVduQlU1blZEL09mekNHWVR3L3RDck5nWVhvMFhsZk91WWt0NHZCSXB3YzBSajBPdUlTZ1ppdmlPQ1BxckJ5QUZZS3VCSmNDK0Izc3QvSS95V25qL293RHNhd3JlZ1cydEQ0T2RzYllMbGpEN3hnOW9lVXV0Q1ZpR0g0UndPRTR3Z1E0Y05PQ0FiWVd1NG9FTHRCOHpwZ3ZONDJENFR5YUMxNkZpZjVFTVc5Ri9Ea1Z3TzFjOXJHeGgrdE1NMVVTZ2pZQlZLQ0pVcitWSWR3dk80aGgzVWJlZzFoR3Z0ZXpJZkZqOHBxc0owdFZUM2M0bXhmWW5mait3MWZFRXY4ZGJ2SitnNmZLVUpaQk9IRzFXRUVlYnZObWkwc1R5Q1BiVmNqTkV2VnhNaUhLQWhVZmtJUjVIbFViTmtlNm13dUNYNURtLzFOYXpQbWMrVGdXajh0YnN1SFlmZ3ZGUUZJajh4Q0psNGhqRSs0bFFwWHlzSU9WOFpXSWJrVmc5MTM4ZTVSRjNHQWRZcmZ4dE9WTjM3SWwwRHIzVjVyUGc1d2dPNEEvZHdVL1hDQndTUkhpcVQwZTZKeDkrWEJIY0VNRUErK2NheGE5bW9aQ1lPVFZ0VXVibXZYdnp0dXphbVRjbFVRckRKdUVKbmsvakxnems0NE1DZEdGd1RvMGZ2VzM3dWoxRmhvZDl6blRwMG1kWXU1Z05FN2VuUzNqcEQ2OWhpRmR1TGdhUHBTQXNzNTVqYTVSckJlajdDajE0NENORVZGdEF4bHRJZlFXNDE1YXh0WEhxdW5Bbzh3NjhhZGlGdlJrOEhJb0VHQTRuYUh5QzVTR1B6R1BOa1o5bUZtMlp5aDBsTUdEYkgyRE1mZEV3Uk1TUjBCUzd3TUFwOHNRUW1vOURzRzBzMHIxU2ZQNVRWMmlQNHBBeWZSejVTWUVoUHhaYmlqQ25BeWtxN1MzRlNMR1V5T1UrK09NNjRIOFcvSFY2WUloa0V2VmpWSklRSXByMmFJUzRmU3ppUjRoUU5rNGtJTGVEeUt0dUJxcEEwOEYzQkFTTUJGOWRRUHBqdEUyRVNQMDJVWGZoSktGVFQzaVBpTENhV0gvUUdyUWdFeUdBNXFjSnFHajBhMFY4MEJ0clgrTkxES2wwRndoU005RGlaaUFYaWp4c0RSYXZyeEl0VmducGxMTnlicEFJVGo4K0M5bG9BbmtEeWZEdXI2dmQxMFNjSUNyL2tNSGR4K3RyM2RRU3ZPdEFTclBWd2lSeDMwK0ZLRVdFd2MxQllxMTk3VksxZmp2cCtHOWlDT0VkRFA2aklVam5CUjZQVVRxQ2Ivb01VWGNMbjY2TmJ5TGV2MnhTVnBrMVNtZ1Vnbk1UVEVlelVLWDVweG5UckRqZzdBQ3BwOS83YmplZTA1T3FMMlJkTmlhS2Y4ZjhPZVNTZk9PNTU5MmVmdlN1MFlNM0RqQ09Sckp5YzRsZzhkbWFOR25abWpRSmxzSjlPbmZpdW9nUVE2MjNIdHkrWGZ1UW56OXYxazZpTlBnZWJTNmNlYURLd01lTFVLME9FTWI5UjNaSDhhSnlTQjFoK0k5TmFnRXExQUhDYUxVMHp6SUZ4RDdwQlA3UHdLOEQrSk9SZU1XUTEzWGNqNGZ1Q0RwWlhFRmdOYW0vWVRVUWRJMlZYZEN2QXYyVGF3STlHR0FnR0tHK2F0MjJndUdxWFFlYkJSaEk3THF5MkdFam9tSUd5K3V3UVFENTJ6dUNMTGk4eDdMY0JPcGI3RkE5d3dPVkJYUW5rL0lNREk3WHdHMDNjUDdnbVFFZUxjRkZkMGpwQUcrRkRhdFdibHdqYlZwRDY2WWVMVGhZL3B2aGkvOHo3SVoxMktFNzdpalZtc0ZOU1dTZkhkdGJkV2xIUXVLa3JNbkprNldzV2JUdVVNcmtDUk43R2pwZWlENHhXY3FmUlJmTldEZmRaREJOblRKSjBoMkptckVuYjVHTU9UTTlkRWxsQVBCR2FGajk2dnFkc2FkNzdKWlQxaEppMDZyWkt4WnR0T085VVlZU1BnQjVJNWlnUUlVNENsMHhnYWN2R3EyRXQwVDhLRlR4ODdDYjJDVjVYWWhoRXBIdFFuTFozcXJMRFVRcC93d21GSWZCVzNXWmNWa3RZbVQxbXRFVlpCUGNlSXJnN3FFSXJwN0NiWlY5Y1FUM3JBa3lmQkU0S1JkNklGN1Jab0VXYTZIQnUvZFBnQ004M0lGSUJTTEFWVGVqWmpEMEZTS3pKcVlNTnc0Skxqay9YNGJQNFdMTE45aHI2QWhUN0hpcGFPS292UFpHN05xYk9HSEs0RVNjTUpjVkZKODJIck02WWFiTWw3RkRoTmp1U2cvUVBUNWZjcWhZQ2o1eU5lVU9tY1NIdDUvdWxIWEhhKytHQ1JIbS9CMUZPemNSQjhMM0ZnZkMwTXp4RXN5Q09Jc0QwUlhqWFlzREVYK1dmRk9VdjFORUxMOXJEcnJKY2tKd1NTamRWZHhaK25YemxWKzMvZHB3R1ZvaDZ0NVp6UjVkUFZ5aStBMVFhK29wQ1VPUjdoMTJ4VXVJT1RRTlhma2tPdWFKT21lSTlVTzZ2eDViYXkyU0kvNE5iVmVMZm1UTStuY2VTUGNhTjhMM1NXT1JxTHV4bVRnbTVhbDJZUkhKd0dQQzhFWkJiYlV3R3hIVDVDT1pKckpvOXIxRitGMkFEZjlXL3c1ZWpnbmdOUnE4Um9HWExpQ2h4a0ZRM1RZUEViZk5RL0g3STRqYlpvUUVZL1NrN2xDNXRTNDhRcTNUWGFqKzRhQ3l5QUlSMHNBZUtzMnE4dzZrZzZkVzJhWFVDSEV2c04yNFlZZTc3bSsvcmVGWWJGczBxM1I2c2JsaFVNTCtWaUJYNzByT2kxODNvV0h1NURIcm9vMll3N3JPMkFjM0FiWXB1RUt2SjlBVS9LQk96S2YrOTJYY3BuYUNNSHpFd1p1M1Q1V2RQbnN5cGt1UGtWRkRaYXY1Y2JSRXZMWlVWUzVpZ1p6TVZrMFFWY2UyMVl3YUxLNGo3L0lRSW9PUmh3ZWdkUVFxazRrczdvK3A3ZDVVNUUwaWtXMHhrUVJrRWxGY2dmNC9hLy9WWE5KMG10QTZ3d0FZcGZxTE5Rc2loZmFpU2JRSzM2dkxhckVMRVpVWFVFVDZ0K0pybHhIcTE4ZE1FQVgxSWNxc2dSam9xQ1VKTFd4RmlwM3RWb1NEY0k2ZzVFRDkyaHlHZjVadTJqTmYzR3RXTFNXb1ZGWUw0YWpuamtFSHhzb2hnMjhNTzM2Uk5wY2VubGxwbklpdVo1NlBycENyTC9jK003SWZuUmMxZGwySUVkdmlUY0xqVTJWbk5teFlNRys5aEp2aUx2VGNUZk8zNWhuQUZ0Y1Rac3pNV1pZdFEyUG9TQy9QV2pwMXNpRndaT1JRNHA2SWRJbkVRQmxKTkF3THFtcVFpbnBLN0ZCU2ZaSG93RWlSbURFZlA0a1dTOFlaVEVRaU1iQzd0bnFycU52Vm11UVhvVFQwT3huM1JmQnFRVjVYR3pKd1BkQms0UEVuZnpnUXBEMnRTWFlST2luK3ZrL1VWZmRSUDRUYTcvb0tjYVVJSWt4Y2pWUXJVSnN0OWgwOUtTbERocDNZNno4dEZvZ0VtN0Q4dXRwS0ViUzA1bktjK0l1b0lVWWpzWjM1djM1dXduMHRRTXBWeXlZY3RHT2g5VDBhZUJhMzdrcERIdmJIYjFqZkNCclhaZjg2Uk9NRkxJOTlWZVBYckhsSFdFQ09IdTZ5ajh0VS9NQW9HdlpqTC93M0d4U3RvajhxcGZGU2xsZHFzc0FYdTRBTE5BZFovY015K0pDZkxzVWJXdWxNRUFiUVVxejVoRUhvaEdwSERXWjFSWlZodlhmNWs5K2RDUFQ4YXY2eFk3TE9OSmh3NlpVRmpaKzh2d3lOc1FNNE9CNUU0S0U2SHVrZUtXZmd3bEN4TmdyM3QvaHh5N29QQTVIVUN0Mjl1dnZJVVhsTTViWFVXMFp3L1AzMjB4MHkxaFhUUHFqdmdOU3dzZEtSc0w2N3VockpabHJSVHZIbmRocDVpZTNDaU9MQ1JheDBGRjhqNGlsMWpHaHo1VmhSZHdWTHRaZUlSWHZuRFlKTzFqVUR5T0EvQWZ5VHdFOFhBSElNZWMxeGc5cWRsdDJycXAyRURKd0lyMnA0U0ZZdk04US8wYmw5cE80eVlWVU4rVDlHQ3pOUS9uRUVxSlBvcjl6OUpHckE2SWQ0LzJzb2I2eW9yclRyS3BVZlhjSFhVZGNGaGltVkFtaFAzZjFqcWV6QjZMSlRGNXFUUW95NkxpSG1QZmtMWlUrbWJjN3BybUJqNVBFcDVZb0p1cG8xNjJycUNLRmxNVlhIRHBRY3U0S3dXVGxuZ2d5ekJsYldOQ2FmZEZ5TVRXY1FLVGJISm1INzVxWEwxOHVQMlVXL3pGNDB3empKdkhIM2dkS2kwaTF5NTAzME9QUFEyRTZHdnNmRDcwbDhFK1ZraWFnTFYrclhXRjdRNVVHazBGNzB1WVlnbnJoTFBoRkhZVS82SlFQN3dGUEFUWmhlcEVSOGdDZWhJTlFSUVl2WjROeWNMS3hCY0FRV3ZNR09hSFNGVXJOY2dEckV4bCs0eUd6TVRGOWRMRVBZUFJCcWY4WENJMVkzdWRZV3ZBbUZIVTVsZFJXZUp3Wi9sbzd1MnJERXlFTjlIdmRRVDUzQkNObGJrSElQc3U4aTVicWEvNTVOOGlMZXFMUURMM0JSUDQxQldvaFI1Z3VIVS9adUVuZi9kS0Z6ZjQvMm5VUThRUnRrZ3NiZ3JUa0NRUS9RbW5YTGxwaFFiL2JxOHZmSFFES2NTRGcyZUlkSWtEQnZBcUtubWlOUklqK2FNUGFHeGhiR1J5SFF5bnVaYUdVSU1mcGxvc2Q3VkVoNGoxQUdFeW9yNjhNUStBQ3RXN1ZzU2M0RTlMNVNaUjEvYk1nT0VhTDA0YnNUcXRhdVhKcXpiQUo2WjJsSVVCdjRFZjk5SkFTVlI2bUwwRjZJN3d3RFRIQUVHSkRKckhuc1JsQUFnUUljdVMrQ2pCMnhqQjB3QXc3NENNdkg1cHJBaGVDTkFVWVZBWFRhamFwZ2xXQnBkZ0ZIY0NFa1k4aWZDeUZ6K1VrMmh1VzNncDFKYVdQV25JRFRBcVpmZXdFTDdPczNRSU9kOTJ2TVl0YmJHOXRKdk9LM3lnUzl6SnFhNS9lRXFpakxUbHRJMklFSmxWVmxCNDlLK0pSZXJmc0xXVXNuOVZXUkIwTC9Rc2NPa0JKZlEyZC83RzJDbE0rcjlpT3dCd3JxQTAvK05McktKK0NxekJiSzhvbWoyTTVVRXN0RHZNaFM4OHNrVE9sYjN1djI2dFg5bTI5ZWQ3clRzbVduYnQ2U2NoNi9mQ1ErRkhYbUovZ2hia2xNcXByaDBQS1JLQkV1RDBVTWVwLzczVjRkUDd5dHFFQ0tMeWczSFRlKyt2M20yMWNkN3JRTUhwOFpseXdYSllmbkJSdGJkdWptSS9PNGo4VStIaWhhYzYwK0wwRHdQT3NqS3Z1SUhDSHd5L3N2Mzc3b0FwVFltbUNobFVoZTZiRzRRTTJjVW55K0VzZy91SWVnZ1o1WWROMnlQNklpbFNUb2l5NEl0djJMdnRPV0lQV0hKOUZJeVhORi9lQkhxcWkwZEJkNWQzZzJVMVJDVzRpQjhHaWlXRE8wS1hLSEg5dkZtcERXWWdkNGtvQ1U4eTZJTktVaWVOOU03QjhVamNER0ZlSFJicGtJTzRTSzVJczNYdnhDTEd2Y1lDWDZoUmpXL2R4U3hWQ1ZMWGFjS2M0bFhIR0RpU0xNSjF4ZHQ0dXdoRERGRFJMUUZ4ZEVHbElScHB1SjBIa2F5RGMvbi96MEd6VFNLQytndFpDUkhKRVZiQnd5YXZ2UmVCbnFNeFdmYVR5QldiUm04WnBWaHRXTFZ5NVpJNEdaT2ZxSmZPK1pVMFZudDU4eEhqazQyMXdnbndZSGV2ZTQ0TTJkYjR1K0xXNHlpMll0bmpQSE1IUHgzQ1d6cEo3Ti8yS3cwekhnTzRLYjhjRzEzVVdIWmI3L1BIQlNXb0tqNWkwWUs4R2d6WWM5QW5aaWR5emJzVHh2cFYzVEZUY0hnTVo0ZmUvV05ldGtxTWZPbXBvK005aVlHcjc1dkp6TEFuMzd4cmQzaHE4RHozbjU5dXJmV01JajJVbXowbitaUE04T1ZzQVVZWXc1TW1XaUJBeTdaOFBLdGV2V1pwdUprdFpYTkNiWTlaY0duaXYvRWY3Q0ozMC80bDJmWVJlclBNYTdCRVdEbTdDZDhhajJNSXJHVFdvMUh5Q1plWVNUNlYrWlB5Q054bWtzSDRSbWRSZWhZeUZTZ3NuNXN3OTJBbDJ0RTlaaEo4VUhuTENqNGdTT0RBL2xCS2NuK0lHdWtKeVFYRVkvUXUrZ21sQ210bzJ5VWJEaU03eHk0U2NPYi8xckVQUjk3V1gwbjhRNzZIc2k4Nk9Qc3ZFWmdrTEY2Um5pbFZzRXMxc2grcDU3Qk9GTUJ1b29UdlRmNFBRZjB5M3h1NG41TVpJdy9mV25xM1VZQTI4cXB5QTRUenlGMTV4RlB5YW1pVFVKcEYvcEREaW9WQXorRDM0NUJTblhsb2phNzV0T0lXaEkrS1NtaWQ5VG1Wb040Yk1PMVR4ZElnSXFSSTFvZzdXNUVhNlhKamF5L2NUZ2N2SjRSQWFJR1B4RnZ3NTkvMFF3N1VqbjdRazI0MEd3blFuMmR3M0JaaWptUDgzVmJwR2hCak0xak9Ja2dEM0oyek00WDgzYmtid2RVenVUZEZVNThuTnc4NDZnU2tSNkUwWkdGY2JVam9GN0FtNkdoOVB0RmFmZkdCaXNCeDNUMzU5ZWlPT0ZDMjFvWEpjSXVZUU1jam9aNUhEczlGbmRsd3UyNERmRlR1UzlkNnBFVEsyZm5rekdBSDk2d1U4aW5oRDVrY2Q1azA2M0JqZXQ4ajlRSldBMzNBNjNKc09xQTA2MURXOGc1UzdCK21VYXVPRDZVRjlwQVR6bVFYUThCSjZnZ0pkdVg4MVFXQzVnTDJaY2RrUmJiR2QwYTNVSDZrUGpkNWVmQVNwck4zNjFUSmd2eHQ0akdkM21zdGlSZXdLTnVCOXVqbDF3R0E2RHBsaUd3VTlPN1QxUUl1c1NSNmluRTdDQTlLWVY2YzNVVDBoeFBJdndLK3hrRlJTQkw5WFBOT2tEU1VOeFBkRGhNWExmMm8yQzRuU0MvZmhiUHl4Z29lTUF0MFV5cnhSYmh1U2xkRk85TGV5UG9ONndsd0gvMm1ZME1BUXFialF1NmtMNHZRWW5iRVBHYVVQZ014YTNxRFhpbG9xUnh2ZHZJSGhNOVBIdWJ5Ym9mVStFSFdjRTZGMHpGNXgreklVK0xDN0ZpMmgrQ2E1ditrNCs3UkQxV0lUOG1vTUNYb1QzME5EM2h4ODQxZmhCVDBJTzkwelFENXlnbjFuei9RYWNGUEExV0VMamZqOW1rZm1ZaGZ1eGZEYldtYjczSmp3NlBoYVZkS0pMdld0OHNkTVBYOXlmZ1NXNGtPWVZ0T3E2ZUlOOEpWVy9mRDA0S2ZOcjU3MThXVHRmbWFlV2FCNFdrWGE0UkJCQXdQcmErYlh6WDdWVUxLM1lpWVovaURnLzVsMFhhNVl0RVVnQmswcVZ0R1ZMWlY3dGZFd0lDSU5acEYxcHNFVEFGdTZra1hDdm5hZVdhRXpvRmJiQ0JEM0FHZnFEazRhOE42SVdsdThRb0llaVljSDkzUnNRUU9mNkJyZVFjUXdSWnpoenU1dzRKSVNIZDVjeGhuNE1MbEVGQlRmSUtaWC9QVkZSaUtCdXdFd2lTamhXNjA4ZWQ2aTJNeEVud1ZwSXNEWllzWW9JVWp1OTRnOG5jVzhXU21BaEpuODA3bFBiby9ZUUdjNnVXK1JOSmNLNjlsbXM5Y2ZWMEZ1ZGpRV2d6Z2owVWJvcktzNC90eEJCSVlOSkZuQnZmRkx4SjhNK3BQVEFmVlIrYW9jT3JUQXBMOGg0bEptUHhjdktQVUhwakcvaG5nd3N3cnRoSHV3bVQxTkcxcDVpK0pwKy9jajhneFBzSkgvRUw2cVJyUW44QlV5WUVKUWZDOGtzTGlTZHJNMVJQSWhFYWhZUTlWZ0EvZG1mbzY0N0RScERMT2dBUVdOTklmakFFcUtMc0VxNUwveDVMd0k3clpOenAwVHRkek5pR2d2dHNRY09Bc2RBTU1LRXY2QXRqSUhMT09RQzFnL3RuRDJoczN3UzE2VUxyNTVjdXR0NEdpOFV6cFNhVTNiTDdlY21CSGtZUnc0dHZYemhRT1VUbVorRW9CK1IzM2xvWVRrZ24wamVuVzk2NG5wWWNGb2tsUk5yejdQODljWGdxclFDVjAyaFh0a0dydmdhQTh0Z0FwNEgwVFNjQmRmYWJiaVpLb0U0b3NaUk5QOENacW5udVlkUG9DaHlaQnhrMWloUk5SNFdSNjZIUDRLSUk5Y2dCTEhFbUZrS2RUVTFXVFZMQmFpTHA3RTQ4MGRQYkE4ZmFOeVlnV0cxWlRRNE03Q2laaW5Odzl1M29BZmRGblFRUkdVbWlGcWxIUXdSQnAwNWszakRDSFpQSG9FV3RHMGVZN3YrZzJPR0RwY3ZEQiswdjY4UjJ3Y0dZaTNXUGc0Qys2dW5DOCtmbFhFdmFDdnMyNXNTWFNqSEppV2tKUmdqVTNjVkYrZnZQaUFEeGpvaGZ1S3U0a1M1cEhEdnJ2M0dzbDBwc2JHVEprWEpQRzZJdzZCaGpUTTAxSUFHdkxXZ21TM0VtRXpKMGtqYzhCd0RkZS9kQjE1V05yTWwyM0wzU05YUWNDaUQ2M2JwaEhtWi8zdVBxTXhWMG9XRWpNU3NCT1BVS2N0WFQ1UEQ4bW5kOHR6bzZGV3h4cDREb25yR3lnLzcwWHR6OTI0cE5HN2FRazU2bnFEU1dTWEdtMHN1bFJiZnRPdUFaU0hlU2p0MStlcXBGdHJ3YlRGUnErT05QUVpFOTR4UmFRdTM3OTIwMTdoNTA3dzVoTFprTnFHOVZIcXpoRHo3dktoVWprU0hjOUdKV0RVOUhZOEdJY3RoaE9tcnRqdUN6MXVFZDRmWnd0ekpTVW1tS1JQbDNFRGgvdmx6ZCs0TVB0OUp4aDFybS80TkJvYWNxeWFpZC9xYTRKcVFIOEZxYVRFSXlpalFhOTZCWGhrQ0JtM05FYjNhVkk1SStWZEJHVkk3cW5ZSXc4TnpNcS94Wk1MYjFzUUx0VzEveE5NMUQwanRuNHNKMWt0U0hhaFdCNnJWdnpQWURIcWh0Z0VESStBcHpVUHpSQVJqMXlPb0MvRlFGOGZqdWppT3hzY2hUb0FZMVVldUJ3TXg4QStPQWFCeEQ4THk1RFRTSVRNSW1rTENPZzBhYXBOSVQvU1dpQVVia2pwL3d6YlkrWU9JblYrSUVzSE9RVW1JaDRzNXFCZ2FRQS9RUVcvUWEyczJrK2VSb0daUVEwbkNqNHNRWGl4S1dLL1BXSkQ1aTBuQ0hjR1poazdzNTVUN1hwZzIxSnIwb0wzMzVsTUJhV0J4ZTZ5bjUyNWJrTHZkQUtkeHRnQ3U3TGVBcEpUWXpNaFpEWEhXSmVIcll4cTNZQ1BYeHVVbGthQlZwV01PK3U1R2JFVHlmVnhaZXdSSGdzbkxINDdqUDhpd2wyOHkxWVNUTmI0NFQzanhGODZIN2JBWnR2aSt3SnZ4RnB4TGNuNlFpN2ZpWEp6M2x5L2t3WFpDY1p2TW96MndqWkV5SFBjTEZYZUxFUFl6Umc0Q3pZNWtjbXgxN3hxTGNLK2FISjQ4YklKMDcyYXJPRjFld2NpWE1Kek1RWmhLQy9HZG1pT2UxRzk1b2hoSnBSdG9TZVhRSnU0aWIwVWU4UUpHa2ZwUllFUHFvenEyVUhuMFZxUGZvS2RaQTltV2VCN1NoZVhRcHluYUxTckJyeURZckdrc0t0dWdlMnNWdCs5VGlQMFR1aFBjRFpZUUlJTExISEpCS3BlWE1PRUZkQ010YXl3eFFvVC9UTnlqbVFoUlA3K3MwUHF4Q09sWkFpeUUzV1N5NFpiU0daeHFUOVdPeEgzSVo5WG1LWUpnY0ZJU3laekRsa2NDWk1FT0duZGlYb2xsSmJPbjdKUE9neDI5SzJUSWhzRkdIR0dORXBKeEVQUGRXUStCREo0T08zQVcza0ZEUjRib2hsTlV6SnJOQ2RKZ3pOS3B4ODltblRjV2l6S3ZqSDJLRGhMK3FZUy9ra1lVcExNRjlZWDRTdHhmK011TTNSS0pRcUszamd0ZEUwd2VRSFFtZ2hCQmF3dHJtb2ZCRmg4UE5iWmJXOVAycDUvSFVaRkVOSWxMTjRqYk41RFFKeWxRWlBrQTFBRjVpa3BpdERVTWZEQjQ2VDdBZWVXRGNCM0pnU0lNcnFYQmk5VTlVcDBjc0JrUExtZDFIOW9pRWpJbXFhWjRmOWdaalpSb1Y0UUh3YWxNdEZIa0c4Tys4YUt5V0QwRzNMRVNLWTFVYXdWT3BvcndONW5QRnJDTG1FR1NhZ1p0SjJhUW9KcEJKNGtaSktwbTBFNWlCaTEyUWFRcEZVRXBNWU5tUnlNWW9KcEJ1WmxJM3hueGpSZVBKNU5CT005ZWljQldaWnliS3Q1U3phQmZab3BBRTY2eko0cndIOEkwZDd1bzBJVG5uQVFFNllUbHJGUzB2SmxZRzhyN282VlFvWVowZ2JzYUwyUURudWRFR0FMVlFpbWJ0cW5JZE9SM0ZCWTkyVFJkaHFIWXBuWVpDeHVndS9BY2xaTDNOc0lhTHFzNVJRam1FeGVyc20zcHFlUnN0b0MrbERYMHZLZXhHWW1ZMVdEcVNlZS9YNTg5ZjJtajdMNmJUdjJGM0xwaERJOHRxSzdldjVmWVFpdisrK1JkU09sY1V5bGdHOXlmV1RjbkxXK3cwYjFIeDZhWStyWHord05GbS9NMnlUTnpwaTFaSUgxakZtMWNsSnR2d0J1QUZ2NE5abnVJK05GUS9ncUdQZE5BSzJXRHNDTW5yN0RjV0xWcFlucU92TkpYU0oxbG1ocHJqSXpmVmJ4QWhubk0wcHpOR3cxQTk3NktLZC9BN3RnV282ZTkzejAvZGZ3ODhkVEFiYzZLc1ByVnpkZWFyMlJNNVVxMThLckxiblpmL3VxdEcxY3ZYTGhTK290ZFBpczlaNm94WU15d0RuTEtDSjlUZURYWXdHcVdqd1cvOStmZmd1djdYOHlPcDBBTHpVQ2plM2dLOWdtRDFsd2UrTmtJVG1lZWZaTGhqRXNzOFFyYVBEczVmNWpSczA5N1gvZWIzVjlWRld6ZHNsNmV4UTVNU0F1T21wUmJPRWQ2K2tXSW5MajdTRVhSN3BMUy9Tbmp4aWFwcnAvWnBHTnJpYURlaWFBQnJSWkdLRG5DbnB6YzdZWEc0aTFwQ2ZKTE5PRlN5NlRZMlNhVEJMMnhiZTB5c0dWNVBIR0xlQjRhYVA0RVd5MkVrUm1GejJTNG45azVTc2dLaE51UkxpdVNXVVVBVWNVUTRaQmdtalVqZmRxTXBlVDZDQjkyNFlydHZ4UWFieDg1ZGxOVzdMRXRPK2Z2RlNoNWl3aTkzb2xhcGM5WmhKc3lMVEJOd3c3cjg1NndoVVVQc01NYUVVc3dudWJ4dExPaXNveWd3Z2p5WkdXWmlzVHlFRTdHc2VaTHR0bnhBZGlDQm14QTg0L3VvUVdsQ0lGTkVmb0hUT3liL21WOXgweWNGajFKMmpjbExqZllHRFBPbkRoVjFoMDcwSmgwL3Fja1p2L0xRYXU3VDRTeFFOaVh1M08vS2dycEpZcTYxQ28yZk5yRUtaS3VvZ3hUK0xNcWkvN2kwa3BScGZBRVN2ZU9QTEM5QVA3c2xFMzdzZzcvamtLalRablRpV3ZSZmt6Vm1sallCQmVFaCtUTHJPcjRza3J4bElXS3pLZlNtVkFwSnBlSlpCTFgvNUt5ZTZEUnRaZXFvM2M3Znp4VXVHSGJSaG0zWXJFbklTYUtXVlpXbWpwc1dIUnFWQlNKSWllS05ZTDBlc0hYcFpaZTYyN0F1Yk5JVjVLVFBXZkpOR05TZEZaQ0ZuRWJxckIyRlR6WTJ3Znl5dGVzV2JSZ3JjUTNCWEpZeVpnMXA1Um1RdFRTb2g1Z1kzeHo1T3o1RTdHSHUyMlF4NjJtczVabXI5cGcyTHg1N2RZOUc2WmtMSlgrMmtRZlhCQjN1Ym14dy9CUi9VTUx3dTlQbFV2bjBEdm5ycG85MDVBMWM4YWt1R2w1ZVl0SWQ3ckQwZmNROE82VFdmT1dLUHFFbXRtQzYzaG00dFMwR0dtcXh3WGNuT2xaRVg1My85YVZPY3VKeWkrYWs3MG8yNWladFhLM0RQV3Z2ZXZEOGdsUThRVldrbDZCRmpTcTZwU1ErU092NXBxRk8zWWI0QUMyeGFGc2dpa2pQbmJLem4wU0JHTXRUbVc3VlE1NHV2L0ErajFiSk9LZFRmek8rTTViUkkzaVNkVElqdW1PWXp0QUxJMGRHR2lLUDZzQk1qdzBKTTJ3NlN6cWc4Y01oekUwWmhuUVdOdnVRT3BkbkVxRERRTVVmS2F4aGhtT3cvcEJHRzFodVZ2VmM1NDUvL3FTTncwQ2crdEJMM0NBempTdXh3enhIZklYalowWUlPT24rWDR3eEtTWXpCcVlvT3BDZ21LaU1XSzY0cjVCMEZkRkJsZDhzZ1B1Uy9QdVVQMEdBbDVyNEF2aC9BYTNac0VmQXVtLzhBRnZhRUdtRy92UjdpelBxN0U2LzBDRGIycXNqckxqTERvbHRsQmpjSnE1UEdSU2NBTzZXZU1IUzlDbkplanJQMjJaM2RDQS92b3RpTUd6WFlSUGx0WVdETzlsK2s2Yk5SZkJ5eEtPNDYxVk5OanVaempPbGFkL0dWNk16aGNMU1RoT3NCcU9JNVZNdnhaNkZEVlZ3M0cwbG5BYzdTVXgyaEtPYzF3Tnh4RVRWN1lqNFRpTkxlRTR2endGemJQUGFxSlI4cFI5UXEwSi8wRzdzb29KSHRLMVhuOGtpL0MrdGtHeXlOOUdNQVVhYU10bWlYakVkbWkvSGZ6eU5ORDduVENpYlB6NURldVdMbDh1TGV3emFIelliTHVPN0o5cmdMOERuUTEzSXE1MEhEaG0vQkNKbjdVZCttN1hRSisvaFVISFIxMjhlS0w2d3NYUnh3Y09EQTRlS1BIVFFGSmNRZFlVUUN1SS9ZUmdDTndYUGl6Ny9QblRzdVp1N3ZPYnRtZysvKy8zRW02bGI3L2F2N3lmMVBmdzNjZzN4dGQzRDF3OUxKZGZXZjJjaEgzTS9qUDhxblIxZk5jRDNrYXZMaEVrN0dOODN6a0JKT3pqSmxLZGUrOGVRZGhKaVFjbjdLWnN4STFJMk1mZ2F2RUZPdjR6MkNPaWkzaFJWSGp5WEZNdjhhWUl2eFdpQWpBS2NFeDFtQWZqWCtEc3F6aml3UXplcWk1amo2VUlxaitjdnhycWNRNGRzMFo2SE9zaFdnTTlITitCVVZNTTdXQlVJVklPcW5FZWFaWTRENVBxTDRpbjRZSEFZcTE2RGNQZmxqaVBnT2RZMXlrNFBpWlRCclQ1VmRVN1kybnBuSmw3Wlh6U0d1ZHhvdm93aWZNWUh6TnF0Q1hPNDJlWXh6R3l6YllUTzhOYlpqRk94SDFUcldFZXUrQU9ETGVHZVJ4RDVUc1JIQWtRTFVFZXp0QVBHbXJVS0k5QjBFVmJUcUk4aXM1YW96eDRjQUVUUkdEMkg5d011N1d3UkhtOGF3WDg2Vk5YeEhIV0tJOURsaWlQNk9EZ2lCSVM1VkZ5L1BpaEdCTGxrWmtIbzB4UVQwMUpqQWNNZkNwa2lqcGZ1RzJiS2ZLNFp4NzQ1a0Y3RStpczdVOWc0R3RoZFBHRU0rdld2VU1EaDAwWU44ZXVLL3RvRFREWEljQndQZkpDOXlIako0d2dRUjV3U1NVdlE3ZW1pdFlJajVLRllobFMxazlGOTlBRmFFNGM1UlFiNGlqM2RzdUZhNnFqWENseGxKc1lQOEk0S1BUQW5UdVZoODZmSm81eWEyVFFsMDY1TWZTcTU5YUdMeTJPY2picHhGR09OMkNIQi81Z1kzR1VPeUgrWS9HVGV3dE96VlEvdWN1UDBKSkxDSzV2UTloMk90cTM4K0NKN2ZHaDBqd1duTGJTeTlrL1JuL0R2dGlsTS9HVFcwSDg1Q1MrU3Z6MXA1dmNyMjNRQlFRcDRLcFY5bGljNU5wZmd2YmZQRm1RVkIrNVFBYXpPQnV6a0swdWJjR0ljK2cyTHVBM0FQdVJGTmNIVjlWSDdobU9BSDJOSCtnZEg3NFJ3UXRMSUJGZnVGV3dWdldGNjFxNkZrR1RmMzNoaE4vRjBHRDBiUy9DSGFlSXhFZk5YZlZSSzh4SDU2M3Y1SWxZOGFmTHl0Z29WR1dDS0tnSEpKUWRJcUNURmlLVXFjTFkwcWlqUjB2TGpoeUpMZzBMaTQ0ZUsvMTc0bHVQblBoQ0VGNzhYNHdLSzhZNGlUK093TE9UeVBQclRUVitaczBoNkVTZXFId1JhbWZodjlUUHd5eDRRZGQyMnl2czNyb3R2d3BKYmZVOVQ0Kzg5VXpzTlhSRVR3bW8yaUNCbEc4VzdWMmZ0MTNLM0w1M1JwSHhtUmcvY1hwbWhweVhrYmdoenRpYjRNbHdwbEtvUWdWYnQrWVQ4MTYvYTRzNUpYbUtlVkthZVZ2QjdtM2Jkc3I4TkdoODQrZjJPMUNGNkIvNFZaaTNlTmFTR2RMQTVvLyszVFozTlI2cldyOWhseHdMRGVoWjZVbnpZbzFEUithcDIvT3V6SzdQTkk1aEZtMVl2R0tWWWZuaVZVdldTNURKN1A1RTQ3U2YyL1BGQmZObTdaQkxRYUEzeE1XdkducGJER3B4a1ZrMFkvR2NlUWJldWdkeThBVGFJeXBUbFhRaFBuUGlkTlhWYzducTZobExqUGlvbmhaWHowTGk2bGxvY2ZYYy9BUlpuRU9YWEN3dHVXblgzcklCa0pTVlFHakN0MFZIRVpxZUF5ZjBpVlZwOWhJYVl2aXJOTGxpV1JHeC9HOVpMWDlpK0plTVJMbm9YaXhKN3NhamwyTEpibFFDSU9DMEY3alpQOWhXZW5HUGRnUDdnV0FMM1F6UTdTSm9Qd0NTL083UmpiSFdEemZIYVFiK3BRaXRkeU00UUtnZ3pSK2FZd3Ewa2w4WCtnTkdGN0VXZHpQZ2JnT3hyUnUybDE1MG9ZRUMyK2ZRREFnZHBxSDRxZ2pGQzlHRm55RUV5QnBDTUJicUFrMUNDTHF4L0lXZnNRS2s2WHMzdkpTUTFQc3gxaG9yc0ZlMCt1OGVJZjY3NmYxbFhGZjEzeDF3V0FSWDRyOWJPV0RMVC85ZHRWaTJUZlhmcFgvNjd6WWt1RzlGUW01MTAyMzkwMDIzTGdzTmY3cnAwcXFicm5tZ2pGMy9GS2ZFalNGdXVxNzd4VXRnVUpFdWwrMVFWMDhEY3kzdXRYZWVpakJSbVphTWp1WWhPQWRlSVFqVFVFcEdWYnBRclZMMDRCV0tObWRaL1FyejlpRklVTElDRVRTRU12Smx2UXRsZDVGeVZjMS9uMG55SXU1ajVUSlE1QzNaVnVDMUFNR3VMSEFGR3hEVjJDTk5NYlRSS3A1WkFrd0FKM0NEdmpseTN1SzhCYmxTYlZNc3duU215OVNPY1YyTW1QVytEODNCLzUvTDc2RnVlV0RFR2hsOEQ5R2ZVMTFCanljWThWamNEbnZqSkp3TWJiQW5STXQ4TzlFczZoTGJpcnJObm9nVURvTW5LY2VROGxwUHBMUERIa3IyQVBSdnRaMFNUeHdsWW5BemZMNjVCWUVRWFBta01uQ0FtWDVJRjNrUm4rOUtzUDkxSFNFTjRkV0UxZkpxd291aC9xalJxK2ZUOWxTUVNFcnRSWld0OXlIVVo3WFlIbHgxSEFYMnhKRWlLaHY3MU9vSSs5WFpGdjVWNnVtNCtnVEZqeHlRazJkZ2oxclhycWo3WkxGQTlYbUhGTlc1M0V1OUJvTlpvbmdLSThyRFQ1MHVMejhsNlVwT2g1Y1BIeEVlVGtKRUlTVUxuTUFXZEJOQkIrNVEzL0VFdEZMRFNNaWZGN1FIenhiZ3I3dVRyZWhnc25DSDZUWi9URlJQWSt1WUU4U3Q0UUIxLzByQlNXa1o2TEtaaWFOenoxUWN6Qzg5dnlzcWRJa01ucHZvajNQN3ZNUHRqZGpvMVE1cmVsY092REJaMXQzUDdqbTFhMjhQQTY3M3hSdTZRKzhQWUF0T0s2U3JvTU5WREQvdkpvTCtoYWpZc2tvWUFVNjRtYklSRzltWmZZZFVpMTBCVE85QVd3cVNJN2hBeTZIUVVmY3FUOWt1dUR4dC9lM2JzNmZmdmdVOGRYRnAzZHBGT3FYLzdmeUYrL2ZQRCtyWWNmQ2dUcDBHWC9oTmdsWmV3a1VtOWg2dCs1UzdkdjIySFliU3BOMVJVbXNjZlBiS1dpYjdpRkM2Z2RXOTJyaG1mbGIyckRsWk1vL0xsRzBtaURScklQaXppSnN6eVRpUy9zRHd1Rnc1YTNwQm5wOEhIWEZMYUtsN2tsY3pTSWpla1hSMDY3b1ZTeVRkalpRRnlWT0hHMGV2WXMvOW1RZDBWV3o1U0ZuM0pHeml4R2pDOHBKeUNNUlM4eTJ6NHpwb1NhaEo3Nkd2OGwwb1NkOGJOblhXdklYekpkSzNwUVU3VGh1UHoyR0h0SXAzRFM2WlVDM3JYaDB0M0ZzcS8zL2VDL24vdHcraTdxQmc0a1FEN3BxMTRGNElidHExWklNdHZIQmkrY0Y5aGVVSEUvWk5DSitZTUVHQ3ZucFNkL0NRdFM1aWdsckg0d1kxczhCYnN3Njhqb0MzZHQxakZGNTRFVTJNSHk5QktQRUN1NGdTU0piSDR3NkowSkk0cjBiV3pBUS96U2J3QjdZUWJVb1FJWis0L3ZLNFk4MDYwR2pnMTVwMUFtandaYXhoclNUSGlLTnJBSUVlSFN4d1l4akJiVlF6OTg5V1pCSTJBYTJhTTdwSjBMOW1yZ0QwaVZ2WGNtUnN5K2hLa2hkTk5wRjQ4VW54azNNTEZzbVladm9zUGRFRGJGVWZrNXBOSnVpbStwajhJWVJZZlV5cXJpQWNXcFAxL00xekRSejViaXM4Nkh1bVM5ZSt3OXAzdURyczdyMnJaMzZYZlBSSlZqZmtQWHZ6TmhNM1pCSWR4MlBubW9XcnlNc0x0VCt2REZ0TzNKdkRpWHN6dGlXOUhmTzlyb0JsWnN3WjhUVUR1OENadUpqME95TytaVlM5V21PQ0pIVXhRUFRLaTBuRVNmVGZwUG9TWG15cU5wK0RSa1EzckpyMWFSM1dDREZFc3phdldaNnpUTks5SXFvMWhhZ1d1MmpGc3NVNXh2T1A5bnlyaWprMFN0WjlDcHVZU05RcmE2TXlkeU9JR3lzMk1qaGlJMHVLbVJ2QmErT1JqWGFrYUE5T2xrdVpuRmF2ZFhBQTJ3MzU2eHpxS0k4YktJdUZNenJxcG5xL0NVMkZVaXVvMjlSblRRdE5TMDJtWnBYbW1PYWs1cUhtcVFiSTVhSk5iVnJidExNcHNDbTNlV21qYU1PMFZiYU5iRnZZK3RzRzJTYlk3aURYcXArenZXSjcyL1k3emRCZWRDOTZMRDJSWGtxdm9mUG8wL1IxK2lHTkdTUFRsSEZqQXBndXpGaG1CYk9aeVdkK1paNnh0bXc5MW8zMVpnUFlUbXh2ZGdnN21wM0FMbUkzc2dYc2VmWVcrNUZjSmFxMVkrMjg3SHJiRGJYTHNKdGhOOTl1bFYyK1hhbmRVYnVUZHVmc3J0dTlzL3ZIN29lOTBUN1F2cnY5T1B0a2U1UDlWUHRaOWt2c1Y5bXZ0OTlsWDJ4ZlpuL2Mvckw5TGZzSDloL3R2eUlXT1NJamFveWFvN2FvQitxRGhxRklsSXpTa0FrdFFCdlJkclFiN1VObDZEUzZoUjZneCtoUDlEZW41VmhPejdsd3Zsd0ExNUhyeXZYaEJuTWpMZGVGSm5JcFhEcVh6ZVZ3RzduZDNFSHVCSGVLdThUZDVPNXl2M0YvY0srNHJ3NlVnNE9EczBOVGNsVm9LNGUyRHAwYytqcU1jQmp2a09DUTZURERZYTdEUW9lbERpc2ROanZzY3RqcmNORGh1TU1waDNNTzF4M3VPengxZU9YdzJlRjdIVzBkVkVkWHgxREhwWTVySGU4NmZuWGExR21uYlN4eXdxUWxNelp2TW14WXQyWDM3blZUcGsrYk1YWFNJZ2szdDQyZGtidGw4NGF0UlVVYkprK2RNc01VSzdlMi9mdk1rZXNINHZaTldDdVhyOHNyS2phY0RUN2k1ajU2N05EWTdYR0haa3JoMmVSeVRVUGY4K00vU1h6K3hydzllMWFiWmt5ZGtaVXhReG9jVC9lS3loelIyekFEVHIzQnJkaWNISEkvbkhTdGpLN2V1N2VvMG5COTVCbHYxOURCdlNWT1dKMll0RHpSaU91NmQ4Q05tdDdxKytydGxkTy8zeDlhMWoweGFkWVVrM3h5UzlYbUk4YjhIZlBtYnBaeEQrd2w1S3RYaXVaT1NVMDNUU0ZYakc3WklmRkR4YlZZRUh3UUZqRFhIQWZnOXNDN2cyajFjeVA4QnkwL00vaVY4ZlA1QzFmUHhCMFlzRVorY3B4K2hRKzNCSCsyUTFoUkYzclo2alU1YTR3NzhtYW1tS1pNUzA0MDUrNWNKSE9DbXdpcGVqY2lxV01yang4N3RqSTROUFFYOWUvNE1RbmI2Y2V0Q3RzZEkwWHZya2k5Wkx4Y2tWK3lXOTVkdXVwb2hhRml6dEdVVXFrMFpkek8vc1lCNDlLaVUrU1U2RGxoNHd5OEdseXdXUTBLN2MvZ2JUOUNoaUZzVkJvS1QvQkNOZnlBRThBWDZyK0dYcklTZ3YxckI3Q3R4NFIzNlRLbS9LbWtEQ0RsRUJiM2d2cmU0RXY4aHh4YUlHNzdyS2hqL2ticzZvVVpOZWJ4RTlaQ2k0dFZleXJ6Wkc1Wm1xL0lxVTdPbnNRSGVpOXhhMDUwRVhYN3ZOVzdSS09tSjZhT0lPN0pCMDR2a09GRHVPajFCdnR3d3MxYnQzclFZTWRnQmp4cDNKVEI2bjEvbkpsUTV4UHFHRUs5aTFBN2MwcDFTOFMxZzhzbUtINm1xUUtiajBCcHF4UVhZWGhGOFAyS2ZWdjJiSlhNT1RPV3pKTStNb3RXTHNqTlY2TzVia2RjeG96TCtGNWg4NlMzWm5wSHpyYWR4Y2JDemRNbXoveGw5cFFGY3J1WjlMRFpZWEdERE9DUklpUm5iOTZ5ZmRQYXZLWHl4VFYwRmpzNk1TdFo0aFVuMjNDRWZjQU8yNEFiQjQxalJPZ1BYaVIwcjZOQ0MrcnZqeklYLzBtdWN5Uy9Pbm5rTjJ1bDFBV3gwQW4yTFJJbDNjUDFZbStFcjdFdTExdEJuYW96VzhyekpRNldDREZyWWpaTmtycjMrTXYzN2wwNmE4KytPY1hHb3Yyck51NlI3M1Q5NjY4ZU4rbE5lOWJzTHpXVXpDcVp0a3U2ZGR2M1JkZXU5TVpKc2F2aWpMRUpjN0tTNUs1M2ZmMXVkYWVuSmMyT2p6RkFmWDExS2JrZm9UUjYxS2pvNkJFam9rdXJKVjRJejVnVU8wbUtUcUdIam84WjN0N2crc0FkQWtGODl3TDREWXMyTHRnZzRhYnI2S1V6YzJiTU1JUWtqaDgwT0xtNGJPZWFIYnR5cGFwUytrejU1dU5IRFpzV2JsaTRnZng4WTFkb0xvU1ZSUjJ0TEMwN1dobGRPaVlzS25xTXhNT094ZEJjNlFZZW1nb0lnaG9JMUNwT3ltM2g5Wk4rbVBibzA2L0ROQm1ud0Vsb2pnUFp0MlgzWGtOREF3ekhBVkFYOXlQL0FuQmRQQnczL05YN1RaU0UxZEQ0YWtoaE9tN3FjK1dkQWVnblYxNUovQjBSNm4wVWwvVVJPY2pFSFFtYk1hT1J4QkZQMUpGSFJIQ0pGcUVmZU92ZVdSWUNGcG5MWFJEMFUyL0hKVkdVWkMzZ2pjMjRIMWtMdkZNblJlSy9xRGZ5RFFNQmN5Wmx1ZG54K2xLUjdLUksrdW5pNnZsRjQxRnY5RU5kV3ZRakVaOEwxNjFidE41b21TZXlGN3NJZ1FldWdFYXdHV1M4R1l4d0dOdzV4YllGRy9kTFlsaFBZOWZYT0k3bGtzUkVMOFNScGVzcVQ4UUxwVmEvdWVnb3E5L2NBZFZ2enNmcU4vZjJsZFZ2emtmaW9ENzhJd3dRL2ZYOUVTZGNIWGwwNE1DUllYMzduaHgzOGVMSmlxdFNCMzNHdEN5VGFkckc3ZHMzYmN6TjNaU1ZJWEhtbWJPenNxYXVYV3VXMW1lbXJaMW9IQmthMTAxT2VMYWU1Y1lUcjhYVnF5MWVpOFNkVVRZY1Q2Z2lucEpjeU1TNDRKR3BwWlVTRkdFdkRqYmk0UUtjcStsQjQ5WU10c0ZiY1IzWWF0azRpSzd0aG1tOGx1WXNpa3h6Z2lWdTVQMjNQdGlOdytIUURsdXVkNGIyWUlHNHZYck5NL25YRGhNb0VleDZqSS82d25abGVOVXIrK3pKcUVEVjVackRNYkRNZXRrTDNCTkdIWW82Y2VKUVdmWHhpQU9qUjBkRUJrdDg5cklaSkNLNkN2ZWxUekpWMEpmT1dabXpZYlhoYUZ6eDJMQzQyRENKbXk2dW1sODhIbkUxby91Sm5CclVmaHlhMGJDTDRXQmFyZ21hUVRPbHJaa1Q4REh3aDJNczVDaCs2cEV2ZHNXYmNIUFlST09CQkZFU2dNZGhiT1h2WkZ6QWQySk8va2xqWjJaa0t4cVhZUjVpbVRFZGFCeUkrVCtaSVo2cUk4RzV0elJmUGgxc3VwZ1VFVGpPY25WRGM1ekpWVWJMa1JrSmtRTU1MYStGM1l1V1BnWFR1bGZiWjYwM21RMEphZW5SRWZGNVo4bXJsRWxqZXNVZlhjREpDQnB1b0tndytoU0VtMVFqQVdRWWpSdERHSTJiN0VCWXdxUG9ObnFRL3Exem1TWUtRTllSNEV6anZneEhGbGhROTR3SXpSbW9xMVlabWFIOWhsNmh1WnJGWXhCWFJPNTRqQ3ZpS3RTYnFiMXdNY3RoTjh0Vm9ENGN6Z0RTVlFqalRLZ1BjWmZsMUFEL01KRHdhSm9yRjE2OHhFR2cvbXZyOXdJSDRiWll6ZmxCSU1rRjRxQVhMZFVXbW44RllhODBSOEVPYk5VSXdFRHVNY29RWWFGKy9MNHdjUTNpNXFMYS91Q3YzdlNwcDhHUnhWdXZ3dFlyTk5SbGE5VWFQbEoxckNadUlicDZCQlAyMmhKa1BZM3JzN0MxRDk3YVQzVTRWOVFhWGozdTFWdzhJRUljQis3QWdnMzRjTUdpaGl0Y2ozQUV0TVZ0SVlMOGF3Y1dTTlRPY25zajZTZUJSTkd3TFJPblhselZUNzI0cW1lTncweFVPbVpNdFBvbHdoS01BaG5HMGh5TVd3eHV5bG16WnJGdHpVZ0diNjBKVVJYektlNGtnRmhycEhFK3c2c255NXFqWmVKVjdsVTJOTWJVWkdTNURmWHdPRFJldlE5MVZFWFlxWk5IamxhZkdsc3hjc1M0Y1NNa1RnMC8xSURqRFJIbWN0TDhzTEdwY2ZQdE9JdVRmQkJwbTB1MHNBVzhwQ0dNNGVHYlFJYWVUdVBHTEJ6RU1qNklKUnFMcktMVzhhZXpRSGo3L2pFNGNPQ3JkQ1VqWnlyMmJLNDhhbGl4ZU1XaUZSSzRnQTFSWU4zWFdmbS9iTjlqcU9iQUNVOW5ZUXJNcGFGK3JTZldRenlMVS9CMEdodFlYZ2dyamFxc0xDTWY0eWl1UnYyWjdrNm1ST2xPNHhFL1FzQlBpV0dnb2phRzVvMGd2d2NOZUlGN0FHSGVqRlBtcWdZenkyWE5Gemt2RWJyM1JSd0VDYmdlNlY4OWxwdVJrNUl6VytMV0kyak5DUllObFMxYXEycW9pS3ZKT1BoNWlNY3RacUl5SXZZb0luYnI3VitzNWZZdmJybXBab3BadzZVaEVnRkJnaWc0YkRoSXgyUW54QXd4RGhoMStQY0h4dzlma25sWXRsSGtoTGlDNUtLaWdvS2k0dVRkY1hISktiRVNyN29kYUNEbmhuaVVQSm12bllONWxqTnJDa1F1UWIwQVdHcHhnczVZTTJQYk5rUGh6cDFsaC9hWmhramN2Vm9uUEpyQnN1cDMrWS9BclJTaFBxNFBvaU9IdXlwM3YycmdnbkpYK0lyTG1yRDhUOWVZTWZrMEp5V0pIRGhyT0hVYjhvaDFvM0tzWmFPU1kwRjc3eEhRTW5aZVJZK2JtRXkwN1FEVVU3ekllS0RyWWtKVWx5UU15SGdzQjJwOFRrdG9CNzRFa2p1QU9CQUV1Rk83R05kWDdOWHJhQzJuVVo3bkNJMmpsZ04vTFljUmJnTTAzSUo2Y0FNWURmY3IxS2xPcnhwVElwZnQySC9nb29FRFB5MWh1Z2E2NEdaUWR4czBJU3pWV042WlpzZXlBNGlETUhiUDFsM0ZKWnZUSmtvNGpIUE1FVG5MalF4a3RKeWpHWEhsSnVXNDJrc0s2b0NHMnd0ZWtNRTU3Z1Z2Y28wcHkyVkRvNllxc2dnVHpZN2NjSkVISjRIN0hkdnNhQWhhekdLSzVab3d1Q2tNZytZUVFuL2hzcUFCQklFV1dvRGVrY3ZmU3ZaSko1dFRVeWR2SytCd0Q1QVVMM0Q4QnlUeXJGbnFCUndMMVFzNEloRWZjcjZxdU9pUXhCMUJ1S0hpeERtU1NYc0JYbHlOS0hEVHdFQjQ4OCsySUZXYTRFSCs3TTBhMG4rby8rM1NOOGdoK1lubGg0blJmVGhoLy9od0xqdmJNR1RDaEFHWkVrWXFONFBpUk9pZHVHT1JwYUVoVWRHaEVnLzg3OENUMVI5NGFyanRHOHBGRGp1Qmx1aUJGanVwVjRIRFljdmxXMFFSb1E4NEtmNGtlOUVFbzhsVFI1TXN3VFVTWENQQkZjQzVkb042bVNyWnpoTkowMlJSd3cyTFNZM2k5RGljTTc2OWVmK2ZyNFB1dCtDMGU4blppaG9Rd0QxSEVpZW9kd1dmSTNjRmM0cE93RGJ2Mkp4c3J1YUt3T1dLcFdTZ2dtSUN2Y2FpdkU2WVo3anBhbit5UWMvZFI1SGs1SlYwejFrUlFkWndvVkhFUGI5c3dqRU9oNEVXVXRoZk9kVjE0RDdpWXJMQUZzNkNEVGM2ZmQvK2hUSS9STDJmbUlRdExTTW5YbHdvbGd6Qm5QazA0cmJBK2MwY3ROSnkvdytsUHNkWEFBQUFBQUFCQUFBQUFYZ0I3YjBKbUZYVmxmZjkzN2VxZ0Z0VkZIQ3JDbXJHSUpPS1k0d1JVVkUwempock5KbzRvYUxpaEtEZ2tJVDBsTkQ5OXRlZDlKY3YybW1OYVVVMGlvS2FWbEF3Z2pOUjFLaUFKRUFOakZXbFRIV2hDbXA5djJjOTU3blV2VlhjRXBXdjgvYjNudit6N3Q1bm43MzNXbnZ0dGZmWmE5YzVweFFrNWV0SWZVK3hrMDg1NjBJVlRiaHEwaTJxVXE0NHpCU1RvTjFuUVRuS3ZlYTJPMjVUaGY5VzNIVHR4RnUwSDcvOFNsNGZ2eUNtSHJxRVVGQXZLRjk1SUY4eGFMQ09rL1FUL1VvVmVrQy8wZUZhQ0k3V2EyQ2szZ0RINkMyOXJWSDZXSi9vdUpBVGNqUTZQQitlMXdrdVVhNktCbjU4WHVOVi82SVE1cnAwUzJOTFk3VTVWOFkreittZmMzVE84VGxYNXR5Uzgwck82N25LSFZyMjg5ekRjdWZtblpEM1JJKytQZWIySE5Iem4zdE42cldtVjJOOFVQemsrTVQ0djhRL1NMeFVYTkgva2Z6eEJiY1VGNEtqQ2laNVdGSHdrOEpmOTA3MG45TzdxdmlvM3RjVi9XM1JML3RjT0tDd3o0TjludW16cHMvMmlpUDZIbEpjMGZmWXZtUDYxdmM3djkvZjludXczNVA5M3U2M3JsOUwrZVdKM0VRaU1TSnhWT0xZeE5tSnl4TlhKKzVOL0tUL0k0bVgrajhDUUhGaDR0WEUwc1RtNGdyNFZLUXd1UCtjNHFNQTZQOXE4Y25GYTBxT0JzZVhuRll5cS9USTB2bWxmd0xMUzFmMTcwRWRjL3EvMVAvVkFZVURLZ2JzVjNaZzJiRmxaMGUvRjVaZFYvYmpzcCtYL2FyczFiTEZaUitEVldVYnlyYVd0WmYzTGE4cEgxRStwdnpjOHN2TEw0YXVMaDlmL3BQeVI4cmZMbDlWM2w1UlVsRlRNYnppaUlyVEttNnMrSEhGOUlwZlZjeW9lS1ppZmtWOVJXdGxWZVV4bFdkVm5sOTVlZVYxbFJNcTc2ejh0OG9aVmVkV1hWdzFxM0pSNWZLcU11SUhRcVNBU1ZXenFsWlZ0VmFYVlo5Zi9kUHFWNnUzVjdmWGxOUWNVak8rWm5yTnIycm0xaXlxZVh0ZzM0RnpGTk9oeWxFZlNmMlVVRytWcUpLekd1MnZBUnFpUTFTdHd6UmF3M1NpeHVqYk9oMk0xRm5nR0owRFJ1bENjS3d1QmNmcE1uQzhmcUNyS0hHTmJ0Qkp1Z1djb1ltNlEyZHFpcVpxck80RjUyZ2FPRmMvMWNNNlQ3OEROK2twemRFRVBROG02ci8wSWlVV1lZVjNZb09MS2JsUzYvUkROWUdmcWlYRTlMUHdqVEJVdnd6RHd5SDZkVGcxbktyL0RHUERsWG9rWEIzRzZZVndYYmhCODhLRU1FRUx3aTNoZHIwUzdnajNhRkc0TDl5blA0Wi9ELyt1ZDhPajRWRzlGNTRJVDJoSmVESThxZmZETStFWmZlRDIvV0Y0T2J5aVB5bW11QzBOODIwcE9xcFFYQTliYzFoZzdjUktyRVdsWnVwdld6WEFOcWpNZHFtQzgwcXVWbGs3dWRyVWkxeEpjaGc1akJ3VzVUQnltTmNUeUdIa3k0RURzU2h2aStldHBJYVJ0a1NYV2dQY1p5bFh6MEN6b1JJVjJXdmtiMUtwZ3ZvclRwbjNLYk5WNWJZY09Tc3AyMHcvRmRBL01aMWgyNmhqclM2ekpQS3ZwNlpEcVNsQlRaWG9kbFFZQXUrZ2hlUXNvcjQ0OVNXb2J6SDFES1NPRW8yaTNLV3FvbS9qbEUxUWRpaGxCMnNoNll2dFE5cXhreXVGTHRHeVNDZnR0TFJGdEpJV3ZFY05LOG4xdWN2U3BMSFVNVWdKMjB6K0J2Si9CTGZIa0g0YkhFdVJmQ1BsR3VXY2xZL2tUVWplaU9SdjY3ZjJpaDZ4cC9RbzRReDdTNDhSZndKNkNwcWxVL1MwR2RMVklOMWhtbVAvcU9lbzl3VjdBRW5YYXhFYWVkUFc2UjNpaTIxRytMMjloRXlyOVEzMWdITXZNOFZwVDZFU3lGQ01Eb3BVQmxVUXJ5U3NVcDRHbW1rL0pTakI2Q0R2R09KWEtPZ3F3bXNVeDI3N2FTcmgvWnkvcUY0aFpnMWhpQkpoS0hTQVl1RWdsWVFSME1HY0g2TGlNQVBDQnNJclp2QXBwTWJlbEU2NGJlMUVnanowc2cyT2NlYzQycHJnV0F5M3VLNXpidm02QTdxZldtSzJBazV4T0pWRVhQSlRYTzRqZllhMWhRVXF3cUtEeWxQdDdVM3BoQm5jTnRNTGJjalFJK0pXcWpIV1F0dGljTXZYZU1LSkNuQUxjQXUwTGE3MVpuQk53alUvRENVOFNBVndpNFYvdDFWdzZxMEQ1UnpnVk9UdFdlLzJNRkFKT0pRNGgwR1dwRTByNEZBQ2g2QUo5TVZFYTNFdTkySVh0Q3ZpdERFSURrRnhPQzZKMmhuUWFJQnJZZFRXbkhBSWREVWF2ODZXaGVzSmI0TW1vcGRKak5qSjlrbTQwNUxvWWpBUzdtU1V4NUV5RjgwelZuZjNQWlN3ZHRkSGhRTFNCcVROUjlvUyt0dVFOdWw2UVNlYVFKNkpLVjIwZUErNExxekpkVEZDQWFsQ3BKTWRjS1N2emJ3SHl0UURMb1dLZTM4WEtSK096ZDdmRmNTZG80b2pqZ2JIYlZFdnhDTnU3WEJyN3FENWZEaDhoRFhGNFpMdjJoK3BYTVhoc2pUVnJ0NnFWcEY5UXZ2bTBKcThhSndQd01JK1plUzF3cmtHVGRCbVc0WUVBUW1HYVpDM3UwV2ozUjZlMWhXY1gwVXZYVU45MTJ1d3huTStrWHgzbUdtcWJkRzlTbWdhOWIvSWFHM1FFSzJCejNxRklIUVR3eW9IRVE1V0pmUE5SaVQvVFJndXhvVjlHa2FZdVo2dTV2dzY4dDJHcFU3V3dlRStXdmNqSldqZDR2Q2dFbTdGejloN3RMQVVQZWFvaWhaYTFIdE50TEk1c3JYTjBkaHBVeGxVQmJsVks5L3RiWXcxK1JpNjF0cUZQdDIyVXVPSGVOUjdTQlN3bTExdy94ak9TYmoyVXREWTZCNVpDbXJnTTBRRFNDa2pwVUpIcXRLMVdJcis0eG9GWFVyS1FyZTFZcjhYTkpNN1R1N2c5NEdSNkg2VU5aRXI3bk5vQVRucVUvTW5PY25WVEs3M3liV0FlVERwTS9naXo3MWVQZUVaYUdXN3o1bytSeXNtNW1TdW12cjZuYWZVMElXMVJuZVVKUFZ0VnlYaFNGdE9pWSs4eEdWdzVxNG14b1FXRWwva05Xd1Yra0NhSWpNbGZCYktRNE45S0pta1pCdWFYSVltRGFsTVA2RDBWY3B6dTVpQVBKTUlKME5UeVhldkdUYXhFUTZiNEpDbjJSQWFVUVBoR21pdG1UNGo3K2ZVc1FuYVlydlVpaFJ0WnRycGMweFRlTUlhc2V3KzlIbVJUa1NxRDFTb0hQVldET20ydVVVUHBJYjlJTVlOVnB2dlZqdVMzS01nckpkU0FXbGZRZHJQYWU4bUpHNlByTGtScVp0OWhyc0JjdW1WMEdSb0N1ZFRxZk1ldCtyWnV0L3ZubXYxS0NOZ2xvWnpyMm1KN2pVSFlmRnRXbXdMMVVDZGE2QzE5T3BubFB1Y01wc1UxMlpvQytkYkNaRllMZmFTa3ZheXRrTTdpTGZhTkZyOE9DMytwWGJaYTJxblRXYlBocGg2aGtmTkdOc3h0TEFSNjI5R0N3VUtjQTYrSmlna05nQVpqdElwcmhrZjYyaWdDSjBua0hxZ05mdjg1V1BaYmE3TmJXNDA2WXhwTENBUGJUUzZKbTVRaUZyZmo5WVgwUHB0VWVzZjgzbi9ZVnNIeHhnY0s2TldtK1pSN2lYb1pXZyt0TWhNYjFKdXNmMXh0elk0ZDIxQW02RE5rR3NEY20xUWY5SmVSQnNQb28zWmFPTm5hT01adFBGL280MTVhaWZkN0VHLzM5eUVMZEE3NFU3b0xwV0VLZEJVRlllN0NaR1ZrZHFNcGxyUVZIMllULzVYVktwcTVhS1Z1RFdqblhxZkl3WXFQNW9UQ3RCSUxScFpoMGJlRTlibHF4em1CN2ZtK3drankvVzVkNkVDTFd0WEEvRTEwQll6dFpDdjFTMjFFZW1TWVlaek50ZFRzV2JETDZIZjJvZDZoTjU1bEhDR3JkSmo5bVprUTAzUmFtb2tHbHlBQnBmb0QvYXVYbVdjdnNtMWQranovN0tGWWE0dEN2TzRkcXJpbEM1VWdjOUJSVWljc04vUXgrOWovWi9TeDRFK1hrNWQrYjV5R2syZUUvMmU5U3lXWDQvbGI2YXZhM1VGNWEraTdEV1VHMC84QmgrM3pacUV2Sk9ocWJhTWZoL0MyRzNUTk9xLzMxclF3c2Q2RkhyQ0ZpSDVRQ1J2anRyM0hleGdnNit1Rm1PMURkUzNCdDVycWQvN0hHMXRjdXN2MFZiRnRJMnd4WDZoSk5hKzNXWnFCMkVySzdVMit3L3RKTnhGLzdmYmRKbE54L3B6WEtOM3FUcE1nYVpDZDJzZy9WekppQ2lnbjl0WnRRZjZlbm1ncjVXTFpNT1FiRE9TVlNIWmlUcFVjZlJTQ04vZVhDK3lsVWlVajc2V282OG1YNEhzYjM5eGZZMkdUalRHaEVyUTFjZFlRYzhPdXFwemF4anY5LzBHVFNHT2p1U3JGT3BoOW9SemY3am13N1VNZmRTTFdSUWRMS0g5UnR1RHRrT3RVQnUwRTlwRjJYWjYyYXlKTmpaSEk3eVd0aVJwQzZQY1ZyamR6TVp1NW1JemI2TDVwL1VVNUhaRHpjelhjQnVpT2ZhQW5yTW45VjkydjE2dzE3Q2JGZGpNTEd6bXFUQ1A4Q1Y3Q3MyVVd3TWxqNG5XL1FjTCswSHFVdVZISGtlVC9QNEFWVEphUjlMcnZ2WkdlNWNSK2wwRlRlUkc4Myt6TGxYQzcxblVnMDMzSjNVQVZsYkdsVXJxcWlJY3lma28xK1pTNmlpVlc0aSs0L1V3Y3lHOXR3QUtJVVlkd3hWSHhrSmJTNTFWU3RCSFBxdjdLSzJVejE4S2pOSkcraldCVFM5RmhxRExvQ3M0OS80aHp3M0VzUlhkcXlKTm93NWZpL3RkazVHTEJBMnEwUnFveGQ1UUVpMXVoM1pBcmZZRU52aWNkcEsraTc1dEp6Ujd3K2NjK3NSbjNVcGZaK3hlcDVlNGhIZ3lrV1J2WWoybEthbmNjcmgrallLdjNTWVFuMEk0MVZvMGpSQ3BrS1pZYTZDMXhIZjV1cTRsWEdnTmNNdFhvZmZaeWRhbTMwTC9DVDBDUFFyTmdCNkRaa0lkKzdTSEtwREp2VDZJSGtLT0F2Y3ljK2dObzkvTVo3Q2VLZCsxQXN0Mi80endNci92ZitaWGZhVWdYM2tROTVXSHovOUphb284V3ZMdTRpemxMMEk1N3VXeUd2RnJTS09BTlpoTDVOYWtFcDlkWThLS1hLN2cxb2MvNjJ1VW5jTGp4RDc2T3BkbXYxWUJoYWkrRXR1cUNyZk9aUm9GWFdZdFhObXNRTG1FaXJqK0FXWHFxZWxObGFHN0NyZkdGYW9pUHRKK1RqditwSWVKWTgyUk5SNUZlZk83YVEvbDZaK1I3VjhKM2NkMTIweW9CNms1K2hmMTRFcHVweXU1WE1ubFNpenRTazdhV1N5MTdxR2RQaTVhb2xWZklqVU84bjBjREpmYkYxVEVXY0plMWtERlUydFhuOTBWS045SStlWFkyK3QrdnhxRDlVWTI1MzdDVk1KcDltWjA3OW9XM2JkaVdxUUNMYWF2Rzhqak16VHBMY2lUUkJ2YjBkSU9OTlBLQ0dnanZwTngzODQxd3haanRveDdXcFBQc0NXUmp4eEQ5aEJKZHJCR2t4dGYyTzFrQXRMZDYvZUw5bFM3a1FEdWVYQlB3am51ZmpFMjY5NVhvRFRTOFZzWFNGZTU4RnhjVi9sUW9ZYjVXQnVFZll6V2tUb0JheitMOHl0VXFTdUp6OUszNERJY0xxZnBUVXF0eEI1WDZVRFZFdGJwd0JEVDRIQ05Lc04xY0x1ZStBMkVON29ISDNIeDlqZ25VbnU3ejNNNG5LcmhsSUJUa2NZNnR3VGNFbkNyaEZzNTNFNlhjeVB2S3NyVUV0WVJObUJQYUNiZ3h6alhjZEMxem4yd2N4OVBQSktBRVg0VXZEcExVU21Yd3ZmY0RrR0tnNUVpNFY2SFM4SDVvNzRMY3hhU25JUWtGOGtsSWY4cXFCYXFneHJnRm9OU2toQ21TNUxZTFFsMTVyazFyYlFOV2dYVlFuVlFJSFdXL3o2dXVQc20vYkVuSCtOdXh4czBpclRJTDNHZlpKaXZzbm9yQVVLMFZ6S1kxc1N4M0J5c3RCQXJMVTlmWVN2NEd2TmU4a3hMemRQTWpLckVWcXE3V1RkaXZkQjJhQWZVaXUyMUVlNkVka0Z1d2RZY3JRT3JmYlQxaVdiTEluaW43aiswY0dYV3UrM1d2YnJid2dkdXZnYUJxQjFOalVFemRiUS9IKzNVcUlqeG0yQ3NWYWd5V28yMG9Lbmg4bnVKdFdzMDhURzJBOTBhdWpWZmdkQm5tcUE0Mmd1YURFMVJQelNYNDVxNzMyMWlORHdQMW16Q0YyMGpXbndCTGNhMEJ0cWtvQzJFV3dtM1FTMjJIYzN0UkhPdDJnR2ZWdmkzV1p0MmtyNkx0SFpMeW14N1pNMlY2ZFlNWFErNU5VTTNRaE9nbTZGYm9GdWgyNkRib1luUUhkQWthTDd2Zmd4VnJ1djBHUTJMZHVrKzlKU2NhRzh6aDVUSEZYU0dqNGVSZmgrcndXcllQVkZjUFh5dEZxVm9vUktSTjl5dTNPZyt0aVN5eFpVS3Z0ZVlINzVyUGNNbGRtaTQxUHFHNzlrQjRiTDJsZUZ5S3czZmI5OFZmbUFuaGl1c1g3alMrdmxkNlJkby9IbVBQVTdzRFk4OWxvcjlZK3JxZjRpMFZHeStjajNtNnlLWHdPKzROajI2ZTc2ZU9tdjJHcUxkRjhpOWQxVjUyM0tJNWFwU3dXMG0rSjJKWHhWNHZGMGgwa0NoN3hRM2Q5aG5UZnBLckpjOEZmS2FzYzB5YTZUTzRiNFhYR1ZKSDhQUGsrTWx5cTBteDZQa2VKYnlLOGp4SERtZW81NmZJVjBKS2FWK2wwOXl0Y20xeWFwQXZaRzdQemhjWllwUjgybEltNjhxcnVSRmV4dUIvTzJreGx5aW1LZlNJby81SGQ5alRYNC96L09aZkt3SzZmMlI5UDZoOVA2UnRLS0ovaHByRnM2R3pvWE9oeTZBTHFTR2k3RFJQSEljR2NZcWhIT2dDNkFMblVPVEhSM09NMU1Pc1g3aGJPVjZPbWRXRWM2eE51cHE4MXg5T3FTZnE3aWY0ZlVoYVJPV01kWTJVVFpRMHdZNHQ4RzVoUnc1NFdJRjU5eWJIRVpkeVVnbTl2Z3B0eldTdU5VNWRaQWFpVTA5c1VFTGwwRGZneTZIdmcvOXdKTFlYaHR5ZmhkK2wwTGZoMzdnZmMrWVI0ZVhLTmZQWTlodUcyWGJGS0x6N3ludU1XcEcza3U4eEFacWJxUG1GcTdraENzVlJNM09NeG54YTB0SjB1bzFkcEFHU1V4NTRVNXJEM2R4TmdXYUN0MXRwajdoYWxMSFFkZEMxMEhYYzJVODRVMUljaHZoUk9oTzB1NUNqaW5RVk9odXJ0MGpaS0MwK2RVcFVYMXhUK2xZSDNWMXJNZkxCV0tHdkpNNTk3cTVscEtLK0QxbXZqdC9FalVaTlJrMUdmTlNqTnFNMm96YUxEQlBJbFdzazFTRkxrT0hrbW1sNE5kSkN6Mll3MEtIRnNhb0sxQVhPelRaNmxGUnA5WWlZMXFMa1RGRGM4Rmw3TzBsdTI5ZGVxbWlia3QwN2lsdkIvdzZTeHJTSkoyVVVRTWw1WFdJOGErRVNpSDNCU3pwZDdZZTBVeTBTR1ZXUjhvQnZ2ZFlCUlZsL08ycWxoenQwZCt1cXVXNUZGSi92K0t2TjFxc1hKOC9ldWxrQmYwVytrL29FZWhSYUFiMEdEUVR5bkVacUlmeXdXZkZGZEY2NWIxb1BzWUQwQUF0Y2cvV2ZCM1F4MWNFUVl1Z2Z0SGY0ajVVS1NYZHMxVkF2czNVMGhDMTRETnErejIxc2FOSXpaZVJsejJBYUpWZFFxMUxOZHozbkh4L210Qlh6VWptZnc4aGpvNVVTa3AvOVpYdlUvdDhHcUxaUDhmLzNqTUk3dnZEY2JTOUgrMU1IQ1QzSjZGYk9KL0l0YW0yWGRQVVd3MitzbzY1SDduZW1vTnNhWWpaZ2pCSS9jTndhd2dIV0xQdlo4K0Fuc0VtWHJHZDNtY0I3cTJ1ZSs0OWZuK0tIVFNUbUVZOGN1aDAzYXVESmZ1Y3ZtT0d0eVE5RnVkYU1PTm9zVzFtMUpGcjdVYU1Ydzd0czhOYTlpcjNhellGN1ExVEVTaTJQOXRxbDduUm1td1o4UlhjNTJPMmlmQnpXeWtwV0JzdzVaQktLMmtiWjlibWY1dDlWZ1cwTzNYWW0zYWpMU1JzSTUvWlZxTm01ZHRHMndZYU9MdFpnZFJHU1NFaUNVdXdabTlEQURKRDUvblVISE11K2ZJRERiWXJJQkU3WitnMUxpa2g3TWFTRXVleWVtdHl2aHlwbWtWcXZZZmJQRjlDZnNDTkVpcUt6dDZ3MzlwbTZtMjA5K0hjdzBzWFNINWdvYlpNcmdNRklNWGtJZTJMMm8yTlJZY3RNU3hFVW1GMC9vcmRadk5Vb253Z3p0NjFWVWc0ejE2SDV6d3dUVEUwOWg1MXJSY0hNcXlWNEYxQWpubG9xMWwrY1A1UGFPUnp5WFgvcVlRdW43WlBiWmZYSEt6Wmx0dXo2T0laZTQ3ckg5SHFwRWdseDhmMnNUaElXKzczOTVnMWs2Zld0YUpVTHdTdnNka1dxTnVEMW42VkkyNXpiYWs5NERVbHU2eS9EV3J3MkdaTGZqRzdSclAvS2FHQnQrakp0VW9kbmJuUXloMGl6YlpZUTViNm1yM2MzaDRGMm91RGZwKzJtMXQwVktyemdaVkxVUDRYcnJuUkh1ZDNJZUc4VHEySVo1em55OGxzVDFxenRnNnB2N2RiN1YxaHoxeVg3YklOa2daSDF6WjRPMlRtWEJKUi9Bc2VqSWRmV3IyUHdkZU5zZXAxeFNNcmFMYk5ja2tNQzRZcnR1MW5lKzZoa0lydFMzdE9xQkpKWDdJNTloQ3lCcXZ2VUd0ZDFLdEMrbnBHSWRwaG5DKzM5L2M4TXR3dW16cmFFOGhYUEp2RlpiRzVsQzExdEJ3ejIrbHpLYUcxNjJzOGpFT0s2T3M1MG1zcStRTGFLRmEzUjhjYWJCbHpodGxNZXVjaHJNNit1cno3M3VyMmpUejdWbWIwL0xTeE5sU2lnLzRydTVpZkI2cmF3empvZWg3MFdKVEhTMXNEc1VwSUdkYzUvNEkxZHk3SllVMyt1NUk1NmJWczl3SmZnVVRjdi80Vm50WDlUN1dON0d0WjEyb2taK2Q3VWNmcjBwN1NyTm5lNXJmV1dteVp1anZ5NWJZQmgrNFBhZ2JKM1dmcDE3cXlrVDJmcGFmeUM5azdWbSt6TW10TDhmUjdYNGY4VFJuMURNdkNQZTduZTIwalVabjRmN050WlBGNnN2ZGNkdStMKy9OZlBGenU2NWcvMnJ2Mm9JYmJWdUxwcGFyZGs5aWwxRUd1eHpYd3krckdWbit0WXhqNXM5N3o0aWtMcFJWWnJISGY5V0NlV2ZwNWxOcGl5YlFyc1N3anBFMktmS1VYK0gzWjZteE9xalY3TFBYRjVtZnEzdHNqN0x0WjlLK281ditqalgxZmMrUXhlVmlWM2V0UWdmdURpYXk1d3YvblBaanZ2K1h5T215bmdxM3cxRHdWcWlSelJnSWRwUFdjSlJIRi9tcnMyVnNVdGFiYkk1cWZ0bGpTYWhYdjNnTWgvUC92NkU0N2JKdjIxUkgvcTUwM0VtazF0NXFsVG9wU3NXTDNlanJrTk90K0RXOGJvWHFyalU0TGJWa1hhOU1jeGR4aUEvRERHbFJ0OWRuM2xMTnI0K3ZaVDRoV1YzK3RNMy9PUHBDcDJWYllKc1VjTXJPNjNXdDZXMjcxSHE2M0Jxc2pYNk5FV0pmeUJKWktmb3hOMnovMUhiT1VIK3MxWjY2OTdGT2xIV2sxWnhuMTFKenFwLy91QTVuMzRrQ1hUL0g3cm0yMGVWbHNPODNiSWQvWDN0dDc1Ly83S3ZjMXE3V1hiRWMzSzllNDcwVDRIbDkybnZ0NHQrZHRld2lPcnNkdTlqTThoOW5lN0xCajJ6KzFPZlpQaXFPYlpaS3Q4M3FNM25XZS9sZVBaVmJ2bytVOWFJblNqMk9jWHk3Mmk5YkkrK251ZlNSYlFxbDVTbnlCRVp2ODMrdmViWTlxTDQ2b2RaVWUyd2ZIUHJHNlpPZFlkOTdlbDIyZHJmT1J1VEU2NC9uNzFKV3RhZlh2c2xYcW0xcURWTnN2TmV5TDdiOWh0ek9pMk5QN1JNL1c5VDRveUlQMmtOTU1tbWxYMjVQcXJ4SVZTL2FrdlpRYWd4L2JqK3d4anozb2Q2c21XMnJyR1lQdlpaRmpwWSs5K3EvY25uZi81KytMcHEzS0NNMzJ0RzlobHZIM3d2aFhXdGZ0K3U5Y0kyVmYyWnQ5MVQ2MTVENVk1ZTVyMjZoUmlUVXdzdDYxeDMwVTFxVjZsYmpWUjdGR3h0OXFmcE9FdFozV1NtTTdhdExlOTFLeXJmdEtHL3ZPbTdEay80WTFiOTV6bldpSzM0dzVjb2U2T2ZiOTZMWnQrM0xld0VxbjIyeTdNMnVlSmZheWg3Vjc5NWN4KzdXOWJQK2FOVWV0dmVGaFBkUzBWelhQdFI5MTgyVERmQStYZjRtYXAzWHpWOVg1S1ptVGU2SG5CK3pCYm1SK3o1NTNQL0wxN0Q2V05lKzFOcGJhOHlsdHRHUzNZck8wbWwvc1RzOVJ6Y3V5NjVscm1UVXZzdW5kV04yVGtmM3ZyY3l6dStuQmwvZEM1bVJhelROdFN0YWE1MGN5MSsyZE5sTHBacHNJeWlLZmFwTzEyQXZScFFBeW5wU2lsbGdxcVJpcmtlY3BnZUwvRS9iNXJjMTFXT0Mvc25WUmY1Q2VvWTJrSUZ1WnRudVNMMHBLaEZ6N24vODNJRXYrVmNnY2RLOXlsS3NlNnFsZWl2c2I0VVgrVG1xcGY5ZWpUT1h5dDR1MG43NmhRZHBmUTNTQXZxa2pOVktqTk5xLzVuU3BMdE1WdWxKWDZScU4wN1c2WHVOMWd5WnBzbitwNlI0NFROUDkrbzBlMW90YXBNVnEwQnF0MVhwOXBzKzFTWnUxUlZ1MVRTMUthcnQycUZWdDJxbGRhcGNGaFZnWUVvYUc0ZUdBY0ZBWUVRNE9oNFFMdzlYaG1qQXVYQnV1QzllSDhlR0djR080S1V3SU40ZGJ3cTNodG5CN21CanVDSlBDNUhCbnVDdE1DVlBEM2VHZWNCL2Zhbm8wekFpL0MwK0daOEw4c0NDOG9oaXk1WUJMbFFzR3FRYzRWajFCalhxQjB4UjNGSUR2cURjb2NweXBCTGhFSldDMFNzRVY2Zzh1MXdCd2dNckFVSldENzZvQ1hLUktzSjhHZ2lNSjBhUmpoQWFCc2RvZjlORUJJS1p2Z2h3ZENYSTFFdlRRS05CVG8wRS9uUWdLTlFaY3JVdkJKRjBHN29LL3Y5VUhpblVWNksxcndQNGFCOHAwTGZpZXJnZDNhendvMVEzZ1FrMENWMm95K0w2bWdKTTFGWnl1ZThDSnVoZU0wVFJ3dHU0SEkvVWJrS2VIQWQ5c0FGVmFCSTdTWWpCTURhQkNhMENsMW9MK1dnL08wR2ZnR24wT3hta1R1RmFid1hYYUFxN1hWakJlMjhBTmFnRTNLZ2x1MG5Zd1FUdkF6V29GdDZnTjNLcWQ0RGJ0QXJlckhVeVVnVHQ4ZWdsWVMwdy93R0tHNkdpc1pxaXFzWnpoT2cvck9VQ0hZVUgrVFpZd1FxT3dwSVAxTGF6cEVCMk1SVjJvaTdHcXE5VUx5N3BHZmJHdWNScUFoVjJyY3F6c09nM0UwcTdYRUt4dHZBN0U0bTdRSVZqZGpUb1V5N3RKaC92M3dZN0FBbS9XTjdIQ1cvUnRMUEZXSFlNMTNxYmpzY2piZFJKV09WRm5ZWmwzNkZ5c2M1SXV3RUluNnpLczlFNWRoYVhlcGNsWTZ4VGRpY1ZPMVJTczltNU54WExwRGYvYTJISCt0YkhoL3JXeFU3RGtHVG9WYS82ZFN2eWJZNFA5bTJQbllObnpsWTkxTDlBSjRSVnMvSHpGMEdNZUdLSjhNRVI5UUQvMUJRTUpnWXJCQUdHdi9GYXJCZ3dHUVVOOHJBOTFXeDdtOW5rZ0tLZjNSeEEvR09Ub0VCMU8vQWhRTG15WE9MWkwvRnZnQUIwRkR0SzNRYTZPQnBVNkJ1VHBXTkJEeDRHZU9nRlU2V1RRUzk4QmczV0tUa1BHMDBHQnpnQjlkQ1lZckxNQTQ4Vkh6Tms2aDVSemRaNktkRDdvb3d0QWtTNEVmWFFSS05MRm9GamZCUWZxRWxDaTc0RlNYUTc2Ni90Z3VJK1pLdDBFUnVobVVLaGJ3VURkQmtib1ByQ2ZmcUovVU5CUFFVdy9BK1dhcm4rbGRUOEhaZm9GT0VEL3BsK1IvZ0NvMEwvclFWcjZFT2poWStZQS9WWXphZDNqZWdyWlptazJyWmdEK3VoWlVLVG45QUx4dWFDdjVtaytjaTRBL2ZVS0dLdy9nUDU2RlF6U2E2QmNyNE0rZWdNY3BEZEJzZDRDUGZRMjZLbDN3SEQ5V1graEZTdkJNSzBDQ2EwR1ExVUxocWtPSkZRUGhtb2Q2S2NOb0ZBYndYN2hzSENZUm9Tand0SDhqZ29uOFh0cU9KT1I4MWg0RE50NlBEek91TUx5K0gwcVBLWGU0ZW53dEw0UlpvYzVYSDAyUEV2S2MrRTVVdmorSGVQbjkrRWx4Y1BMNFdWYUdpdm9xMXlwNE03Q1U5U1hIaUhxNzBwczA3SDJaMnUybmVyQnJ4RU9VTjdYczN0TTdjM1IzMnRpQmluWDJxelIycTFlWSsxVGErSXFJS1doZTI0ZDVKV3Q4WFBPUEN4Ti9YVXc2Q3Nla2J5YjVmS0NEcnVkYWZtMjJucDFjOURDQmZ5YUlKZFVybDI1MXhrbjVhdEx1eXlxUmRiaXNpK3g5czU3YVJHZllJK2hQY3RTMitzWnZsTE04M3Q1WWwrUFBTU2o4SDEvKytZcHFhdS9Za1c1dXVGbzgremw5S2U1c2FRL1MvNG1UNU90MUg3V3B2NjI5TXZ2dTlyeVZML05nemJZZzY0aFQwbUZTRzUxM29ML3g5YWI3WGwveFZiWnMrVGRKWGtlZnBGMEIrR1dhRzgwaDJ0ZjZiQkZXR1ZDMkpjdDhIcGZ6UG9rLzcvWXl1eFAvbGx0eHBzbUJTNTVKVHhpSFVmZ2w3VU9TdVZiQzcreWR5eEpiSDdLUDJ1TDZnd2Q5ZGZ0MkszUHNQdGdMaS80V2c1clVyQVdIMnNiWGQ2M3NqNjUvMEczOXZ1TXQzMEp0QmxLVXV0S0g5Vk5CdHk2WWw5dGZrZzlxZnl2MVBpRzNkM2xtS1FIUFBhb2ZXWnQwV3pWOWZ6d2ZKUnpXNnJzT3JrZHA2emhLeDAybnhyaVh1K0QvcDdmMzJYTi9XKzJJZHZPdVUyTDVpOHhMcE51SHpQOTdIM29CY25UVm53TmMvQnlORGlkY0piOUVJNk4wWWhwOVBycnpPdzllNXF6NW03LytsZWdFRW4xYnBRalJ6MGxWU3V1WW9Xdi9uU1R6VW45MWIwVWlpbWc1VHBKUTExU1luNFUrN3RUM2UvUy9sTTA4cXR0Szc5dUlaTFgxRTRzWDFKQUUxL2xLS1QrdDZ3ZUtSKzB0N2wvL1RqYVNkeXFJYVFsclEyYjN1eC9ZOWhvRFpMeTVOYXpCdzNUWHBmNEQ3WTRwZkZlcnQrRXZwYkRmczRZYXZJMjEwVHJsZlcyV29KTG5xMUFMeTBxc2xhWDBhQ3pYR0kvdUY3WGxiekcvWUtXejR6MEdHeVhYRjZ2bzhHTTgxUnVhdDU3ZWYvb3E3QzJsTHlyYlpHa3VOdks3KzB0d2pZL1cwdXV5V2xsTjlpT0xuZWhMSXJtUzdZNTFkcm9LdFNZdGpyY0J0ZDgvOFpwSGVGSDVBNXkyRFpyQk0zd2FiZDNpZTJFWDlkSHZQdTNBcUo5M1JiNE1FS05RMEdIK3pmVSs2aXYrMkZWd3YveUwxL2ZwSnQxcTI3VGZiNlNYNmxWV3ExYTFhbGU2N1JCRzFtakh4VytIWTVtZlg1c09DNGNIMGFIRThLSllVdzRpVlg2elBCRWVJcFZPU3R5MXVQUEthWkJ5Z08wRWhTb0Q4aFhYNUNyZmlCZnhhQ1Bxa0FmbHlESFBhS1llMFE5M0NQSzFXMGc1aDVSTDVjcFZ5dEJiNjBDUlZvTkNsVUxlcXNPRktrZUZHb2R5TmNHMEVNYlFTLzNMbUx1WGNUY3U0aTVYNUdIMURNVi9DdmF3ZjJLbnU1WHhOMnZ5SE8vb3FmN0ZYR2srTCtVQTBxVkMvcDcyeTVVRHpCY3ZjQ0Jpb01LYisyRktnUWxLZ0tGM3ZMenZPWEhpWllUVDRBUjN2NVRWUUx5cWRXL1B3Q0tOQUQwVUJuSVZUazRWUldndHlwQmp1c3IzbUUvWjM4TkFtVWFESTdRRURCV1E4R1J3bnNtanZkTUhPK1orTUhnbThKN0puNEVPTks5NTdHRVFIalB4STl5Zk50eHRHTWtDTzVEcy9zR1lzS1Q1dXc0Y0laR2d4cjNwOC9TR0hDb2U5V2ozS3MrMjczcUU5eXJQbDU0MWNUeHFray9DNXlqc1dBMForZEFlTlVRWGpWNThLcUo0MVVUeDZzbWZqRVk0MTcxU2U1Vm42eExRUi9oVzhQbk10RFhQZXhUM01NKzB6M3NzM1FWcUhaTE9rN1RRTGw3MVVlNFYzMjZlOVZIdWxjOTFyM3EwNFJYVFJ5dm12UUh3TGZjcXo3YXZlcGozS3NlcTRkQlQvZXRSN2x2ZllMNzF1Y0kzNXI0cytCYzRWc1RmeEVNMUZ4d29udllKMnNCT0VXdmdMT0ZoMDM4VlhDT0ZvSitXZ1NLM2RzK1VxK0RFOXpiUHNxOTdUSHViUi9qM3ZZWjdtMmZxY1VnejBmRmNUNHFMdlpSOFYwZkZSZUpVVUVLbzRLVWVuQ1JqNHJ6dEI0Y3BDM2dNTFdDdzMzLzZwQXdPQXpXd2I2TDFjdDNzZmJ6L2FzaHZuOVY1ZnRYdzN6L2FxanZYdzEyNy94NDN4MGE1UHRDQi9pSXVzQTk5ZlBkVXovZjk0Z0crRmk2d1AzeUk5MHZQOWI5OG5OOTE2alNkNDJZZncvNGpYS2xBM01QcXNWMi84bmZHbSt3dFhpU0xmYW1OVElqTDdGUGJMYTEyMDVvbWEwRitJRFdSTmdNa3ZheHJUZFR3allRYnJIMW9KRnJTZWdqN2swTDdBK2t2RzltN2Y0K2ZwMTlhSytwbEpueEY3Yk9raW9oMzYvdGIyeUdyVk9OUFVEOFB4eS9Ca3ZzWTdEQmFtM0RYcTd4Z3kyRGs4RjlIZExQVkpHMStmdlRTSTRNaTF5UytkNEs4MjhIUEVlSm40T045am5jbHFpTHcvMDcrVjZDK2ZrdWFCbG43Vm1meEF6cThrQWFTOFViWE9ZT2J5cjV1M20rVHBaenp2SisxMUpLeDVESzcyejJzaTBIemRZQXRYYkp0OVhhdlA0a1pmN2ljbnh1YTh5YzJ6YXUxaHQxZ1ZiU3R3blovS3lGMUJhdS84VmVJS1dGWEphU1B3L0ltdFAvdm0xYlBWVFhiNWZhRGhYdjZhK0ZIVm9YMGxaVjhYMzN2THpiZ1VsS1JDdTZoTFVqWTh5ditVSDd0N3FXU09lS0gzN2VDcHl2UXZvcWdCSnQvdHZCcHpRZkIxbmZjeXo0NGsveUVjWlNaNkdEcGVSbkh4MWR4MmwzTE50ekdlam96eG44elZPVEJ0SzlPK1dZUldlVytZNGtkclhTSlhXNzhIektHSEZ4QjJGS0x5MStucDVIbVo2WTFYdDZhaHp0cnRrMnBGSTdsVXAvUHNqSFViTS9LZHNjK1JwNTZxT1E2ZVdUaXNhd0JIK2VLRnF4ZWcwSy9sVlJSYVhKNWZGUFBWNmE0amFiM0tRcTMzT2s3VjkybE5GMitUeGplK3lYc0RmUDRxYkc1SmQ4Mzg4MjB0cGFILzlmOE9tS1RNL2VPREtmTTgzTzFkcDlObG5wdk9lWjJjZVVTK0NCZlN6Wkoxelo2cmxxZlgvVU5VaHNneW9KaWZudlM3Yk5aNit0MWs1ZkxTTytBdjAwS25DMm10UW1WVVgzQm53RC80MURValgzczQrZ3BVWlp3aGM2OUZJYnBWc3lkZDVWaTMwT2JjTHJXVzZic0poV0gvOXhXMmRMRld3UnNqeHZ2N0cxdHREbU1ydCtDcWMvMlVaNUtYL2orUzE3bTN1d0dmelM1MzZiSjFGK3ErL3l0VkY2QjJjUFlTK1VwcFpGQUhuVXl4YTVSMDllTkdlcTlDdnIvSGNMMStJZSs4aitCSmJhSjY3dllNMWVBL2RwZm1lUlN4cm91WDRHTGRJdzhzNjNoZUFqQjMzaCtNVFdwZDZ5eXh3eDBaRyt3NjIrOWhtYXprUDZGdnZBZnE5S254RUNhVUs2alg3Zm9UMSs1SnJacXhwcU0vRVQ2NUJ2aGIzcmRRVW9YMFZBa2QvNEo4bWZlOGNqaUViUmUvNXJtZk5MYW5kNGZlWnpvVTdvSXUxZVcrZmxmQjd2OEV5UW9mUFZicVZMclIzc0FqdU4zNHgzcWVza24xZVdRN1B0ZFh1V3ZFdDhUc3BMM1RzeXg4N24zcDUzclNYeTEwT2szeUwzSzF2TTB5R1JwOG0vamNiaGZCNUhSMjIyVE5GMXJ3ZGUxcHhhVFhpK3pIazNZNjVldCtkeG5hYVhsRGJTWTlHSVdKcDF4N2RPUGxzNVZrVFU3Q1ZEdGpzOTdYdUgwV1FkK1N1ZXVnTjEyVUpHMkF6emZzaVlkL3crcG1BR3RmcUl3dkpTS3dyOHhZeTVxbDJsSGxycU45YkZzNDdVRjBuUzlWMjU4eG9vQUsvTDU1ZUlwMXVWdVdXMWU2MXRuZld4ZXhmRXJTS1AzNjBLMFRYanZOR2FYRFBHK2RiVW1DeXlIYTVCYWxkd0xkaHV2Vml6NUdRZDVuOGtTYk9ZOVBYTFo4cUp6akxzaEpwVG11anFHeEhXMEhFRzNmUDdUUFpKMmpPZ1RkNHV0MnBhRUkyampCN3c5bkcwWWMxeDErUDJTQlBFSVdMK2ZDbEg2cjdaRzcxc3M0M1UrZ3BYL0U1bGZrZ3FNVi81dXcwdTVHeXRwUDZjYjVCc3B1ZXBWcFd0SkZJck5PWWxWNnZmN3RuYlhvZTJ1SHhEMGl3aHhpaCtqYkRBSGxkTU5aN3lrS1FxbFVMYzg4aGZvVXJpUTZFaHRwalFvY0gyRkhtWDIzVDd0UU0vS29VL3UvNEtPajUzaHB5K3VwZC9neFVrN0hmMktqVzAyUHMyei9nS0s3djNEeksrTmpMWFBteFBxdFFlUko0YXpwOGxkVEU1SmlCaEh2em0ycXFVUjlRR05Ybk01RzExTDZNdWJRZk8wdkw1YjBvdjF2VlhTOXovc0l4NTEyT2V4MnZQT0NvVndmZTFaYldHSEZiUHJMdkV2eXZISE55bGxiYWxmWUhCVTBEU1E1TkxESkNOYytCelcwZjdYMk96UGZleURtTTBINGhacmNrbHpZZlFPNXJjS3JlTzZJdDlheU9OMVVjcjFVUmErNkpZaG4zSHFLWFdjOHp4YzQ5NXlSSW9ZZTkyOGh2ZFZxQmlXMFRwV3FSOTJlWUN2Rzc2K3pXYkNieTlLZ0FwSFhCbHJYRS84WHJ6UVI1bGx5cm00MjZEYmZGZGNkWlZnSFQ3aEN1UGlSck03TStrcldmVS9zaG50Vm51RlhYVXk3UFdET2FoVVVZRmNpMzNVZk5RNUZjTHp1M3VDNzhoRVh0YlN0bU50OXB6dDdza3pidjFRbjB2a1NyN05kVHNOdmVQdmlwSnVGNGU5ektlRXhLMUpod2x4R2NvaGs3dXhQNS9aTlBzUitCbW0wNXNpaTF6SHZrZzZnM09IOFMrUHJSMUtiMEU5UGM3eGJDeXA3ZzJGMjNjYlg5bjgrMHRKUG9WZFFlYnBoalhWOXJ2U2Z1UTNCZHcxbVkvNVB5OXlNcWxJT3FPdkIrWE5PT2JObkhGTTFmVmFWYTRPVFhTU3pyNXVhMWVmK1ozb2VJZUZuZnlBNnBBcFNDa3lIcGsrdmowODQ0VS85VEsxZHV3M2xhcUNNMnNUdDJ2WE9yVVdkdWVlV0VCOWRUajlaT3pQZldYQThxQVpLUXZ2NCtrTElqUXR2bVpPdHdMbW14YitsLzl5ZEVjcmFRc09qZjZrVU9GcVhLdC9ydlpHb0h2SG4zMVoyaWR2NGVkZlRWdngycGp6TUE1YVp1eTFGTVBXYXJHZWRsOWYydlpzNmVmTnU4bTkrWUxQWEQrR285MC85Q2FPMzNwaGwwdXp3V3k2U1UxYnhQYTdDLzc5cjF0MnEweitLYnVTOEplNVBibzlqWGY0OVpKcHh6ZGZxbUplUGVIMjI1ekoyMkhTQk1OMk1tbnRrTFVCdGZOZS83ckwvS2FQSlM2MUV1OFkwbXpQZW1GZW5hbGN0WHYzaVZJNldXejY4WHJOK3RvbzVrdHR1YXVkL0xJRmI3b0x0NmVyMWdMNDJpcDNLT3oxczdmZTRxT1lkN3lhak1OVjVHR2dVanJIdWZ2TUZHZUVzV2pxNGQ1V08yL2drb2d3UFVFdjRkRmYvbU9ldzFEYlptbjFhZ2F6cHc3aHRseWZqdWlENXdjems5bVZnL3F3RExqVzVuME1ML1IzK2Rya0ZTcXpqSmp0c0kvWHduWGRxNy9KaFFrMzhjOHdsN1g0VHBVKzVuQk5WV0x2WVQ4VlpKeU1zZFJkUFo2MS81Z2F2NU43bkdmN1hOcnkrenh5SHBxRlVuczhhNXE5eWQwdnJiWnhUcU9JK0tkNXNyTzgwc205OHh5dGluS3M5ZmZ1c3RTSnQ1OXVYMy8zc0xlU21ETktYdXdUcVVTeXN2c0RkTDBGZlMyNzcrTGsyN0xlWmJNVmpxTHZiamY0V3VMTnZjVFRFcmJaMmpKMkRFN1BHT2ZKWmFoU1VXN0owMFpYN2N0NmJEalBTeHpQMUtaUjBpRG42ZnoyUE5PakRVNi84MVc2M3BabHRxRjJlZzJVS0I0NS9XTjZ5VmtHVWZKUGF3dHM5K1BJbDJrNzZiL040MmJ0aTgyYnN5eTUzTHZ4ZlA1V21OdWw5K2NNZWVYN1Q2OTA1OFJ5cERPR2pPL0VXQy82OXdLNTdQWGg3SERubjBWczZmUmJodndIejBIZkxQNEFTNTkzRGI0MmFPN3I0Q2s0b3I4QU5BT0xMcmlJTzRFV20xdHRLdVdHaTJrMXRvS2ZqL3hYSFdlN3duL0paNkdUZWgxcDd3bVNxem8wTHBka0tYMlVHTWR2d0tUN2RuZnJwNUo5cGgvTlFKd3dIV3RYTU5RSTJSN1hnUFo3T3p6dW11cTIvRmg5V2wvcWQ3VmFiK3VMaVAvcHE2NUtmcHJzamdIbTcvc3VzNlNhWFpRNTFwb1F5OU5lLzRDa3NzN0dCcXU2ZzR0OHRackdLaVVvTUxVcnNmQkdmTjZJbTArUER4cWZSeElKYzY1QkNva3JTdTltUWNsbVczdzV5RnErVjNpNjdwNmZwZEhlL2cxS3N3Njk4Yk5mSSt3Y3ZlemxmNmJaeHdhWmh1UnJKQ1VvR0pWcCs1YUx5ak9lUjdvT08vR29YejFsdXpqdEMrTkZnSkY1eUdhRCtKWjV6dVhCdnZNa1pleUR4VFZaUittdUhWK0FqWW44OTZFTGxiWXAvYWhQVzhmMkFMaUgxSSsxek9FN21kZS84dDlqa3RVNG5xT0FmK2JIUko5cXNCWlgrSTVJRHJzbHdxZzgzMGtHbysycUR1ZWU1TExHbTFiS3I0K2JiOWh3KzcyMk92ZGVvZmVUMS9lNnphT2RIODY3WXBoRy9oSWZxZG95ZkJFOHpyYlhxcW5rOTJ1cEFZcjI1Rkk2OVBpVktsMGo2Ym1TMzF4c2ZvTHIvaUM0aUN0ZnVQd3E0SElMbmtNK1ZKdkJSQXZSelB4THZUWkJxMy8wbjloMzliQlhqYW5XOUkrL2Y1NTluczA2MTJ6VkxydDNyZnplSGYzam9UcnIwY251V3Mwc01PekxKbCtBR2xwTmw4VTFlUzF1R3dKdjJNWFJHbGVvc3UvTjNaK00zK0pMWU9XK1ArY2VjNCs1WGQrbEtzQVpOZktKbm9pUktPelpQZTl6allSTDdiM0ZBY2w2WHhKUlllZGVqT2U4c1ZyTXl5M3VwTmVLak5IVHVjeld4R1Z5cmNsNGhlSzJ3ZFp2Z1lWT3MyN3Z6TytGMkh6N1gvWmIrMSs0ay9hazg2OTIvOGlZYXhLYkFYOE5udFBGTysrRjVPK0Rva1dTcDdlbHFhWFI2eDFELzUwM00vK2xIYXhHR1FlaWV5ak95TVd6OUJZcEMrbEgzbmRlNFZlS3NqOW0rd1NwTFd3TW5YbVdrM1ZQUURLQTUybDRGNmx3VUFhcXVFS09sQkhLRmZmMHRIcXJXTkFQeDJyNDVUUXlhazNYZy9RNWZvKytYNmlYMm1FSHRCRE9rbS8xUXM2WFhPMVVGZnFOYjJqRy8wcDB0dkQ4K0ZsM1FtUGN6UVVCQTBEdlRRY3hIUWd5UEhubC9OME1PaXRRMEFQSFFwNjZqQi9sdjBJMEV2ZkF2azZDaFRvMjZCUVI2ZmtLOUt4b0krT0EzMTFNdWluNzRBcW5RSjREaHRVNkRSUW90TkJxYzRBL1hVbXFOUlpZSURHZ2pLZERjcDFEcWp3WjVZcmRiNHVvSjRMd1FCZEJHcDBNZGhQM3dYZjBDVmdrR3RrZjEwT0J1djdZRWlITjN1RHB1dC9FZjluLy8vTlB3ZTk5QXVRSjU1RUp2NEFpUHVUeUwzMUVPaURIaDlEL3BtZ1JJK0RZajJocDRqekpESXl6QUZWZWhaVWlpZVJpYzhGMWY0TThpQXRBSVAxQ3FqU0g4Qmd2UW9HYUNIb3FkZEFUSytERXIwQkN2UW0yRTl2Z1Q1NkcvVFZPMkFJUFhlcVNzTnA0VFFOQ0tlSDAxVVJ6Z2huRUQrVEhxM3dwMzF6L1duZmhEL3RPNUJhNjVVTEJyaUYzYU1ldE14OWF0THl3VDBxQUNOVUNBNVJiOUJMUmVBdzlRSC9vTDdnZGxyZGozZ0NITzF2THNqZkhMaE5BOEVnN1FmNjZ4dWdTb1BBRWRvZnhOMXkvMFpEZ056Q3h2bXo4WExiR3VlMkpiZXRhL3paZUxrOWpkTTNnWFFrR09lMkpiZXQ2OXkycm5mYkd0L2gyZmdiT2p3YmY2UGIyVTA2SHZ4QW8wR0JUZ0MzNkVUUVEyUEE4VG9KeUcxeGd0dmkzL3ZUOGxQZC91NFE5a2NjK3lQOUxERGQ3ZThmL1duNXYzZkxtNkx6d1ZSZEFLYTQvVTExKzV2aTl2ZFR0NzhmdWYzOVdKZUNVOXdLcCtreWNLbmI0ay9jRm4rbUg0QkNYUUV1MTVYZ0ZsMEZldXBxSUYwRHlqU09Oa3Zqd2ZkMUEvaTJiZ1RTVGVCV1RRRERkVE9ZcEZ1QWRDdTRYYmNCUXRvalRRTEhhakk0aHRGK2w2UXA0Q0JOQllmcWJpRGRBNGJwWG5DQTdnTjM2b2RJTDAwRDMvU245Ly9HUjg3ZitzZ1o1MC92eThmTTFUNW01R05tbk80SGczM2tYT3NqWjd5UG5CdjFHeUE5RENyOUdmNEovZ3ovVkI4NTAzM2tUUFdSTTBXTUhPSXZnaElmUDNmNytQbXhqNStmK1BqNWV6RitpTDhLcHZ2NHVVeUx3UGQ4RkkzelVUVFZSOUYxUG9wKzZxUG9SaDlGTi9rbytwa1dnN1AwUjYyUS9FbisyN1VTM0tkVjRJZGFEZTVWTGJoUGRlQ0hxZ2YzcWdFa3RBWVVheTNvbzNYZ0g3UWVTQnZBSkcwRWQ2cFJ6WkkrQTZQMU9UaEJtOENKMmd6R2FBczRTVnZCeWRvR3ZxTVdjSTZTNEZ4dEIrZHBCemhmcmVBQ3RZRUx0Uk5jcEYzZ1lyV0Q3OHJBSlVFaFNQNDJ3YWlRRXc2Vi9LMmJXOFBoNFZ2RWVmZUcrTWh3REhIZXdDRitjamhGOGp2QUhlR3NjQTd4YzhPNXVpcWNGeTZRL1BzWVY0YUx3bFdTZnlVang3K1NrZTlmeWVqclg4bm81MS9KS1BXdlpKVDdWeklxL0NzWjFmNlZqQnIvU3NaQS8wckdmdjZWakcvNFZ6TDI5NjlrRFBHdlpBejFyMlFjNkYvSk9OeS9rbkdrZnlYaktQOUt4a2ovU3NaeC9wV01VLzByR2FmNVZ6Sk85Njlrbk9GZnlUZ3ozQnNla2Z6N0dBZjdleEJqL1QySWlmNW1VWkcvRGZGMy9uNVJiMzhuNHUvOG5ZZ3IvRjJqeVdGV21DWDVHMGQzK1pjMHp2WjNKU2I2ZTBlVC9iMmp1M3dtSGVjejZjMCtrMDd4OXlieS9MMEorZGMydnZYL0FvUTEwd2g0QVlXV2EzQ1VWeDNHZjcvMzNYMnpoQlJDQ0JCQ0NDRU5FUkFaQk1RWkNRRkNyS1ZDdUlVQUFWTEN0V2dJU0VMRlFtc3ZsRkpBcmJjV0tsYWx0TlRlck5WaTZ3VTdqdForOEZNLytLR08vVkMvV0RYMnJ2VldQTE83WFRjME04NHo3Kzg1MmZNLzU5MDVPZlA4RjRGU2JvN0dFclZldGF5ZEVUM2QvYjIwa0FLNGRJa3hRRVNLaEF5bGxER0NjaXFvWkN4VlZGTkRMWFhVMDBBalU0dldTRXlhRW9ZeG5Dc1l5U2hHTTRaeGpHY0NFNW5FWks1a0NoOWdHdE83dTN2NmVUZkhiWUVtNzdGdmgyVTVidS9kdThlS0hIZnU3OTVtVlk0OXUzZDFPeS9IM3JES3Bqd1A3Tmx2UzQ1NzkyL3Y5ZW9jKzhLc2JYbnU3dDFwZTU1OXN6NXNaNEd6M1ZMZ0hIY1dPTmVlQWovaS9nTG5lYkRBajNwVG5nZTI5bm5rUGU3cjgzaU8vZUZyZVZlT1FBUUltQjlWQVpJQnJtQVlwUXluTEl4R01KSnlSbEhCYUNvWkE4aDRRQ1lBVWdMSVdFQ3FBVWtEVWdQSVJFQnFBWmtFU0IwZ2t3R0pBVWtCa2dBeWpnYXU4YUhvZVBSQzNCcTBPdTZQejhaUHBLYW1XbEpkcWNPcE02bUxxWmZUbWZTc2RHZjZaUHBDK2k5SlhmTGJrcWtsejVYMGhPZkZUSktwenN6TXRHUTZNdWNRa0F3Umo3TEdHNzNKejN2UkIzelFtNzNGODk3S2dGL3dpMzdKdS95eVR6bkxoL3l1Mjl6dURuZTZ5K3ZjN2FmOHREM3VzZGU5N3ZNejdyZmZBMTd2WnozbzU3ekJRejdzSXo3cVYveXFYL1ByM3UxajN1UGpQdXNwditjVG52WkhQdTB6L3RpZitGUHY5UnVlOFp0KzN5ZTl6eC80UXdiOGx0OE8vSTVudmQ5enlCb1NTc2hrNzI5WjBlbFBwSlpKMURHWjZjeWhtVVY4bkt2NEJGZXpsR3Y0Sk10WVRoc3JXTWtxVnJPR2RqcFl4M28yME1sR05yR1pMcmF3amUzc1lDZTcyTTBlZXRuTFB2cTRrVnM0elZudTV4d1A4Q0RuZVliZjhDSy80L2U4eEN2OGlUOHpJRTZ4MFE4Nnd3ODVreGlRREhLUks2aWprZG0wc0pJdWVyaUJZOXpOT1o3a2FTSzdQVXphNWE3alZXL2piNVRZNW5vT2VZUy9POStmazdqQ0RmUjdPKy9ZUk9KS096bmdVZjdoQWhKWHVaSFh2SU4vMmt6aWFqZnh1c2Y0bHd0SlhPTm0zdkJPL3UwaUV0dnQ0azJQOHg4WGs3aldhM25MRTd4ckM0a2RidUZ0VDNMSkpVUnU5VUpnbno4aklrVWNCS09wUVZxRGhyTTJxSXdFaUNpbGxoampabVJHM3FHZW1JamFlRHBTVlJoQlBTSWJNYnZ2MXV3WnBnb250VDNydzZpa2hnWm1NSmNtV2xsR3UvT0pxYVRNcHVCamdpOElQalo0Yy9CeHdSY0dyd3ErS1BqNDRJdURWd2R2Q1Q0aCtKTGdOWlFoTXJ4dzg0Mk84b2ZDWDFGMGtGSmU1UkQ5SE9BMVh1Y04zdVF0M3FaUVFRM0RHWEM1YmE1d3BhdGM3UnJiWFdzSEVWSkJEUlR0UHRWV0VpQk5PZlhNcFpWT1lrQmFpYU9LcUNJNHhHRk1CTE14UEVDK3BvN0l2d1pDVE9STGxHTjRBRVFxaU5IbmtjcThRejBTVThHQWpTU0FaSWdCUFl0MjVHc0d6eHdqOHBSTlE4NzFFSHM0cUc3STJUWlNkbVVWRFRrL2s3VE5PZkh5a0JWbEpOYVlGODhPVmNNZktlR2RJcDBac3VvWFpIaGhrSzRmc3U1ZWh2SHdaV29ic25JZm9mZStUdzFGdDNpZ2FJVlVJTTJBd0pWRVFRTkJ1TTR0T0tpeUVxbkZ3bDRSTXBvYVFDUW1RcGZiQWUvYnY3NTQvOXdhdDNxSVVpS2tsYzFRZEZmWE04M0QrVndQaWU2dDN1WVJiL2VvZDNqTU96M3VDVThXSmZ6L012b2VUM202a01iM0dUSzRLSUduRWVjek9LUXZvL0o5Ynl6anFHSTgxVXlnaGtJYUYrVnBMMzJjTGlUbksrS1VRbG9XdmpXTmxHZDcwSGxEdDhsM2o4ZDhQTnN0UWwvSWRnVXBKNlIvWU1qNWZHN3ZZUzhocDdPSkhQSzRLRlhtWlQxTldUWlg2cG5xcjRoWnlqS2Z5L29LZjBuRVVuOGR1TXpuQTFjZ3NyUW93MXNvcFpwYTZtbGtPak9aelR3K1JqTTZIMjFDRjZETjZFSjBFYm9ZYlVHWG9MT0lnc0xiZ1RsQnc3Q3djK0lKUktZWG5VRWxKVjRvN294RVFhMUJjSmJ6T0dqOWRZaXNIZlRaVTRpWHZlY1JSQ29IZmJZU2tYMUY3MjVncE4wTW5YR25HUWlTa2NSVURQbC8zMGpJbnFMZDJtaHduZXZkWUtjYjNlUm11N3pXTFc3OXY3OGoraTcvSlVIaHptZHZldWwvQVVCbW5yZ0FBQUE9XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9zdHlsZXMvQ2lyY3VsYXJTdGQtQmxhY2sud29mZlxuLy8gbW9kdWxlIGlkID0gNjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///61\n");

/***/ }),
/* 62 */
/***/ (function(module, exports) {

eval("module.exports = \"data:application/font-woff;base64,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\"//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc3R5bGVzL0NpcmN1bGFyU3RkLUJsYWNrSXRhbGljLndvZmY/OTFkNiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTphcHBsaWNhdGlvbi9mb250LXdvZmY7YmFzZTY0LGQwOUdSazlVVkU4QUFLOVVBQXdBQUFBQkllUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCRFJrWWdBQUFOZEFBQVhuSUFBSEp5WTdJQXgwUlRTVWNBQUd2b0FBQUFDQUFBQUFnQUFBQUNSMUJQVXdBQWEvQUFBRDNlQUFDTzdQNWJ5RjlIVTFWQ0FBQ3AwQUFBQllFQUFBcTZFSndRMzA5VEx6SUFBQUY4QUFBQVlBQUFBR0JSQlZQRVkyMWhjQUFBQmNRQUFBTG9BQUFFWGh3VTNOWm9aV0ZrQUFBQkhBQUFBRFFBQUFBMkFBWXI1MmhvWldFQUFBRlFBQUFBSkFBQUFDUUtsQW43YUcxMGVBQUFDS3dBQUFTdEFBQUhSTzVFRURodFlYaHdBQUFCZEFBQUFBWUFBQUFHQWRGUUFHNWhiV1VBQUFIY0FBQUQ1Z0FBQ0dxZjBkZTFjRzl6ZEFBQURWd0FBQUFWQUFBQUlQOWNBRkI0QVdOZ1pHQUFZaWVGMmJXZjQvbHR2akl3TTc5Z0FJS3pQVlVmSUhUTzAvK2wvNzZ3SlRML0FITFpHWmhBb2dDYWtnODdBQUVBQUFQbC92UUFBQVpGLzNYL1ZBWmhBK2dBMWYrMUFBQUFBQUFBQUFBQUFBSFJBQUJRQUFIUkFBQUFCQUl0QTRRQUJRQUVBb29DV1Avd0FFc0NpZ0pZQUVvQlhnQlFBU29BQUFJTENnUUNBUUVCQVFLQUFBQXZVQURrZXdBQUFBZ0FBQUFBVEU1VVR3Q0FBQUQrL3dNcC8wRUF5QVBsQVF3Z0FBQUJBQUFBQUFIeEFzVUFBQUFnQUF0NEFaV1V6VzVjTlJUSC81T21TVCtTQW9zVzJGU0hEd21KTkRlVHRndVVzdWswU3FrMFFxaU51a1R5WEh0bXJQamFWN1p2SnRNbHEwcThBMHNlZ3pmZ1hWandBSndjV1plcktCWGlldk03MzhmMjhRWHc1ZWczakFENXZoLzlVbmlFSFR3cnZNSDhRK0ViK0FhL0Y5N0U1NzNQVGViVHdsdjRGRjhYM3NZWCtMWHdMV3oxc2JmeEVlNFh2c3YwWitFZGZOWHo3dWo0QmdyZnc4Rm04Y2Y5UWQwSDJKYXVScHUzQVZ4c3ZDODh3dVBSdzhJYkhMMWQrQVorSFAxZGVCTVYvaXA4ay8xL0tydzEwRzlqTXZxajhDM3M5TEczOFJCTjRidjRkbU5TZUFjblBlOXV2Tjg4TG53UFAyLzV3aC9qczc2M1Q1aS9LM3gvMFBNRGNNK3Z6YUp6S3VJMURCYm80S0FRcDZxTHhyK2pTZXk4Ti9HRmpmV2wwNXVzOXlkTzFXZXZzbksyTHVwSXJDZlJreGpxdHlZbUd6d2RWdVB4NFRPYWRkWnBHby9IVHpHRlFvY0lBNDkzSUV5WU8yYlBtcjRNMlVTS2NsVGFOQ3FlVVpqVDFIcVR3eEVOUys0UFN4N1I0L0hoazJYTzdkSEJ3V3ExcXB4RVZIVm9EazZYWnUvWUpMdnczQmRld0NLaVJ0a3EzaUJEWXg4VGtXdWM0UlV5azRObDZhbzNGWDhhK05Nd0FtOWhFSkdZQXp3SWg2Z3c1bldJWnlETTBMSEZTWWF4cktjdkRmZWxzdEZrdmV5Q1ptczZDVDVQMVl6MzJXa2JLbm9SMm5XMGkyVm1wM21nMW5odC9hSzZwaitMQkdJbVpKWVZOQXdhc0UwNkRaaURNSVdWSTg4c0g0RSt1TXY5RCsxU29oN0xycDVnaWN5clpkMEJyNVdzQ201UW8wS05nSWF0cCt4dHNJZGpHRG1qQlh3NXI1Y3doUlV5RERSSU12UjE1UFRXSUp6SXlXWVpwbG5wdFlPV0U2OWtOd0V0ZTBiSno5MlZUSE1FcGxicWFORXNVRTNWYXQ0NTZwSzVuTE84TkRUbm8wOFVvZ2hhWlVVMWE1VDFSdFBLNXFYMXZSdk5yVE9KekVYdE9zM1FCRzNuYTc2WVJ4U05Tc2swTTFja3J4cWhsRU5rb09DcDdkaGF1eldwYzJXZG1qbER5Y1J6RTlObGdMWXAyMW1YeFZ0NXpUYm5tQ3Q2N3RmVWVYZWxjWnNvcjl1d2lLcGQycHBTbU9lVmlvWmJkbzVtaHRvWWtxbTdiSFRGMHhWSmFXMnpEVjQ1R2FuWXFFdUpxNWpkTzllL28rbS9lRG1lZTFOYkc1KzRKYm1KRmVZeVA0UU9DYWFmdFl5bFNQTnlhMGtzY1dEUlVNeUtxUzQrcXN5T0JtRUZLNTZzdVNZYms3d25JM2tOTGxDejFFRVhUWVBBYk5sclhXNzhFUWdSQmdwSittd3dnN3RpODFCb0Jyb2tVeHlMaHNyTGJ0R1ZXSzRwazZsd0RpWDlLTEVZaVRXSXJKY3A3eXRvV01scTVZK1FCN2tWUEhTSmMzMW5GUWpQNGFWS0J3LzNIeWZPMllYV2FGbTdrRmZWaXI0R0lZbG54a3BldXltbjdDVFhUT1NXOVVHeTF1aktlNnpLMjR2U3BaWTk1UEtmVTNDRFZ4YmxqMU5zWlM4R3U3anp2LzRWMCt1MC9ldmZFM3N0dDVYRWMvRVBNUEs2aXdBQWVBSE56dXR2azFVQWdQSG52Ty9zc0JOd2RGTTI2empuc0xjRkJoVlVGT2FWT21Xb1V3ZnpocmVpRUlTaWdoZ0VBMWptRGZER0JQR0tBY1JMRVJVRUx3Z2FYZEtTSVY0UVRZUzZucVB6YnZTYmlRbnBYcHZHOUIvd2kwL3lmUDhCN3IrSEVRQk9CeTRDQ0ZQaFRBQldreUpBRUJqSWNud3hUc1RGTkRGRExCYkx4UlBPUHFmSDZYWFh1V2wzci91UkhDQ3JaSTJzbHcxU3k0Z2NLNXRsWExiSWRqbGZMcEdyNURZVlVscEYxQngxaDFxcm5sRnB0VXRsdGFNRGVyQWVvbXQxdlc3UVRicFZKL1FzblduTWVKdThuZDRuM3VlUldEUVVyWTJ1dE03UmluN2Y5NkZra1d3c1dpYUpxU0pSdEN3cldySkZ5emRsUzJYUkVwSkRaVmpLa21WaTJYS1hUSlV0Q1RWUHJWSHJpNWJ0WlV0MTBWSlh0c3dzV1RaNmIzbjd5NWFVNVNnbGkvRC84dnY4YnIvTDcvUVgrclA5ZHIvTmIrNnY3QThVL2k3RUM3RkN1RkJuRDltRGRyL2RaN00yWTd2dGJydkRiclZwdThIZWE1ZmFSYmJEL0dtczZUVmJ6R2JUYVZKbWdVbWE2V2FZQ1pzYUV6TFZacENweXZ2NXZ2eUJmRTkrN3JmSlhGZHVSUzZadXpVWFBCSTU0aDNlbzFvQ2s1MDJCUCtmQWs0UVFQQ2ZWUzRWSEVPQVNnWndMRUdxT0k2QkRHSXd4MVBORUVMVVVNc0puTWhRNnFqbkpNS2NUQVBEa0NnMHcybkVJMEtVRVl4a0ZFMk1aZ3d4VG1FczR6aVYwemlkOFp6Qm1VeGdJczJjeGRtY3c3bWN4L2xNSXM0RnRIQWhGekdaVnFad01aZHdLVzFjeHVWY1FUdFRtVVlIVjNJVlYzTU4xektkNjdpZUc3aVJtMGd3QTNpUWgxakZ3NnpsYVY3Z1JUYXpoWmQ1aVZkSTh4cGIyY2Jydk1rYmJHY0hPM21iWGJ6RGU3ekxYdmJ3QVIveUkzY3lrMW5NNFdjV3M0bjVKSVhESXVhSzBhemtXVEdTaFdLTWlER2J1NFVTaldJNGg4VW81ckZVdUx6Sys2emdGbTRYSXpnZ21vVG1OcGJ4Q3pmVHlRTThSWVlzdmVUNW5qNE1sdDFpUEIvVHd4OENmdU4zMFNxbThCTkwrSTRmK0pYN2VZVDdlSlRWUE00YXVuaU1KMWtQck9ONU52QWMzWHpLVnl6Z0N3N3lKZmZ3TllmNDdCOVFld0lZZUFHRmszMW9sZVVieDcvWGRaL050LzErN2pnOU9zZDJkbzZ6NXB3NzFZN3JOTWhTdDZ5dHpJV29TVkNJSnlFTEZoSFZyRXpGbC9XZkJLR2s1Q3BtQnROc2FhSmhTcElFb1lza1p6a3dVWWZwTk9mTHpsN3E2dnM4bk5GQ29RYytmTy9udnEvNzdmcmVsOWJaQUFCSVJwb3FaRXNycXJRRFlaMk5VUzZLaUc1SEpxNmlTdVpqZ2l5eWJkS0d1TTVGa1JUWkNhbkhNSWxhai94cTJ6V0ppZkkyUWxwc0hScXhibDFvWFJxMmZxNlRyUkZrYWN3R3RNSTZaWm9Oa0pOeUUrTjBPUkxVdStWUHhGeVljL2ZZSGwwRzFXUGMvM3RxTlpsTyt2bC9HaW9Qc0YxbXZmb05OUVoxQjZqWFNJcmpkZFJlNmdwcURmZDZGalAxVTB6VnoxSHIrbEdubjlnQmJjQmp1c2JPeWp6N1RiNURuUGQ1WHl0UklqMjJWM0o1emxwazZsTHIweEF5ZEM3YmhjaVVCZ1MxMW43d2NpVmgzalhmWHRXWmJCZFlqM3VIKzlTUkJHT2ZzMk9ja3lGTkhEdG9WNlNSZDU3RnVUbklkeFdJNm1qYnJTSDdXVzVZaDd5Qm9FUjVoamR0azc2SEVqLzNzRll0UnA3T1orNGFlSSszTU5hTDBZZnNocXlIdUNMa3liZThUd0ZVWDBQTXk3M2ZGN05ic2hvbCtqSm15aW9VeTA3TWtQRjJWWmNncGw4d0xzTDFzKzI4SkhqZmJaeWZZOGRkSENQZEF0TE1zZjNXNHVYOVRnVEtxZlRDODJFbzlPRmY2RVZrRHZwd0czTXhoWnJqZXpFVWV1R3ZsN1RyWHQ3dmhKdkRNWHJoK1RBVXo0ZWhhTno2QjMyNGpjY3hTUk4yMnZkaUtQUkNuN2NUbnZwcjFOaFZxYkhPUUJuQ2JoMHkrZS83T1BobWZOOXUyUkZaWTVkbERiTDl2RzlHTG5aYkQzb2hPRXlmWHNFU1dXbS9hNU9kY3NQcENUMmd2NFdzRFVnVS9xZjF5QXNVWVRKK1JDbU9ZeW82N0lCOGlGTFBHMmxoZXdjOTI4YzNNSUUxc2RSU2dRQWl3aHFRVXZwV3luT0c3Q05wdGo1cFp0elhLSmRHNmdiY0kwazhLQnY1dndVbEhNdVNoS1ZrRlgzZkNaVld1eUNOWkFOSldxOXM1RjIzMkIrNkdhT2xDNFh1SlNTODg4b1puanZMVGdVS1NEN2JRV3NQUkswOVk3cTFaMWF6TDJDbnRNL2FkUjMxRjk3ckN2dVVKS3hiVXJ6WFlveVR5OWJOOWFxMXk0NjRwNWlEYzF6L0JUdmp5aGsvZ0VsdWhGMXpUMk8ybTRDSEF5Mk0rd0NWWHI2MEJUVmFnVHg5RkVXeXk3WkxoSE4zSWVvZVFhRXN0UE82RlFsZFRxcFoxOFFiOTk2L2V4MkxmYWJaWHVabnI2NUV5TjNGUFFuSHd6ekxDSmZMZmRuK0wvU29kUVdTbkhlSWIvWW9ncnFPckVYUXRaR1RDQUtBZURXVFFERnpYc2pjeHFXVi80MXBrcWlRamRRdG1NeTRFT05HMG9NVTQ3SVlsOEVZNVR4bDNBakdDZU1VY2NDcmE3bUVPYktWYy9leHZScGhxY0lUY29MckhFWU1LWlNKMmlVNWhIdHhDMlc2QStYc24rYS9tZE04eHlINlg0YjdaQ21tVUN2bEsxVHhMVVowSG1MU2hHSGNNMWMyc1E1cUFhSmtIQmxPeHBNR3NvbmtFS2UxZG9iMGtXNysvNStNSWNWa0ZQdk9VdGVUWldRR0NhYzFvVS82ZGV4SUZobEc4a2xwT21ZaTUvWlNrZVovWkN6Slk3OVJDOGdzVWluek1WRVcyTWRTajZETXN5NVp4UGZlZ1BHeXdwcmtmcnVoQlZDT2pkRWNhNU0rMW1jOWlsaFBaZWthYWROdTVtNlBEZWhuck5HZjdLSzhpd2dPMmlYc1o1MDJzMzZPRHZyNWo3OVN6ZHA5eG03S0dQdEx2bVJ0bGR0bHRpL0lXdXVVdFJqRk0yVmhGK3M5UkJiWmRYblJ6bkhOaTF5djgyLzlPUStNQUFBQWVBRmpZR1pnK1A4RmlGTVpBaGl3QUFCZHFBT3JBQUFBZUFHdC9BZFlGTW56T0E3UHN2UXN6T2lvcklPNDYreWlnb2tjVk13NTU0Q0lvSUpreVdrWEJDV0lxQVJGUlZSQVFaQ29vS2lnZ0RuSE85T3BsL1h1REJkTWQzbzFYT1BuOS9ic2V2ZTl6Ky8vZmQ3d1BPK3pNTld4dXJxNnVxZTd1bXBrbEtrSkpaUEpyQ2FGeFFVa1J2akhMVW9JZEpnWTRSOFFQaVBCUHlJc1FNb2JKbmFuT2hRbUhRcTVxRFJONjJLQ3Zickl2KzVpaXJXNFhLQW8ydit2UEVSZ3I1UnVwd2tJZkdaQm5sWnZlMUN2Q0dLS3BycFNQU2sxMVk4YVREbFR3NmtSMUhocUdqV1g4cVI4cVFCcU5SVkxKVkZwVkRhVlR4VlNKVlFGVlVjZG9VNVFaNmpMMUMzcVB2V0krbzc2a2ZxRmVrZUoxUCtSMGJLdXNwNHl0YXlmYkxETVdUWmNObFkyUlRaWDVpbGJLUXVWUmN0MHNyV3lMRm11Ykx0c2o2eGNWaU5ybERYTHpza3V5MjdKdnBCOUkvdFI5b3ZzZDlsZkpzaWtxNG1sU1QrVHdTYk9KaU5NeHBsTU5abGpzdGhrbVltZlNZaEpsRW1pU2FySmVwTWNrMjBtdTAzS1RLcE5Ha3lPbTdTYlhEQzVibkxINUpISmR5YlBURjZiL0dueUg3bVp2SWRjSmU4bnQ1Y1BrNCtUVDVmUGx5K1ZyNUtIeXhQa3FmSnNlWUY4ajd4U1hpYy9MRytXdDh2UHk2L0tiOHZ2eTcrVWZ5OS9KdjlWL2s0TzhvK21jbE56MDI2bXZLbmF0Sy9wUUZNSFV6ZlRFYWJqVEtlWkxqWmRiaHBpR21XcU0wMHp6VGJOTTkxdVdteTYzN1RXdE5HMHhmU002V1hUMjZaZm1qNHhmV242dTJrSE1rWGRFSSsweUI1NW9FbG9OdkpFSzFFWTBxTjFLQnNWb2pKMEVMV2hhK2dSK2dIOVRzdnBIclExN1VSUG9PZlFmblFzblVwdnBQZlFoK2lqOUVuNkN2MFovUzM5bkg1SC8wVi9WSmdvRkFwRzBWWFJSK0dvR0thWW9KaXBXS2hZcVFoUlJDdFNGSm1LSE1VZVJaV2lXZkdaWTFSaVJFUmlWSml6cy9Oa0E1amdiQVNHbU91a0VSSndHK0Z1QUJPTXNZbVRZc0pJd05YWmViZ1JlQmpCUkFOd2R6V0FvUzRHTU56WkNOeU5ZS2dSRERPQzRVYmdZUVFqRE1ERDJRaGNqTURWQ055TXdOMEloaHJCTUNNWWJnUWVSakJpU21KY3RCUjBjWEdiRnhrVTRtOElEM00yQWhjamNEVUNOeU53TjRLaFJqRE1DSVliZ1ljUmpEQ0NTVVl3MlFpbUdNRlUvN2k0YUgxRVVIQ0NJWkFZWXdCeFlTR2h4b1RBYUgyVW9lU0lZVVl3M0FnOGpNQ0llb0lSVEhRMkFoY2pjRFVDTnlNdzBqbHBHR2tnSWN3L0lqQXNPSGh5VUVTQ2YweGNkR0JpUUVKOFltU2tmMEpZdEtFeFY1ZWhSakFpemo4d0xJQ3NBVkhCWVZGaENjbGhVUWxCSVhIK0VmNHhwRnBTVUd5aWYwUlVkSUlCUmdURnh4c0NJWEZCL2dsQmNZWndZSFFDd1JvcUlYT2ZORFE0akpRS1hCV2ROTjJWakpoYlFseVlmMGhpakpRNWRLSmJSUFNhb0tpUW9BQ3lCRVVFVFhmeEdPcG1JSHlZcTRGUncxM2NqR0NvQVVqakxBRVhJM0ExQWpjamNEZUNUeVdIR2NGd0k1RFlOb1dJcTVFblE0MHhxZnJVaVZLaUJOeU13RjBDVTZaT1hSTVVGMDNrUERJdU9pcklBQlAwMFVZWUdoZGtUQW1PVG93ekJzSjB4cFQ0c0NRakROSUZSUmxDUWRLSUdrSlJZWjhRR1RBSFJrVkhTcGdsS0dHV29CR3pGSkl3R3dNU1ppa2dZWmFnRWJNVU1tS1dRaEptWTJhTWYwQ1FZM0NjZjRDL1kzUmNZTlFxd3pQQThBdzBQSU1NejJERE04VHdERFU4d3d6UDFZWm51T0VaWVhoR0dwNVJobWUwNFJsamVNWWFubkdHWjd6aG1XQjRKaHFlT3NOVGIzZ21HWjdKaHVjYXc5TklaVUl3NGNXcUlNS3lrQ2dTQ1l5T0lDOGdFb2dKaWdzSUl0aElLQ0l4bm9DQWFDS2h4b3l3NkVBU2tQaEhBT0VlZVVxOEkwK0pjd1JLZkNOQTRob0JFcy9JVStJWWdRWitFV2pnbG9RMklqcktrQjBaOW5kWWttVUNEQ0pNNENlSkpxRlBGTVdUR0prVElWSktZbHhjVUZSQU1na21CeG54QkNTRUdiRkVoNFFGU0JQazcwNUVoa1VaZWhLWkdKRVFGaE1oMVFrTTA0VUZTbVNRMG5GaFVxMVBhK00vSVE5amx4TkNveFBqL2FPa2ZrdHJGQUYvWS92WFhDU3h2NmZqcDE3OFgxMzRPeHJqVDRpV0ZoM0hBUC80SUVOTVduS00wZERrbUZEU0ZTbTRpb2hRZUZDQ1ZQTGY4Yi9MR2hPQy9pczc2SDh5ZzVJQ0l2d2pwUlhNRUExSmxPWi9aUFQvb1B2MHN2anYzSC9xRTJLRDRpVmUvb01oS0NyUVB6N1VHSXlVZ3YvVWpDZWpFU0hoL2UrVS84RTF6VEUrM3RrbFRucTYrVWNTaGtyTWxHTHVrdndRT0RRdUtDUXNYdUtSSVhsWWdIOGNHVVgvaUFTRDNQa0hrS0UzQmhNUzQ2S0NWd2FUdjVWaDBpUENBTW1DU3FyR2g4VTdSaG5YN2IramlRR2ZVc2k2cVFzaTBYL2xSUG9Ia0VaSXdEOGdNVUhLazFhL3hFZ3lja2xTeE4rWXVTb3V5Rmd4T3NGSUJnbkhrZDRSa0JBV0VTaGxrUlUyeEQ4dU1UTENQMUhLL1lkMkVrNk1DZ3lLKzFjZi90N2pXWk5ObnJWaGsyZjlhWmRYSyszVkpsTHJxTE15U2paU2xpcXJraDJYL1dwaVpqTExKTW1rM3VTOGZLQjhwSHdlMmRPY05yVXdYV1hhWlBvZk5BT3RRUHZSSlhTSFptbEx1Zy90VEkra3A5TCtkQkNkUksrakMraGkranI5bnV3azNCUWpGZFBJN3FGSWNVQnhVbkZCOFpQaXRVSTBVNXNOTXB0cHRzaHNoVm1JV2FSWmpsbUIyU0d6RTJidFp1Zk12alQ3MXV5cDJaOW1uZWFVT1crdU51OXZQc1I4cFBsWTgwWG13ZWFSNWpyek5QTXM4MTNtRmVZMTVvZk5UNWkzbTk4eS85YjhCL01YNXIrWnZ6Vi96OGdaSmRPTEdjQU1aaHdZZDJZVU00R1p4c3hoRmpDZWpEY1R3a1F6Y1V3YWs4ZnNZYXFaWTh3WjVncHprN25EUEdDK1pINWkzaktkckJuYms5V3dOdXdRMXBrZHhvNW1wN0VMMmVWc0tCdlA2dGxVTnAzTllyZXd1OWxTdHB3OXdEYXdMZXhaOWhwN2wvMksvWkg5amYzQS9xZUx2SXVpUzljdXlpNVdYZnAwNlZ0L1dZQ1JlQ1Q0a2Q4b01FQThDa1poUDcxd1NmakpFb1lDQnozQmpmeTY0WjU0S1BsMXcwcnNSbjRjS0dHb2h1WHhJbERpWHJBQXZHRXV1TUFlV0lSN2dDVmVqTDN4SE95TTkyakVobWM4SG9sTm5HeHM1OTM3UU5xUVBmdjkvZVhKL1RVY2Y2cWtvZUdxK21iNXluQnRsZ0lzQnZNNzY3WWVybEJCdCtIUHNQVmhBU004Q3d2dkhhQUhjSGR2M0Rxb3djdzVGSjRTRnUrbm5oTFdlazdMOG5sYkNyY1VxU3ZLMHVMams1TWlJNUwzVmVYbGJzbmJxdTIvQVczTTJiQlJOZnZjbkZldmJsMi8zeDdSc0dLbjV0ZlcvZThSUGtFbk9TTVlSZmRiaGxoK1pPaUsyUjRxT0VLWC80S3dIWjJYbDc5bFM5NmpnMVozYTQ4M1gxTmQ5emxyNXpoLzFnVE42L1hvWUhIbG9lcEMvVnA5NnRxWWRFSjdhZmpxSGN2VXVDdW1oMk5icDJ1emYzaDI5K29QMTFhZG5CQVhzejV0amZibzNyYnlFK3FteW96MXBWcHNQNGl2S0VuUlJTWW14eVNtbEZUVVZwWldhcmtPVXo2NE51SllTMHRqZTFQMHdWVytnZjUrR29peURLNkpPRzVJaXpxNGFybVV4am9KeXFLRmpMSjZBS05jTW9SaCtjbG5GL3o4eTgzYlg5OElhSm1VRkplZG1hWXBid3NTOWoxRFdFK1B3ZU4vQ0VDRmhic0x5OVg3OTZYR1J5UWt4OFhvUzJ1MW5QcGc4V1JtbkRkV3hHcFRKcVBoZEF6dWliNm5SM2NpbE0rdzFVUU1SaEF4OEFjL0dQbEpERVpLWW9EOThZaEx3bytTSUhRekNJTHJmd21DS3hHRWJwOEV3ZjNDN1BkZ2ZRNzZ2UDNhOXc1RzJIb0oxZ3pXZ0NLZlAxWDIvRUpUVVZ5RWw4NWxVVkRtZ1VNYUR0ekhDd1huQlNnUUVROVRZcGtQNGdhRXY2TUxqNkxtblFmS2p3MFc0TnhlUWFPOGN5TDhrTzlpUDM5UERTZWU0NysvZDI0eUFwb2VEbllJOTZYeGtGQ0JiV0VXSmgydVAxTFZjdlY4UldqNHF2REF4VnJsZXp3UWUvUEhHdHB2M3E0S0RQWUxXVDdiSzdDK1ZRTS9aL01YSXE1NWxXdVV2M3hiZGU3R0k5V3JVVitSb3RiOVJtRjYzckdsclRxTjhyMlRmdHBzTnhXMkFMTkYwQlVzUVhrZmVwTEJQdDI0ZW83TkF1L0Yzc0dOTis4ZmUveFF5MzRwbXFLQjlOclFGYXRtYkU2ZGFQV1NYbjVjWUVPaDlTMDRBYlZlYjlFQ1pzbzdzRVpzNWVzcWsvMm1COFZFUk1hV3RadzgwTmFxVlI1NThZWmZINHFVZHdvM0pqWk1WZHVOR29HN3UxeVk5dDJwQTlYN2RtbzNyOGxOUzFPOXB5dTNWRzJyMWlpUFhJRnF4QTJHUmJBQS9CQWVTT05wZU9rYjdJTlk2STdINkdBaDhKalZpUVY2aXpad2dHSGdvRHpWaGhmeUpEeVQzbHkwTzJlMyt2U2x2UzFWV3VVM3lma0orWmthR0VCdkx0dFUzNlFTN2JFRFBxendqZ2hkNmhuYjFLNkJSdXlnNFBnTkszVkp5MlA5NHF4R0xWODBhNURLN2I0ak9NTEExKy9CTWsrRE5YdlF2TERGTXhZbE5CNnFLem5ZV0thNWZQQ1hzOXUvekx2Y1cvbTJHZXo1bHZBR1g1L2wva3RXMVlXMG56blJjbGJEV1lxSmRBMVlJWHlhTHE0b0s5Ni9FOVJYckVEVy90a0RrS2wrbi9nQ08yR1hJWmpDTmhxd1RVVVBhOC9kdVY0ZUhPeXpPbXBlckFhYkw4WHErWjR1T3R5bGQ4Nm0ySndjSWdiaitKdHR4eTVlYkF4ZE90YzNZSUZuYU1NcERZN3RWUEhCNTIrbDNsWkRHRXdHTjlnSERqWnZjVDh5dUl3ZEhvTFIxOE9nUjF2NzNpT0h0SFlSd3hmYnEvMzhkMVlFYURudzVqSDF2QjhNaGhIdndCeTBnS1o4Z1h0RkJtMUlqdFcwQVkxZ2o0SDBUcGJHVnZoejZMa0E3ZDFYdStldyt2VEpxTVZUdkVJV3p3OXVQWldYVzVCWFFDYnpaVDZnTnZMRWllYkRwNXVpRHZrdEMxcmhyMkdud0hHZ3dCa29HWkVHNkExbWNrZ1RUL0dIY2lxVC9GUXpWc1JFaE1mdFA5NVNkZnEwQmlZczVIK2VjVyt3dGNNb3JIVDRmUEp2d0g3ekc1aG9PUFhldlZsSmExSXlFMWZGMSs3TzBDNWFpbEozdEhwOW8zNTU1UExKWStFTlBnVmE5ckdJRU15Z3g1Q1p6UExoaVpFcDRlcms1SzA3MTJoOXFwQ3lvQ3c0dURCVVBYbFc0SlJnN2JjejBjR0t1bElkVTZKdGowWEtjdDJScG96RDZuczNqdDQ5UXRaU1BKOCtMQ0RvVDdOME5mUkNMSjR3UmJpYklTalB3VkIvQWJ0UEVwVFdiTGxPUk5Eekhhalk5ZERMVmljcVFKT21aM2x4U3Nja2hFZlRaREQzTG9LOVY0WGZPMGZnRVhnZll1a3hEQnViblpZY3AxNlRzblBYR3UydXBNU2lNRFhCMCtHdFp3TnFvcHRQSG0wODFSUmR2OG8zU0ZycWlwbjUwdVFlU1pQbEpEL2s4aFZWWVY1aFhvRUcyOGFobkEwNTY5ZXBuTzVpTlN3SGo1ZGdDdklmVnQ3R0ptMmE4UWNKc1gwdklWL2Rpa20yNnI2ekhyL1ZrcWszRWt4LytoMWtSeWQ0N2RTQVV6dDZsVEljclBBS05mZFhOMzdpVEw5Ymg1bGZzQlVpc3dIc3lSaXowbXBjSFhuOFdFdEQrK0dZK3NEbGdZRmtOWjVwR1Z3VjJYeXMrVk5hRUVuam9GSlVPQW5zTDdrd0JQcUFGdFF3bU9WbnoxazJhWDZiLzVXYk4wNDl1TGJzNkh5dER6YmpEK3d2S1N2Zm5ab1VuN3dtVVplNnA0elVuWmNMZzhUTGVwbTRCQWJ4K0FBTmZVUTF3aDg2RC9NZFMyaGMxdUdOOEhpYTh4Rk9nRjI2QUNGZ1IzaCtPUlY2dkg3OUhYUTlVU3BzQXkwRWdUWDdwN2doUWJEdTNJRFlZN3c0QzdwM3pxTEIxVlNjZFlRQkN3WGVkeHYyM1VMUVRkRkpFcmd4M3JoN2pIYmRIQ0lkS3crdGJqM1QxblNaRExZcGpiV2RLUWhJeFc0ZHZHSGkra29UdHphay9XeUxOSEg1T2hBUVBrZEhZUUZ4TldDSnNJNkdhc2l1aGg2bzA0Nk94anlDVlRRdXdldWlzUXB4cXdXZnhmNWtvU1lyTXZqU2VCeCtnYmh2VTBFTCthQmxTVjk4MzdQd2dlK2NCZkVJV3l2Z09OYmk0MWlEc0tBUXBUU09IdEZKWkE2c1pRVXdSQzV1ZzVmODA3VlRubUsxR2cvQ0FqYkYwMWhBTDBEbUJxYks5NnlsUDhQQ3ZRSWRpMUtLTXZidVZUWFdWemRxbE5lUEh0U3Z6TWpKenNrZzB1d3NjUGtDellKOXpnVkdlVVIwNndqaHNSZGVnQjN4SHJaRjNCREZzTmdPc1hpVytNVjdHZFNJWC9BVjd4RStTaWYyUTV5blFGNDdyQTRpOVRDT2JLa21JMEEwTzFib1Q5dkFRcGdIM3VqM3NRTEx1d29zZU1Nc0dBQ2xNQVVyZ01QTHREaWFDSzcvd2RDMjl0Ym04OGNqRC9zc1hlbTNSTU90RWpxUzlUTDI1OUc2OWwvejlSYnM5Y3NuUGhSckhXZ1dZZkxneng0TG0yRTdmWm5uMGxVTm56ODY5ZUMrVnBwbUxFSElnWnJGNUVYTUhvUHVvajNCQUFyb0RyU2MzUVpEV0N6RHZiQVZwa0FHVnVSSEVXUnFPbmJHTkcrM25NVCtWcUNtMmM1ei9IWUI0YTQwcXhPMWV0WmlEYUhZeW9MTlVtVGtwR1RIYWViaU5yU0ZZVy9ZdEdpbTFxTDRvdVI5ZGFyR1dsSkV4dktiVTNLek1sU0R2eGhETUp1d1l3VE93b2Rod2ZRSGtNblpGcDE0UnFKRjluU3J3SXJud0k2RW5XNkFFNHZBbmhXbFFVUnkxaUlabEdPaDN6a1k3QXlXYkN3RGpoMmhpRjBvY050MFo2QXJ6SVN1RWc0OEdUU2lBMWg4QUkyTXpRVkw2QThtNEFUZFpTeVJMelVDRjdvRzFJakYzZHRRMkpyVlVjdlVDMWF4a01HTG00bkViNmE1ZHZMKzY1aWtaMkVTd2NYRE9Kb0ZPd3UydzlKVFlGTkFCUXVCZlpZbHNJVW9iMGZlcnQycVZ4Ty9aRWtGbUFwOVlDdFlzVVE0ZnlYc25BZTlaUktEWVFqNU41ZUlDdU5iaGlIY2plYUErd280bHE0RUdrbFBoRmhkUnhBcDhRdDRQaU9kZHY0R0pvd0hqZklsVzZDRDZkQkxkQ1Y1OUh3N0JGYjBsVjhSR1VWUWc1Vm9RVkpQNnlDUW9KY3ErektrQ1N0c3hTSnNRZVNQWnZFNE1Pc29BSnBndksrRHd2ZVplcEllaVZpWVF2clRTeTZoY2Y0QWx1L1pYSUpNQUsyTUxWa2JIeEtaRUtZbEtTNjRqKzdlVTNhUHhMeE00RmxlekNlOHlTZWl0V1YzM3A1ZHFsdHMrWmtUMzZudUxXdG5BMUpCRHRlQUlyemhSUjFZeWxpOWhmSUpTMThSV0hvMWRpWnNIb1hKRXB6T1lEODIrZ2hENkhPaldabHNJemxzMFZRb1Jaa1BwMUlwYXFJZzIweFJmaVpVQ0ZHalUxUTVSUVZUMUhxS3FxZW9YSXJveXFsZGxDeUhvcW9vS3AyaTlsTlVLVVVkb0lqR25GcExVYnNwS3A2aTRpaHFBMFVWVWRSV2l1alZxWDBVMGFsVGxSU1ZRbEdORkhWUVJwVHJWQU5GSGFZb2dxZUpvcG9wNnFnSjFVcFJMU1pVTVVXMVVVVHpUclhMcUxNVWRacWlhaW1pbHFjdVVkUjVFNktQcC9aUzFFNkt1a2xSMTJUVWJZcTZRUkVWUFZWQVVaOVIxRDJLK3R5RWVraFI5MDJvR29xbzdhbXZLZXF4alBxR29yNmlxREtLMmtGUlR5bnFPeFBxQjRvbytZbE9uOXBHVVhrVXRaMml0bEJFOVUrZG82aHZLZXFLalBxSm9vSW9jaENsTmxFeTB1c01HWlZGVVJzcGNrbEFiZ2xrZVRRVlRWR0VTeE1veW95aUVpa3FqS0wwRktXanFCZ1psVUJSeVRJcVhDWWp6WkdiaTBJbHRZZVMxZmFscWluWmpiNVVwRXoyVzdic3JuVFNIVVRaVVk2VUM3V1FpcVV1a3Z1RWViSS95RmwzcWttMlNRdlI5b1BjVk41WFBrS2VRZlQ0TmZJMitRdjVlNkt2SDJMcWJqclJkSVZwdVdtMTZSSFRFNGhEemVnTWJVT1Bvd1BvY0hxWHd0eHd6czFYdENrK1YzdzBVNWhabUhtWm5UWlhtQTgwbjI4ZVFNNnNwOGo1dEpNeEpXZlRNY3hLSm9zcFl2WXpKOW5lckJzNVRiYXlqN3ZNNjFMYzVWU1hEMTF0dW83cWVyRHJtYTZmYzVaY1BOZk0zZW8ycEZ0cXQ5M2RQdTh1Njg1MlYzYlA3WDZnaDAyUDZCNXhQVGIwK0tySEx6MDZMR1phUkZzY3NtaXorSStTVXJKS1c2V3JjcFV5VUptc3pGYnVWRllwRHl1YmxLK1ViM3AyNmRtN3A3cm5vSjdMZW1iMVBOWHpzNTQvOVB5VHlQUmdmaVpmYVVsWjJsbE9zRnhpR1dIWllObGllY2J5cXVXclhvNjk1dlphMFN1cTE3cGVsYjJ1OTNwZ3RjUXEyQ3JCYXIxVm5kVzUzbXp2bzcydjkvNis5d2VWaTJxRmFwMTZyRHBVdlVhZHI5NnJ2cWorU3YyNmo2eVB1azlCbjh0OUh2WjUzdWVETUVDWUtFUUxielJJSTJoY05YTTBxelFWbW5iTkpjM3ZXclcyd25xc2RiRDFSdXM2NjlQV2Q2MGZXWDluL2R6NlpWK2J2aFA2enUrYjI3ZXg3NjIrbi9XOTAvZGVQM1UvVGIrKy9XejZEZTgzczkveWZ2cCtCZjBhKzMzZjc0LyttdjYrL1RQN045a01zNWxrTThjbXdtYU56WGFiTXB1ak51ZHRQcmY1MnVabm16OXRaYlpkYlZXMmcyMUgyYzZ3OWJKZFpSdGptMm9MQTJJSFhCeHdlY0N6Z1JZRDV3N01HRmczOE82Z25vTThCMjBjMURqb3k4RlRCbThhZkcvd215SGRoN2dPV1RRa2ZramhrR05EN3R0WjJvMjJXMldYYlZkamQ4ZStpLzBhKzFUN012dmI5Zy90MzlyLzdxQjEyT053MStHcFl3L0hYbzRhUjJ2SDhZN3pISk1jdHpnMk9IN24xTVZwaE5OaHA4K2NUWno3T2w5MXNYQ1o0RkxnOHBzcjc1cmgrcldiekMzY3JjS3R4ZTJrMjFOM3p0M2UzY2w5dFBzTTk2WHVvZTRwN2pudXU5MFB1QjkxUCt0KzAvMlIrelAzOTBQUlVPVlE2NkYyUXoyR1RobzZkZWowb2Z1R1BoODJmVmpoc0crR1R4bStkZmdwRDVtSGs4ZE1qM2FQL3pOQ05pSjR4TG1SM1VaR2pid3lxcytvVWFPaVJqV00rbUkwTlZvMjJuVjB3UmhxRER0bS9CamZNZnZIZkRibTZ6R3Z4bHFOdFJuck9uYkoySlZqSThidUhmdG03UHV4bmVOTXhubU5DeDRYUCs3OHVJL2orZkhXNDRlTTl4enZNOTUzL1BMeDF5YU1tekJ0Z3VlRXpBa2JKK1JQdURtUm5XZzFjZVJFMzRrUEp5MmVGRElwZmxMNnBQeEoreVkxVGJvMDZkNmtieWFQbWF5YmdxYjBuNUkzcFhMS3QxTTFVMTJucnB5NmRtcmExTnFwclZQdlQzMHk5Y08wcnRONlQ3T2Q1alF0Y2xyT3REUFRIazdybU41dCtydy9jNkc3NkEvZFpSdWhPM3lBN3ZLTmx1S3JEdS9PVnpSWmdyL2xTZGFIVG44RjE3bUd3NG1HdjJGRnVvNEF2YXdFSnNqdlF4d1BwalJveEJTRVo5SzQrMGZMR0dHcDJFc0hiWHFMTDhEOU1MZ3JuNENWYU1KUFpKUjNJTTl5SXNOQjdna0I3UFN5cjhVK1BIQVhCTnkvTDNTNUtBQjluZ0dMMVF6WWZzQWNMZTNVd1BZOTdrWWZBcnNyekdwc2w4YVFFTUkwdlRwVXdEWTBwUGZqd1lMVXRxQzVsL2E2ZDJEWm9kRmJGRUUvb3IzNUdkeUhnYTN5TjlCZ00xS0lMbitId0xyd3k5OWVxYjRLV0M4MHRKT1Q4L2M3cGlkcHdiWVNuWTk0YnAzSjJJM0NyR3BNeSt4blc1bWdtTmdsbWxGNWtlY1NHTmVMNDM2SjBIQndaOTNiNlRxSWVydXppSG53SnpCL0t0VVVMQkluMmpISzhuT2lDOTVBQXBNcG1OZ3haRGJwbldjbVdBN1VpYStnbThVMkdCUUtXdWdHL1pRUm9taUpaZUFNc3VmSFlUR093Yk1tLzE1VzlQbVIrMWZ5WHZSK01lNExUUGZGMUV6TUx6M2dXN0Zhc3kxei9VYWtQTzY0ZE1haWZpcm5lMDZndW4xeGYvTnB6WjVkU0puUU5oM2hGbGpJbjZ5dWFxblFsQlQrZ0MweTFwUFNzUkV4YVJGcXY0aERoN1ZnRGZ2NGRXVkllU2k5SksxOHY2cTljVy9Oa1lxRWlOams2QUNkaHNPNXhoR1NrUkdTZnhvZERnL0F6cnEvTnVobGxhQ1VWMElRangxdTRMNmZPV25lM0VOemZsd0ZadEJGQmZuQXdqQndBNlNaOWd6aFdGTEhESHZpSXlvTzk1TnFaK3BsTUFkNnl1RzJPSThIcDRWZ05mbTF4bllLdWptMENkUFlUSVh6c1FVZWlwMXdGODBkRndRUllBL2RZVG1VcWJoRStFNG4ycERxWWltRHU5T0ptTE0rdk5RYXFGQjdtKyttL3Z6SHBRRy8zMTc4QzNDTnlVRGpMc0dJKzZPT0FaM1UwcDhyR0x3RU8rakFVd2N6OWJMMWovbVY5YUZuZGhUbDUyL1ZySnM3UFdqRnhwU0pWcURhQWJLM29GVmRDVzZiTTMrWi8xekNBd2JXZ2lDREs3RFdTOEJMOStoZ2hWNzJmUlovNC9UWks2ZERqeSthdFhUcC9HV0gvUzVwdWZSdHVnNDlPZXZjN2dqbGNYKzZjOWRIUFlKK05BZktNMHdWT0FQWnZjaGhKbVR5NzQ2U3p0TjNLNWZPSGhpSTUySEZqSmkyenpSUDhUWWVjdTdESVJnTTNhZURCWjZFODZiZ0Jqd1ljN2V3RXFab3VmNWttenorRDJuUEJnbVdJSFFJcVlKTDUzakUzVDRwM0FCYm1BSE84dENod3BWVTZDTmFad2xyd1JHV0htZkExNTBCZEVoSUFqVVA1NHVFOTRZamZqLzZHOUVDNFhrMGZvMy9STkFlemVQaE5BUkNHT0l1N1JPeUNiYVZ4NW5zNGNMTENxWUVuR0FwdU1yRm40Y3lWd2dGeGRCTDZxTEFreDFwTk82RjRESTl5NWR3MW5NOHJqZURrZldNR2ZkZ0o3TXhpNEZUanNMWCs0V2o0QUpMQ0IxTGh3bDREdUdldHg3Y3BLZUY4dHdQV2Q2TTB2azJmTzVOcEdvT0hyVVBQUFRndU0rUWYxN0l1c2Y3MTYxdTM3RlRHcUcwQmJOQy9EYW1UcldDbnR0Ly94V3NWQmREVDg1ZlJEUWlHcVVWdUVNNndWQzhXU2hmemtCdjBCd1FaQmRER1JJWDQ1WUxGVVU2OFRkUUVXMlJaaHhNK0FhY2xTK2hER0w0YmMzbDVhMVZMUWVzdm02OWVPT042c2RKTDdFREhqaXdIKzZsQWMwNmRQWFFoYzh1VklTR1JhWkdoT2cxQzhLUnk5SjFFeGVxc2hUS3gvN1lJVWFBMno2L1BYc0Z5MTYvZUMzYkR5WVB0d3JpR0IvKzRhdTYxclBhcFE5UTBPSTVheGVxOFd3c0F3Nkd3V1RvQnViZ0FZTStPR0tOdmMvczVib05wWVZiY3JjUlZjb1oySVJzNmZVQjZIRHFxdElRZFg5blIydzU0UGJrSjYwbnk0NVZhR01LYXlNdXFMZlN2K2UvZndNT0twaVA3YUV2RHNCUmVDcVpIK3V3SHNaZ08xaW5hUk5kK1BFNVFVdTgxWDc2aGxNM2o1eTVjTFE4MmwvTFRXQmtZb0RsUUlZRFBoZDRHQW1XNEFDOUxNUSs0SVFaY0ZPK0JmdFNaZ3daS3hvRy9QNE1MQjk2blY2MVI2dDgrYWo4OHBmZnFGN051WTk1RGJiRFIvaUQ0SUR1MGhjUHhBY3M5ZyticThYOThTbitNSXhFUDlMS3Q1ZHFvdjNuK3dSUDEzS1FtZ0pPNHBSZ0FjOEZKZGJBSXZEOEZTeWVOMmhuQ0tEUEJYdlJBUWJKeEZJWUpvY0ZZTTgvRlIzV01GbllubzhXOEtCVkREZEhrSWxlbG9PWXI4cDFzQmRzWUFnTWtZRzc1U1hZSyttbTZzRUc0UklDaGlBNFN4OGtvTlAzSEFOMTZkQVBtK2hnTTZqQUM0Wkk1OS9qb3AxNGp3ZjU4ZWxlTzdWR1pZaWswRitoVmg3YW1JUHdNanhIT2hmamVXQ09yV0QyTnpjUHRoL1dLaE9tQXF2NFd1eUc4SHM2Q3FzUUJOREs0M01TUGIwR3FySEovQytCZ3ZGZyt1UWQ2V1FPSWU4SURJWmFNdGtmK3d2WWpaNlBheEV1cHE4QUFhNlRCSENocjhFUmllWjUrQWppSk0yU3pLaFZPc2ZjVDRVaDRqMjlMQXZzNWFKZEtkTy9jeDN5eVlnSVdhRmVxanR5WkVmKy92eENiV0ViZGtqSVRrVFppWnZqOVNwczlyVUhxSWxTNUh2Z3F6VkFpVHNRQjVFRXBUakJFdWJUZUlYWUMwUjRpSEFValMvZzJuOFJjUnc4WDN5UHVBZTVZQ2RlSU1UNm5XU0FGUytRN0hPTUdFWXdkTFFRb3RiUXVMNHpib2dZaC9CU1VtMHcvVm9NZU40WmdNQ0Noa05pMk1CT3NpcEFtZFRlSzh0RnpHSkc1c1BJNitGcVgrRlB3b2RDNkFNem9JOU1uQWZENVVaaElnMWZnRUlrdmU1SDVRSDZHWnhVME5YNVd5SkpBYmdQZjdjNmZObXk4S1h1MnBIMFVaaEJNTmZNMHQwRng3Vi9vLzNuZ3FXOXJYRHZDYzFuUTZEcm8ybXYwUmYzVDM4QXRlci9jZHNDQjZMNWwxaU5OcTVkbTdOTy9kODNMcE1TRjRUN2FaM0JpclF5bU5CYVNtaWRJTkhxUldnVmUxakNLTG92SEVkdkd1NC9BVWIxZnZKWHVJOEc3eUFzY0tVdlFpbjZnbDRPZmZnak1BSDlRRjgrRU8wM2Y2WGZSQzNYemxoc0JOdkY0QVlLOEJnQkE1VXZDVjV1dXFCOE1JZFJ2dHpHUUZleVNGNEFPMWtISTE3Z3BhMUk1M1ZwS3dLQk5HWTZMeUNDM0RBR0hDeEpCV2Z4bGw3V0FrUGxZbFdIZDM4R1ZraUNrbFhLNEJFMFVLc1lHRTZMOXBLU2JEcU5LenR6RUNmV2tRTHZZSkJjM0VBS3BYY3UxNG5McndyTnBPUVlHamFKcTg5MHJrYmdSc012VXFWeE5BN29YTEZVWEVIYVdpZ2h2ZzVSaEZkUkNPYlFlRGo4RGpjQkkreEw0Nms0MmhHaVVaTUF3L0R2K0JiR0NKYlRIQXlTNnVqaDFEaUdhMkprNGo1TEx3WVBPU3BBRkI3SEh3QXpoTHZUTUx5akFFSDNLZ0Z2b1hISWYzU0lDemUrQkdGZktnODlhYnk2UTQ5d1Q1cTg5a25GZnFRaWhQNmxRM2pMUlFhNjAzall4d0pKOFJDSHpSRDN2YWpRQVNZMXBaNzVTRFJZMDJBT2tXQjJYQUFOalgwQkk2NFVkNGZ1c2dtNE95L3VnTzZkT3doaS8xd0J1b3ZucGduY0JNR2dkMU1lbWkwb1M4a0YwaUZ5Z2VTN2tnR0xOT2hqb3hQTlFRV1JlZ3ZSSGh5VVNkRFBjdmROcER3WlhueG01VGRxNkE5bTBCTm1ndG1NbDVqMzlFbUlUZEJlZ0gwSUQ2YVZTZGpoWXlpQ0wwUnovdXp4eUdsYTVVbmJIS0s4VWkvMWIvenMwZWw3OTRsRXBJSTE1SzRVc1BVZmRrQkUvZXRIWHgvUzdoSU9iMmYrK0VkckRPRWJHZVVwOGJXME5iQ25GK0FxVkw0MitNaHdOYmJHY3R3VlQ4QVdENGRBbDgrYmp0VHQwK1prYkU1TFZTbFRNM0kzNUczUWtMN25iTXN0M0tHcTJscFhVSzdCUGxCcHVKN1JLay85KzRaR3cvMmpONVY5MHByS3dRMnU5Uk00VEkwWFpQQ25pUGdhNklsczZNSW1kS3p3UU9YeHdZS2tTaWNjaEY1L2dCSWlRSjJ1dC9DQzNoUEJYdmtUWUdqaVIzc3VXN1FrcE9IQ0YrM25icmNmQ2ZQVUtCOTNPdUV6dk90ZEd4Z0J6cjhBQmRwYXphK2lqM1JQaytHRmxEL1ZwQ3h2OUZDVG5UcnBsRDFtdm5TSGJ1ZWJLc3RMdFZrUmFHeXl6NnBaYXVYTEdXRkgyN1hjbndhbG54cFdrM1hKVk5wZkxMZThCazFvVzNWKzJWN1ZNNis3L1Zjc1N3bU8wRnlDc2dSQkdvSWc0VHFacTZlTDZvNjBxVThlaUY2Vm1aT2VuYWhkaUV0SkQzeDhHZGhEUkVmUllibGFNRjZnMVh5MDVNa3QyenFtYitjR1VtSTU2YVdLVERhcFdLYWVEOW1nUzQxU1J5YnR5dEhHWVFabDdENnk1cFQ2eDg5T3Z5M1hncm5ZTGwyTjdnVmJiNEY3VGpEbkVzd1BMY2tNd3hwb2hEd0lSemlBeGhPeDg3ZWk4bS9hcWtGNTZ4SnB4NWRvK2tOSitmNldrZ1p3SFlNZGlmQndvcU5Pc09od0J4ZWltZld4dkE3TnBCODFoOXZWSnlzaUE3SnkxbTFLMDBvU0FYYjBEVGlGdHBUbWw1U29mcDV6YjlDcVNldG5MZFcweEsrb25hSDI5VXhhRlVuMC9QbTdjdmVVSnpMdW5hNFNRNGkybzZpdXNWWGRha0NVdm1tZGRqNnVSdHlmcERtUkREOXBicmxsTkRsUVRXRjhCTmthZzRaZERyV2llVCtHQTY1Y3lDRFRZUkE0a2lYc2xzZ21DcU8rNEpXUHR4VG1sdTlOWkhEUHpyZEJ3bW5JUmhGbHAxYy9rcWFJdVRSRnRLUXdPK01aNWhkNXgwVEVhYmcvOEZnZHpJSmVrQWNDRVo4Q3NGTStGcytLRy9oUEV2RnlYMGJ3Q1hzMTFtSlQzQVdUbWZ0d01EQTUydmFHa29vS3JTK09DeEtVajVVdnNVYTh3cDlwWEQzYmRxSDM0cVZHa2Y1Q3kwMGxpL1lIR0xSUjJpeUtQZUEzL2lBTVFsc3o5UVVKYXQ4VmE4a3R1cko4Ni83Y3V2eEV4azNpeHluUUkrVzUzOHJQMXA1UlYrL2V0S0ZNeTUwVkNnVGx5MlFZRXN3b0g4eGxsSS9MeVNLOWkzSE1BaDZ5b1RmWTZtWG53RmtPVzBTSy80V3VoZDdJanE0SFc0VDcwS216ME5LMDJNaEY2bmc2R3ZkR1Qra0F2QVJ0U3QyOGRxMXE1TVVsTDQ5V0ZtM1pwcW1DTG1oVDJyck5hZXBJM2E3NmdyeHRlZHUwM0FMR29sUWE2eWVFRFhQd1NiUXhlWFB5R3BYVHBZbC90cDdaZjdSQ2s1T1JrNTZoVXNac3ltVmdJSDJzb0hiclhzMVQwWEVkTXdjZlI5N3AwY0crNmhVSlZjZklYVkQrVHUxVmFFRGN5VWJCeUZRaWhNUHdqU0M0Z2JBTC9XUG5oaUNCZzU4YUJmaFR5aHlDVCtyZ3BMUnF0UkdoQjJjYVBPQ0xvL2dMQkVObzJDcGRPVHZSdUE5dURZTld4QjBudGFKQXpkL0dhZ1FqYWR3TE5rTUtGS0FtNmZhaEZ4bFJoRWZSWUltejhWcThBOEYwbXRzanlLQUhYamhSNE5vRm1XaGh1VlRBTWp3TUVOeUQ3bkFIYUl2cllPRUt2UEpsS2V6bjJ4dVNsMmZsWkc3TzFGNFJsRzgzNmpjbkphc0czVnIwUm5PNFdvaWdROEtMZHpPSHdKWElSMzVSZmxHUnFqM3VpRStKNXQ3dTQyZjMzRHdNWTYxdTdtNHFiVkVmcVJLOGFkeDFqQThlSEs2TndMWm8xdHJsOFF2VkhGNksrK3IraXRUTGZzSERlQWo2S3pLTndVSC9pVVJjWHdNOWQ2RTcrYWN0b0MvMGRBTUw1VnY0ZzZnUWZNTDJ0bTdQMjBHMlY3VmdSUnJlV3BaZlZxcDZQZlBDSUUzd1JlWWdmYmgrN1lyMUJvcFhZM2VrZkxzNWZUTVpKZDhEUWUycG1zbHJWeTFkT3lzRWo3R2F0VFl3YVpVNjZCSnprb1l1UDV5SGZuWGFlaGlBYnU1dXI3eWc1bUFDK0VLUFJkRERRcGt1YmhWWlBrSVhrUlN1WHBOY1VHaThueHhmRmhSVUdLS2VNbnZWMUJERC9lVCt1cjA2cGxUYkZvdVU2Ym9qeHpJYnlmM2tzYnVIdFFZRnlobzhSOWV4U2krN0JPUGxNQkVhbGdpM3kzVVB3VktjcjVkVlEzKzV0TXdvNkpLSGYreTRjN3Z1WG0vTU5oTnprWWc0SDdWbjRLRXJ6MiswWHJoUUU3NjZRQXVXalJuWC9LNlBQdEM3L0xjclRKTGJFU0VGVXdPd25jcis3TGp2SkwyRnlVNEJlTkNDSTZqbHJRNE1ETm9oUElJZU1CZDZ5Qjg1TW1DM2w3a0ViVHhNb05mT1JuZ0NuZEFYd1VRNkZ2ZEFSSHlyZ0lCWmRNVUhoR2ZUdTI4Z21FM3ZKMkVUR253aEgwa0NPeG1uajRGMGhJZlNMM0ErR2tCTHc5ZFA5MWVVWGdZeDRoaitlN0ZmR2pPc3N4L0s3M3pDUC9rN3d2MkVWd0ZQMWt6ZUl1MFlBNDVFVCtNT0E1US9aV3paSUVqM0ZQelJkUzJSRFJybGpiTm5oUG5ITkM3WEFnUVlVQ1pncXpJbWJCaGpMNTREQjFsZW5pRFBHeUJ3cXdTWS9BNW12b1hwcE1sZ2tNbUhDR0xBYmY1Ryt0THJnOVRXQTBmaVhnUHVUM3IzNDVXTGx5dTFMZzBvYm0yQ0xsanRIMW5kK3VEVTRlYm04dGc0Y3VIdElseUVibW1DQldTOG04NkE3U2xHSEE2V2NyRVZlQjRlZE9iZ0hxSVo5bEw4dDdZZ1ZoRDE3MGxqY0IxNzh5Q2psME4vZEszczJQbWJxaHZMems3V0ZESlZPU2pyQ1YvMkcycWlxMXNGTGt3WUNFL2VndVZiV2JPa1BaS0RyempGanVGQVd5SEFScUxERUJYem1BSHdzbGFBNnEwQ2pCVDMyZ2lMNEVrOEF5VWs2aTF1N0M5d09DQlhnS01kWHRtTW13QitaRzN1cUFWVG1lZ2kvc3ovUnVOUkgydlJGZ1pHZGRTaTMraEtNRVdkempTMnhvTkg0bUdESG8xN3F5MmtiVHAxQ014b2JpeURWK1BWUkhFQ3JBd3NkdkV6cDFWNm9XM2I4Z3BIQ2pkdklRNVBoUCtFazI2dWhwOERoUkhDU1FOclFzamQrYXN3Qm41b0U4Qlc5Nk1lQmtzWGloWktTL0NCQnQ1WlVBNkNLemk0UkZCdWlpRGh3WXh5SXZRU3RVUVZKcHJtL2pKQkI4ZWZqUXNucjBreWc1Vjl3TmRZWlhLSFNqU2R6U2dyeEpFd3cwWVFGeFBjaWhjRmVnaDZiZ0ViU1VrZFRCRm45UmVJNm5FbXdWeEVNRWNOWmlTOFBGYlJ5cUxPN3o4S2V4aHVKWTRGbGZpcjNzS2pUb0F4Y05oZG1NQklkLzFQRElkalpmZjNZdmhVaHZ2dk5IR2srQ2I3L3lvSEptSzRrMVR3ODdoL0VydUlwdUlmdkNPdHRCaE9JaU9rM012Z1lnR2U0QVlUd1kzMHhkTkRnS2NqR2VXVDJSOHY4d09sQXFCNEpoTTFZaDFmanpjajdFSERKSEUzWDFXV0dyczZXaGNibTFSNm9QN0EvaG90SGpDZmp5cU1MZFpyT250L2RFWE53bGRnazhmc3d6WUlQT2lCSFVOUWJWVlowMG5WdmZsbkozcE1uanBLdzRsUGMyRklQbGptUW4vcG50NUNlYWRqUEF6aDY4QXFqMXdLMTBKLzZmeGNDMm9FSitoNkdJdzYyK25PLzZ4aVlEbXR2QU04MkNPb3BNT3hQUktYR0kvWGY0SVZEMXVoZlRadVJ4eWtFb0hvYUE4VzhLamZNUSt1OFZxL2xVUW84b29LY2d0R0NrMUhZZXllcDZBNCtMVDNER0dPY0pvd3JUdTg2TWlkU3JvTnFmL3B4ZzlpUHFXS2YvM1ZiUXpoM3A2UHVmK1RDRjkyNURwSlJmZCtTajBLamhZUUFzNW53WWx3TU1SZ2J4TFZmUEpZNDJsaVBlRnZOQjRMdEF5b2lXbzU4U2x0dVpTbWZIS1E4SGdRTTA2QUtWTGozRGd5Qi8vcWxpMlFoT2xTRTRiRCtGVndzTGdIanEzZytDOXJENDg3cEpHcEF2aGFUaFU0MkVXMEZlQUNwbUF0YVN4T0VZM0ZOcmpPdjZCbjRlc0l6dEhSd2p4OEhEblNzQmp2NXcrQmkvU0tyUUJUaElmUWRXQzloakVjbUNVaHNlcXcvMHNwU1ljTmtRNnJFWXp5M096L0tQbEZ6Q3hHN0duZ3ptTzh0dk9idnNJc3BtT1VnUytQTzhNN2wwcHhzWmRFTDhtUGxPS0xtVU9mN3RNM1NrajcvemZTaXg5Tk81OUloU3FJNU5YRHNFSndnM0VnMmFvTlU5ckRDaUovM3hINXU5ZTV1WE43WCtHUG16cHhoMTRHdldZeVVMMUsxeVlkdnR2MWZ4Ky9SMVpNUGVhcEdlLzZjdHo5cHlpdTljTGE2K3EvVFIyL1RMd1RkRTc3K0lYVDR3bXVxTXAzWWZFczlkL25jQzFwa3plZXZLc3JzOWVYYVhBRmZvZ3lLelpXMWFsRTloc2VqOXpZMThsR0haKzRkWHVTRnNyZ0h0cXUyeG9mcStLV01TSmo0TU1kcU1Feit6UExtSTQrQmo3Y3Vld3R4ZUNqeEFXU2U1VkUvejR5Uy9PTG5KcHJ3TzBMY0NNZFRDVWRYRHVTbExxSktWSnEwQ2RESHVQaFZXa3Qxc1BNYk9HWGNoMzBCcldrcllEdTVOQXhYRkpZUEJROUpZMkVUN0IrMWlEdENJTkd3cTdUazYrQjNnZ1FEYU1NNmd2bzZrUzBGOXB4ZERWMFI1SU9CNVJyQUkzWGlUOUNid3RZREYyWGdQMTY2SXNWTUZpNVduU0dKL3p1WFlWN2QyaEtkcUFydGRmYjNxcCtHdlVqSG9ocGJEb1AyNGRyckRzTEpYRjVJeWFoNzByYktrK29yMWVFeG9XdlNWcWwwNjVaajFZbGVRYU9VUzA0SG5naVhuTmdMVkhYSDFoYm1McFdsWkNjSEJPY1dWVytWYkwzMU9BdTZ3MEdRdXRWczA2TUJSWTBaOS9mdUJqWjdubFFFMStNbFBYNm91d2RSU3B5SVA0SzdId0ZaYlZrd3pOUVVKcmhHMWVtQ2YvUDVGZ0l6bWIrVGpXRExRNVNuaTJlTTlCUTlzTndYY3VIdkkzU0hRWTVXQmVjV3lpRnlORjYvcmtoakpLbThFOVhsekpLYzJxekZJa1hTR2l5UUVKNnh0Q09RN3FRQ2s1WDM5dVNhY3lrUTk4QmdyS0tjc1BiaUkzblRtb2hReUlFa3llMWtqVC9zdzdpU0N1VnBKRWRDd2trR1l0SUMxMXdOTlRNSlF0OEdsQ1lBcTYvRGhLZkRuMzFQWFN4V0FlRHhaMmdWWHBCSTV6bGNZOXNOSFRqY0I5TXFTWmVtd2lXMzF4cmFpRldNc09YSEw4ZThVQU5YZS9kdUZXdnhXYm5rTkxMYUZNN05henRuQmFlMEVWMVd3eEd1QjdQY044bFM1TEMvRFgxa2Q3N1I2dXhjdUxvV1VSYWV3U2dnNFYxOVczcXM1V3hzUWxwYXlKeXlNcU1uZmltZytVTitacFhXemNsSStYV21lbWVrWUhxMWZGNzY3VGlPTWpsYjVXdkNOZHV3RXNVcDRvUEVadGZycDBzbnVJZlJFbWd1T1A2UjV4MnVZKzBkTzdjSmkyZFI1cUFLcngvci81aDcxM0NrZTNNQWtINW0vSGtydXorQ3Q2UUFWdEFRdUtCRHEvUmpQSTM3SVh6K2htVFlJMERLWHJPRVA4Zm95bXl0RzBEYldLZWdQdUJ0ZElTdWhHVy80eG40anVrbEhSUS9xcFVtaGsybGd1SmZSdW9KY1hKUDhuV29vZWhrWE8yYTRWLzBrRGhJRlZ3TUNaOVRkNHFOV0JIZExCL0kvRTRNa3Y0TWhXc0lCaTZnUU53c215d2d3d1lLQmYzZDlCODZCT01sc3hzR1YweEtxOTNFT2FhY2c1bkgwenZQU2I0OEhEUTNqb1NXcmw4cTJmdit2aGxsVFBVdUE5R0RuZ0lwcit6QmtjWUFiMUJnT3lYVVkrWFhkYmFZdUFuZWZ2TW5iZjZSUHNYWjA1Y3U5d1E0cW1SRHJtdFJ0blVHdys3WFNCRlBFOWswV0l6a1JvaWlSWkVFTHZvR2VWK3NrRTd6NU5qOFBrcHpId0J0a3A5Vmo2RzN2Z0hjZ3llTDRnSERaMStQQXpQTXNRaDAwSEtOa2FKYWRxbk5qN1pwMTAwSHArVlZ2Z3pxQ09OMld3bVlkS1lEV25NU20rb0lBbDlQT0cvaGhTM0J5dkMvM3NUOEZhQzdGMkRBRDR3Umc0KzRocitMTk1hMUxUY055aG91YWJUelBRc2M5SVlXNkhCSHREdGxNQjltNkxiYnpRbk82RC8rK2krUDVpLzl6bUthanExNXBJYVJvSUNCSEJ0UzJ2UkhkWStlckRvOG9USnFEWm9XZWxDTmJiRGx0Z2NUL0V0OHRzZm9oMC9HWWtEb1lDM21iYmNhMDNxbGgzck5PQUJMaWh2Zlc1T2hzcjVEVisyYTJQV2JpMzJ3QzZJS0pxMmIxYzlhcnYvUU1NdGtJWmZPc2JXa21Pc0RkbjdORWhyeHorcDNjVmFBOXRxY2RWOEcrWmY2YkNMc0svVysxTWlrVWFTR3BrbkVFbTBHVUF5Y0IxV2txdzlnbEVPcGZPa0pIaHRmL0haRFBRc0Y0Q2M2a1JIY0pTdmxJeDY3ZW5Uc0FGRkdqVVFOcUNRTkJCNVdxTUNZdW1LcElnWW8zNElSdU4zaVFKQktyVUhOR25OQStnQkJEOE8rSGhob2lUZ2pRS1IxdTNDbTc4MTRTa25tV1pZQnBwTFZjQmh6Y0l6a0ltd0t6MERYKy92RjR1Ny9kR3lBTmNoRGp0LzB1YTRXajZBVjc4M1YwRTNHMytpMmw3SFRNV1BYWUpKd1dkSDVrc0Z4VzlTd1JGclFRc0RqUmFTV0FCNzZUMnNqQkJ2aVgzL2Z2djl0M1phS3lvNisvTFNQZ3VmcEd1aEQ0SlNBclFJbDVKN2gwK2J0SVBTSnMyVFRuSkR5a08zUWlZMURmem5oWXZuQVlmVk1PMnpTNVhIVDVMTGkzUnZRb1k3V1FWd0Q5QStmWFVMdExncmREVUliUjhJQnEzeWhQZzhsUWZPdUFyKzQxY3dOVlJhQTMray8rMklNSHQyN0hJZnpjblF4ZFZqL3hFbGJQVnlBR2dlM2FoclBhbjFhYjRlZlVjOUZoN3h5bWlqUjhPTkNyL3duTnhOT1J1MStGV29RZEM4QW8vYzFDaFBTS0owL2tqb1RBMVJteC9PRVA1YmNXNHRMcDlKMU9iNCtjZWRSSDErWXc3UjBHeGp6a3Eyb0FYU3V2Tm1Ca25vVE9zOFQxUTNONGpxNWxZNWllOHl2TjBOKyt0bHhyZS9CeXo3OVBZL2gvMDY5eHFVMVdSTFNiQ256SlFrd0lUc1BiMllkdUdLWVlIck1rTXExK1dqRjc5VUtDa1VmblJqQnVVS2Z6Z0lIQUZRUElNaFo3Q3hZdnVyd2VCc29Sd1A0OFYySHVUWHYvaDJueFpUdERJOUxrdTMya2U5Y20xMXBWWTVYdks4MktLeG8zT3ljb2p0NE5SVHMxOXBPSHhkdktrckZqSTdFTEU5RFcwL2M3TDVZdlBxeHVXTC9YeVhrY3dNOGFvTzRvZzhXWFFVekJWd0s5WTlnNUY2V1JwUThnOVl4NWZ1enR1eVU3djNCNVNUblpXYnBZN08xKzJxVnAwODAzaWlXRE81RGkxZE0zS0ZpMnJHeGFEckJKTkNQR2RjbGhvWldHeFk5QXJJT3VSSDFxRUNzZzc1a1hYSWh2UW51TU9MeHdQb29hSENLeHB1Z3gyUEI5RzJvY0libXBzbk9Fc0h4QW1aWUVYMDA2YkFXNEFDSE1BTTdKVko0aUhSbEg4SWZPY2p6SC9YYVFvT0pOOE14OUxLazNabjU3M1R0Rlh2eVZORFY4WG16TTA1ZW5WaWZDSFJWWUNTbk9rbHd3L1FRSHFXSUI2SGRONWdTVjY4bmhIdlNVbC9yZmlVOUorUjZ4bGMxOHBBckxpZHIwODROSjQ1ZHZRVTZkRkJjYTRPck1GQjlrVUgyc0JFQm0xZU85MEtaRnRUR2J3WGQ5TkJYNUlUZkcwREV4R1VrenJOQ2t3S1VwbkpCRW1NdUlPdlR6dzRuamw2N0pRR0Fpei9DWE5UeEhrU1Buc0pINS9DR0xHOWVnNlU2bVFjQThHV0tVd3FTVEw1SjRsYmlEbXBndFFNNzhtUXM0VW53ODJGMlRwb0JScTBaTkRpU3BrSXJFVzR5MFdtbVptRFc2WDdzZXZRdXArcEF5M2lscGRMUk5MZ1EvNzdrdElyTE91ZzczNm1HWHhPTTdnclRTSnBUQ1R1aTNEWGl3eDBwZjJ4anlIWWJFamtUb09aVGh5bWw3WEJSUjZqbC9hZ0FNWFB2d0FDTTRlZnNRSXJIQjJ3bVlZVExiYnJZS3BlOW1BdGYvSGt5WE10NFVlV0xWcXgzTXZ2VUhDN0ZzNWFYanhad0pEQWVjdUxKd3FZVTFwT1BKcjdZcFFPVXQ1dUsySysrQk9ZRDVKRlN2c1RvMFdLNklveitQQzhwUDBIVmUwTjFZY083b3VQV0JZYUc2NkJCTXYvSlZWNTRzazg4VHc1aDZjODZWQm04cytmUHdEWmQ3TS9jL2Z6VDRsWnJhMktEUzcxVXp1NlRzRFU4T3N6Zm13K1hseHpTQnRUZlNUbGhKckRVeVRkZ0l5b1RhSUVEczgxUkVJRURyNUt2Y3djdmN4WUtKM0ZrbzZsOXRLc3pNVTE5b3c0OFlNOXc3V1RoVmZReXpvVUhRTFJEOHhLdjh3MEdzckNUOGF5YzNHbFBVbUhKelZNVzdMUUp1cnNCSDk0NmNlY0VaMklGcUE4Z3N5QndRem5DRDlVTXBBTkp2STJNV0NRNEFEZkhXRGFOd2xpMzQ0cHRnTG00V01WSTJvN3ZGMllZZkI5RW5QR1Q0QVY0b3UrekFUNHZwcjVMa2RvaGc1YlpwWkhEYk1yV2RqMW1aMkFKdzZTZEI2T3VFdWdNQUIzcVJVZ1lLdncraHBSd21CbFBBTXJ0d29nSENNNm1LVzRpeDhUdSt6ZmhHQUxRc2dZUWtqc0ZrSUg3bm1BaWQwa3dDTklrZWdZV01YQTE1Qkh5TUI4RXJPR2tLRUNOU0VESzZ1WkF6bEN5Z0JiQnFhbGd2cmhxOHUvZlFzcVdUdjh3ZCtuTnlYbEpPWG96Y2JRaVlNUnlHbHNjUWdvNGlta3ZubGxYOVVKN1Vvd1J5blJZZW1CNmhtTEs4NUdhc0dLdnZZSzRYQzZQSC9mbHIwYTJFemYrQTNoY3ZweXk2M0s4K3J6cDliRVZXdS9Bams2N0QrLzFrNk4rMkgxYUN6TTFZNmh1ZTBaMEZNY0JUMWw3OEFhekVBbGZ3ZjllS2RiODBEZVdyTnIreTZOZENaYXYwYWZGYXpXZVc2NVRqWVErVHUwQlpVSUJ0NzlGYnFCaWVwYjc0c09JeWN2c1VuVStHUHYyS3k0alltYmU4ZmdYZ2Z5RDJ5cDNObzdKMk9UYnIwS0FrUVpYN050MTdZaWRWRmhWcXBQNkxMQUNDSy9hbEdtZytybk1nRHhQL3krNXdpZmxWelozdEFMY1RWNlIxK0NhaVJXNG1yK3NTaVR6dDJZeGtzQ1lRbkNBajIyVTRaZTA2MFFkd0xIb1hzMFdFRE1jaHlET0dkbWd3Znpxa1BnQ1FFSUxGWUlXRG1ORVIzSEN0Z2ltUUhsV0lHRHRuOFZVSkVDNm1sTXh6SlNRRVVLcU1jS25RdHhMeDZVVWsyYUUyOTVNQjFqb1JlUHVSd0dPQnAzZHY0VDdpenJMT2IvaWlBMWUrY1lhdjRuWWhvREtub2tNZnZIZlVqZG14N01QYkdZaDE0RWw5VTA1aThkS1pwQXc0b3R3bnRTV0VkRE1XbnBFZDBzbGZlbDRmTmxBcHoxWU5aQkx3TnRIYXRKOFRoRGNXS2QvekY4R3ZQYVVCUVV5d1R4amdkemw2QU9aUDZLSmFXc0NPVzlDY3BZV3Z5Wm9QeUN0TGVFeGlPWENSMC9lakFBTUkyUGdoZlNqUys0UytSN0daQitRY01TS2NZUTRoa2FacExPU0U0eWhzNm94Z3A5Y1BkcFRDREQvZldIc1JlQlRCK2FrdnBxYkt2UFh6SmFmRWthZTdoQ0lBZzd2RVRDTkhNU05xZnhvaFlHekVqUWpPN2NRMmc5K24reHdUZFMrSTh2TGM3SFgvTjREbDZFUmljelg5SXczUklzNkJHdWFIV2xBTFdFNmxwNHlPUFpKTHNmR1o1RmtjTEhSZE9ZZDRaaVNxbFlHQ25tL3ErQk5DSEk1V1NrSDlBMzRMUjBQeEtLUnlMc1RvamxwREhmbEFMVzBzV3lhQXZkQ2RSYWtFMlpzbGI4bmxSUG5ZS1V1OXRpRmpkWnEvRmNQQUxiNFRROEFWamNGUndmbnExcmF0UXFROU85VUQ1eldsSndPOUk1MldoVnlySVpkbXI3R2RkL2g1RWd2L3NEOU54djU1ZXZ6V2ZPUXduaW9OU0RFUnZCWFI1b0NSOXBXQTNEWUFCa3cxRGJOM2kyRm45R3gwcmttaG1saEtYaHJ4YW1tWDUyZGRrUVBCU2pVZGhFdTVSSXpoSENnUHRFRHFiVGwrSFFGNTBEU1A5b3lCR2Q1K0FXTko0STJTOWtJQ2d5VGlZRUVxVnZRcWQ2b3VSMWM0ZGt5WXlZNVNUNFBjSDAvRXNkVEd0Z29QSVNEOU02TmtDdmp4dGd1Z0kzNFJ6RTdjVTlkSCtSbHcwRXRnaFExWEdjeHptNERzR01qeTdRcThPbFdlQTZ6QjdxWUNiMGtxenAvcm9ENTNuOEdlUWhQUE5qQnU3VmtZRm5Lcmh0V0tuN2F4cEJNYVpGRU9PbGVUS3R3eG4zK3VqY0pFQWVQb2pJRE45Ukk5enBXTXJqUHhWZ0NiM0VqWjNaTDE1MGJoU3pwUmppb0lUa3d3MVNBSGhzMmJteGMrTkxKOUdRSzdIcFR3VW5VdnRyaEk2dGVUeUpZSklvVlhWeUVyTTdOMktldUFMQmRwSXQ5c3pqc1lSY3lpUElPN09sR01KU2RhdVRPcGdNVnRJRnBxeGpOUWh5S0tqa1liSW9JNnFjMzM0QkhwUURmOEVEdERnWTl3SS8rbjVMMEpKbGZuNlR0QmpEVEJvZmtkZ0VUOGs5dG1zREk0cUVUWGNnalRBU1RuVzZrdWFhTzhjUlpwSlNtMG1wZW1PcFJsSm9wS1hvQ3VmeE5BVWNnYzJZL0NNOHZYTnlaN09DZ3hQMWd2aFpDL2t2WlRwZDhUbVlKbzNGSnBER0E2YUxrMFJTUmxUVUM2UUk2VXdVWVNjK0w3cVNYamVMay9GMENaOUUwSlZ0T3ZHWlpLU1gxaUxjRkIveTRqaDhEMDhoRW9KcklCdHFTR3VpWitjRm11dndtVWxHSDNyQkFmSS9TeS9yWTZvRFZ4NFRKS1RJeDgxa0VEY1RJanZ6eFNHRUl4MmJpSEJzZ2xtS1Q3MmVRYVlNaElBU0dMQ1dYUVpIeUpOdVVSdkV4L3lQRC8xeHIxM2E4dVRBaGtGcWpEQS9DZy9CSG1BeEhOU3c2am1NQUIrNGliMnZZY3NGNDlKWGpkT2V4OTNRd2R2bnQ5U29MK0xOL0tVbWZYU05kdFNHMVI1RDFKNExtbTVlTzliK1JFdDJxK0JEK0hjVkJzaStBRmNJUDg2SXYxc1N3K1Bhajk3Z1NwTERPNjhxdUs5ellhRG9CZ05sMVpaaUdRekVuOU5RQUt2d1JnaENjQVVHZHBaaEc0a0hvVVNNQXhIM0NqS2d1K3p3Ym1IeGRsMkhCemtROGgxRCtNNm9qeDRJTkxRWTArR0J5QlVJa0UxZHh4Ym9KdXRJNjlqQ1F6ZWNvc0NKSDZkZ2MzaU5zRFVOQ3p1UFNyNHZzSzFqQytMZy9hK1MvMnlXY0JBRU1ZMkkwa0ZvNGJIOGV3OHd2MzNwNExWTG1qbVhMMGJjVVlQWmsrOUFEdkpoMzJPeldmT0NGeXpTWGxzOHA0R29QOHlIRDhkeUxheTh3VGZVUlFjZDFJWkVybzViclE2SXJUNTh1S3JtbUJZd1Z2Smg0ZFdISTdSSER0WlhONmlQVmtlSGhNVEVCR281M0IvN1F1OE9LK2d0K3hMczVWOW04c0dKdWlpTkorNTlsUWJ1NFdQZ3RHS3A0a2g1ZWEzbVBQU2VUMk51L0ZqTWFUbVlsY0dJKzhUNDBjSW9yQjNGY05EN2h1N1hBOEtQZXRsRmVNRkRLTzB6R21FUHpQMTBVSUJxSUlkb3V2MHJCSGJBalR2RTRHTTA5MHVTY0d1UlFKNWkzbnhtTEJNckRCR2daaTlmL2hzNlF0ZTBDcnVHODg5djNmbm1ocy9aeWRwQ2hrejJBY1NlNkJrWnR3N3ZqOTQwaWVZQ0x5NEJTOWt6NlVJVDFQS09ZNVlraS93VUpPRVJMODd2WE5JNW4rYmdheklLWVhvWnZPa0k0enRIZkF4REhWK1QxSzl5U2FrWGV0a0V5NDZ2Nk01aEhXRUlGNXZDSXZ3VWRmWWsyUTZrTWJnUC9YamNEVUtoRzRTUjRRdERvZmhQSG9MaFR4d01nUEFrR2dkamdHRDhKK0xnZ2VRbXBBZGVkcERNM1Rpd2tuZnMyY2NFTUJwc1pZbXRyRk1FTUFFcjZQVW5Oc0ZXR2xLNlFDZjV1QjFNWjdBL0VOOVA4Q2Uva1dDQW1IaVVZMy95RzRFSjFIQ3hRajMwaE1tZ2hHbGdLZS9ZdFkvUkM5aFFncFFiQVg0eHBCRkx5OFJOaVJ0MEdreTJFd2pHS2Q1RlB4NkNUVldkT2t1UVAvemxiUjNKVU9EUm1FY2J5allUTzIyNGlETjRHS1Q0TURRcUtqZ3hJTDAzVHIzSnYvOE80UUdLZ0tLUWlxaGFNN0syR2tuOHk3YWpLMC9XdmUyZHJUZ0FkUGF1Y0FaL1MvcDd0VVRYNFVlNDJpT2JoLzFRQWRXNDR0bHpYRVZDcGJEWCtSa3V4WHR4T1FtNVFEbmVoOHZ4ZmtRNkF2OEhGSEpyQWY3Q00zblJkSUFpS3pUQ2QwcU8yY1NmY2FoQ3VtYjEvWVgwMU1ubEdRd25Pcm1wZ0pTL2liWmsxRWgvSmQ5NnYvLzkwd3RhM05DcDRQOC9mbm9Cb2d2NHFZRUppNmVwMXNIRlg3Q2Jnbnk4SUQ5UGMrY1lPbGRmMzlpdSt0enprc05BNzNuVDB2STNFTGZ2Ti9UbWJUbmJ0Nm1VM3h3b0xxK3ZMZFN0VzVPV21yQk9JMUU1NFFXeGk0UkZaTll2Tkhhbit6aCtUc0dsK1MvVjc2NWV1WE0xK1BEY1F1MlRzK2dGYm5FQ1Y4VW8zOFlKYUd2aHp2eWQ2c3I5YWRHNjVEVlJFZnI5QjNLMEVxclNwNkthNEJHMkN0YkNtNzQ4VEpnQzZPNlZwL01oakJ6NmlBQjRJWmlRekkrakgvMkVEQzIvaEVYUFlBbXBNUnRNcEpiWnNmejA3ZGVYUEZXL3ZYRDF3VVB2RTZOaW83UFdFYmZoc3doR1BNTXA5RXE4NEVVc0tpb3FMZHlucmkxZkd4NmJ0RFltS3I2MFpyT2g5YW5Qd1A4NVRDR2pxQVBtcGFFdjRuQ1l4dStNaUN5SVZPUHVnMGRoZGYvNzAxLzhldnZTVjQvbkg1MGNIcG1Sck5lZUx6MVQycW8rVUptOW9WU0xKMk43dnFxOHRPcEErWnJZZUYxeVhLeHViNlhFSkhIcFMxaXFseEdFVTJFU2oyODV3blE2RjZNQjZYaWlwcGtwaGhFL2ZOZFFZeVlSTWYwSENQNnBXSUFDTVBrYXVrcWRhanpPeCtTdDIxdWkycjFyYjAzTnJ1UjFLZXVTWTNJMDJNWTBaRjM1M3BJOVpZMk5lL1FweWV0MElWcDMwejh1dGQ0NUZucG9WWkcyWmRmK3hrYlZsYVd0Z3daN0xaOGZXaEhhbktieFMxc2Q1cSthY1hYRlc4UElUWHNPQVZKYnVXRDZFcnBJYlEzRWsvbjArb01iYTlYQVBmOEt0TzhtZitZMGNNNmkwZU0rQzdoMXFMNXdYN2wyY2VyU1pCOTFiRUxCdG1RdGpBRkhQbGFmSEV1NldWVlp2cmVxcWl3NVhzTkI0cWQzSmd4dEVTQStsWWZOMG90eU10d1R4MEd2emd1ZG5wall2M1Fvendtd0ZIcUpFZEJiRG51LzR5RVZLaEVlUzRNVkdOeFNqeDdKVEQ2a3VRcG1xTnA3L3A1NWFreVdBbW1pYTdFSC9aZVZKUXluOFZxb3hLbTRFa25XWkZaOUpaL1d3T0NkcGFzMXhBc0F4WjY1bkhwVkhjTm9PVEhxbkhDY05CUkxHaExqNE04U2dSUk9FYVEyR2c1bXJhdlJFSjlTdEcvRnNwMUwxUUdNRm9ZYThDTFNEV0xvRjBFMndrWTd2NTF0eUpxeEY4QnR2RUI4TEpWM2pGK2ZtTHhOd1BiME1xd24vWk5NQVpWUFBoa0RjdUs2djkzZHRiS08xZzVMYitFalE2em9KakV3U2ZwdVJwRHdYakloK3NxSVY5endDV3NFQXpNSVNnZmFWMEk1TTRoYzRsb3pSQlUwQ3c3VU1NM0pRck00VWpvNnd3WHA3THdDR2dJRkJ6aFVLOEMrclFLNGl2NlNDY09CZUFhMmtlZzhjWlowZklaRGZrd3ovUEZmQi9ucVNnWXl5SlJwRmdjT0VoeWg0Z0RUVEE3eTZnNXp3MEgrUERuSVczVUkwa0crTW9scDloUEFVendvSGVRcnE1a3ZjNFFqY0pvYzVETnJtUDNKd243b0s1RlRMbEV6M3BKNFRRL0lKY1RvU091a0g0U1k5WVNXTUJJYkNHNFNMYmwrVE1HOWYxT1NSUWp4Sm9Ua0EwZE84cGtIbVB4TkF2d0J2MHQwbEZjeDhLdUlDQm1aU1V3ZW9jSWVkaEFxTXF1Wmxod2h2OVNXNlp4SzdFZ0tvT1VET1A4T1EvUVdFQXRDTHJES2x6QWJ6dkNGelNpNXNDSDhpdnJOdDBRV3YvRzU0Uks4T21YTldtMFR6RUxZak83YnVSVkJNbXpuRDFZbHI1aTVNcHBZdjcyTmlOeDNzcVh1RkZIMlRJUmpJQU1ua01tYXdVd3VEaFFQOFRjenZhN2FxZnNQSElPVnJ0ZW1QOG5RNXV6WWtiTkQvY1BsQzVmM2ErMGJrQzQ5Y1Uya09pUm0vN0ViSitvT0g5bW5TOXlxNVpaRDZ6dHcraE1HR1Q3cGtRczlsRy9GMEk1V0hqTjBBSjZEZHEyUFB6QlBiVDlxSk83aGVuN3E5NmNxcS9jVmFUZG41bVJtcURiblpoTnoxUS9iNlpLOGlxMzd5R3lIZWNRV3JQWkFFdmthU0t6ME5aRG1WdWxySU54QU9QNHJ6SDRocS84QTZnOXlHQ2p1NGV0MlZKVTNxbzhYUnlkcE55cCtuY0R2cU15djNxMzZjZTZ0QVU2T28zQlArNGRUZi9ycFZPdkpjbzNUVWFUTFRGd1hwL2JWMWRTVEZSZ1BrM3lJdDcyKzhyc01IaEZsYmZsck5JWGVVb29PYkNzdHJWRlhGbVhsYWN0K1FUdVRJN1ltcWNkNHJScVRyTTMwUS9ObzNTQjBoZmJFMnhBdzlEbllocmhrY0hwMzh4WDBmcDlGQnNXYmRQb2xQQlN6ZUorUXFOWGg4V1dOSitzT05WZFhKUWRwY0JOZXljOCtQUjY2dnI5Ly8wMDVzWWY5SEI0aGpHanA4eVl2UzlaSFZjMVJEeHcvdEsvSHhibFBEeDhvMmJWTG02MUhTOWRGNkZhcFY4VlgxbW01WUhpZ2d4M3ZZWUJlc2hIcVJxelE0U3gvQXZ4T0MyRm54MGFGcHNYcE5ZYmhabWpyemkwU2VTZGdKVHE0Zlc5WmpicTJPQ2syT3pjN0oxdnJqNzBRaHpNM01aZUFsMEZ2YVRYcTNaSEtoeCtJYXpqYXhrU0VCMmpxT3hmeVg4QjdoTTNwOGZnOUtad0VUbitRTjVXaHdsQ3drdCtIRTN6Q3h0VE1KSFhDdXNJY0xWR3JaTzZxU1R1c3ZubXE4VkdKOWh1eHAxUjE5ODk4ZUdWY1kxTWJFMGx3Y2tHYm1HSUJhb2lrZ2hVOUJKYkJaSENVekJDeHlRQnlLV0trZVN2YXd1eDlldmdnYVRLTERJMjRsZlRUUTZwQmlWc1JaZzBsT1BBNkpvaFZ3Q252aUpZa3J3VldrQzd1MjErcnJpM1J4MlRuYmpSMmtXQWlqRUg1dS9KM0ZhaytYM0YrWXB4bmxsK29walk1b3R4SEhSR3dMa3F2elN2SkxkaWhVaDdaaXVsTVFlS1U4azQ5UVZSREVDWEZHSG0xU3VKVjhERUJMa0UzMGw0MzB0NEo4RDh0aEo0ZEd4RzBObHF2eWR1ZXUzTTd3VkdJRlpuQ1NmQXo0Q2d0SjhRVTYySTNFaHdiQ1RGTEVUZEN5QUNpb3U3eEFWemZaaE1wQ1lVK3hxbmJMSjdoNjJ0MC9qTldSSVZIUkplZGFLazVjMHJyYzRNbmlIY1F4QStLTVAzM0p3aGNPc2VSWGpYQ0NMUm0xOEdFaStyWDM1T0pUaXhxdi9PKzVocTRPaWtwbFRCWmFxU25OQVdKS0xhRE9mRzVKQWExY3pvMFBLYnA5U0ZFeW5adTFCMmFvcmFUcHFEYnVhbmY1bWdQbFJmdEx0YXV4dmFTdkJCcjJwOXNSWjZ2cTB6eW55Yk51emd5N3lxbGVZZG5TM05sQTlDYkpITmErRWFzNFNVZi82M3IxeEZ6MnVqSWpKZ2tiZDRPQXkvS0N5V1NVM1BTQ2NsekRGOU5hQUEzWWxsN3I3aXA2SkI2OTU1TjJYc0lPa3U0cmhQTmlEWWFUS3BBSVQ4dUR1WTNLTUpLeDBMM1oyY3ZYenVoYTVwN1FPTlhpakszWnUzWXFTcmVzN09rWm50U2ltYUQ0czFPZE5lM3hYWGtBcytaZm1VaHQySTB0V21vYkgxK1JxWnFiWHA2WXZ5NjRrck5Ub1ZFYmV0cmNQcjl0VjcyRTNTVlBpUnpncjlOVi95T3B0SDdYNk4rZElZL0NzbE0xZ1dwazJpZERicEtrOHM0dERrOUp5TkROZTk0d0oycXZkdTM3dENVdlNDMnVldHpOcWgxYXd2THR1WnV6U1BybXk4Y2Z3K0ZldG5uWlBLQldZZkFyOFQrYU5PNm5MVnBxcG1OWG8vcm0vYlVsR2x5c25JenNsU1pvTml1MkpsWFVuQkFjdzNhcEFteEF2dWhpS3cxdWloMVZHcDUxZGJjQW9LeEdZaHdZTVVtaGxqWlNhTmtTZmZIL3ZIZ2p6QkhYOGZ2cFRIaFBwQmNxQ2E1Zy9IaWRiQllXczBQa2F4bUJrd2dzdXE0QURRTms2WHB5dEx1MkZNSG5vaWJTcnhVWlJBcEt2bmp3eEJZMGx2WDI4S0Nnc3oxNjJFYUxGMi8zZ3hiMDVPSGI4bGUvdk9XN042a3pZMDczdUQ1R3d2eE1EekRDZ1NhY3lCaUpDWVREQTR3Z29jTFlqTENQRzJMcDZ5R0taTEh4UjE4RHB1UzVad2JBMmVJWDlsckdUd2hFMlAvRzBtSEJYUEF1ZXhYaEU5SXl5UUlrcVg3WUYxL3hIRW5CTERYeTg0U1U5cHZMZ2cyZmI5ZXpieFp6YnovTU1MZ2cvdit2Y2NPWnVBT3hvYUdwZjM0TnhlRWdZUUlnN2R0SDcxRnVlUnQ2L3d6dUEwSEcrVnZNQWdyZU9qeHlkdjI4VysvcWI0S1hDOGNNbnJiemtqU2drMGxPaGZ4dkc4bVl6OEtNNUszN1U5Ym1XQ2p0MjNVMlFUR3plaHRtL1VVNUUvZVNROFo2TVZLM2o4cU1UbzJwYnpxZUUxRlRYVkpZcHdtQkt6NDBlTm1PMDg2ditqQlY0K3Z2N2puZVdtQ0ZqcHdONzZ6Qkgrakd5Q1d3RGRvQkQ3SiswY25Sc2RJTldzcmFxcWttaSsyOHFUd3hGSEd5bDk4U1NwcnVEb0d3aVJIMHA5WE1IaHhCWXlxQU9mOU1oajJoRi9XRUhTcGNKZmtwYmgyK2dSLzcremtVVll3cUJDNmdod2NWYmRXblowMnc5TjN1b1piWHdGVFNZVWQ2L2s3RnkvZnVoQjRjczdrUll0bWVoN3p1YUhsempEN3dCSGlKQjNLQk1qa2Z6MENpOTU5WHJ4a3pwQWd2R0RBcktSVHR6U1BKUGZRTkdKekFQYlFneGptNGdrNGJUWStqQWRoN2pMdUJ1TTNhYm1EVEQzMDRpV2ZUTU0zcUhvaHlZdklSQ3lXOU0xeE0wWjd1K2NrOUxlQ0FmUnNmSnBZbEF1M1AvbU1oZzhWUHJtTWJ2amtNaHJvemh3UzFvS2FoNVlpNGFuQllYU28wV0YwTG8yZlNRNmpUZEU4ZHFCaG1lUXd1ay9ZWS9RWDNUTmNxR0QyL3UwdSt1dFE1cE8zNkJsSnYvdUludW1MUGJIbk9NbExkRlE5VXdVV1ZwMGxOTGVUS2NwaTRLYWpzRjlvK09RcHVtaVlzRWNuN2lUQ201VEYzenh6OXVxcDRHYmladXMxMy91dy95WHRiYmpCM3p4TkVrT2t4S1h6RElrY2R0YkJFaDFSWTRHSER2ek9DNkI5YVBUdjNXWDA3NTBXYVBUdlZlOEEyVHZRcXE0Uy85NTV5L3puU082alEwSFAzeURObkFrOXZuQ21vUm0veTFwdXMzQjlPV1B3SmEwUFpUWUw0dWJsUXJudUVSQzFoS1FmNlNlSGNRYmI2MGNHMit1N3ZUSFRnaUpTd21PV3F4Y0ZObHcyMkY1WGg2L2ViclM5WG5samRLWFI5dG9WNFI0cG1CcUlCNnZzejQzN2xvangrNTBDV0g2eXZXNXpZSFlJN1o4c3I5c2RtYjNNS2NudTJzVmdkKzFpc0x0Mk5kcGREekRhWFk4eTJGMlBOdGhkajVIc3J1MXBXQUQ1MGxlVnNBZE9uMlUwdS80VzU1TUJsQng5K0E0MzRDMjJIMlBBZ1V6Rm9XQ3IvS2x3NndZQnVob05xcU1rZytvelo0UUZ4S0Q2YW9BQXRtVUM3bFhHckI3R25HTEVmcEs5OHdHanZmTkczRU5Fa3IxemhRQngwcVQ0ZlI3enlhcXc2MHltUVlDRk1GWmVCUm1uQlBEQXVmd0p5YnJGMTJEZElwcVpubUJhamJIbEdxNVFnTDV1RE1mdDBuVzQ2bVhIeGYzODdEYnZXM2MrUC8vdERkL1RNNlpPWHpSS0E4czY2L242K2wxbEI3VDZzdXEwZytvN24xOHc1SVpIcE9rVHRQdjAwYnZEMWFUa3lEbXRTMjlyNFV2eFQ3N3pBUDQ2b1I4aDlrdlVTVC9ubHpCUE96M0lrNmhlbHpEY0d0RGVlM2YrN1plZ2xwMkRkL3dsZXVPYUhPS2NNSXZXMlNLaUx1L1JDTlF3R0tnKzByUnQ1MzV0SnBsRzJXdVNOdW5VMHhmdFB4V2hCUTE5NmgzQ0lmUytMV1ZiaWpXd2hqNzlGdUVNK2tMTGpZb3o2cGFqYWFtVjJwdGtaTXBDVnBTT1VXTWJiRFVDOTVxcm5VRnpCb1ZqOVc2QjZOeUNvR1lVTXdvcVJndmMzeHEzT2tuakZtTFF1QTNIM0k4SHBYMFdoMzJKeGkxZkFHN3NJUVlmcGJrazRmWWlnYWpiTnN4bkpJZDYzVi9MOURJaUJvVFJtM25zZEFOclBuZlZ2TDZMNWoxWkFlYWdVTUZHNEtBWHVBR3RtZm9jNFRCc2hidGpiN3hEeFdHYlQ3VmhQbGpJNFROeElRL09zMEV6N1NmTm9Dbm82ckFUbU1FS0ZkNklPY3hqTjZ6UTNIVkdFQXBXMEFPOFlUdXB6OEJoRUdSd0J3NTdDY1Fua0lFMW1PRXJ3VXg2dDRCZHgzSUUzYXNOUG9FKy81bUlKT2MvQmh4SkNmRDlheUxDV3k0Wm5QL3NQeTZYM3BIeDJJeVVvTEFDRUxSRGQyZ0RaSEVmbEE3UVUvbXlBbG8vT1pLc0oyNFpDWmdpYmhuWnVzMUphMVNEYmk5NmJYUWxDWlZjU1dwQVpYQWx5Wk5jU2VLUCtoUnI3aHBjU2VwaElIRWxPYmIzdUxxcFdsaEI0eTVEdmJCdGhEWVdjd1pYa2tWcXp0clFjQnRwdUowMERMYkEyNE5TK1JaRTBaMTRqSlR1WmlxQU1qcUw3Q1BPSWpNdURkS0VYR0xxNmNhRHFTdldFNm95dERGWVJhamFsSmFUbnE3eXFUUTRpNnhiNWJWdVZnUWVTSnhGQXBJRDFNRjBIRWJvSkExZG41d0YyM3B0RlhEbzVwN1d5a3RxRGs4cU56aDRBQ2Q1ZUt3WFU1WUlGMkdDd2MwQTdLY3ptSUVtaWM5M29jbExPR25JQ0dHSWgxTVlVNVpxdEdkUHJoTmduYmpXWFFBTkhNMFN4Tk53OU4rV0Z5VHByeEJqa3RIeVlvcUVSQ1poTjE3SFM3RVFob1B5RkxBREdhakJFK3hseEhCSkxnNlZYQlY5Y3ZBOHlWVmFoWWwwWUd1WUExbGdBZE1nUXRQSjBWRllqVUJIKzZRc21XdWp4cVp6dnBKdXZFeWtqOUMxelBFc012aGR2MDV4aHE3WVY4MHQ4MlZxeWJhekhMNkM2L3oxVTJjdXQ0VWVYenhubWZjQ244WlZGN1Fqb0MrdlBMZTFMTGQ4bXdvNzBobTVDWm1yTks2ZG95VHZwcVdwMEF0a1lCRUx5dE42TUFjTGl4SVlPaDhHZ2djTVZuN2JvWVJFbnJ4TEVHNmxZN0VGK3BLZXNuWlI0Q3oxMkJEcHc1UHRMeDVYbnRYc29LdEJpUUtEeTlwUHQ5WWV2Ym92TkNCejgzcHlOSURCZE43Mi9PSmkxZlBaditBUmtoL21STnh0WVlQWEtaMUcrZTJvOUg0enNLVUtVMDhId1hSd0E5UGZRVGlnNFpJT01nVi92MlJuU1MvWkJFRjZ4YVlLaHBlcUU0RHVOekF0Rm1BUE9Nc1BpUlY4MzZkRFAzeDQrdlREaDZGUCsvWWRPclN2NXJ6bGw5ZXVQWDU4ZGU2WU1mUG1qaDA3OTlxWEdoaGd6MStoOVE5UTdjNTlWZldxUS9FVm9ab1J0SFRvdUVUdnVZVjIwWnZiK01JanFJVGV1WU80bXEzUFROSnkrSlJZcG9NQXljNmtsTUZENklrNEFQMU9jL2ljZUVQM0E2aGxoVEJDbmltZTVEZnYycFZUcFA3NjgxTXZUc1FjV2V3VEdyWXFZbi9VeWFKQ1lybWtqVXBiblJtbFhwK1ZsNWRGRUQ0UVcwRFRvSDlBM0NOSlhYRHVNT0hyayt0OTB6STJiczdXN050UlhYNU12V3Y3NXB3Q2JkRTVsSmVka2I5R1BYYkNFcmVWZFFIbjJob2JqMnYvVjkzVC85OFVTdjgvcWJId1VQRThESmFsR2F4VTVXbXpCS3pweUFBSFdickI0RitlL2k4cmZ4emFrWnNsQUdQd0ZQRHVTQU1YMlFacHZUeE83QVFFcUJySmNIaGF4eTZReWFDbFl4ZGZBVEtFYjlLSldJYitydGttdVJZTU1RUnBnM2VCTWJ4ckpzRTlvR1BEVDY2Z3NkajFYdWtIN2gwYitEOXZQcmhWb3NWbXRMSThKaXMrTVV3ZHZxYUVHSkw1NWVmbWsyOCs5cWMzWitabWJWS052aFh3blliRE56dUtpU0ZaUmdmWnhqUUV0NTJWRE1uQ0dwZDdydlQxSlptQkhXdC8vUGtuR2FqL2N1TVBHTHhHOUhIRWE2VFM2RFZpTzUrZmZOSHJ3YU12ci81MGQ4SFpTUjVUcG8waWRmcDFiSTRqT2l5Uk5ub09GQkRQQWI4UnBJT2NnZUlGNUN1UnVDODlEbHVoWDJtNENsWTh0cUdkU093VkxRbmJUcDFrbHdsQlJOaWM2TEhIaFQ5SjZnT2NxenV2UDAra2JUMk1sSy9IWFhpRGJPM0l6eS9RUks1YnZUNVNuWldWUzJRcmZTbmF2SFBQNWlMMTQzdEVES09iRnZ1R2hLM1NjcW5GNG9aaUVJcFBGdFBZdjFoQm9vbkZZRi9jV214R291YlFpd0UzRnFpS21pNWR4ZTk3RW52WjAwcXFSdnBNbUR1MWxicE0vUi9aVk5rbVdaM3N1dXlWQ1d2U3oyU09TWVRKZmZsdytTeDV2ZnlhL0J0VFI5TjFwcmVRRlhKRG81RW5Da1dWNkRBNmp1NlRTZEtkN2tPUG9DZlNDK2gxZEk3aGs5aE45TmYwTS9xdFFxV1lwRml0Mktvb0lSL0ZQcSs0cm5pcDZEUVR6T3pNeHByTkk1OE5XMjYyeG15bjJXNnovV1kxWmdmTnpwaGROL3ZNN0xuWmIrWXljMU56MXJ5N3VhVjViM1BCM05WOGxQbEU4MW5taTgxRHpPUE1rODB6ekRlYmJ6RXZNejlpZnRiOGt2bDE4OXZtZDgyZm1yOHgvOENZTWtyR2tsRXhmWmxCakFQanhuZ3dvNW54ekZ6R2x3bGxFdjc1SUhZVDA4cWNaczR6VjVnYnpFUG1LZk9LNldEK0Q4dXlQZGhlck1EMlp3ZXpEcXdITzRtZHkzcXhLOWdBTnBTTllIVnNPcHZEYm1HM3MwVnNHVnZMTnJGdDdFWDJGbnVQL1pyOWlYM0J2bUwvWUR2WS85UEZ0SXY1c2NKRHhRM3FnN3N6OHJSVjBCMFY2UU4zUktnSExoYnd6SENtb2ZnUXlabk1MQmIrL2ZGa2ppL2VYVlpkdlNObGJYTHFtbGo5MmowbG1pQnN3NWVXVkJ6VUtNWEd3cVJVL1JwZGVJSis5MzV0S3hHSlo3ZmFQMitNUFJTK1U2dDgzN2E3c2FGWmRYbkZ5WUZENXkyYkY3RXZ2RFpONDVYcEY3eFVOZS9NQ3FBMEhIOCs1OGpxR2FxLzdVY05kc2lRN2NoREw1ZTN1TzkvbTZMK2JmNnNZWG1IenFWb1RNcktvRG5xTVJITlYzWnZxU2lvMUQ0VjdSQjJwejA2KzZPczBPejRjQlcyZnVjQWpxU2U0aHNZMXFoNUp5WWk3ditkYzI3by85Zk91U3kvNW1CRDVpazFjR0Q2UFF4OFB2ZTZ1OHVVK2U3em01Yy9PRkJkdUx0VXV6TEZTMDkyQWJFN2RpWnJ5Vm1iVDBncExhc3JMNnZlWDVLY0dKV1FISy9sOW1XRXROci9yOThDMkV3MEUydFZMSGpRMWgzZXFFbm9kRjdGZlBJRDh4YXQrSHE4U1hJZlkvOVhLK0wvc2lFK3h4VGZJMHJQZlUrSit2TUVoSzRUOEhJOEc4R0lhSDRZL2VFM3hHNGszZFhRT1lXNTI3ZW9EbXlwMjFhbGVTTDJSZXovWmlLNGZzRC9HQUQrWS9TblpmbStkSEovcC9xVlRpOGpSN3JkbS8vMVQ2ZUcvbmpSOTVzLzZsSmYyWVFqRnFyNE4vVDZhY3RuakVtTHhrb3IrSjBHazY4ZS9Va1dST1YrdEdwRGJOZ1NOUmJvU3hYMVZ3cXVtZFV5bFdBaU9ZOXVLdDFVV3FKNjNGelRjcW9zSWtDVG1iTStSd1dxM1NndnYyaVA2dHRsTC9BUWJEZkdHalA2L0RWYjFtaG0waHprOFVHRllTV1JtaWxUbmpsLzhRVktyVHUwL3JDNnNXSEhuanJ0ZzRuUG4wKytpMHJyQ2h1YVZFY3lHbExxTlBmdU96K2JNQUVWUjRYdENGV0hyTTVjRzZtZDhJV0x5NzFKYUUxa1psaXdDbnBZbm10cXVuQ2hLV2pKa3FDZ3hZdURtczRST1gxdzY4VE1Fa2I2amk0ZVFCTVNyQkFMTGJsZ0swNkVJYkptR0E0ZDRDRVhlNHIzK1pkUFptSTBaUHJNTVNsYUhBM253QllQVS94eTlOSFAwRnNGaTdBN2RNTXp5YzhkZDhPTGNPK0hEcjhFYXZBd2JBdm5JWm9lWFRMOTFtOHFRRTl1L1V5YXhEZnBKRWNFMCtqTk9WaGw2NHNubURVenA4RGpqKythNjh5NDMwanRCZGdQd1NCYVVnL1pnZzlpNi9pRmFYN3BDZVRpYTB1QlRvdDdLVElPN3MwK3JmNytXVHNvS3JWZkVnMHY5QUVMYkVMdmFFS1hpazRVVmFxcjltM0tMdE9DcGFJb0lyWEFXKzNodUF6VENkcVVrUWd6Mk9JRnpVRXJ2MjNYdnEwbDZyYm1LTS81cXdMbUxBbytlbkVMVVlKdDEyTEhOY1FmS1hmakpoVTJlZG9YWE1IMVR6Q0Ricy9tM1I1WnBJSHBnR3JCRm5XRzA3R0VWVkJKNC9sWWdUanhMMzUvMUt3eUR6WE93aVB3SEp5QzdYKzNoWDVnRDZZZ2g4RWduL0lROS9SZHNNWS9RdnZ1OE11Mkorcld0b3prUTFxOEhjL2x6eDhPOVo2MUxHRFJvdEREcDYrZGFpWWFBSTN5Z1ZmaTBwVWpWWk5PTGIreVN2UERQTFJ2M2M3a1pGVklSR3lvUnZuRHlwajlKN2JsYnMzZnJZV1pzSmN2U2QrV21xcUtUZE1ucnRNNDNVVEtCeWxGV2NVbHFnTzc5KzNmbytFaXN0ZXRTMWFucnQxVmxLemRwVThzQ2xmUG5SdmFMMTM3a21aem9aZllDM3JKMk5xdGUzYVhxb3RMMDlQMmFkZnRyMHlyVTE4L2UreVBQVnJXVXZvdzlzbmpoZzlqKzNzYlBvek5yMDZNU1BtM0c3aWY5Sm5xRVBYazJVRlRnais1Z1pjUU4vRC85VFBWTTJqTWhRckEweXdlc29waHNUZHMwY0ZzUFpHejIvenlocURURjlwT1hHMEpQYkpzd1VvZkx5SW9zL0VwQkc3MGRXaUh1Nklyd2d0cEltREZMbEFzK2ZPenk5ZW5iOHJack5sejRuUjk4NWJpMjFiWVpPTmdGeXhUcmFoZWVla2NDd0hsT3JBQkczR0VudjBSSnFIdGU3YnZMVllkRDY5ZnZpd3d4RnVUbUplK1dWV0VKeUIybEpEUFNCOFBZZi8xNG9oVUQyQzM3TTJ0SUZ2NFFYUmlUc0w2SUEzNVNzVy9QOXZSdGo5NjFmcWN0ZGs2N1NKY2dqZ2VMT2x4MGh5YVNMTzBaS2ZIUmhHRGZkSFUwbFhnaU9YNjZFbUw3eU5zU245SE90K1Bob0ZnaDlnV0hqeGdCSGpnRWM5ZVlBOFNKakdYWjVqRXNSUnlnZUVrTkJ4N0lHNHgwd2hXRzZWdmVFdU93RVkzWURaNlYrSyt3NnFqRGNjdS8xbzRRYStCZ1pYb2dUZW9zQmNXY0ZjWGJEM3N4T1JmQXpYZmhTRTJaVnY2N2xMVmdmMTdhOC91Q0k3VmdHVXh1cFFUL2hvN3E3Rmk5RmlYK2JWTHZ3L1Z0dXNSQzUveE1CVzY0Nmxnam50aWN6d1ZkNGVwMkF4NjB2Z0tkdVhGSk9qZW1VUno0TUYzenNMZHlabEJIR0RhT1Fzc0VlNmhnSDNUOGI2WkNIZFRpRklLOTJJZHFERUhuTWpxV1JEQWdzOVlnbGgvQnJ2U1RwMlQ4Vmh4TXNMVEp3bmdUTDhXZzJCK1p4RGlvRHBWOHQ1a0kvYXZidFVVRlc3TlU2OWJzU2d5ZVBPL2JOdGI0eGkyTW1kUFNwd3FKQzQ1TG1GdFNjWGhBK1dWR3ZZZzRTZitsUmJIaWM1MU1BQjFOdExoaE5GZjBKM3VuVU9rdXdTT3I5dFdzcnRjdmE4a1BXTXZrY05ycDg1Y09oVjJiUEVjYisrRlBvMytGN1hzMzk2WXhOZVNPR01TVHBOem84akNNT2x6emh0SUR6Yng0aXdjaDhCYWdadEJDODBnSU5Bb0NCc1NDT0hwUEN3a2JGc0lYb1J0WG5naFlkdEM3RVhZeGcxaE9IQVoraFJDR3hrVzdNaGJqLzFJL3FXNzlIOFp6ZmpITUt6UjRoVW5UR05ZNlFqQmt1c0gzM3BzQ2lPaDU1MG4zMXlMT2orOFFUUG5BR0pQaUNlaUNLb1h2TGdldU03MU5INWsraW5FV1VZeUZ3VlFuR2ZZSU9aWUlRdVRMQ2N4ckN2RDhhNE1ld1BhMGRaOStYdU5YNlB4WFp6c0g2Rmh3UjlHQUdtZXBjZElCeGcyNXNUQ0pZRUJ5elRzQ3lmb0J6YlBaZXg1MWZZODh0UGcvdkVvSnlOM2ZaYUtsU1pFU2s3TStnRENkWFZKNmNaTWR0YXNBR3lTcG1XZndHRDlreDhzV1ByYkxRS0xudEJnMmo3TkFUUGpNWS83YU1tb2hrdWp1b1dNNnNwRkVjRTU3T3ZuSUZPZGpENngwQ3VBdE1tSlU4Q2VSZGllWm84SU5BdC84dXdic0ZnRVBYWWFudVMwelRab0RvQlpHcVByaDdBaVhacGtWb2dEaDlFd0JBaHJyY0ZOK1F2TFIxU3NQcm1UTkpLdldiZGlNVHVhNGZTK2d1SFR6Ty8xYkZwNVJmcEJOVXQvUThqTFhVK3VkMWtFSmFRcEIvSnZUck5CbW9maFNQbis0Tm9pZmF5Sy9lU1JzSko0SkJ3TVpvK3RLVXFJVnEwSWpacXI0VzY4dm4zcTh1V2FzSkR0V280K0JQWlhHRW5DV0VMNU1MSkIrNE91QVJXYkNqMEpZMlV3RUN3dFdPa2pDR2w2aTBQU1p4RFl3TmpLWnNuWnBrREx0VzRuMjY1Q0xZdHFHWmJmd2hCcTFEVGI0YzJ6NWRMTjNJMFBrSytYc2VrTUVOc3JJTUxDWWhQY2JUVG1BM2I3MTdPMWFRVXBxYXJFTlVraEd2WTBnN3ZRN0Zyb0RRdklkUldvWk94TFdQeE14ajZIRldRSWRWRDdVZ3I3L1NSamY0WmxQOHRZVU5Ic2RSMTRRWGZ3SWkzUVA4TWRpSVFKNXhxazl3R2MvZ1BNcGRUelB4NW1QTjBRUzVLbWt6ZzVyUHF4Q0Z2UkxMWWtpUzZTNzVrZDJMR1lBYk9PNVlBSTJvSHVZRE1NbkhheTRDWm5nWkJFREtYWjVVMkJiVzFOUjF0WlM4TWNQVTlTUjRJOVdCT1VqVFVuRHNWWGh2aXpiMUpCRUFOQllHR0lSRllQR1l1Z2E1VkF1S2dWYlVFck15QnBsWkJNRWlTV095TkNEcG1mTEIyUGFTUTlFV0wzd3RWU1FxQ0NadjlmNjBtWlRBQUFBQUFBQVFBQUFBRjRBY1c4Q1hpVjFibjMvVjg3NDg0RTdJeVFrSkNCQU02eklDaUNRNTNyc2ExelZRUkJGQlVIVkJ6T09iWjllNnpmZS9wMlBLL0RPWFdvVXFXS2dGWUp0VllaSEhGdVpaQldDSVlwSVVESVFMS1RyTzkzM2RlNjlyWERrRktINzN2KzEvMDhhN2pYZEs5NzNXdkkycEdUbEtWamRLa2lwNTUrem5lVk4yUFNiVGVxVEtuaThWNFJDVXI0NEU5UjZ1U1p0ODdVRU42OHI3L21saHMxakRkdnlmTGpEU0pLMThWOEJXVkNXVW9EV1lwQU5UcFIwZy8wb0lib1lUMm1JN1VVak5aeU1FWnZnaFAwdHQ3UldIMnFsVHJScGJnVWpYZC9jSC9ReVZhak5BMGNkY2k1ZDExeDF4VnZ5TGtuckg0clVqSlRZaWt2cHRTa1RFeVprdkpqWEsrbURrdTlJUFYvcC80aXJTYnRYOU56MG4rVGNVN0dTNW1IUkMrTmZwaFZsRFV1NjY2c0o3UHFTNTZzdUN0bjRPQnljSFh1di9JdXo1MmYrOUtBc29GblZkdy84T0xCVncrY0d6c2tka1hGZ3hYMVJmZmt2NUxmVlZCU3ZhVDZ5WUtyQzJaVUx5bTR2ZUN4d29lTDdpbDZlTVNQaTE0c2FpaytvdmpDNGp1TGYxUDhXdkhIeFd1THR4WjNsMlNWREt1OHZPVENpcnRLS0FlQWtua2xyNVdzS2VtbXJKR0Ryd2FnNHNIQk00Y3NMajIvOU1MU3kwdXZMdjFSMlVsRFU0ZStVWjVUSGpNcUtTOHZQNy84MHZKTHF4ZVdYMFVlOTFmOGdoclZWK3lvYUIrMll0aldZZDJWV2J4NVZ4WlVsbGNlVW5sQjVlV1ZWMWYrNzhvbktsK3NmS055VmVYV3l0MVZXVlVsVlFkVmphdTZ1dXFlcWg5VVBWbjFUdFVYMVpIcWtkVVRxOCt2dnIzNi91ci9xbjZ5ZWlGdFd3UjlXTjFTTTZ4bVlzM01tdC9VcktocEgxNHdmT0x3R2NNZkdQN2k4SStIZDlmVzFwNWZlM3Z0ejJvWDE2NnIzVmpiVk50UzJ6MGlmVVRPaU5pSVkwYmNPT0pPOE9NUnZ4b3hkOFJmUnF3Wk9YQmtseUwwWTRxeUplVnFnS0tLZ1J3VnFCUi9oYXBWcU9HcVJSTkdhcFRLZExBT1U3bU8wSGhWYVlJbTZpaDlDeHlqTThHeE9rZm42amg5RzR6V2Q4RVlYUUpPMEdWZ3JLN1FKSTNUWkUxSFQyNEUzOUl0dWxWbjZBNXdsbWFEczNVdk9FZjNnWE4xdjM2dTgvUkxjTEVlQXBmb0VUM09XUGk5RnBMVGkxcE1UcStBbVhvVjNLd2w0Qll0MDNKeWZWTXJORXVyd2QzNlhKdDBqN2FBLzZWRzhHTnRBLytoZGhmUi9hN0tWZW5YcnNiVjZyL2NTSGVZSG5MZmNtZnJNWGV1dTBwUHVTbHVpdXJjVkRkTmk5MnQ3bGE5NHU1MTkrcFA3b2Z1UjNyVlBlSWUwV3Z1S1RkSHI3dW4zZE5hNnVhNlo3WE16WGZ6OWFhTmlMZmN5NjZPMFJKUjFLOXlML3RWU2xXeDk0d25weFcrMlMzeUhjcFFnVzlUSWE0aXYwM0ZmRXVnVXQ5R3JGY21mWkZHYkJleDdjVDJFdHVpSWNiUmJ1a3o2YU5TRlVIRnFsRUozeUdLOGE2aHY2SnVFV1ZuSzRXU2kzeXJTRS9hZHRKNmpmRjF1b1QwbHlsS2ZTSklMb2M2cmNVMW41UUxsRTllZWY0RGFoZW5oQWpwTzBqL0llVTNVMElwZVRURGwwSXY1OUc3dVRyTGQ1TGZGL29wNWYxTUo5Qjd0WG9jbm5ub3gzemlGMUMvcFg0SDVVVG9IZWVHKzFXbWFmbmt1b1pjNCtTYUxlcXNzZjV6ZWp0TGwwR1B5NW0wbGltVjJyVlJWZzdwQ21oRENaeERrRmdwTVdQOEs2UjZVNWNRZnBsdkloVnRVZ3FwQ2tpMXhTMkN6NkZUaDZxR3RCM0k4eTlJTEkrU0g2Zmt2MU55QmUxWnJ6TFNqOUZJMmpPQ3ZMYko4a0lHVHhEM3BIOURUMEcvODMvUzAvNUZ6ZlViOUt4L1c4LzV6MmpqUlpwUG1nV2tYdWgzNlFXL1dpLzZCcjNrMzlMTHlIUVI3cVYrdTdYOUxlaGQzMGk5M25DRVU0OTAycFhydmZJb3ZaRGVMcmJXT1dxVm9sTDhsY2hsUEtWTkpHd1NmRk5KZFF1dHFFT0t6cTkxRWQvaGFuRWY3SHZkSTM0MU91alFOYTlxeFpCRGdiV3oweVJjUm00VmxtTUdzV25rdW9wY0N6VUp2c2x3VDZXL2JzUjlDM1FyZEIvbFB3UmZuYUtVdElHUzJsd043dUZLbzhSeVN2VHVFT1c3UStVWU8xbHVxdkxjVE9MdVZZU2FiS0FXSFc0UmNYWGtVVU03ZTVWcFZzWXBWMW0wMTZzQUh5TWl0RGRicFlTWFFaVm9DN1d4bXR4QjZ0bnczSWQ3TmJRUnJpMktPVWQ3SXlwMTFkU29odHJVK3JnN2lIQnFSVTJLM1V6Qy84MXFzdFg5UmluSUpjcklqRkdqTEdxVWp6Vkw5UjVKTUFmNkRxdFZEdDljK2p4R2lRWDBmeEhmSWZDVUVsdEpiMVRSZ21yOEpqZDRKNnZVZW1NYTdobitFM3BsaSs3aHU5RnFoNFh4bTZsWkx2S0t1cEhVOWhCa2NiVnZjRlA5ZWpmTnIzVFhVL3NiZlkrN0NacnA2OTBzNkY3bFVPTlZibzd2Q0RVZTZ1cW8weERrMTZNb3NGcnl6WU1LdkxkYUlrTTRYSksrTkZzTnI3UWF0aUJIRjJRWW8zWTFMbUl5cTNLanZLZTBlaXR0UG1GMXlING9KVzBqN3hSSzJxMDhjcUdFMEVNRlZrSVo3Z3FvVXJtSmtxWkE5SmltQmYzWnFHSElvSm1TWXBSVVFPKzBXR2tIRTNhdlVpaDFyWldLaGFMVUdOWS9sZExTR1MwWjVKSXBXdWkzVW9PLzRVcWxGcThxNW44b3M0YUVGL2x1Mmp4UEpmRGJPR0YwbGFIbEZmNDVEU045cGFwQXJxckpjN3hTcU9GVnVwTDRTWXpjeWNSUElkMDEvaE5xL0E0MWp1aGE2RWJ2cVhtRmJxWDFzeG4xOS9rZnFBN2VMU3AwOGgvVG1yZG9EVE9HL3dTZFM2VlZoMkRGVnRJeTVnNFYwTHBsN2lEQ0R5YnNFRnA1cUc5aVZFVGMxVXAzVTZCcm9La3FjZE5vL1V6Y3Q4SjdHelNMVVhPN010d2RoTjBKSVIzME5oMEp2ZTErdzNjTzVjMzNpOXpMTm1ONHBKVnJmZFNFZEpyUjE3YkVTQ3BrakJkQnhiNUxabEdoVXFpU1hxMGliTHgvMC9wcUtqUU5YWjVObW9lOEQyTjd2YXRFUjBkQlUyME1PMnF3bk5LYktYa25wV1pxa0t3VUhhRWk5S0ZZcGJ6elpWcUJxNHhhamFGR1kzVTQ5anNiK3owUlMxd1dMSEc1VmlpUDNoNXBXdHRCNmhqMXF5ZkZjbXozaGpBUDVjdm1COStxQVdGZVJMOHBtYktDeFcvQ0ZRdXBWbU9oZXlralJzcGFVdGFTTW82TWVtbHZBYUhGTmxkRnFVTU1iayt0aGxGT1FaanZDcW1SczNMaWxOT2lJcmh0ZG1ORUl6WEtZSlhyMTVESzZUTG9jWnU1czBsWlFUa3RsTk5tV3R1bEtOeTVmcWZ5b0JnNVZRbzlJYXphNXRsNmN0bUI3RC9SQkN6N1JFcTRoTGdya01Fay9KUGhtVUdOYjRObTBlN1o1SGMzN251Zys2REhLV1crc01IdzIweUl1d0gzSm1nN2FYY2drWjN3dGVEZVJmcFdxQTEvTzNOV0J4Wmp0MjlVSis0dS81N2kxSzJia2RNRDlXS3J2RjlIdjIvSEp2VzZ5ZGljS1h5dmdhWmg1NitGcGtQWFladXVKMndHN2h1Z0c2R2I4TStFYm1YODNvYWRtMFhZN2JqdjBDQTBPTlBOOXEzdUx1aHV3dWNpcVpmaHFmTmU5REh2SEtTVHE4RTIzOFg4UWcyakpaWG9SUlU5WEUxZmp4RzlwV2hZWlRvazlnNFMyMEZmeDdGbkE1RmFteVpEMStLZVR2eHQ4TTlTcWU0MEc5ZXB1M1VZa3ZzQXliWHJDYVR4SlBRVVpjN0JGc3dqeitmcHBmbVV1QUI2R2Y1RlVCMTVMeVA5VzBpL1FYbmFDRzJpak8wYXJoM0tFUDJxRnBWcEYvNVd0TFJOQlVqNE9TVDhtbmJ6N1lTNi9LMUllQjRTL3JONnNGdTlmTDJmNXlLcXhRYkVISFhHRHRTNGE2Q3AwRFRDcmxYVVRlZDduVXFaRFFhNkdiaHZnRzZFYm9KbWt2Wm12cmRvT1BZaTI5MEczeXdOeFY0VUllMEpTSHUwbTYweWR4ZGhkeE0zSDBtL2JEWmlPSEkraXo1L0FrazhoZTdONGZzYy9ubTA5SGtrTWgrcEwwRDdGL3JQa2NKYldnU2hYUnFHdmtlSll5NVdEanFTcTBKNnFwZWUrb05ZT3hEUDdNeTdpaEZkRGM4WTc5SHZ6ZWgzQzcyVlJtODlTQTRsOUhVcHZSWFZKTkpPNW5zdE5CMmFBZEVLZWl4R2o1V1pEYUxtdW9mdmZmNTlQYVE4RzJsUFUvOTVoTTlYbGEwZDY4dytaTm1hcmdIYVNPOXZvcnp0V0pzZCtIZXFWaTNRTHFnVmFvUGEvWC9SUS9Qb29XZnBvYm4wMEg4cWpydWJ0dlQ0aittaDM4cjczOUpEbWZSUURUM2s5OUZEOUE3RUdOaDN6OEIzSzkvYjhNK0NibGNCUFhPNHV4T2FyWUgwVE14NjVpbStjMWdQekxYZUtkUFpaalZ5bUd0eTBkTThXaGJUS0ZYd0hRWlZJZmxxT2FUN01kTHRScnFMc1I3TXREb0M2YVloM1R5azZ6UVozbXY1emlET0xBZ2pmamIrdS9uZVE5aDlPaXhJTGdmSmxabmwyRTdjRG1nbjFBTHRJdjlXdm0xUU81cGhWZ1BxaExySU00NldkTlBuUFJxa1hxWEwrMjZzeHNkWURZL0VQbkJUK0Y0RFRZV20rVVozTFpLYURsMEhYVS9ZREkva29Cc2hzeHhJKzJhK3JCTGNyY1JUWjNjSE5KdDg3NEt3Zm1FOTRtd0ZXWWVNVXRBRnAvbTBZZ0UxS0VDcjMyTmN2NGxtcjlZY2FDN3VaLzFIYVBoYU9JK0Nzd0xPa1dqMzMxbUp2ODFLL0YyMGZCMWEvcG4rNkZmcFZlejY2N1lhZDZ6R04ra3FlbU1sdllFZHA0dzh2eFI5LzRVcUdEZkRLTDJTRXF0VXFHcWtOeGFwakVmM3JUZjgwN0k5RkhRbGRaeEV6cFBKN1ZyY1pwbElNd3U2RS85c3oyNVVsZWo0QWoyRWxCOG56UlBrUDVkeW42V1huK003anhvL3oxaWFUOTh2Z0JhUzE0dUV2d1M5VE0wWHNiK3FveFZMU2J1TVhudkxiMVVEOWQxSS9wdUkzNjVpZW5hN2RsSm1pMUlaQ3lQVUtxYzI0dHY5SS9Uc0hIcjJBWHIyVi9Uc1R4VEgzdzMxK09jWkM3K1U5NzlpTEJ6RldCanFwa0RYUUZOVnpqZ29jS3lRM0hTKzF4RjJQZTRaV0tNYjhOL0k5eVpvSnU2YitkNUMvSzNFMzRaN2xvcmQ3ZEFkR3N0NEdNZDR5SGQzTVM3dWhoZHJqTFg2ekZZMWRScXFIQ1N4WHM5Q3owRW1DZDhVSkZHbGhiVHFKY0xodHQzVVcwandJdnJzTC9SWmwzTHB0enpzVjB6WjlObkxHb2E3MG5lVHp0Rm5teGxGUGZSYnI4WlR6Z1JTVDZRL1Q1T2o3MWJSYjluMDIzS1pqY0k5dzFaL0g0bzY2aDdjOTZtTS90cWl4eW5SK2dxeXZsSVJ0UnVnQmZBdEpKK1hDVnVFOXRWQnkzd0hOZHhCM3podGhEYlI1OXVWUmQ5c3BWK2k5RXVNZm9tR09ib3B6TkdyMWNVM1RqbmQxTFhIMTZ1WGVNKzZMS0tDTUVmM0p1Ym9xZEEwNkZxL0lXbTA5ZXc5MmlBYmJkQnQwTzJLMEI5RDZZOXkraU16MktkbzZJOE94MzZWL29qWnVtaURDcFZqNjZKaWlMVjJPSGxvUUtML1YyT1ZqUVJYWW92S2JaKytERnJoRyt6TUlRT08xY2o4VDhndHJxWElLT3pnV1RXeHZ5THZEOGc3U3Q1dnlOYnhmRzF0aHlUTEtIY01JMnNzcWM1U0VXVzhhV1ZZVHRSakdlV3Z3T3BTRHNneHUrQnd6WVBtUTFsWXkvazZWOE0wdzZ4Z3J6NkhheDNoOVh3M0tBdnI5WnFyb3k5T3Nwa3VoMUZsKzFIY01jcTJXUTZxWlBSVTJVNTVLRG4rbGRIK0lkb1NRVnZpYUV1NjdSbW1RN2IrZ082RTdvYnVvK2NlMGhEVm1Vd3kxRURkTjBMYlZhc2RLazJhcWZMVmlyK05OTzMraitwQUpydVJReWZhMklVV3gvMm42b1o2Zkl0NjBYVHZGMVB6VmtabnFac0NYUU5OaFdaQ3QwRHMyTVA2SUVvdlo3czdjTjhKTWNOYUR6K3JZRTlWbzlHS0lzazhLRVo3SzJ3RlZxeHFhalNlVms2a3Rwem5KRmErazJnUk13M3k5TFN5Z1BIUnJudHNOem1VbG1hWm5hcnp1MjN0M29CL0kyVHJVL0xib1doWVBaWEs5QjZpeFVIM1cyVzZEM1V4WHVQMGxlaysxT3QzeWJOenA4Vmg5ZFM4cjFhSDFxTFQ4TkFEd1o3RWtQdFoxT2ludVA0UHRmcVpqdFRQYWZVOHRHcUJ5cFFlZHN4WkdxTVV3ckowQ1Z5WFFlZzlOU3RFQ2tYK1hiaWFWSUorREtGL1N2MjJvSnZQb05tdm9KZGJzUHoxWnNsTjcrRVpvRUk1RlVIRjVGa0MyYTZjYjVuTjVuK2xySmkrb3lqbFpWQmV0bDVMbkw4VjRMSXhSM2xGZm5NWWN6c3BlMDBvZXpObHNEY09aMWp4Y0NZWGg2c2pqTXdPT09LV1R3TWNuWEEwaEh4MmhYMU5oNmdKWERzUytiVFkvdDY0Y0xPYkMvbDBLRFZJaDNGdU5YUzh4OUJxWElRWDJHbGlvKzIzVXNOSnpscnlzRjBxOFNaaDcyMmNwbGxaVmw4bzFGZTVvUWJFV09uZGhINUJDUjlxTEhTSjk4aTNQVWduR3hsM08rWnY1Wk9xWGtWd0ZETlNTdml5ajZUT2YwRkNQYVIrMUdwOGxzcXhBZE9SOVVCeVdoNHN5RmJrblJ1c3lEWmhSY3htWkdrQmxLb2M4NlhoUzNOemNLZnJaTnAxRlJSQzNUTXFkTCtuanpQaFBZSFlJNGs5TWluTlNEaU9oT05JNDZpRll6UWNvNU00YXVFWUE4Y1lKY3BTbnV5RUZTcVdVNGxwVEhiUW1EWElvaU9NeEd3OW50QVcrbEFwWUo3VnJzQk9iQytBSXlZN0ZRQjU1QlJqSDFLaEtnM0R6U29tMkxORHliY3ByTnJYYUFLY0UvMHFVZytubkppdExhL2dleVhhUElrYWNjcGxhOHpiYkk4VjFXeSs5NkZMRHhGUGZiU1FkSFdxcEY0SFU2OVQxRUNMTnBKdUU3U2QrQmFveldhN3JXRzIyNkJPdmwzcy9lTG9aVGZVUTgvMUV1LzlLa1o4azlrNFpycytJMzZhOTJHL05NaGRCMTFQMkF5K2ZWZmxaYXhDb3NFZXhwTHNZU3hoSWFnL3MxNDBhVlhlNnVieW5VL2FsK21qT21RMDNNNEdvNHdITzIyRDhxaXhuUUhTOG1xL0Rja3RaUzN4R1pKckRmdjVYazJDWndhdHV4UCsyWXpjZTNCejRxYUhpQTg3VE50VnR1Tm1sVTFMUHpLN3h2bWhtdzdOZ0c2QWJvUnVnbTZINWhKdisyZnlkcFQ2dHIzbjJmczF0S3pLWEIrRU9TNDd6SEhaNUwyVk5LMDZUS24wZDVwR0tBdENhNVZydTdkRDdIeDR2QzdVeVlTZHBxak9oczRoN0Z4eU9RLzN0NkVyOFY5Ri9QVjhaMEx6Vkt2bitkcHBONFQxMHV2NGwwQ01VV3B4TUxVNFEvVjhOK2dNRjlHRjdnaGtleHgwUERRYUdndU5nMDZFVG9MR1F5ZERFNkNKMENsUW5ZNWdES1hhYWVNWVpVRTVHcVJjYWxKSkhUa1hvUFpGdGc0L1dkbjBRenpSZ2tUTm9hdUl1eDYrR1JxcW1YenZVVDRhbXhYR3pFaGFVSnRvZ2RWZXgxTDdFYXJudTRGdkE1TGJxQWl0T0p4V0ZMbmpvT09oMGRCWWFCeDBJblFTTkI0Nkdab0FUWVJPZ2VwMEN1MUlKZmMwdmxrUXF5bmxrbk1sTGFraTkycHFNcDd3azIxbDJxSFQ0RHdiT2cvNk5tU3RJTzU2RllaV0ZOS0tpSTI3ZWVSRFA0UldwTkdLMGlEL01UTDU4MlduSEZwd0FpMG9kTWRCeDBPam9iSFFPT2hFNkNSb1BIUXlOQUdhQ0owQzFXbTBrRHY2VmNWS1pEeXozcW1VZEpIdjBoTjhmd3M5Q1QwRnpZRitCejBOZmM0ZVpSMFdwWjd2Qmh2UkcweExmMm52bCszOUZMSW9RRCtMN1ZSdlY3RGRiOW1KRytQSlR2WTRiUXZuZ2J1dy9LMTJxdWJKN1QwNUczK25LOXZPdzN0dC9SYno3Y2cxemF4ZHRXcmg2R0IwL2kyY1JsU0drNGhZT0lISTF5em9Eck5wdGVFVW9qQ2NRdXpDdGpsa25LWjUrT2REQzZCbEdvZzh5N1FSMmtRKzJ6VTBuRHlVcXdYM0xxZ1Zhb1BhZmJjNm9OMVFKMlNyR3loeCtnYlpQbHBEK3U2MklNNmpuZTIyb091Z21ZUWxkbFhZS05hYTRmeUhVd1lka1dUUEl0Z3lXOS9adkRDQW11ZHBBY1RhbVBMbTAxN2tSbHhNVDdCV2VaS2VlTW92MHh6c3lMTytUczlCdHUveW44Q2JGZlpkYS9VQzYrK1hpSHNaTFZoRXIvNEp5Yi9xVjdERCtjaktLUXJ6VDZFY2ZkUEMyRW4xMkhzNHM1RjRUdUt2Vyt2b29kK3B3dGRyR0dHVjhGY1RmNUpuUDgxM0FqWjFvdjFOc3NYMjAxZFE0MG5zaXllamEreHZzS2VjWnJBaWV3aC9uVzlVQTNsdWhEYjVCcVQ5b0RxZzNWQW4xQVhGb1c1MktUMThleUh2SDZSMkhta1B3dWIydUNsOHI0R21pak1ld21mYXJCRkxySnFmWmZhWlR3Kzk3RGNoMFhSbFVOOHEyanJVVHE1TGFQRVE1Rm1Ldnd5WnBacms1ak9TN1crQThDTVpXeG13M21Tc1IzU1dHQnUrRGRjbHBPVnZtM0J3ZG9ZdjIzeFJmQXMxMWlUUWJoSjRIRW5ZaVMreEs5Z3BMNkxWN0FTUkYvTzZIS1d3eG5RWCtlUGN4ZjR5ZDRrLzJWM3F6M0NYK1VwM3VUL1BmZCtQZDFmNHU5MlZoRi9sVDFaYVdCbVZrditubEZoRC9wNTYyMnBXVVVKWEV4cXpFUGh3c1R0T2hQekdlRWlaQ1BtZkVMS1FrS2kxNWIveExUTmZjcTRyRS9FTDhUVW00bitkbEdPV1FvNVc2bnVFbENtYXRNcHRDU3ZMRGJMVk5HRzJocFd6czZCWVdITm55ZjYrVFVpWnlTZUhOSm5FSFVsY05yTEtDMy9ES2tjR0ErRVpSUTVIaTNLZ1FwME8xK0Z3SFFmWEVYQ05obXNNWEtmQ05VN3A1TFlxeVY3VkU1dG1lOWtNRlFDcnAycHRSVHFFdkVybFNCdXhWaXdpOWxGYXNZRFltYlRpUWRKL1RDdWV4T1l0Skk4Vm9oVytMZnlWUDY1UUFqRWJiQlhkYnZ1VU1yaWlZVy9TQkY4Yk1aN2N1dUJkS1Z2WDI2cDl2VkxEMzFaNnFVWFVWdWNwdEMrZk5ON3ladVdPcXhBWFBLYW5oMm8reEhsWllpODkzamVZaTFqNHpCcnd6ZFEydE8xYzc5MjNvZk9oNzhpNTcvTDlIblFodVdiRGNUSWNYZTQ4eUxnWVIvK0Mrd0lQTjVURWJmbE5oTHNkYnNzUHp2aWUrVm1KRytGb0piOUd1TmJEdFo3OE9zbXZEZTVldU52ZzNtbmNSOFBkREhjUDNKMXdkOEpkSDdoN0EzY3YzSjE5OHQ0QmR4ZmNXK0hlQUhjYjNOVEVkOEc5RSs0MlpjRTlHdTV0Y0crRE93NTNDOXhiNEc2SHV3WE9PSnpjNklDekNNNG1heFdjY0swSnNmRkVxWnVJYlNKMnB6c2ZTdVJqcGNiaDNnSjNpNVZhQTNjcjNHMXd0OEM5SlhDM3dOa0I1elk0dHlnRFMrRGRKZENsMFBmbEdQMmUwZThaL2Q3c1JKZTdHRElPSkhBWjdzczluRkFTcCtYVERxZmxBMWQ4cjN3MkV0dnFHTXR3cklkalBmbDBrazhibkwxd3RzRzUwemliNGV5QnN4UE9UampyQTJkdjRPeUZzek9SNXc0NHUrRGNDdWNHT052Z3BIVGZCZWRPT0psVDROd0c1elk0NDNDMndMa0Z6blk0VytDS3c5V2hkTGlhckFWd3diRW14TVN0cEUzRU5CR3owMTBLSmRKYlNYRTR0OERaWWlXMXd0a0dad3VjV3dKbkMxd2RjRzJEYTR1Y2pWZG5vOS9aU0dVKzF6am1sQnBjMkJYYjVUclc0VDMyYnJNOTl6cjQzeVBsMzBqeFBDUDRmYmphR01HZk1JSzdsWmUwVS82UTJBWnlMQ0cyMmRiQlk2R2ZrdlBQTkRMY3NQRmFDczh5YWhCaDlzREhOd1dlR0R5SHduTmNtR2NzTHV6RWZmaWJiVlJsRUhPTXNzS0pnVTg2VDJnZzNaODAxdjVlMlN2UzJwa0E4NDRHS05mdUZKblZnc3hpMmNuSVV2Zy9TcHlKTDZVR3kzUlV1T3UwVXljbzFlNkJkQ3ZUZTlLd1YxVytjcEZJbnUvQmQ2b0tpUzhpcHBoUk5BUlhxVExObWxkZ2VZZVJwcEs0S3RKWDR4K1BmWjlBTDB6VWVYYlBZWkxmcGNtMGx4TlNYVU9hYVh5dkpYd0dGdmhHMHR6Q3luSTI2ZTdCZjUvT1ppWGhWUWRQQTNFYktYY1Q3aTNlTzluZk4rYTVTcjVWckxHcUNhdEJWNGVqRFNNSkc0Vk9IOHlLOUJEY2grS2VvekxPMW1yY2ZPaGxaZExQMjBVL2E0VFpXTHVaNVJ0cHpZaHdEalRVTFNJMlVpR2tvWW9YSzVmb1l1UWszKzcvNmx1ODl3Mit5Mi8wbi9xNG9ZMytpSG9lM0pEdjlEdVVaakU4K3NZZTMvR041ZnozQStKNjE5OGlvVXRaOUVwTU1kK0tISVEwMm1uMlJud2JOSWpWQnJJMWllMUFMbHVJN3dWMkY1YXZKNVExTnJUVTcweksrVDMvSXcxbDFrMHh1VGJSVjNrYXhydFkrYVROcEx3eS96UWhlUnBLVGlWMmEwcXF4SmZtdDJtNE1uRkpVVWorV1RIcUNiWEhlOUk2Y2xpRyt6TmZ4emdSbEU0ZU1sY1crVE5tL0ZhMFBnMUllWkN6dE0xOEI0cWVsWWdsZjJyVFppNGU5S0tPVWt1d0VaeERJSlV5Nm5ld2FuUVkzelR6UmYwWHZvZnlEN0xadnhTaXpocUdTN3hyUUtueVFOVDMwQVo1SDNLZTcyL3l6ZVNlSGZ3ZitMWCtJNzhZL2R2aTEvdTMvZHVNOEY5Uk5sYkoxL3NPc0FtdWJiNFJhNWZxZC9xWENQbkFhaTMvYjlnRWw1QXpta3NlNzlFejNsTXovekdjYy96ci9ubnlidlR2KzhaRW1ac29jNVhmYWoyOENqU1NjZzI4bTNESExiUUZidm11a0RYOUswZXVUL2ttOHZrTkhQdDdvcVR2c0xZeXZ2NnhUaVBETjVSRDNuTWxhdkJiYXBqOEZJQkV6c2lkWGd0bE8rM3J5ZmN0aVp5WCs1dndmOEFlU3NqeGozdldNOGtkQ3pYdkNDM3RHeDRlOUQ4ODFQTUYrLzRhaWF6MHYreG5GT09uNTVyMkNtM3U0MnRVZU9qYk15WHE2b0w4bXBLNFd2M1d2dW1FUGJlY1hWS2RnOHZIKzlhR09pOW5OSFNnRFo0KzV0d2dLZWQ0c3MvR2tFS0lBL3ZwdDRSemxFWmFLNTlCaHhjaUUyS1MyK1ozS3p6d3RDQ3Z6Nm5IVy9CK0dDU3EwR2Vsb1M0UjdmbEVqSno2ZndMSFB2ankrc2dtMkEzNzlrQ2U5MWQ4TExka2k4UTN1QS9zY1Ryd0ovdWZra2JrQUtUeGhYL1J2djlwbHVVSC9jOVIxdGRCcnhMZk51Rk8rSnEva2l3MzY1dDVxTmNCem9NL01UMTArNHh0MjJNc3MrcmNxd2RqKzlHTkRqUSs4ZlN2ZFltY28zMXovdjk2dmNFc1VtL2ZPdSt4UDR2Mm8wc0ptK3E5ZlVGU0tQVE45ZUQvdnpsN0Q3WHhqaWFOaEI3Zm1NU1NtaWdCN3YyVjYzMlE4NmZRZXY5OEg0bEYrL3JzbldtdUxLaHZYOEM3Wno5YnlkRFhMdEVZRkpIOGFtZ3o4MnpmSjMwUGQ4Uk9ROEZlYzgyWS9kbEV1eVgrRGZaNkg0bVZKbWJER0NHcHlmTmowb2lKSm8zQ3ZQNXNOeXVzN2RhZjVtYW5zVlpwako4Y2tSLytGdDROeVdNUnU5T0FaVzAyTFBGYnZxSStML3V5K3V4NyswampNK1g1dGo3cmtLNGthY1NnL0lRYys3RXF2aDBwS3JGdWp3T2JTMWl2NHQ1Ylk2MzliajgxWEV1WnBiUXc2dGN4VWtyN2FHUXBTUGlzVHV4OGNXWGhyZ25oeFNIVzJrbDd5Zk1yYU0rQlBDY0E5cVhJTVdwcnA0S2t1S0hVYmFEQ1krZUcyY1FmQVdmU2FMWVU1UVpwaEVZYTU3NmVkTVdTMnBNR2h0cWRFOXV4cU1UT1g4TURWNjJLaUlrRi8xWWs4OVdlckpCVHQ3N21oN0Z5SUU5dXNCc2ZRVTJzZUYzZjFYS1MzeWtLUmFDK3E5d1V5QmxFYk5GWHRDemYwT1BiOU9VZVdyM0hyc3hoYzlyMnZ4S0Y5OEJXcURYc01WdDlvd2FIZEgvVldYNFQ3NzNYUVdYTWo1L3pQVFQ0Ujl2N3NBT2RiYitaaDlwOTlTZnY2NTVoc1lRTnZwTTVKSjFkVkk1eS9acWt1TzErRFpZd1VRcWNYNWpsL014dndHV2wrbFgyVGRINXlqTHJHMG51VjNqWEtKV2NzVEsrOXg5TG52THF3YjdiRTlsSGl2RCt1dlpBdE91M2NyVHpEZWFNalg1cFArdU41TjJTSTAzSFBub1plU1ROVG0vYTJGaE16dlhKcTY5OXI2bmc3eUlzQzJEcjl1SmtqQ1U0NjRtUGVLL2cyNk4zMi9hUVlER3d2VWVTUFBQM282TWpGRUVXcTloeHYrTC80SC9xVi9mSitkTkV2ZVQvd3ZuUzY5Uko3TG1YUSs4bXpoM2cxSFR2VFJaOVI3MlR5SGN0SjNuUC9NTitXUU45Z2Q2dC9TYlc2ZjRCZlZOUHRtb1UrK1l0eFlHdk1KRGh4LzVGcURNRUZQazdWYVNCeWF2SzhQMmJVdno4eEx3by94MTdmOElyMG84MThYM253MzFaZXIrN3Y5MmluK3RQUSt0K3FtR1NScXJXdjlobjUveWNmenhwcDd3YUM5UGtQd1FiUUV2ZjB5NGZoejc4R3ZYa2ZYMk5qOS95VldZU3BKV2Z0QWFGa25jVEI3SkM4Ty8wTzVKY2Z6WVVIZm5ubmdHSzdwRm55YjdyMlgrZGRaUkcwdU1mK1QvNkZmNzMvbW4vcHo0dGVpWEp2Y3AvZ3E2M0tkdS93TG5objFtdkpTd0p6N1J3d3BpdHIvQjh1VldvNytyalc3UlBudFVIbFBOUUcxOVIvNEJ2d1lvK3RQKzFvVyswczVYMThQYzVKVEJMa3hrMEthYUN2bGFFTlBNWlkrLzdSL3BwVFpPVVdBdnNTRTRiYXRqMzNFYVVFYlA0T2RSbnNYL1l0L1JyODllSC9jeld2dHBQMlBHSi9VREltVENMOWZmN3pjeEY5L2NkTWNrMmxSUGlYbWlWNWJ3NVNSbzk1aDRTckdsbW9uK3paTEhrdk5UUDQ1MjhSbXJ1TXl1KzRUa0Y5Ky9iZm55bGtIdVNsTnBWazVnSHljM2VQdFNPMzdOYnp0dVNWd0I5Zkt1d2N5dW90UmR1cURmNWJ3WWg1L1pFemxJazlPQlB5SG0rLy9uK1QrWjhQU1Y5Nk5jbDVtdmZ4eTdVSk1aOUtETm9TeWw5MTR0dVBOdG5weGtsTnJtbm9yNkRkeXdFbENYcFJrekQ0UmI4cFVtNlliRklveDc5K0ZteWJoRGEzR2Q4ZENLUmRkYUQ5VWwxYnJMUG9YdlZlV2pJNDMvUXFPZVFjL08rLzlJUXBQRUJmUmMxT2UrNUh5cExhTjIrWitud2x3N2ZxZURESC9QTFZBTUs1Q1Jpazh2TnBZOExnRDMrVldMMyt3UzlXUjk4bStqdEtCaUluc1pzUFpjRkplMlQvVVppQy9RMVBiN2xnTmJYRnl0RnFYYXpMcXBzNVNyUHJFcWhpbFNzRWcyMi96SlNvV0gyVy81cU5HQ1VqdFl4R3FPeEdtLy9mZVlTWGFZcmRaVW1hYkttNkJwTnhWSmZxK21hb1Z0MGgrN1ViTjJqKy9TUUh0UGpxdE15clZDRE5tcVRkbXFYMnRXaDNlcFVsK0xpUnFaNjVaMWN4Rlc1NGE3V2pYU2ozQ0h1RWNmL2RuRy9kOCs2K2U1bHQ4alZLYUtMbEFKT1VTcW9VRG80WEJtZ1RGRkROamhXdVlZOE1FWXhNTkg2amZ1MzRGc3FBcWVwR0F4WENhalNZREJCUThESktnVkRWUUZHYVJnb3AvMzJTeVJ3Z3FwQm5rYUJGQjBOVW5VTTRHNGZ5TkJZa0tueFlJQW1nR3hOQkdmb0V2QTlYUVl1MUpWZ29LNENnelFKNUdneUdLWXBvRkRYZ0ZNMUZSUnBHcmhJMTRKOFRRZmpOUU1jcFZ2QVlOMEJEdEdkNEJqTkJxTjFEemhhOTRHeGVnZ2Nxc2RBdWg0SHRhb0RRN1FNSEtRVm9Gb05vRmdiUVlrMmdRTHRCR2RxRnpoTDdlQnNkWUJ6dEJ1Y3EwNXducnJBdHhVSDU2c2IvSXQ2d0FYcUJkK1JCOTkxY2xMRUFaMXUvK0hIMGF2RGRUQTlXNnRTZW5la1RxU0grVXNodlh5SURyUC81Rk5EYnorbDQranhPVHFlWHYrOVl2VDhzNnEwLytjekRnMTRXVmxvd1NJZDZlclFoWk1VUVJwcGdOTThFTk1BTUVJRFFhVUdnUkhLQjZXaWQ2MVB5K0dxQVk1K3B6YXFCV1Z3amNKOUVDampld2gwS0VqVllUb1M5MUdnVFBRMGJub2E5N0hnWUIwSHluVThTTk5va0s0VFFJYkdnVXlkQ0VicFpGQ2hVMEZVcDRGYW5hNHpxTjJab0VwbmdZRTZHOVRxSEZDamM4RndKUHh0UXM1SHJnTjBBUmlvNzRBQitpNFlxTytCQWJvUWpOUkZvRWdYZzJKZENrcDBPUmlzNzRNaHBtRVZ1aDRNMHcwZ1J6ZUJTczBFdzNRdnFOWVA5Qjl5dWg5RTlCTlFwZ2YwYzFyM0M1Q2lYNEtEOVNzOVNQakRZS2dlMFc5bzZhTWdVK2dXc1Uvb2FWcjNqSjZqYnZPMGdGWXNCQVAxQWhpZ0Y3VUk5Mkl3U0gvVXE5VHp6MkN3WGdPMWVoME0xaEpRbytXZ1RHK0FnWG9UbE9zdE1GSnZnMHk5QTBicFhUQkVmOVBmYWNYbm9FRHJRS0hXZzN6Vmd3SnRBSVg2QXVSck14aWhyU0JIamFEYS9sZmFJZTRJZDRTR3VlUGNhTjVqM1NtOCtaOVRxbksvYzc5VHRudkdQYU9ESFBySCt6bjNuSExkOCs1NTVia0ZiaUd4TDdnWENIblJ2YWc4K3c5VFplNGw5eEl0aldUUFZLcVUvV25PSEZwd21lUzNLMCs1dmhuVVk0OGRjMW5jYm14MWlKc2krcG9lTytIWnpUcm1DOUFzT3hjQ0VmWlgzZmlkemlOK1RlSXZDWndJZ1g1Szl3MTJuNS96ZGwrZnRQb1laRy81K05kVmE2ZzVVZXR3NWtTdGUvczc3ZWx2NTg0YThxL2VTNUJVeUxkVnBQQTdMV1VYYTUrZXIyTVB5SjRsc1RQeUM4ajFMLzR4NnB5OERzQnQ4NmpnVEZYL2ovTnJrdFpZQllrMVlUenA3YitXazB5bnNEcjI4NkVtLzlRKy94WWJQYUJUNm9NNWtWaEUzYjJ5a0crdDVMZmFHbStieUJuMHNuLzUzSzlpdGJueUs5VDZiLzUzUXU4WVMzbXM4UjZ3ZGQ1RC9nTmI2WFY2ZTNEalV3b3VNYnEyS3grZGI5ZStuOEgrVFZhcFBPUXBleUpXU2dzdVdrQ3RkK2tyUDlUeGZvazg4elNBWGQ0dkpYYS9ELytEVTQzOGZqV0UyMWg5MXFHMjYvTngwL2s0ZlJwSjdDNi85RU0rbjFGU1IzQXY0ZDFnYjBMQ21oUzMrY3FnYk1MZzdpZS8zWDZkLzlRc1UwZWZXcHVQSHZwYUhpekhFck5veldDYlg0K3J3WC9jZis2K3VaOHpsQ3BzeU9zSjM1RmhyL0tSN1FaM29kZmUxNGQ5MTlhdlVPdEdQeS84cFY3VSsrZDJTdlpmZm92eWtwanlRTmpIb0VVdC9mNnRJMEt0bjRTUG5WdlM3blcxWHhQMkhkNDM2aXMvN0dWL0pNY0lwMTZNN1Qvd2ZvZFMzL25TZjZGeC90OU1wN2hWR0xSaU9XVDY0aGNMRisxNk00elNMLzhVV1VudDZPSmF4dmRQYU1WTC9sYkd6ZGJrdmI2M2MzQytuMUJpbGwvVjM5eG81NWR0dVA0STlSMEJNZXBNV0RoVnlkU1hmcERybVpUMG1MbGJHRXU5VnNzTnZqbHA1dHlXTkxhaS9jK05mak4ycUlBY1BtTys5WmIrenhBbnNMd1hJdWU0VXIrNkRWRTFFdmdDTFBCdklzMWZJK24vOGJlSUdjN0s4anJXYmpsMG1JMnM5Ni9idmVJMyt0bXBPb1hhMktsaFNxamQ0WXFGVTQ1WVlyVVErd3F5bnV0L0tNZUlqSVgycDlPT0xFVzlsK3gyZnFuTlptYjU3R1NFa3MwWDdiZldXZUUwSWhKcWZTUjVTUkErRnl4VTlDdlZlZ3I1UEJ1OEIwTlZWdXQyS3lGS1QvUWk4OTMyQzRaUWF6a28ydThLTGxVTzRyRzlWSlFjdk44U1VqaTcrV0g2Qjd6eS9FTDBrZmszM0k1ZkNRZmxDci9vY3p2SjdhUVdiYWFwYTZHT0x6VURwdGxhVlo3MktBKytFc3QxRnlQWUlkVTBhanBBQXpXSW1ETGIzNTJrSzNTOWJ0Qk5tcWw3YmFmd3VkWnB2ZXExUVY5b3M3YXFrZFgvY2U1NE41cVYvemgzb2p2SmpYY251d2x1b2p1RjlmL1RicTU3anZVK2EzMVcraThxZ21UVFFMYXlRTFlHZ0N3TkJLa2FCTEtVRHdhb0RBeXdHcVRvZWhEUkRTQmRONEZVelFRUjNRc3lyVTZwK2h6a2FoM0kwM3FRbzNxUXF3MGdUMStBSEcwR1dkb0swdFVJTW0zZkVyRjlTOFQyTFJIYnNhVFovNzUxMUh5dW5PMVlNbXpIRXJVZFM1cnRXREpzeDhJS1czVktBWVZLQmJLMlhhUjBNRUlaZ0Z2NGNFbTBsdkJzTUZJNW9FQzVZTER5QUZJQTdFdkJCQ0VGM0RGd3VNbmlQQldBTEJXQ2dTb0N1U29HM01FSGFXSXZEczhRa0tOU2tHcXlHMlN5a3lyQWNBMERsWVpxNUcrL2xBZERWQU9PMFhEd0w2b0ZvOFhlSFRkN2Q5enMzWEVmQ280WGUzZmM3TjBKWisrT203MDdidmJ1dUk4REoraDRNRmFqd1RpTkFSR2RBRTdVV0pDaWNlQWtuUWpHNnlRZ2pRZWxPaGw4V3hPQU5CRWNvVk9BeEM2Zm1OUEErV0tYRDdITEo1NWRQbTUyK1lTenk0ZVhYVDY4N1BJSllaZFBDbmI1OExETHg4MHVIemU3Zk56czhzbUpYVDQ1WFF6TzBpVmdnTmpyazk5bG9FaVhnM05zeDM4dXVuK2xKUGI5NUQxSjErQ2VDc28wRFJ5dGEzV2RKTFNURW1ZQUNSMmxoQnVCVEZNbkNFMGw5bWJkS1drMk9GaDM2ZDl4M3djT3RkT0NZM1EvT0ZZL0FhUEZhUUV0K0FVNFRwd1c0T2EwZ1BDSGdQUXdHR05uQnVQMEtEaEpuQm5BOHpqSXNKT0RrKzNrNEhRN09UaEZuQnpnZmdHY0prNE9jTmVCY2kwRzM3THpnN1AwWjNDT1hnUG5pL01EM0V2QUtWb0tuSmFCVEMwSG8vVUdPRDM4di9TM3dCbDZHNXlrZDhCNHZRdk8xUXFRci9lMFZyS1JPY0ZHNWlVMk1pKzFrWG14R0ptRU1ESUpZV1FTMGdDa2pXQ29OZ0haV0wxQVc0QnN4RjdJZU8zRTNRV09WTnpoZER3NnlzN0U4amlIR0VaSXBhdlVRWFkrVnV5cVhZMWtwMlJST3lXcmNDUGNTTWxPeVdyY1FRNHJiMmRsdGU1UWQ3aGt0dUM3N2toM0xHNHNBdTR4N2dUYzJBWGNwN3JUSlR2Vm1Pak9jUTlMZHNKVzVmNmJFemJaQ2Rzb3N4M2ZNOXNoTy9QNGpsa1FPVTQrY0hQbUtwa0YrWjVaUXRscHgyZzc3VGpOenVKSzdDd3VabWR4aDludjdsTERMMTJjMGlUZUtZU204blVPbHdTbHF4Q2txZ2lrcUJoSUpjRFpDWjFVQmlLS2pHaUZSeU12UHVnSXh2b0R0aXQ1MGJleGZ0c0dYbUIrZVpTVi9pTC9OT3ZjRmVCZHo3MFl2cHh1S01iYUFqL3Z0LzFPL3pyNHd1ZzFkZ3UvOHd2QVgwbFY3ei9FLzdyRzhINk83MkhFditTZllsWDdpbzVpbi9oblR5d2x2RXhlYmI0WDhCWVd6OXc5bFBZMk1ZWURPWTMzM25leDE5eklXbUkrMzJYazJ5Sm52OHpaeEhxb25mQlA0ZkIyazM2UWYwbFZ0RzB1OWQ5Qm1rMXkydGNUcFJaYjdLOEpJb2NXcGZGdG8xM0lJSEgzTXBiMEY3VnNlNmRiZTVweENZb3FzOC90RTFKNkhuS2xMdEJ1MzJTY3pTSkVJU2ZDTi9MbTl5ZnNCWHB3ZFpOMmx5VDZFSGMzSVMyVUhhR1U1bjd2NzZWYVdhS2tUbnJvWFZwaC9PVFdTajI2YkQxVGFuK1ZzZllvejlLMDhVNnptcXlpOUdhbGVaNDkxLzBtbFoxS3MxWlJnbktWNHp0QWwzTEN2aVREMDZNazdUVjQ0aURDY21sckM2NGV5VmI3T2NxRFc0UVNRaTVlV1pBc3BCdFhKbExMRUdkNitIYjVMYUNiT3JjWWRxcGFOZFIySUJ4aHJkdi9LWnB2RGJXRGVLZFNYL01qbXpqdkpxc2gvV3poZVpDMUh2OU93cFAzVzdpTVI0cWdxOGlWOU95M29HYmVxL3hTb1RXZ0k4aUtyN1dYZm9Pc1JLc0ZITDdkL1BSbTRDSW5YQTcvTnVQZlJycVZoRFdJSGcxUG02RWUyc0c3TWZoYi9TWlM4K0RhWVBsMktCMkpyYk1jSS91OXdXQzFaTHkwTVBZWEs0T1NaR2NmTHVtMExBTlFkMmdIdXpBSGY5eDQwRjZybXpOWUd1VmdCVDVQeUNwcSthODNtZlNHVUZzRkpmNldHTEd4TThnME1qdm9DVStTaHNOcjhpR0hvTjNzbFBkMVV6V2s3TUFLOGVEaTJVc2pDbjBUc0ZCUmE3OTJmL3NGeStYdnlDUXIvUDJaMVptTmwyeExtUlhTV1Y5cmdOS0N0TFpnN2VLa1NGTVVpdTFaUHY3RVRZUzlReVhUbXhTK1B2aTdMSGEvdnlWSjFNSXJ4cnN6SVZkaXZJZFdzRXQ5RDlBcnVGcjRycERFZWhKcEpaZk8rNEJPSEhqdnlldDU3SXRlN0xPdE83M2Z4NDYvMjA1L1ByRGQ4eTl3dlkrbHEvWC8xL3FuSGZ6Rk15OEZ5N2llbXR2OEFIbi9JclFLNmtXK0cwQXYrNkEvK0Q5WmkwcTloM3JENzFJcjRXcFdvVEpwTjJsVjdYa2ppYTFZa2kyVTJRMTJrdmVuL2pYVjJPOWZrUnIxK2NpYlZqT20ycWhWT2hEMTdDRE5sbEQ3dUg4ZnNPTm12RFZhUG0vQS96WXhEL3JIU1Bldy83bi9CSTVsdEtNbDZmYkNXLzQxd2pwd3ZTSEptVjZ2cGcxOENaM0RlejcycnMxK1NYcWgvd2pmVDNrdkFjdHNKUEcxZmlVRS9pV1UwY3o3WGY4Tzd6V2VHWnJ5NWdQbVpFci9NOSs1cXVaOW5WK0M3aThoOXNmUXV5cmtQUTkvQUNWNkh0Nm1VeGxLUlU3TDRRbWc1TDlMMWcveHdCTmxkbWRrUXNna3VEcXA2MHEvazE1Y1NZODhTaDY3cVhjYStUOU9HMS9sZEVmNHRpS1JiRTZoaC9xYi9mOGh6eWIvaG44NzZZd3puTS9idDlCL1REdThsZXBzajU5TytzVzRQTTl1T1hMeXdaNjArbDZyZHdBeFBZclE0eDVmTytpVmpWeDhPeW5WYkEyeWJ3WGNoTUhIMi9LUTd6RnN0bGxuSFQyR2ppZ0QveFpaSEh5OEpaNXkybFdmMEh1M3g3bWFDMjhYem9iVyt1YzFrSjIzUS9zNWYwZXZCcWpFNURrd3pBNXRsTGhWQlVxVFBhd0gva1NkU0NGQjJSYWVRcTFYcWpReHQ3VGJqUEdSUkZpcHlTUkxwUkFwa3Y1YUVvTVVyQmUrWUxuRUE3L056QnNzeDFLL1duekRpbUdsaFNXZnNqYlpyZWRuL1dvNzlmclFUaE5MUVN4eGU3ZkFaTklSOG80Z05iY1BtWWpVNzB0d3ZzT2JGb0lCUUlrbnpjcUc5cmdEdEFtOWJyY1VpZndZZjl2TjVqRVBRenQ5SERSNnhxeGl3SElLRXFELzdmZmQ3VUV2dkJUSWZqTVByRXg2UEJyc2lhQUJObTl2OVYzRWpzQ05WbGw2SGpSa0YyRE5hSGFnQlM0a0tXWk5RbnA4cDgxbFRzREg5M00rNVV4NzQ0WjZjdHlCZEZzc2xQV08xV2R6d3BhYVhKRVQ2elZQYk9MKzFUdDcvaVpaMldoNXZUSVRwMHM4aFB6TiswUlBVWnZFYUdNVTJYdVFqUjNITzg3WGZ2a016T3FidEpBbDcxTHpleHNKWGhIalk5V0hqTG4xUXZoV3dyZlRwdldrN1pZejJ4bFhERVNVUWlyOFNnOHJuLzA4TnVydG9TYzk4bjFQdERNeFQ5SjI4NlVsWnZtbzhueVhhQkhvRkdQSjBqWGpDL09UcFM5UWhCN2NCWWZ6ajltZVNhcmhMTFFXRkt2SU42bldSa0tybmZnZHBBSytNZDRGL2kyek5WSDRqalFKUmxTTUhWK09memp2Y2gyRlJYdEJJK0EvV2hYRXZRR2ZVd1VZcVNKVitQdXh1RS81Qi9nK3d2c1J3MmFkcXRNMW5OUWpUQllSVytQeTlUdXBXMEhTcmF3VXE3Mnc2enVvbzZNVVIzdzI0NCsxQm5iLzEzNE9NbjRZMXhMeXFPTzArQmM2eVA5R3gyZ28vZy84WnJDQm1lRUJPU3RCYU1LYXBQdjZCVDdlOStZeS9xSEFuc1EzWWpXSkFDWGVFUEUyLzVzUGwvbWJ3bitKK3F0Wm5aaHA1RFpDbENCUjIzVzJQbG5DV3V0ejM4aDdxWndPQjlrZy9PTFg3d2J4ZmY5Q0tleEg5cndYdkh1dkZVMHFaSE1WTWsrRHgzYlNTamM1dkdvcDl2dzdlbzlxa1dnSHFOZEE0eTczbTFRTHN1VGdxSVhJelhxaXhQUWtTN3pwcFd3NXEvMklZSE1qMkt3MXBDdjByK0VqQjErblVjUWZDUlg3NStoOTBkc1YrTXRWd2ZuK0svNTVldk4zZ0prY25mbHZ0UFZVVUN0MExPdzlPbTBIWm03QW1yanYvWE9QallRbkhtUW95by9ZdU52Z04vSitqNVkxMkRwa3JWK0U3aTFRTlJCeFhUNU9iWmY1LzBmaDNxUHRydU1KMlRyV0hHdEorNmpZbjBpMGQ2NUNMZnpIRXFPRXNxejNVK1VTcS9LRkN1ZmNLaUN0OVNBNitRZXp4M1BDZlBRTDA0bGFtelBtRXQ1by9sTGpuY1ZZK2JtZkFoN20rNnovaWI4QldRNEZHYllXSVVmc0RkYlpmeURacWJsak5mUmgzMSs3c3k3NWhCWnZKSDl2WWMrUVlxdGZnSHlmd2xJOXlObjduK0I0QXJuUFVpSDFTVmNXR3ZrSFZnQWZROC83MjhLOWtEaHJtWmZNK2pnb1M4T0RIamJadnRmVHhwMGFEa3hQTkJ5U3Jib3pWVVJZQU8wakhpb2psQWMzRXZWZndEZElBL0RsQStTbFFpaGI2VkNSOTd6eGt5cWJsclF4VzlWRGRvNWkxdFpySkpxVkJVOU82QlVIeWNpQlBvL1prMFpBL2VTQ1RIYUdNVnhuOW5ZRksyZG1BVFNDbFo4cXpPWkVyYlE0NFFvMk9MTDMzeVJOMStLMlE5eHM2L1hYSlZLMTdiSGY0UnpBZUFQTVRjNkdkbUQ4RnJyVzNpM0cwd1kreFdkcGs0RUVkcGxkMjRVMGVrQ2pyMC9tQ1dPbjZVdmNCdXBOdUR2M2pLV2NuWjRuL0FaMnY0L1Z0OE0waU5IS1NKd1gybUpybWRCV1J6Z3VRcE5sMGh4Y1RZQnZrTWtIYUpGSkFvdTJBWjZsd2VyU3MzMXZ6RnFaRmhaV0xlUnVMbUJNUTZqRFAvVXJNZDlOdm51dTZTQ1FUVWw1OVBoblZocDl1TzhWY2NqSFZwM1d1Kzk1VHl2K1crSU5MTnhXWXhiU0ZNSjdReHp0TmY4YS95Wm84ZzJCYjVXOVYwQngveEZZVE54SGloam5Cdnh2ZWZKQ096eFBPeTRlWlNJUDNBWmlnMzVrSUJQNUxwUGdnZCtkd0Rva2FVbmZkbjdpUDdDUnM4MXZJZC85UCtPVVluTHNVTG45MTdDRFJCZ1lpVC9DbDFrVkZLbVcyWDFrQWxJRm9SWEVNNitZYTVSaWxuS1UzNDd2S0oyQWxFNkFrNXgwc1A4Q3ZpSmNSd0pXS2VqUlZ1aDlzTTZ2TkhwZjJib0lqTlRSOEpoTUNPSGhYV0JJUERiWDcvc21lRGJwd3pralBwR0tVTEJVUjZFalkzU3NCbGlPUS92K2FyaXYvR3dNYkxOVHMwWWJCeStFY2QwaEc1MEpQZW5kMDU2RWtjVFhYRHpHNzgyT2JVbncvd1ZLVHJ2RzN1dlE4MVpLNnpaZk40Z25PTnBDcWF4anBiN3JrLzRmczR2TXMwbG5QRjVLOHNVcGt4cnV1VnZZNnp4cmFNaUxOWFpZdFJBR3pHMWZtM2Vnb3RBL0VTQmxFWnRGUERIQ1oyRUsvTmthWk9FRnZNdWdYSWx2Rmk3ODRzM0k1dS9FaGg3YnRlQ1Q3TDlhNTFzcUhwdGh2OUt6Wjh1VmgvYjBocGorbnFIN0NnTjlZd3VGQmtQRTRDWVVuNkNLeEsrQVVoVFdzYmFHOWVZcUpIWW9WR3k4V1JBQTJlaEpFM09OeWNTd3k5YVRJd0d5Z3hSay84OCtrZjJmL1ZrdFN4Tjc1ZjZlR1BYN3dsWnkyMFUrdGs2SUFkYllpWDF4RkZkVU9VRytVT0xjcXJUUFBuV3o4UStHTXVBcVNycTNWV2d4TVdBUDlxT1JrbGI1ZXBOSWE5QVQ0aE1yVjFiZFNiWTE3d0F0Ykx0OVA3VzkzeHJUWDdGSzR6NkVvbUNROTZiZmxMVFhxR3ZmZTE0M3p2NmZ3bjBIaHh0aysrdlRzbjJtV1dkYXdyN2M3d3F1bGZxYW40UmQ4WDErSzUzMmovV0V2aFZ5NURTU1ZWODdjK2hUdURZYnlKTTNhMER3cWY4OGhIZDUzaGJUYlA1RzB2M1ZmSEhqV0c1eHJ4dlA1N1M1enFNUkV1OVYwR3BDVm9QMWRvYTZrVlE5Z0JNVUcwMmJBM1lGZTlMOHovNGltUHpDU1grNG5RVUZmeFAwS3UzanpvdU4yM2gvTjA5TlM5YllYblViOC9jdmFkdFdVRzhhc0N1Y3JLd2lwRG1jS0JNcjhWNExyUUtjdWZ0ZCtLZ0ZJY3RvSXllWVVDdVNYTzhYNFNLdGpaVDFvQkhheXR2V3JqYUdXbkVqS1dnbjZJWnM3YUFjcTVXSE5vbm5nRzROcnJGem1PaSsvbThkdFZzRTJpWGJWVmdaZ2NlNG9hUUh2a1I2Lzh4K2Y3Rzk3OUZoNjlpazNIZWJhMWNpdno5KzZkKzJaL3JQL3ZuN3JuMW1sVkNic0lxRzZPa0RlY3JwcFU1clFZYksrSDVDRHVVZ1I2bkt0bThFWlBNdGdncmw4QUcrdVZBNU1RNms0RE9iWStlbXh1OGJDTTMyN2JoVC9KdWtKUlJZYXY5SHpzNWZBYy9ZdW0wbDlCN2xGd0xibVFZOVdSVmFsR0hyeW4vOHNHdWxuQ3p2TGJYdGE0SnNGaVBoejYzOFFYTGtWNUNVWHdSSTZmc3BZYUNOcFpCLzRudGd0ajlic1dDdFZ3V04vOWo4K0hqL1hza1BvWDRsV000WVd3NVdRY3VvVmQrbndDOFByclFEdHlmSUpHcjlrMmZ6WnlTTWkwZWhsN3duTHQveUsrdHZMZU83b1M2N3ZmZDNtdzhXU3VHdkRWNjR3Z2hnMUN1Q0wwQVdFM3hyQVQ0N0grMmhONks4MmFVcjN6ZUNGWjZWcWFYdE51NWV3eFpjcllBdm5CazJHN2Z4YmdPc1dTUmJ4MjdUUC9tRUZHbDczeiszUFNCblRXSG03ZHJ2TC9PdE4yeStBT0hVLzdPa2RVUWtmS05tRDByMmJWL0M3allsWWEyaWlkOStKSDZSVGMvMWVjSmU4alBQRHRWTzlEbE5TU28zQ3BGanlNOXB3SUd0M3F3VktVb0R0a2JZWXkyVjVwRjRjR2ZKOWJmak5wbTBRMTEyaXIxWTJ2dnZyNFJUR20zdng4YVNEL3owZ05uWVJPeGY5NWxtdlowcHJmSDFZYS9VdW8remtuVGY4R1grNjEvaUhINW5zcTZZN0ZzTzhIZGJwWEJ1czlSUkZmTDlVSVNCYkNEVkpLUVlOVDJKOWJVKzhJVVFHN2tlZndhcnlCanBZcDR2NzFiZU9kZ1cxdmlXYjlSQ2wyQk4zbVBlZnA3M2U0ellwZFlYTVlzWEZNNEtFdnFZRGY3aDQ3dElVWlJZbjdkYk9scEcrQ3FieTJPR2YyeWhTaG5UOXBkRCtBckN1cmdVRkFCY0pnK283OWl4a1piVFJ5Ylp0ajR1VlpidnR0WkY3VGRCSmhQaVhrQW1aWUdiOWFUSm9vN1Q2WC9udllTMUhhZWpjcUxHU1RLSmhMbllCY2o3ZjZRbHlLUkF6c1pydW04TU1ta2lmSzZpMkhuS0I3SlRVL1YzZjhHM0pOMjlzWE94UGMrZEtLVjUvL3VyY0dvVlNRNDFLNW1mOUQ5TE12YWFkN1lsbmNjeWRtakJuazhra1YrV0R1aXhHeUV1dVE1QmUrSkp2OEJQTmNtNlBTVFFIalJ5b0dxQVZLdVI4QnlrbzVTcVl6VmF1VG9CRE5JNG5Xai9vZjVpWkg4cEdLWEw5WDM0ZnFBSGRZZ2UxcU02UlU5b2tjN1VZaTNWVlZxdWQzV2QzWUc4bWJ1TEwrbDJ5amhQdGNCcEJNalVTQkRSUVNERmJnK242VkNRcThNQXZ5c0hHZUs4Z1BDalFLYU9CVms2RG1UcmVKQ2owWW42NVdrY0dLQVR3VUNkQ2dicE5GQ3EwMEZNM3dLRGRRYkkxNW1nUUdlQlFwME5odWdjVUtSelFiSE9BeVg2TmhnczdnY1RlNEcrUXo3ZkJVWDZIaGlxQzBHRkxnTERkREdvTklsVTZYSlFyZStEbXFSZjlUbzlvUC9FL1ZQOW5MYjhBbVRxbHlCTjNOYkYvVENJMmozZFhEMEtCaURIMzFIL3AwRytuZ0V4emRWenVMbW5TeDBXZ2xLOUFJYUllN3E0RjRNeXU2RmJxVCtEYXIwR1N2VTZxTllTVUtTbElFUExRVVJ2Z0h5OUNiTDFGcWpRMjJDQTNnRUQ5UzZvb2VlK3BRSjNoanREUmU1TWQ2WUd1N1BjV2JqUHBrY0gyMjNVVkx1TldrNSs2NVFLQ3BVRzdsUTZiYkx4ank4TDNLbHNjTGx5d0FYS0JWSGxnWU0wQU55aGdlQkdEUUozS0FhT3RETWsyWjMwRzFSaEdBWUtWQWtHSjkxSnoxSU51RS9Ed1NUVmdzbmlUanB1dEFvM1dvWDdVSEMxdUpPT0cwMGkvR2d3U2NlQXlVS3JjQjhIcmpHdG1tcGFOUzNwVHZxMVNYZlNwNXVHL1REcFRucU9UZ2JYYXdMSTBFUndmTktkOU90TUMzOXNkOUpubWViTkZKcUhHODBqL0J6d3YwenpmbUozMG45c092Y2Z1Z0RNRW5mU2NhTjV1TkU4M0JlQyswM3o3akhOdTFlWGdETk4vLzQxL0llRHk4Ry9tUmIrdTY0QTM5YVY0Q0pkQmE3WEpKQ3BxNEUwR1JScENxMlZyZ1VYYXpyNG5xNUwzRldmWVJpdUc4RE5TdHhWNXpzVHpDRHNWa20zZ1dNMUN4eXQyNEYwQjdoU2Q0S1JtZzFHNlM0ZzNRMXFkQStvMWIzZ1ZtcmQ1NFk3WDBZT3JwK0F5WGJEZlpLTm1hdkVtTUhObUNIOElWQnBJMmVLalp4cE5uS202ekV3U1krRDc5b045K3ZzaHZzc01YS1FNeU1ITnlPSGNoZzV1T3RBek1iUDdUWis3clh4ODI4MmZuNHN4Zzl1eGc5cEV6ZmM2Wi9sWUxLTm9sazJpcTZ4VVhTL2phTHBOb3ArS0VZUkxWc0JMa202NFg2alBnZDNhUjI0Vyt2QmJOV0R1N1FCM0swdndHdzFnSUhhQ0FacEU4alZabkJIMGczM205VUlibFdUbWlWdEI2TzFBNHpSVG5DQ1dzQlk3UUxqMUFwT1ZCczRTZTFndkRyQXlkb05KcWdUVEZRWE9FVnhjS3E2d1ducUFhZXJGM3hMSHB6aDVKeGtOK2lQY1NtSlcvQXprbTdCejBpNkJUOGo2UmI4VEc3QlQ4Sjl0YnNhcXpIWlRWYTJtK0ttS005ZDQ2N1JBRGZWVFZXK20rYW1xZGhkNjY1VmladnVwbXVJdTg1ZHAxSjN2YnRlWlc2R202R2g3Z1ozZzhyZGplNUdEWE0zdVp0VTVXYTZtYXAyTjd1Yk5jTGQ0bTdSd2U1V2Q2c09jN2U1MjNTRW0rVm02U2gzdTd0ZHg3azczQjA2eTkzcDd0VFpicmFiclhQY1hlNHVuZXZ1ZG5mclBIZVBlMUt5LzRIeGZidWgveDI3b1grVDNkQy96RzdvLzhodTZKOXZOL1IvWlA4YjR3cjd2Yzh0YnA2Yko5bXZmbTZ6LzVaeHFkM2N2OGwrKzNPTC9mYm5Ock9ZazgxaS9vZmQzMCszKy91eSsvdUgvNytFOEEya0FBQjRBWTJWVzNCVlZ4M0dmNys5enlXRVV3Z2gzRU1JYVVDS3lHQkJuQ2toQklnVkZBNjNjTDgwZ1JCS3pjMWNhaFNLdlZKYThJYlZBdGFxOFZLdEZtdFZ0QS9XNmxQSDhjbEhIWGxRSDZ4T2JFdGJyYldLYTg0NVRVN3NlWEMrMmQrM1o2My9XbWZQT3YvNUxRVEtPUmxCMUh6cnBoWW1kYllOZE5ORUF1RDZkYXFBaUFRcHlpZ253eVFxcUtTSzZjeGtOdFhVVUVzZDlTd3NXaUV4U2RKTVlDSTNNSmtwVEdVYU01akZIT1l5ai9uY3lBTGV4YUsydHM0QnJ1WDlTSERlZk52N2owcmUyN3Q3dWt6bHZhT3Y3WWladkhjZVA5Ym00cngzaDFVdUsvaGdWNThyODk3VDE5NXRROTc3dzZ6ckNuNjh1OE1OQmU5ZjlsNnpvNzdjbGxGZjRiNVJmNSt0bzc3U2psRi92NTBGSHp6Y2I5L2IzdHZ2VU40SHdxZDRLdTlBQkFoWWVKc0pTQmx3QXhNb1p5S1o4RGFKeVZRd2hVcW1Vc1UwUUdZQk1nZVFOQ0RUQVprTlNCS1Fha0RtQWxJRHlEeEFhZ0dKQVVrQWtnSmtCamV5d2ZOUlIzUTVyZzFhR20rTlQ4WG5Fb2xFVGVLV3hKN0VVT0pTNHJuRW41S1o1TXJrN2NuenlSZVNiNldlU1NmU3cra040Ym1TL2xYNmF2cGFXYXFzQlFFcEkyS1lySGQ1eWsvNkU3L3B0N3piZTN6Q2V4bnhVMzdhei9oWlArZVBYZWEzL1k2SFBXSzdSKzN3bUxkNzNEdjhpSjEyMlcyUHZYN1VQZ2NjOUU0LzVwQWY5eE9lOEVtLzYvYzg3K2Q5eEMvNFJaL3lVUy83ckJmOHZrOTcwVXQreWNmOHNqL3dHUi8zaC82SUViL2lWNE4veldHLzdqZVFMQ25TbE9YNk0xTjAxbk9wWVI2MXpHY3h5Mm1raVdZK3dLMThrQTFzNUVOOG1FMXNKc3NXdHJLTjdleWdoVjNzWmc5NzJjZCtEbkNRUTdSeWhIYU8wc0V4anRORk56MzAwczlkM01ORm51WFgvSmJmOFh1dThpSi80YStNaUF0YzZMdGQ0bnRjU2x3NFNibENoaHJxV1VZVFdRNXdCME9jNWhHR2VacklOaytTZExPN2VjbjcrRHRwcys3aGhQZnpEMWY1VTFKdWNTOERQc0FiTnBCeXEvc1k5RFQvZERVcHQ3bWZsMzJRTjIwazVYWVA4SXBuK0pkclNMbkRnMXp6SWQ2eWlaUXRIdUpWSCtiZnJpWGxUbS9qTmMveUg5ZVJjcGV0dk80NXJydWV5SDZ2RUJIbkJGT3BSbllHVFNRRlJKUlRRNHh4STdLa2tEQ2ZtSWlhZURFeU0vOVdHQmZaanlTSU9adzd0Y1RvMmJUbmNnSlZWRlBQRWxiUVFET2JhSEVWTVZWa2JBZzVMZVRxa05ORE5vYWNFWEpOeUpraG0wTE9DcmsyNU95UTYwTE9DYmsrWkRVWlJDYU85clhSYWY0NDF1WFJFT1c4eEFrR0dPUmxYdUVhci9JYXI0OVZVTTFFUnR4czFpMXVkWnZiM1dHTE85MUZoRlJTRFVXN0w3S1pGSkNrZ2pwVzBNdytZa0NhaWFQS3FESWt4T0dkQ0c3RzhBQ0ZtbG9pL3hZY1lpS3ZVb0hoQVJDcEpFWmZRS29LbVQvZG1FcEdYRWlxOEJVeG9NUG9ya0xOK0prelJGNndvZVJjSjdFbmcycEx6bVpKZUNpbnFPVDhVcEkyNXNVZlNsWmtTRmx0UVR4ZnFvWS9rK2FOSWoxV3N1cVhsUEdiY2JxelpOMGxKdkRrZUpFdFdkbExPWGUvUS9WRlhUeFN0RUlxa1VaQW9JNG9hQ1FJZDl1SzR5cXJrQm9jM1N0Q3BoWTZSMklpZExPNzRCMzcxeFh2bjEvallVOVFUb1EwY3hDS2VuVVBOM215UU8zQWErLzFQdS8zQVUvN29HZDh5SWM5NjdreGZoZng5MUV2RkZIM2NRTnJpMGg3RTNHQnRZR3lUQ25jWnRPWndVeG1NWnM1Vkk5UnQ0aWEzZlFYc2ZKRmNjRW9IOGUrZWlFVnVSdm1DY05kVXJnWm52Snk3aVlJL00vUlh5b0lsQThlZUY2Z2N4YzlPUm9IQmhNSVhFU1ZsYmxNa3NseHBZNUZQa2ZNUmpiNTgxeHU4V2RFYlBUNTRKdjhSZkF0aUd3c292WTZ5cGxORFhVc1pERkx1Wm1WM0VJanVncHRRRmVqamVnYXRBbGRpNjVEMTZQTGlJaHl2dzdMZ3lhTU1ZS1VaeEZaUEc2c0RaR2Q0OFl1STQ1Zm0vcy9wR3JjMkVaRWVvdk90SjdKdHBYbUZoY1pDWkxKeEZTVy9DLzNFM2hTdEZ1V2VuZTd4NzN1Yzc4SFBPZ2hiN1AxLzdqMysvLzM1aC9yNDF6M2x2OFhKemVJTmdBQUFBPT1cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3N0eWxlcy9DaXJjdWxhclN0ZC1CbGFja0l0YWxpYy53b2ZmXG4vLyBtb2R1bGUgaWQgPSA2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///62\n");

/***/ }),
/* 63 */
/***/ (function(module, exports) {

eval("module.exports = \"data:application/font-woff;base64,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\"//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc3R5bGVzL0NpcmN1bGFyU3RkLUJvbGQud29mZj9lNmQwIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmFwcGxpY2F0aW9uL2ZvbnQtd29mZjtiYXNlNjQsZDA5R1JrOVVWRThBQUtGY0FBd0FBQUFCSVdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJEUmtZZ0FBQU0zQUFBVzgwQUFHem53aUhTNjBSVFNVY0FBR2lzQUFBQUNBQUFBQWdBQUFBQ1IxQlBVd0FBYUxRQUFETGpBQUNUdUNoUWhaUkhVMVZDQUFDYm1BQUFCY0VBQUFzZ3lzSFEyRTlUTHpJQUFBRjRBQUFBV1FBQUFHQlFPVkdLWTIxaGNBQUFCYXdBQUFMb0FBQUVYaHdVM05ab1pXRmtBQUFCSEFBQUFEUUFBQUEyQUFVc09HaG9aV0VBQUFGUUFBQUFJQUFBQUNRSnZRYlhhRzEwZUFBQUNKUUFBQVF4QUFBSFlBYjhTaHB0WVhod0FBQUJjQUFBQUFZQUFBQUdBZGhRQUc1aGJXVUFBQUhVQUFBRDJBQUFDQ1hxWDdPZmNHOXpkQUFBRE1nQUFBQVRBQUFBSVA5b0FGQjRBV05nWkdBQVlxY2JNcWVyNC9sdHZqSXdNNzlnQUlLelBkVlNFRHFYLy8vSi95eHNQTXhQZ1Z4MkJpYVFLQUJxdlF5ZGVBRmpZR1JnWUg3Njd3c0RBNXZWLzVQL0w3RHhBRVZRQU9NTkFLOUlCNThBQUZBQUFkZ0FBSGdCWTJCaE1tTGF3OEFLcEx1WUloZ1lHTHdoTkdNY1F3Q2pPZ01ERXpjSEN4TWpFREExTUREb0J6QThxUWFxNFdBQUFoKy9FSDhHb09DLy84eWEveDBaVGpBL1plUlJBR29FeVRHK1lUb0twQlFZdUFHUGZnOVlBQUFBZUFHVmxNMXVIRVVReC85ck8zWSs3SkFjRW9HUW9BaGN3TWw0N1hCeUVGTHNrRnlXU3hMbEdLbDN1bmUzbFo3dVVVOVAxaHZ4QVBBRTNIZ01MaHg0QThTSlorR0NvRndxRFN2TFFtTDc4cXZ2bXVycUJYQnY5Qk5HZ1B5K0duMnJQTUl1dmxUZXdCYkd5cHY0R0Q4cWIrSDI0SE1GSCtBYjVXM2N3bWZLTy9nRTN5bGZ4ZllRZXczdjRZN3lEYVkvbFhmeDZjQjdveWNidnlqZnhNSG03OHAzMXVyZXhZNTBOZHE2QnVCczQxUjVoSHY0UTNtRG8zZVVOL0gxNkZmbExSQitWcjZDbzlHSHl0dHIraDJjakg1UXZvcmRJZllhUHNKcjVSdjRZdlNYOGk2ZURyeTM4ZjNtMzhvMzhYcjdjK1ZiZUgvbzdUWm4vVTM1emxyUGQ4RTlQM2Z6UHBpTTUzQ1lvMGVBUVo2WVBydjRqazV5SDZQTHB6N1g1MDR2aW4xd2tvSlZPUk1yNkZ6eHl1WE9wMGlIMVhoOCtJaW12UStXeHVQeEVTWXc2SkhoRVBFT2hCUG1uam5DWWNoTHZpTkRKUnZyR3BQZlVKclJ4RWRYMGpHdGw1TGF4M1EwUG55SVUzaGsxTkNHOFFJRkZnODRmMEpndW1nbjlTQ294NktVOXZqZ1lMbGNWa0ZxVlhWcURsNHUzUDRUMS9sNWRMbkRLemhrZFBCSWlDQWNvc0tZenlFZWdUQkZEeS9GQ0dNNVI4OGN4NW5pTFBrb2ZkSjBSVTlUTEJNejVTL29yVThWbmFaMmxmMThVZGhwbHFoMTBmbzRyeTVwMmFNRE1STUt5d1lXRG8zWTNvQ1FNQU5oQWkvRExDd2ZneTdKY21FMDRuVWtYL0VRQ3hRK0xlc08rQ3psVkFock9TdlVTR2pZK3BLOUhmYnhCRTVtTWtmVStUeURVellvY0xBZ3lURFVrV210UUhncWt5eXlGbFB0clllVkNWZlNmVUxMbmxueWMzZWFhWWJFMUVvZEs1bzVxb2xaenZwQWZlZk9ONllzSE0xNDFCMmxMSUkxeFZETkd1T2pzN1QwWmVIajRFWXpIMXhIN3F3T3ZXVm9rdld6RlYvRWZjck9kSjFycGtHbGFCcWhycVRNUUNsUzI3TzFEaXN5YjQwUFpob2NkUzYvZGJrN0Q3QytLMzdhRi9FMjBiSXRCT2FLSHNjVjlURmNhTngzVkZadG1tZlRMbnhOWFpxVnBjbU9XdzZCcG83YW5EcFg5OFhaaXJjcGs3SFdGNStpQ2JKQ3VUSG5FbGR4ZTljdjMrdkp2M2kranZzVFg3dlljVXR5RTB2TVpGOElQVHE0WWJjS0ZpTE45Tlk2c2VRMWk0VmhOa3kxK2hqZEhRdkNFbDQ4V1hOSk5pWjVQMDd5T3B5aFpxbUhWVTJEeE96WmE2VTNmaCtFREFlRFR2cHNNRVc0WUlzd2FOWjBuV3h4VmczcFMyN1JheXpYbE0wMGVBc2ovUml4T0lsMXlLeVhMUjhxV0hqSjZ0bXZSMW5MYlJCaE5TNE1uVlVnUEVhVUtqMGl3bjlQWExJenNYK0x4UEVaQnEzb2E4bk5ubXhkd2lERDZaU0Q1SnFLM0NJalNkWWF2YjdIU3Q5ZWxpNHRINCtpLzJzR1llMlZaVFF3VUp0K2k4TWVydit2LzRySlpkcmg5ZStMdllaanFZTk02UjgyTksyTGVBSE56dXR2azFVQWdQSG52Ty9zc0JOd2RGTTI2empuc0xjRkJoVlVGT2FWT21Xb1V3ZnpocmVpRUlTaWdoZ0VBMWptRGZER0JQR0tBY1JMRVJVRUx3Z2FYZEtTSVY0UVRZUzZucVB6YnZTYmlRbnBYcHZHOUIvd2kwL3lmUDhCN3IrSEVRQk9CeTRDQ0ZQaFRBQldreUpBRUJqSWNud3hUc1RGTkRGRExCYkx4UlBPUHFmSDZYWFh1V2wzci91UkhDQ3JaSTJzbHcxU3k0Z2NLNXRsWExiSWRqbGZMcEdyNURZVlVscEYxQngxaDFxcm5sRnB0VXRsdGFNRGVyQWVvbXQxdlc3UVRicFZKL1FzblduTWVKdThuZDRuM3VlUldEUVVyWTJ1dE03UmluN2Y5NkZra1d3c1dpYUpxU0pSdEN3cldySkZ5emRsUzJYUkVwSkRaVmpLa21WaTJYS1hUSlV0Q1RWUHJWSHJpNWJ0WlV0MTBWSlh0c3dzV1RaNmIzbjd5NWFVNVNnbGkvRC84dnY4YnIvTDcvUVgrclA5ZHIvTmIrNnY3QThVL2k3RUM3RkN1RkJuRDltRGRyL2RaN00yWTd2dGJydkRiclZwdThIZWE1ZmFSYmJEL0dtczZUVmJ6R2JUYVZKbWdVbWE2V2FZQ1pzYUV6TFZacENweXZ2NXZ2eUJmRTkrN3JmSlhGZHVSUzZadXpVWFBCSTU0aDNlbzFvQ2s1MDJCUCtmQWs0UVFQQ2ZWUzRWSEVPQVNnWndMRUdxT0k2QkRHSXd4MVBORUVMVVVNc0puTWhRNnFqbkpNS2NUQVBEa0NnMHcybkVJMEtVRVl4a0ZFMk1aZ3d4VG1FczR6aVYwemlkOFp6Qm1VeGdJczJjeGRtY3c3bWN4L2xNSXM0RnRIQWhGekdaVnFad01aZHdLVzFjeHVWY1FUdFRtVVlIVjNJVlYzTU4xektkNjdpZUc3aVJtMGd3QTNpUWgxakZ3NnpsYVY3Z1JUYXpoWmQ1aVZkSTh4cGIyY2Jydk1rYmJHY0hPM21iWGJ6RGU3ekxYdmJ3QVIveUkzY3lrMW5NNFdjV3M0bjVKSVhESXVhSzBhemtXVEdTaFdLTWlER2J1NFVTaldJNGg4VW81ckZVdUx6Sys2emdGbTRYSXpnZ21vVG1OcGJ4Q3pmVHlRTThSWVlzdmVUNW5qNE1sdDFpUEIvVHd4OENmdU4zMFNxbThCTkwrSTRmK0pYN2VZVDdlSlRWUE00YXVuaU1KMWtQck9ONU52QWMzWHpLVnl6Z0N3N3lKZmZ3TllmNDdCOVFld0lZZUFHZDFGMklsT1VieC9IdmRUMHovdi90NnJicjdybzUyN3JqT0R1ajYrenNqbXZ1T3V0dW9yV3pyVyt0YjBHWlZLZ1JGUmlZZGhEVldWQ0dJQm1ZZU5JTEdwUlJVZUJiTDRSRUIyYVVCYjBnNW9HTHFRZWxNUVRCOUx0alcxS1VvSU1QMS8zY3J6UFhkVCtQRDFFQ29DeGl5MWxyTzBuNVdXYjVhbkxSV25KK25NVjhSOHFHbVMzWVowejFaUlNzbDM1N2tnN3JZYUg5QUw2WldiYWRWbThsNlcxTTlqV0s3YlQ0SU8xV0p1NjlaTDFFU3VzV1daSEY5Z3N6L0I3NkZKTmVSekxxMC9oWFZQa0RqUGdmYXA5VUhKUTVqRVNUOUh5QkVjdnJ1WU1HUDZUWXBmNkRpaFhGck1iWGo4WEgxTGVPYWY0d3RmNCt3LzQyVmJHSWliNVh6enUwL3pOa3JWOTcvUWlLY1orcy9tb20yRXdTM3F6L3ZZR1NaNVNEalRLTGxHMmdSdjhsSFhKbDlmUllmV1hVTzFHYlVyU1ZrdnBGYzhPNit6VC9XWTBkcDhVZTE3cGhGdmwwcXFKYmRYNkRkUEUvKzRrMjI2YTgxVEdpR1BjU0NjcGdlYTF2MC9sMzB1ZExkTjRtcG9RNVhsQ3VkdEVjZFpHMWZmVDRSSnA5T1IwaDk2SFBWdENzc3hxMGJzQ2VZNjd0b2R1eUpId2xRLzR5Q1V2U2IrMU10VTR5ZG9haTF0ZEZNOGxIUmRuQ0hMdElUY2o3dGNUUy9EL1VJdFRobnl4ZitkTHloSGhLTHZ0NWF2K3V3OVc4bTdZUVF5MnVFR3F4VHZ1dHBoVHlmaTNSZzRvWlZJY3JxUWJmaHZ3cmZpL24vWFpTNDNXNDJoSUtJWVphWEVHMUNEVUwwZW9WQjZtMkV0V3hUV1NqTnpSZmR5alVjZnpPcUc1dWxUUDJJb2tnNU4yMmt1QmphaTJoZUpvbTFiN1J0bk9UdndkUkRSMGVhdkNVYXJrWnJBY0F0TmRBYkFGRG5DUEZlUkU3SUcrTjJjdk5kb3d1YjZBWTdXYUo1dWFzbTJhcGk4TC9IQUI3azR5OVM3Y2RsRjN5cXV5VzE1aG5yeWhxVFBNelkvZmh1dk44SHdNNnN5VjZoT25oOTlxdnVoT1R5Y2ZTMHFMMlRNVUUrZmdjOGhPS2FydjZKcEwzblhKYVJ0WFhMSmxLMmM3U0d1dlhQVHRWS1d1L2hmNWI1ZlBvYnMyNVFEcTZ0L0p6bENiakY1a1JSWlZMMFNydWlGcnBqKzNRdkVkSksxLzRBVVo4dnRyOUZPd0loSHZyQjBucTNXbTM5Y1NWeTJUNFh2aDBlcVV2aklmN0gyMW40MThHUWZDSDlIODZkR2JRcWZFRDFQb2w2cU41dFA4YlAxZXB4TlpxM1JGeXZwOGEzeVpicVltT2lnQll5TzM4cTNMNy9IK3ZBUVVJNzdXVldhWDdWclRmNVpqRzd1SVcrMXJ0VWZXM3NOSktETm9KdGF0WjVVY1ZSMFh2czVVVkx5c1dXR0U3Nk5POHJIMmg1OWVaNGx0STJINWE3QjJhN0NXS3ZnamtCc25LRk1uSkIzSllwc2thS1VpekpDVXZiV1BQT1dtUkQrVWpHWkpPV1NvRFVwU2tUUExGTEZOc2xSN0pqYWtXeGpSS2gzUkxrK1JsT0xBK1pndmgreGErMHhJUDMwdUoyd0tXaCs5ZkdGT3M4emdKZjRKaWJDNjNqYjhqRThqNkJsTFhZeTlROGsvcFZmNnl1dnROZkVPQ0UzSkkrKzBmci9WNDdXMHBOOXI5MUZxYUt0M0xSaHRCYmZYdG9kNkN6VFR5aWZveXNvVTZlNXBhVHBMZ01MVi9BcEtNTFUwQUFBQjRBV05nWmdDRC82a01BUXhZQUFBb0NBRzRBSGdCbmZ4M1hCUzc5ekNPejdETURHUndWTlpCMlhWbXdJSmRVQkRCM2xIc0JSVVY2YjBwWlVGQnhYcnR2WXVLRFNsU1JCU3dsMnZ2dlhldlY2L2RxNTdCNFB2enkrejZmajdQOC92eis0TE5TVDFKVGs0eU9Ua25vU2xySzRxbTZicTlvNU5DVStPQ2swYW1oTFhwbFJnWHBrVzJWK3RRMVlKVnRhQlQ2MW5qTVhhNmgzYldvL0J5aWFKWXU1OVRHQUliREt4OW5JREFmZmJFZFR4ZWwvcEdzRkVzVll1cVJ4bXBSbFFMeW8zcVNIbFRQU2dmYWdqbFIwMmdRcWtZYWpLVlRzMmc1bEZMcU5YVUptbzdsVStWVWhYVVVlbzBkWW02U2QybG5sQXZxWCtvTDVSSy9RL04wclhvZXJTUmJrUzNvTjNvam5RM3VpODloUGFqQStrb09wRTIwZFBvT2ZRaWVpVzlnYzZoZDlQRjlINzZPSDJhdmtUZnBoL1JMK2wvNksvMFR5dkdxcGFWZzFVanF4WldibGJlVnQydCtsa050aHBsTmM0cXlDclNLc0VxMVNyVGFyYlZRcXNWVnV1dHRscmxXaFZabFZzZHNqcHBkZDdxbXRWZHF5ZFdmMWw5dFBwaDlSK2RqYTZ1enFCcnBHdXQ4OVIxMS9YWERkT04xWVhvWW5VcHVremRQTjF5M1FiZERsMitya1MzWDNkSWQwSjNWbmRaZDFOM1gvZFU5NWZ1bmU2TERuUy9ySFhXdHRhMXJVVnJvN1d6ZFRQck50YnUxdDdXM2ExOXJFZFpCMWhIV2lkWW02eG5XTSt6WG15OTBucWo5VGJyUE90aTZ3UFdSNjFQVzErMnZtLzl6UHFOOVZmcmFzYWFxYzJJak1LMFpyeVkzc3dneG84SlpLS1pOR1k2TTQ5WnpXeGxDcG1EekRubUx2T0MrY3JxMkxxc0Urdks5bVFIczBIc1pEYVQvWVBkd081aHk5aEs5aFI3aFgzQ3ZtV0Jvem1PRXptSmE4MTE0SHB3QTdoQjNIQnVOT2ZQVGVCaXVXbmNYRzQ1dDRIYnhoVnpCN2lqM0FYdU9uZWZlOE45czdHMkVkc21wTWJGcFNaRXU3bTU5VEdEbm00V1lBNjE3KzJ0QVhkdkR6UG9hUW4xNmowcG1uamF1N2wxdEFBdkMraGxCaDd0emFCRE96UG82R1lCSGhiUXdRSThMYUNqQlhoWmdMY1plTGxaUURzTGFHOEI3aGJnWVFFZExNRFRBanBhZ0pjRmVQZE5UVXJVdk8zYXVRK05ENDhNTnZzOTNTeWduUVcwdHdCM0MvQ3dnQTRXNEdrQkhTM0F5d0s4TGFDM0JmU3hnTDRXMEM4NEtTa3hMUzQ4SXNYc1NaMWtCa25Sa1ZHV2lMREV0QVJ6VG05UEMraG9BVjRXWUVIZDB3SjZ1VmxBT3d0b2J3SHVGbUJwWjI5UFVrRktkSEJjV0hSRVJKL3d1SlRnU1VtSllhbWhLY21wOGZIQktkR0o1c3JhdCt0Z0FkNUp3V0hSb2NGeDBRa1IwUW5SS1ZPaUUxTENJNU9DNDRJbmtXTHA0Wk5UZytNU0VsUE1NQzQ4T2Ruc2lVd0tEMDRKVHpMN3d4SlRDTllvRFpsSDd3NFIwU1JYV0VoaWV2LzJaTVRjVTVLaWd5TlRKMm1KSFhxNXh5Vk9EVStJREE4bHExQmNlUDkyWGgzY3pRMzNiRzhtVk1kMjdoYlF3UXpJT0p0Qk93dG9id0h1RnVCaEFiOXplbHBBUnd2UXlOYVhzS3VGSmgwc0lhMTR2MTdtU0FMY0xjQkRBMzM3OVpzYW5wUkkrRHcrS1RFaDNBeFQwaEl0TUNvcDNCSVRrWmlhWlBGRW15d3h5ZEhwRmhodUNrOHcrOEsxRVRYN0VxSi9JekpqRGt0SWpDZVl6WkJndGtDQzJSS2pZYlo0Q0dhemgyQzJRRE5teldmQnJQazB6SmJFU2NHaDRXMGprb0pEZzlzbUpvVWxoSmpkVUxNYlpuYkR6VzZFMlkwMHUxRm1OOXJzeHBqZFdMTWJaM2Jqelc2QzJVMDB1NVBNN21Tem0yUjJrODF1aXRsTk5ic21zNXRtZHRQTjdoU3pPOVhzV2xxWkVrRm9FUkpPU0JhWlFBSmhpWEhrRzBROGs4S1RRc01KTnVLTFMwMG1JRFNSY0tnbElUb3hqSGcwK2hGQXFFZGNRanZpbWlsSG9KbHVCQkNxRVVCb1Jsd3p4UWcwMDR0QWpWcG10SEdKQ2ViaytPai8ralZlSnNETXdnVCs1bWppKzkyaVpCSWljeUpTaTBsTlNncFBDSjFDdkZQQ0xYaENVNkl0V0JJam8wUE5FK1IzSitLakU4dzlpVStOUzRtZUZLZVZDWXMyUllkcHpTQzVrNksxVXIvWHh2L2o4N0owT1NVcU1UVTVPRUhydDdaR0VmQmZiUC9YWENTaC8wN0gzNzM0Lyt2Q2Y0T1Rna21qdFVXbmJXaHdjcmc1cEMwNWxtRFVsRWxScEN1YU40U3dVR3g0aWlYbi80Wi81LzBkRWY3L0pJZi9iMko0ZW1oY2NMeTJncG1Ea2FuYS9JOVAvRjkwdno4Vy8wL3EveUlualExUDFtajVmekNFSjRRRkowZFp2UEVXNysrU3lXUTA0alM4LzIvTS8rTHlhWnVjN05ZdVdIUGJCNU1sekJSdThRYUhwcWI4OW1wTFQybzhJVnU2Slp3U0hSZjJPeWtzbXRBdU9UclpFa29pcU0yK0pNMTFENDRuNDJNZUd4THkwTmlSd0E1SjRaSFJ5UnJKemRHZW9jRkpoQ21DNDFJME5pYTFFazZ5ZUZOU2t4SWlBaVBJZjJDMDVzU1pZZHovcVRIQjhobjRiekExOUhlTXVROGsrSCtseEFlSGtrcUl4OXdwQXYrM1Ixb2cySklZa2hSdUtaaVlZbWtHOFdzOUlzRGNZd0xKZ2gwWm5KUWFIeGVjcXFYK243WVRmMnBDR0ptWS85dUgvKzRhbmNpMjBjbThiVHl0YlFBUk5ZN0twQlpTbCtrNmRCZDZBRDJhbmt5bjA0VmtZM2JYaWlMYk1TZXJNV1R6RldkbEl0dXVFcktwYXFwYnBOdXVPMnd0V2Jld0htUTl6ZnFxOVZQcjcweGR4b25wUWJZMUY1am56TCtNeXRxeU10dUs5V1ZqMkVuc2RIWWh1NWJkUnpZeTc5bnZMT2FzT0piVGMwYk9nL01tMjVmeFhCaVh3SzNsam5DWHlJYmxEdmNYOTRYN2FhT3phV0hqYXVObDA4L0czeWJGWnA3TktwdHNtMTAyZTJ6TzIxeXplVytqMnRhMXJXZnJhTnZFMXRYV3k3YWI3VmpiWU5zWTIxbTI2MnkzMk82MkxiUXR0ejFpZTlMMm5PMFYyMXUyOTIzZjJmNXJxOXJXSUFyVlJRYWtvQmFvRGVxS2VxSmh5QjhGb1RBVWplTFJaSlNCRnFBMWFEM2FoTGFpUGFnS25VRTMwUjMwQkwxR0g5QjNWSTErOFRxK05tL2ttL0h1ZkZlK045K2ZIOEtQNEFQNEtENkpuOGJQNXhmejYvanRmQ0ZmemxmeXgvZ3ovRVgrS24rZmY4bC80SUgvSHp1ZEhXZkgyOVd6ayt4YzdGenR2T3g2MnZXM0cyUTN3bTZNM1hpN0lMdHd1Mmk3K0FWU0k4blRvUkhpMDVkTVdqcGRCb0dkbnoyL2VKY0I1bkVmaDcvRWJyaEJIODl1czJWQVNjeUJaWVdscDQybmNoT2lwczZhbHZpSGdtc0ZJL0FmSndhWmR1ZnR6ZDFTdEZ3QlhUYVR5bm1NbVRSUzVzRUw2a0E5Y0NkL2RYQTk3SVU3WWcyNmt6OHR2cVBNcDZVZ2ZXNGZTUi9oTE9rYjhPS0NGUXRYTGpmczJicWxZUGNHMDVUMDZWT1RNdVdoVWN5QXNKVFJ2b1laVVBFTWUzRXJsaTlmdVV5K3ZwODVrcDlYZE1od2VjeXBkbTM4Ui9YTFdwSzFaSTRzaUZtN0MrY1ZHTUhtMVYyUWdlcHozcVAxNEZGZHUxMEl2cmFuYUYzT0ZtWFE5REZwZnNhVTFCVXJwaWpRQXp6RXVLUzBoUGprclFWNU83Ym01KzFNU3lBby9qcDIvTWIxbzZQYnRSc3pvbC92c2FkZnliQUFEeFdUbDA1ZWtpV3ZRUXZYemkrcU1Lak5zRGlFNDEyUk4yWWYxd2hnVUFYKzVMNzFlZHZXejErd1VtNG04V0pZUVZ4WlR4UVdGeHNtUTRSRFdIN2N2cDRvTko2RWVCZEp2OHFONUlqUDJKeVR2WEZMUWY3RzlLbW1qQ2tKQ201cEhaYVJzMjFyOXRhOXBadlQwbEtubXNLVkx0YWZUbFZkTG9zcENsbW44TU9sOWJpZTZJNndQYlpwaXR2aFRzQzNCT01ma3N4M1FkZ0RXM2ZIVnBqRzFuZkJRK1pGYUEyMTNrQXZSWjJJNVpwUlhOdXg0enA2anpuOFJsWkhrZkJFRHZlQ1dtMmhsU3hVMjdTUStOMHpRZzY2RzNIak5wakZUWENMZDVpQnBwZVBGaDNNVVhoMVRDQ0NFZUFJRThCUi8xSDFVaXZGa1hqRUNhNEZnZ2t6RWFkL1VoMkZIWEVtbm5DQzAzOGNoVERWdHcrMlZvUm9kTWtFTFJ0TC9IYVVQYjlvcndmQ0Z6bCtoSFFkOU8yUXZnNHZYcjl6b3dmejQ2WUV6UmpjNEthRW16RTg5UEtWN2lPZGVrUTlJSjVjVEtocEhJc1VWL1M3TWgyd1dNY0pYbkRaQkdXUGFOanlVWGRTZFJiOUtzYmVPVnlZazdkRlRsMHlmZkU4K1EyN1lNMzhyVHNNMEkyN0VYSWU2NXFQSHpqMkQvblZGQ1ozU2M3T01tUHg1aW1tR1hObnBjOVh2S1l4QTJlR1JRMHpRT000TVdINmxzMjdzdGR0WDZwY1g4dGtjQ09qcDBiTGdydWt6NDBtekRsVDRsVzlPSFJ4MU40cXc0SGlzclBuaXNPQ0FxTENoeXlVY2FtMS9tdWY4SXFxZ3lXVnQyNlZUcHdRRUI3WVc4R3NOVFIvZngrc3J3ZGM4Tm1wNk45ZjJsRnk4VThEMEMzdllTTTJ0dXlHNmVHbGd5NGx5L3B2L1NZSERPNXJ3TmJ2dTBKenducVhMbDN4WmFBdWl3WFFNN2doaSsyd251RkZmTFlqREdFWFljNWxPaDRvLzJBM1FjKy9ueFRsMmdqaVhDNGtMVFk2V1E1SllJYUhoQTN2WW1qMnNEbTRRb3RIWDREYXVHRGovQTB5cnJlT1daYTFKR09hd1M5bVROLytzUWVxOHRmbDVtK1REeFV6cC9kdk9YTENzSEhoK2dYclpXeUVKbUpnU1ZSRlJYRnhSVVZVY1dCZ1pGU2dMTUFVM0FPY3NkOFl3bU5RaHpEQ1dNSUU3M3NUcUEzOW85OURQNVlNL2Z0TUpBc3ZjVmNUOVAxVHV2a0gwaDlXR3p0c1Irdm5sK3p6UUwrNmdTTU1JZ1htYmRxOFlLdngySjlicTNJVi9lRmxLRmNjTUQxdzVpUmpVdXJTWlZNSTRiaFp1WnZuSFRRK2ZIWVFyTFlwRDlTR0REaUJOYlpsMXg1bkxxK3ZXSjFyM0xGMS9oK2JGZUM0MVltWnl3S01uVDBEc0M1VlNYZGxjQzFzL1lFVlZKMGJGemtuSm5pUWNjQnJuTXp4Qll2WHI4c3g3bGd6Yy9aNlpjVWZ6UFF0TzJidE52S3AwMmRsVE10Y3MzcUtQSGNaczg2VXREYmU2RGNocXFjeTZTSEhsNE5CN0hheHo3ZGJCNHZLZHBLSlZKNjN1M1R2N3NTUWtNU0VSWkxibmQ2di83cDMvYzNmM1c2MmE5ZTl0eXNoaTYvWWROV0hWdUJzQkxjMzM2QVdLSzczc1VOUXdMVEppVW9oTkdaZ0ovQTFWbXczL0h6REh4K2oxODl6M0pGVHZMWENlUFprVkU5Zi81REIvUUlPbjUydkNGQXVMdCtRdlh5MzhYeEYxQkMva01CK1BoTU9YWjZ2WU1mSkRLWlgvZDBDV2htaDNkOWZ3UnI0ZG5kYUxGT2dDemd4b0tzSnhEeVVjcmdiZG1HRTROM3hsYXRYeHFHNU5rTlNwZVBSRmFNbnhFU0hrUTUwWnZYMmxEZlMyMUc5Sk9KYklnMUdZTXYvRk1UT00xaDlrOTVrNmUyUDlLZDRFVGNFUDJnSTQ1NUpXTWIrSU9IUkRQOTlHbkF1bitIQVp4ZmdlSndBQzAzUU5ZMCtCK2ZGOFhzakR4M2FXM0xvVUhqcCtQSGhFZU5sWWRiU0dXUUNIc1FEbVlQc1FSaklMRm14Wk4wcVEwVmNZVkJRYkd3Z29WVGw5NmFJRnl1WDdqMTJ6WGkzY1B5NEpRb1BjVGttOEFSNzFUdU5aOENGUFFPZURKU3pwREZIUVlhakhDeFZ5ZEM2c3RnZEYyRjNLR0t3Sjh0WER4K0tlQ3lXTVFQU2gzWEJ0WXlZZFg0Q3JhQURXTi85RHJWUDl2REpWc0NobkFFdTBRWHM4RmdqSG9HNzR5Yll4T05SdUFkMnhsUDRIRk8xZnhwUGlMallSZUxGbnBMd1hOcFhXRkMrTDdZdzlMREVoK1Q3b3ZnOHhQOUVJbWd6RUJxeVlKNlJ0ZGorQXdkY1pQanFSUk1RWHoxTUJDdmNuQUZIRm1ob3pqUmkrL2JvZTRmaFFjQTAwS28ramNmTnNBN1R1RFVmTHhXRGZndlNPL0VIeFFjUGNTZFNjU2ZvMnZrKzlzYWRzUmQwN3R3RnZIRVhUSDRQaUE4Nk00THFMV0lLK3VIYVlBMjFvUjlRdUIvVXh0YTROb2Y3NFJ3UjAyb1UwSnlRSlYxZkk5MEdHYmFCVExDZjRKcEwvRTAwUWVKTmtKd0dYbWswaUY5MWtNazdYZlVBM2p6dENEOTh3RGtNSHN2eTRBZGtja002THhadDMxNVFzRDBsT2lZbE9TNHVaWHVSN09IUTljTFFlL2N2bm5sd2YrQzVidDBHRHVrcTgzQWlNMTNpZzNMaksxZXRIbzc0cHhEN2xENzZMOVFsRmJqeTRyaDlvWWVQbE84N2ZDUmtuLys0MEZCL2tqOElTc1EvaXlwUFg4d05HaVd2UnlOZllHSDBzSlN4OFRMdlZ4RjA0a1RGZ1JQSEF5djgvQUlEUjh1ODZjWURTQ0RObmZKSmQ1UUhUemdERGpYRGVPN0NpcjhQZzhIQVgwYnFVR2pNdzN4UjdZWGp5QkxKNGNQUUdNaVBnZHBjVFM4Y3oyZ2Y0VGh3NU1FR3orZGdEbXpXcG9jejVpQ053OVB3ZWdiYmNzSXpDSDlNdyt6UE9takJWL3RqdVNhYXc0ZlVhQWIzMkliVVJTemNxVm5FQ0c2U2dETk1pSDhDWVU5b1dFa2FSTHdSeEx2bUsvSEMwQXd3cWkvUytMUWxLUzhsL25KQk1Qa3lBNytQZVdMcS9nUWJ5RGNVVzV2SFBBcDlJaC9BYTRUaEFlRURHSEdDc205YmFmbDVBL1l1Rnd1bnJrMmRaRWllbGo1bEdpSFVXL0ZIelJRblRwMkN4NHRBMVV6QkZDZEFyZnMzbnUza1U4MmYwZlVTRHo5RVByZzQ4c0NCNHBMOWZIaEV3dTc5Y2pNSFBvM2VLUEhuSy9jOVVRUW9KbnhNaU80d0RmSDJSV0RndWN0RjJ3L0wrWi9qV0d6WGN6Q3VyeENtS0gxS3cwOGVlc3hGZk5wMmtsdHZ6ME5Ed21RU2pDUlFBS1ArUFQ5TjBocStXdUxUN09jaFVzWVptdEpWWklodkVPSnlRTjE0Q0ZZSzV0Y3c0K01pZVpCMFBLZmFxZjFGZDcreFBqNmpqcjNnSVJpOHlWOHd6MExER25lRzM0RHMrVnNTTE9YdFNWTi8rWE04dHYxM3E0VG5ZRnNlVXl4dUFST2hMVVF6WC9uSTRvbUsvbGt3a1lrVllRUVNka2dDdEV6ajljdTNSa1N1aVRJT0dCN3B5K1A2VHAvaE5Pamc5R2VheHd5MndVNjRFV2JCaG85TzlwY1RYQXBZNEc5ZjRJY2lZVFhDUnV6SENDZHdUMU4xcnpSK253UWYwMGdaOG4zcUJ6d1BkMDM4TzBLanRHU3lMSkxWQUl4dnI3K0JOU1JIWkVWbFNVbUZqRTg3VlBLam1keHAyYVpKaHVEWVJMNENhUEFBQ21xVFBDOU9IcjE2OWNSWUQxa3dWUWVUY0VnY1dTdytBZlZEeHdOSDh5ZVltT3laMjNJTjI5ZVR2b0p0alR1MnhiYWtCZXF5TlBySkZ4MS8yZlFlcU5jLy9pWWxTYnBFMGlXU0hpVFo4K3padnhsc3h3NTFaZmhGWUF1a1NRTEpKQUwzbng2WTQ0UzJMaEdyNHRja0tvSUprYUppVFJZNGtyYXI0ZzhuSGxqZ2VMRFc4WGc0cHI5V2h4UDZrTHFBLzZLRHdXU0lUNEdPckVBa3RROXVhL3BwSWtoZHdTcFo5dUFFRmx2eFJRUlB0U1R5c3Y3TjZLakNDd292MWpRQ25kcUk0ejlrUW0xMUZnaDhSUW5aRmtTV0JQSjRwSnZwSjFsWVNBTjV0VE1JTk0vNUJDV05rSVhuWkp5aEM0YzNFVW8wK013ZlJTd2ZVaEJYem0rR1k1djVKVE5sSGs2S1BFMy9RVk0wUzBWUmxHMUhJdjZSTHhLOWdLS0NyS2hJaWdxanFCeUtpcUNvMlJSVlFGR0xLS0lHb05aUjlFS0sya1ZSV1JTMWphS3lLV29uUlpRQjFEU0tXazlSeVJTVlJGRnpLV290UlMyamlNcUEya0lSZFFHMWc2SXlLS3FZb2dwcG9qZWdpaWlxaEtJSW5yMFV0WitpeXF5b0tvbzZZRVZ0cEtpREZGRXFVSWRvNmhoRkhhR29QSXBvSEtnL0tlcUVGVkUxVUpzcGFnMUZYYVNvY3pSMW1hSXVVRVQ3UUMybnFDc1VkWU9pcmxwUmR5anFwaFcxbXlJYUNlb2hSZDJqcVVjVTlZQ2l0bExVS29wNlRsRlByS2dYRk5GZkVIVUZ0WUtpRmxQVVNvcGFTaEd0Qm5XY29oNVQxQm1hZWtWUjRSUTFuYUxtVXpUcDlVeWFta05SZjFCRS8wRVVJUFJpbGtxa0tFS2xuaFJsUTFHcEZCVk5VV2tVWmFLb1NUU1ZRbEZUYUNxV3BrbDFvUlM5V2s5dG9PZzhaeXFYb2k4NFUvRTAvWDRKZlUrVHQ1dFRyYWkyVkR0cUxDbDRueDVHejdGcWJOWFJLdDVxRjFGZ1BDZHFDNzNPalNnc2p1aGU2RDdyL2tNVUQ1MnNjNnlQVzE5Z0doSWx3bFFtaTFuTXJHSjFiQ0c3bHhPNXp0eEVMb3BiekgyMWFXalR6Q2JJWnJITkRwc0hOdTlzd05iRGRqcVJmKy9iWXNTalZpZ2NiVVFGcUF4ZFFNL1JUMTdoMi9OZCtBRkVXajFIcE5FT2RvUHREdHQ5cVdWWGExQ3R6RnJMYS8xVDZ6OENKN1FSWmdpbHdwKzFoZHJOYXZ2VW5sNjd0UGFCMnFkcWY2MUQxMmxYWjFxZHJEckw2OXl0MjdadTU3cW11blBzZGZaMTdZUHNRK3hqN0UzMjZmYkg3VS9hMzdGL1p2K1AvVGY3WC9iL28yK3Y5OUFQMTQvWEIrakQ5YXYweC9TZjZ0SDFiT3ZWcmVkWXo2dmUrSG83NjcwVFJiR0o2QzcyRXNQRUdIR3ltQ1llRmI4NDhBNE5IRndjM0IwR09pUTVUSFA0eDBHdHo5VFgxL2V1UDZyK3hnWnRHbmcwNk5MQXQwRjBnL2tOMWpuMmNJeDBuT0s0d0RISDhiRGplY2NIamw4TUhvYmRock9HbTRhWGhwOUcyZGpKT01KNDFualArTFloM2RDbFljZUcvZzNqRzVvYUZqYThUOFR0SkdteHRFZTZKYjJScldWZWRwQWJ5VTNrSVhLOFBFM2VMMStUdjhqL3l0OWxVSG9xZlJRZnhWY1pyWVFvNmNvOFpZTlNwZHhUM2pzNU9BMTFtdXkweTNtSTgxam5ZT2RsenV1ZHk1MlBPSjkxdnU3OHdQbWw4M3ZuNzg2L0dqR05oRWIxR3ltTm1qVnlhK1RWcUdlakFZMHVOdlpxbk41NGF1UE5qVTgwL3Q2a1daUGhUZVkwT2RSVWFPcmJkR2JUM1M2MVhFYTZiSERaNTNMSFJXMW1hTmFwMmZobUdjMDJOWHZjbkc3ZXZMbHY4N2ptYTVwZmE5R3RSWThXUVMyV3RsamZvclJGV1l1bkxjZTBYTjdLdHBWcnF3NnRPcmZxMnNyVWFrNnJQYTFPdG5yZFdtdzlzZldDTm81dHZOcEV0a2x2czZUTmpqWVZiUzYzK2F2Tmo3Wmkyelp0UjdZOTdsckx0YlpySDlkK3J2MWRmVjBIdTQ1MkRYU05kazEybmVZNjMzV0Y2MGJYSGE1N1hNdGRqN2llY2IzaWVzZjFpZXRyMTQrdVAxeC91VkZ1Vm02OTNHYTdYV2xuYkRlcVhYRzdwKzM1OWtQYnA3YWYwLzZPTysydWMrL2pQdGQ5bjBjdGowRWVpejN5UE81M0VEcDRkaGpYWVh5SFBFK2paeC9Qd1o3VFBEZDRmdXNvZERSMmJON1JyMk53eDdNZFgzZjg1TlhiSzlCcnM5ZDJyeUt2ZlY2cTl6RHZDZDZyTytrN3laMmFkV3JYYVdRbi8wN2pPbzN2OUtwemVPZUV6aSs2Y0Yzc3V0VHQwcWZMbEM2enUyenFVdDdscjY3MXU3cDBkZTNxM2JWWDE1RmRBN3ZHZGpWMXplcjZ1dXZYYnRiZHhHNHR1bzNwTnFYYjhtN0h1dmZ0SHRqOVF2Zm5QZmdlUGowRzlCallZM0NQV1QzbTlEamM0MnNQM05PK1orT2VyWHQ2OU96Y003bm55cDUvOW56Yzh6Kzl4RjdkN3k4Q1dwMEJOSDBEYUVnQlduZkRRUjFTN1Y4emhBVzY1cjFJa2xKcVpuQkN6VklCcnpQLzkxaC9TUG9Db2c0V3ZVQzRBMXRZTTVONXoySTliaW9HRmtjZHVDOEZSVVVTZ2E2eDZtU0N2V24yUmRDaUJGcm9ueFdwajhTaGt2NGFESFlZS2dtUVJUNkZIZjRCcDNmZ2xrYS9WcDFFcU0zR1l5Y0dOMjROd21QMDdRaUMrby9SdndRMC93ZnIyWHhOQ0duMmp2aUt3STFwekVaak53YlhOd2NhV1FLTldVaHZKVUo5TXhhU0pQelZ5dlNUUzZPdmdlSGtsNk5nMUVFTnRoV0I0c0J1eStWbmZ4ditHbkVIMisrVzNYS1lDV3RTZHhVWXlvdExMejdlTlR4cWhReTFpNmRkOFgrSXVSeEhzR3JxeERsTjllN3FiR2gxeFFlb1pQbnZOT1pJMXM3SjBZYkE4RGhmMStEVEYrYkt1RTc4YXMvTExxQ2tPenB4QW56T2VqUEVCSlAveVg0RHlqOVphZllWVDZWL24wcDZJd1ZOMURsOUpYM09jYlVJdnllZVBoUk94cTNGWVVpQXlPbGc0MjFTTVZqWlg0RUdyY0Vlbk1GZUg2ZnVkNEFlTFBhQUxoLy9aYUFUaDMzd1VDZGdjcmN5Ui9jZVBuYlQ4TDNqTGN5MGFqWUE4d01yL0lvaTViVXo1czFuOU9VOVIwMFk2MjVvZmJjMUtIZlBsWnc0THV0VDlPVjQyQzV4VEV4NStmN3R1VVU3bFkxcm9SYXV4MFJHeDZVRUdmVjcvTlRCNHFHUzdYdjI1OGVIVDU2UkZKTXNSMDFPejJHbWJFN095emNJZUw5bExHa3lsanJMT0FyWHBRT1hwUU53UjhSVDN1QzJZSXRaK2Q1MXhnbFlIM0NFL2dib2Z4VWEvQUJXN25hRHdiYVlhNHZiNENrR1VncDZYNVpnSHlrSFU5cENHMndMbk55dEQvTURzMWR4QTl6ZmdQdjdZRWNuRFZsZkJteUJmUU50Z1pRYkN4OU1xcGhHUTY4Zk9paDZnWndJSTJEYnN0Z1dnTUo3Tlg4eStQYm51eTVQenZYOEJHaHZ6QWRzRThZSVQwNGhtSFZaT3B5QjhHamMzQVJEVGRDWmlKTVB4ZkZGVVlmWHJuMkNSbzBQbWpqVFppQjNlL1dYODlETWNDbml5T0F4WVpGRXVKeVA4SmdOSnZCTm95OCtGZjNMUTQ0Y0xTOC9jaVNrZkt4L1NJaS9MTVN0TTFYSHB0RnFZbldJU01RMC9PTlhMQU4yckFEb0lTb0hHYmFBckFNZnVDZGVYWE42WjVsY3VMVWc1NkR4VUo0cGRxdXlLMnpOY0IrRHo4emhrOFBrMkxRRTAzampoTGljd2pRbHFXem02YXNHTER0NHJlOVUwVjhlZU9ENnhNL0d6OWNyTCs1WEtxNXNlUFRFOEdUYW84QXI4c1hndnBVdVJwZStFd2NHS1lIOXAzZnlJaU5qUlhabC9jeWJOeGlhTGNFOWgyb0o4OXgwbndHald5KzBhUXR1TmYwNG9mU2hWQXIxSVNBZlFjOWU2TUFCdEJrY0laMkVZbnlrMThjUi9BME5kWVdnaUhBV0s5QVFsQitBbk5TR3VCdUxkOVZZTVhCMnNvZ0hzekFZRmpQQ29RcVVCeUpNelpieStrbDNNOEVHNG9FQkZuaDZQelNIS2RtU1dsd3RpSnNtamRzdzFJaGpzQXR1anFmaHNWQ3JLVFNDeGtEOVF5bzJ1RDNGanQzOUlpT1RGUkEyL25VUnJJemxlN05tN0Zid0JYeEp2SEtzL1B5Rll5SDkrNDhKSGpUVTc4QmxNaHlraDdta0FuWGViYWxtSnViaEJic0l4eGNoOEFYdncvdHRoUE9WcUd5dEJLWGUwcjFNNEM5SkVBTzI5a1FNU0w2RGp1ZUlwcUp6bVNlTmtBUzJJTU4wQ01Yb0UzYkdUZTRpcUhYMVpGNTVyb0w1V1YxOE1USk9uRkNBeGdZTkdlSy8vOUxGb3dmT25qc2FORkFXOEdqQ0NENXBNRnh6N2ZYSHJ6eWVKT25kRnNMRFNaS0FSK0ZHYWRBdkRaeTJ3QkJMK3JPcmQ4U0F3cGlEYTlZdVhicFVYamdtSUNSb3BzMFE3c2JxZDJmQXlYQXU2dEN3Y1JIUkFiSyt3VUo0UVRETTJvcUswNlQzMEVqYm85TnErVHlKeEtnaGFXajdlbTBwc0tVTFFWOEkxcWZKOE1BcGlCTlhjT1ZiQ29wM3l1VjV6Sm45KzA0OU1IenU5QUc3NHVhZEdtTXFjM0hHc21reTJNOWo1cTlldUhhZDRWVEJuemV1N0FrTWlKOCtLVDVWSGgvSmpBaEtIVGZha0xsaytwTHBjb3BscWE2NEx3V2FsMnE0UGY3VnUxZVErTmZIMTNUWjU2ZGZWZllmbmZvY0ZQSHJrazlmb2JVQmh1RzI0SXhEY0N6dWh6dVFFVTJETHJnMVRIL3dzZUR3Q1huOFZTWjRwTy9VUVVZOEhGdURQWFNDL3NTdEJaM0JEYWdXMkxubHVON2pURm1ic2xjdVhyRjR1WElNRmpDdDJkbUJURmxtNE9ad283TmJHMXkvNmFVK0x5cXJ0cFh2VkdKVzcwazhhV3dMYVdMbkJTSERSaG5IcHBVZHYxSis1bXpGanJqeFJGYVQ2TFpJK0hjUmNEQVVXT2dMTnZhUG9DR01oNGJZQnNnWjU2TVg2SmMvNUhMZytQd0pjQzlIWHVpWHJlalZNMXNyenR3eWdGWFhSMWlXTVkrclJPajducnRTSE8zbkZ4NDFTR21CVDRnYU9rNy83VnBKMk1nUm9WSDlGUUhXWm9KUmpRVkgrakxTcVM2Wklvei9BZzJBemxWR1M5Z0Uzcmd4akNPNUVoWkJQZFVmNnBVaHVBdU5kWkFJOVVUVmZ5MWFqdXVKaTBsYldDRUVsUkVFMnh5Nm9sUGtnNWNIZXVnTjllbEgrUWdtT1pEZ2J0RGpQQkoxQWVyWGpNcVRZSGNtMkdNZDZFQUdPekNCYUY4R1R2cks2a2dIbGNFL3NCMmtjUDZ6eDdyaitrYk1OM29DNUxzQU5yZCtBSGVtMTZETkNqUTR5QUFkMVFSb1BNUkl1TE83ZHY2RXAwQkg3QVFqZjF3L2RLaFEwYWV2N3NRSU1JODA1U0E0a0JXZE5QeDhQcXAyZFNCbkZBcmVpOC9EWGl4dlF5VDFQRDdJQ1Rnb0ZqMENKOTBNSkJ6TmhQcnFYMm4wVm5DRVVTRHJ0aEtHeE1yZnJ1QUU4cHZ2VUU5V3AyTzVaam8zT0RKaytNaVFQYmNXeXBjNDdKaE1haHRGY0pBQzZob0g2TW5pRXJVSkZNRjVCZzlnY1NtK3pjQnRjNFgrM012M1JJWmVCQTNVMjJrYXlRb2RvQUcrcHBMVVBFa2RTVkNRbEsxa0psVFhhRzBkeHVHd210VTRXbDNOWU45Zi9pUnRKZ3RCWkNNQ0hJSHFYS1ptTGlmQUJuUE44SmpVWHQzTElVT0tsMmlUcEFOZmdNYm9FNkhCVnVBaEVPd0lFU1pyQTZJNmlDUkljOWYyaHcwYUVoemFUOG5HdkFoT2IvNEdFZXExZllPZEZMeVpOSFVySzhDSllOT2hkRE8yc2dWU0VMcDhNYnZncFB5aTFldjdubStaRStmM1BQbGs2Q3BCNDhWZDBQRE1DY21STXRaQkhkY3VvTU1DTXlNeGRtNmM4YmZ5UkJHQUorM1lCVHo0Z3gzOUNCUklCbWVkMnRzQjJySzROUnhnM3VTZXZ2UFJBTFhkLzlHWU41OTBWWUZkTjluZXdJdWtpRFYzdlR4czZQQ1EwTDZLY0UraS93UUpwcFBoVWsrcXBkMFJNR1RsdkVPNERlYmtJL1dUZWtja1RQWVUxNGVVbWp1Z3FIZTBNejM2OTRtZURqNW10SlZnUUN5Q2orQkwxbnQxeHpNRUczLzVNOUNJaFUzVi9neDJZUVYxY3l5cW5nNkpJbTZ2VHRkMlhMaGRUU1oyVURPMVZQRFhjamRod1ZOZEFwNDFTOHdseDJvbG5RbkJPcEtTaW5tN2lGM3hBdEsxQlF6dXhFSW00ZXBwR0Jqd1pLRXRMSUEyZUFFRG5WazhEWDR3QXJRZ3pWbERHa2VjbzZNazRRcWkxYmNPVTlCVjlLZ2N3U1hzSlg3RmR0VnJ3ZTR6enZoUENDZkVXNzdNOEdPV0NBS0x2MWZITXJnMksxeEZVT2V5QkZray84OFFuT0VDL0srMW1HL0NDVHRVR3hQOEpKL3l0ZkN2aU1mQlQ2WXBpOGZobjh3YUJMVWhBMnJqREViSXhqVFF0TG9CMHlMUU5hc3d6UWs0WWk4aXZUdzBFRVVqb2xhc0pHckZkR2RKK0Q0RGVLY2ZVQWc4SktiWjM0RDY4QWM0NmpOaGdzTlpUbjg0ZU5leCtLdEdjUG9iZE5BQ1hMeEFoNXYwOG91TlNsV2dETmZuOUptL29qZ1Z3U0t4blorL1QvK1JSMS85ZGVyd2xhc254cldUaFlwTUVDQWZhdE5GK3hCVXF2WEVXUkp1QlN5MmdxWlEvOTdUeDl1VUpVZ1JmbGlxTHdBZUpxVXRsMkF1MUNlYWtkTHFLQkhYeDBYc3JtbWh4WjVHckxURWpLWjMrMFJLTzEwK2tsKzJUZEZucGl4TmZpbHRSMXNYbE93eDFOaEFlL0hsaVNOWHJ4NGY1OTUrOUJpZnZtT092WlNGU1lndWd2cVhrQTY2d01sV0NMZjBsZWh5U2RmN3Q3YnNCSGV5YkgyK0xMekd3V0FMVnNEQ0VyQ1psV1pmQWdiSUpBMTVWREpKYkxQaHI0NWdOTUxnVzRTNlJrVWRpT3NOSjlxY1BWTW5GblUxWW1NYmJJVWRzUHpCQmVyZnFDb28zS3BFY3EwbkJIY2NGRlIyWXBZTURhQysyRy9jb1h0M2p4MjZmUEhZK083ZHg0L3pVWVQ3MnBrVTJCRjYwemYrSUcwTGd2M2lpYVY3OXA4eWFpZkJ5bm8wL0FXdU84RXZJenhXaGwzWThWY1VPSExDTkFteUYwdTZaVkpHdGJNWVdCcFJXVlZTV2xFVldScXdDZUVNcmYzcXZUVFlUSExjaUJjak0xTkQwNmN2WFRKTHhqcHUvc3E4MldYR2Y4NWMrVWRSQzdFamx3R2U0c1RTU0ZLK3BOSlMvcmdKd1hKU1VxMVVzMFRjaThYZDhFQkdkYmZVREE3Y3lkUGdnSWN4MEpIRkFiQ1hFWEFHVVE5RWtRSVE1RkFkcFdYakJMWE9SUWxxYlpmQWgzUzZINGo2UnlRUnlya1RSUWRPbjgwTkhTM2pTbWhBd3NlTEt2NDh0OHNTRnVFbVlURm80SEhTelhkTTZ0QXcrWGlTWDE1L285K2d5ZU1uS2ZwSFo3RytKb3NUN2hQRWR2YUVVUHJLeVpMKzNya0xFaWVrSW5vZTBnMGozRnNtUVQ3d1dhc2wrSU1NMlB1cHFPZW9tUEJVYzJueFY3Zk5rcXgvZjFENlFuSVYvSEFDZnJtV3pVSC9YdDJMUjRqVjNiQitCTkc1N1o0V1dON0JpQnUzTmZOWTgwOVlCMDZYRHU4bzNhN2cyUnorUXgxZ1lhd1QvdTd1Zm1OOGZQdzB4c0ljR1VNSzZpMWJMZWxMVlU2ZEpTNmVPWE54bGpIWVo0WnZ2S0svZHV1Q0JLbmM5ek43cnE1YnYzRCtSbG1ZbVBrRmJuNm05NE1BQnREcjhrRHFnYkRqSEVDd2lmeWFwZGtEQjNiMVlVYTFYc1IyL2RqQTVPZ3hjaEpHclA3ekt6eUZiWDEyeEx1eUhTdVhyNVBCaWxzd1o4cUNER040Mm9ZRENvUjhCTlNjRTZLUS9XVndoSUZrNXFhcmtnTlJ6RlpHayttOURKV2RsOVJDYlZTZFdHeUxuMkFCbnBoWHZZQ2FMRTB2SThEOTh4SjhKUm1jOERVM3VNYVFmTkJPU3pPeXdNQXI0UEFyTFIrMFZiTVkzSUIxdzllZDRUb2o3RG92clhPQWxteDI3dVgzbTNPLzRsWU53STNGL1dBWjlJQzV6MUJMN0RJMWQrRGZVM01kY1hzV2VwUFZVU2lWNkFGSVNGb0VOckRocUtRT2M1Z2k1U0tpUTVjcVlZZjQ1NEVrSHdVMzRuRDlRblJaZ2M3Y3hZaXFnWnZraTltbFZSY00wR1dGaEJzOWtuWWlHSVhiaXo4bllOMS9KbkFDS1kzS0VUeFI3Y1VSZ1R1dkt0Qm9CY0pkdUVFbEFSZW55b015SWdJR0duQm5ia0NSQlBWSjJpTjBENExBT2hDczdmVlpVQWJUeExUaXZiUDJHSytlTGJsYXF2UTZ3MFNueGs2Tk5rNU5YN1ptcWpKaEY2UHZzU1VxY25XTXNkL1FDSjhJNWZZd3BtaDc0ZVlpNDZic1AyWmxLK2JqaENBOC9KRDBBdXJwWUFLVUpLSURGMUU1NkM4UXpja3poNmZjaDAxbnJtNjVncTFMR2tUT2pBa1phUFFkV2ZYNHljbktTeGZ5d3NMWEtjQ1VUcmt5OG5MelRZNS91Ymh4MkNxMXN5c1dESmgvZUVONnZoOTlCN0V2MUFVZTdIb0FyLy9ud2c0VUhEQXdSZnNZdjl3aytjdllsVDJjdi8zb3laVUxWNjQwUUtzdmVDQ3IvemFqWU9idUlzT2Y1Ym1WSnd1amhpNld3VzR6ODJUaG1PKzRuUkhYOXo0blBkcURpTG9kSXNyUi9VNElxQVBtYVVBTUNjQW92c1g5cjBQL041ampvQzJzWVhCVEZqZkVDN0FNQzU0aGNNVnJHS2UyMExNdjd0a0dldDVBTzlHajZxTjNKYXlydVhKWEVrN2ljR0NxeHdCamZ4MEVyREcyRjlUVzMxTm53REx4Ny82VlBjcGtsMk5Nd3ZyTUhUc041UVY1QjQ4VnhRMlV3VDZIQWZxUHJ2ZXhhTVJXVFhwZ1c3OWRZNDVHS0tHcEVjRkRESzVYSnQ0T2w3OVVTaFB2U0xpdWljSFd5Ky8xQUFjajBGL3ZnTzNKeVVmSGxzNlZtaDZUdG13aFU4cEZQUW5PZE80aXBNdDFsUVM0a1BIZzc3OGg4dTNiQi9ZUSsxbS9IT280U2ZvbzFlWmY4ZWoyMkxqVnl1c0M1a0xHOEF0TmpaajI5TUkybUh2aEJWYWZUbDg4bjYyMHoyY1NaaytPR21NY0UxaDI1V3BGNlZGRjZDaHRYb21JV3RjZlBiMkhWQzlnZFdyQk9qUWZhZFdvSHZkZlBhQWg5NTkvMzJrYnFVYm9tVU1qQ2Q1aGYvRWIyeG5hTWxWYkN3NGNOOXdjZXJxYmpOdlhOUGtIbER3MjRiNzRyWW9yMlpZV0U1dWFSaFE0Uzhuc2gxZmFXUXU5OWFta0F6djFqNzVFeTFvbHdaekwwdmt3Q1Z2RDI2bVNlcjZKMUJxZXo1RFVVUzVJd0pGN0VXenprNFR1RW5ob2VwdjlYMmhZOU8rNzd6cjRWLzFYZlBkci8vZnEvZSsvMU5SbnNZaXBudGlBbVRjZW9GT3lhMmIveXdwREpCeUd3MHlFdFd4cDRERWxMbDIxdGg4cU84ZDRzZU83TXdJT2hQK0prdUNmY2RJUXBIVzk1dk00QkNkek5MMWpHOVB6TkdpbnFVdnRRZnFxNmo3cDJ5NUErdXRRaVNQYklQMmNHaGxubTQrRGJpMTZOcEJzMFIvM3NpaFhMYm43ZjliTEpIZWZPN2lZWk5KdlU2ZERTaE5KRmN5WWF6OVpsd1lKVHhhUnJLdS93cjFQK3BaSDFBWXVCTGRLNGRkbTNQVXR1S2ZqVk9EVjZqUjZ3elVKUXFDMGkrUWhIVlpqSnlEQlE0SWo2ais3U1RoZmplMGtFV25yNmw4OVRZZitXcHJXanFpdUlGdjlhRmJqMnhNMXZsMS9SSkxQUXhON3FBZE5vQmMwMVRlRWVwRVMzSEFZai9UUHdPYlhSYkcxbGdWcVBhTFZOdFdMUkdKUFBDa3hkV3Qrd2JhdHUzTzNwOFhKL2pnd1JvSVR1RndrcXg5ZVZlM0diTisrc2JERWNHL2d5ZDY5QjQ3cUZyWXBkbGV5akZmOWFqMVNFdFNqaThDaEZHeldaaUZhUFptUGZzNXdBQWQ4QnJ3Z0QycmpQUEFFOG1HdHllRnFZclE5YUZmMkIzUm1JQmQzWmpGWlVrU1lBSmNZZklralVoMFp0dXB6djZVNmRpS0NycHRmZ04zT1Q0NUVxb3NDRjZ6QWdBd2wxcDhSd2hIc21panAzNmpPLzBGaVZ4U08xQmtCU1A4R2ZINHRNZ2RoV2pjU1ZOdVpneUZvUDZIRUxkUUNtanlDSm5vSHFFVW9rZW93UVRJWHVFaHlqRVNiSmtyQ1NNSnpBWWlBRmQwUVdmYkdTaGZCeVg0R09FMEFwMEFpNW5uTXVJbEM4K0wzbFJYbTd5dUxMUWdMVFlnTGsyRzRRMmgrZk5tK0FoSVhWeEFhRmsvaTlPY3FDRllpQlRubFNUQ1hpS0F3OUF0NFFUMzZYNUF0Y21pMXcyS0VLOTJidnNSWFdSSlhUeE53cFM5WUFxKzFpSWhGWTZXckM5RXRwQWxHK2dicXNZRVMxUC8xVmN5UVFpVDRTSHA5TDcxbWQyTVVJcW52U1ovdmtVT2c1bG9JWG5Vam9SZ3RFQy90K2MwWld4QkJjSFdnVk9OWXMweUx6eVdFdUl5bVFsTVlCazJtUW1OOWEvQytpY1lqZU80d1h0TGZ3TmRxb2hxalA2K2ExTmxrMnoweWxEQkFoT2xBdWxTUjlsdVVjaTcxT0ROSTd1UDJsKy9WbDB6Q2lmTVpsNHl4MHZlSWw4TXVLTmRmdTEvdTI0N0o5eHUwYWFCeGpLUVE4V29NMmxNMFoxcStqQXN3WnBKS01nK2ROYWhESFg3YnA4WEVyTndRTDBNQllHWm41TVp4d3d4Q3VBU250TzdCc1A4WTJrcmhrcnBUNjEvRXIwMWFBQXBKOTBpU0Zzb3lzellSalVaQWszZlFaRGpJcEIrdXBCOWtUVEgzWTl5dmgyMGxhREZXczRtQU5TVDVta1ZFMFR1cFM2SHZidWtERWVvVVFCQUVQSWhwWnJsdWtpWmh3aHFSeEdrU1pxaEZ3bHlQa1FqR0wyL0JIdXliL29NYktsZ0EwU3dRSytRQU8vT3pyMG45RjJ3MVlhTHdSeTl3WEFvTk9rTWR2VWx0Q3UvRTdEV3JzdGZLVzljeFZmbjc5OTgzZkhKL2dtVnNqNW51MkZPdW1VcWs5Y25jMzBmMy9ua3BMekl5Zm1wcWJKcWNOcDJKUzR1TUhHcm9laWJxcUVuT244SG9xNHFtYlppYVpFaE5UNDRPeUNqZEpUdVptT0VIUGFFVzJCOTdlZlhHeEZQOWMrWDQ5WXorUVBLYUdTc1dickVSMmt0WmFzUkExRjZDWUxXbVdJcEdsMDNRckxFMFVZM3NJQW5SNlBEN2JxYUs5MHMwWTh0dFdVUXNDczV5Sm9zRlJUTERBSkw1S0RqYmw0T2oxeUxVQ2h6MCtTUkRORWwzd00zVWZacU42cDhtU0dvc2dhUmU2b3NFbGM3ODFBd1lZRjUvL0U0SzFRY2YwRU1xMU5kUHJ3NkVQdUxFektpWVFTOVI1ZFg1Q254bkZ5OVpzbldMQWRxM2Y0OWJEaG1SRWhJb2w4WDY3ZXhreEdJWHJ5NXpGTEJKWnZZdks5NTd4bmg2ZDN4VXh1ek1CR0pRYWgrTXVsM3FEYmEzTHUrNGVFZ2VVWFV0N3E0UitNZkVGRUxSSDYxNVBGSU1TTTdidlhmM2x1TGxwSHcyazhKMUdERnBqQXl6SVo3WUZaVWV1MjY4YjdZckVpckltcUpXLzViTzFrNUUvMjQ2ZjJmclRjY2xpRWhwMHR2R1lEOVZpUjNMQ0hPUS9yVW1PN1VtUmxCNHA5cDJJQ0l4RGRTSmZwTCtOVzZMbDdSQ2s5RGx4NUltWkpGNGlPaEk4cC9IUzBtMG1Xd2tmdmdpMUpmMDMrR0hxNlIvaTF2Z0I2M1FPa2wvYmhrNWtkeE9oRkV0NEFhMy9ValVscHBENGpSRUJKM1BaSFJXaytqTEJOczVtRmR6MkJMOUVpUjdFMGdUd1RFQUpMMkhxZHBHRE0rUDM3dTNJSDl2V1Z3K01XZVBENVBCeDBHTEs4c25jZkg1WWVZNC9ibXFYellhaWp1WllBZkx2MEdwcGhKb0FFdjJJWFYxdFpVWS9RaXo0NGRVOXMzcm4rMFkwcXdrYTI5bWFacWpSMFJoWjVCT0Y4YmxobTJjNExnalpkeUdpVWFNY08zT3VBMTJBcXZHNEFMZFg0QVIya0g5Z0IvOTd5aTRhYzBVY2VEUXlrZVB6bFpldkhRMnlNdDdhS0N2WWhGZWpqNUFSSHdodkVYa2x4TlptZ0NqY2RmMjZrRURwUG1TL3RJdzB0VUpGUVBSZkFMVlNEOFNFMVl6dkNrU1VzMXN1cDdFUWhLaHhDWG9WVFBDSFAyYlgwbktLVksyQWZTRzRab05XeE52TWdURWdxM0pFaW5WVFAxYjB0aEZ5QjhjeVRKZ1E2aC9JN3BtQ3luLzZLUUpna0VIeERBRG9zRmFuSXhVSyt0MEpOeFBNaFZBTGRnRHRRclNOT2tLS3RWbFlyRFVkOGVRZlFHSy81RExma2ZPTSttbEZUTU9HbVBRMVpTejRaWEtzVXNEVDR6MlpiYUZUMXczem9qcjRnM2ltN01ITDIzZS9NZWNiQmwzeEFITXpLM3p0dWNab0M1MkVxZG1MRjJScVlBSGpHZFdwUzlQbVd4b08zU0NyeXpNSnVhalJHRHgwdGpMcUxIRGJPSlRSL3VSNkFlRUhid2tJdHBvN0hCTjQ2NUpoQW9Sa0Y5ejJCTC9ISncxcWFmVEl1UkIrdWdBaVBReCtoSVphaUwrNUVjVC96SlVLbjNLa2ZUSEJ5QkN3eTgvOWNYU2Iza1JKaTgyQzR5NnFhanY2UGlvWk8wMHcvRS9McHVsZzFLcHBPSDlzUWlaaTNtdHJMNFFocVpKOUkxOWFKa2szTFdjOU5GZnRaUEJFK2F6UGhqQlFZZGJET2c0M0tFWEEzbFl4bjl6cnNFTTFuRi83MmZ3T2s3QVBwcTRuRWEvMjRkZ2lnUGM0RjdzMDdKN2hESndDRHRpNER6RHROelB5aGk4bGhPcXFVd3dZQjU0NkoyRk1BTHQ1Mmh2dHUrUzliSGdDOUJHK3NsakVQMFFwOStYSXZYbTlMdFArZlVvYUV1K0xrSG96WjM4VXljVWZYSWZJcEgzem9SYTMxNC9oVnFZQXNwK213UU55Qng5b2g2R2s4T2xtaFE4VnZRZGV1aHZSZjl4RUpLOTBMMHIrVWNQS3FNUFhrdThSUXltRmF6Ync3Z2puNEVKWXdQa0l3SDk4N3NaeVVsZDhScnA5MW1kM2dscUJXamZwTXY0WTNka2tXMEpzelpQcy84dDRPcmRUZ1lTUnNhT05XZDdJUExKc2V5NkZHZzZDZVIwYUtMM0FNWDhnWjJwZlpqT1liNW1tL21rN01nYWlhQ1dDT3JqOElyc1lhWWdpOFFJM0NNemRyM2IxVUF0YmR1dlllSVVhZVV1Qkh3UHFhbDYvVG1pd2FFakVvaFh5MGZ2Q3BTMEhYWUR0ZXJ2TTVxT1NhMFN2eCsvZFgrSjBwNmR0Q0F0MXQvb24xYVl1NENFdWk0NTBldWJVY0JYMUNzbXNzV2xOMVZ6eE1vM3VxS2lwS2lpTXJLSVdQbEdUNVFGbktLZUlxczh3YlM2dWlGWjVYRXhUbjRLcm1uMDluYzZjTUhKNHZaTlM1ZXZWeDV3QzJiUFhEalRHRy9hbUgrZ2ZNL2V6VXJ2VGN6RXRPRVJQUXkreDRKdkVEeWNldndCMGdlcFRQVWdiY1l1OXlZQk1tT1hMNUd3MVY0RXdkWERSU3l5WTNCTDVpa0wyZEJTeFBYWkFTVDBqQlhpVVdmVW5ZemhiR0E5VGFvQXJEM3c0RWorR3VncjFiZkx4WCs1aFRQbmtYT0JwT1MxSlFxazNnZTI1aFJtbjNENjlKbUlaSGZFZjNENnlvNVZ3OTZWNzF5N1pKa3NBT25HR0UwOURnYVlUU1R5T3pEN0xDSXU4ZitjVC93UzNxWDZRQ05RdE1YU1ZRZmoxZVdpRHltelF4MnpRZElWVmRjWCswc2toT3Rvb1d0aTBHNWk5cmhxT0JLNi95NWxUMHJ0QjFmOXM5OGw5ZGZBMzRFZzZLYU9NWnZNMlJPVHVYSXQzWUtLSkk5MUlCaTc0ZG9icERKU1lkRjFNVUdDMFE0Smt0QVdCcG5nK0wvUWlBeEFxM0lFRzZHakNNZWg5cis0TmpUQ090d0kxMjRNdGZGeFRoaWRZNEltWHlIMkt6UWhlYnVYbzBPd1NHeEMwcHFBRGdqOFNrckVXa0FUVXJBSnJxMGx4bkxDTHRDWlZNODAralFjRXpIN3R2VWw2YzAvbDZTMmJ6R0gyVFp0TUNjTHF2dGFFM1JJbzZ0ZlhCY3JJMHNtQmtaR1Rnd3NxWkEwYndUeGxsWklVU1VUSjVwakl5c3JpMHNxU0prN005OE1Kb3p6enlZaTZMMmRhVmFxZi8wRWhuL0E4RmwvNkptbVdSZjM1ZVVSNittRTBPREV4RVdTNjUwK3hIcjYydHZYRnV0cE4xbmRnOTlwQnRaNzkrWVJBK3VFaFBCd3piQlJuL1lNMzhGdGlHQlU3UXB0eFBMODNhVmF1a3h3YW5raTRra2UvTmpCN1c3dnZ3N3YyN0luVjQ3ZFZaWjIyUGpYZldLWDNmVm11L0docHRqSnlwNUpvVnZIRzl0MTYrMnFDSGk4V2RnZEpGbDhUVDdQUnZCMCtndnA2QXZKSGpxKzBSVGE2STNlUXcydEhpdDZJakpoUS9GdXpYTlM5UVFkOFFoWEx5S3djU0NDV3RlWkw2UkRXcW5PYi9SZXNQNi8rWGRhazB5OTRVV2lwRzVyaVh6aFA4bVM2dFlHQ1M3d2NycWtEaGViSXc5NGxvQ3FoelpCTGVFL0s2VnEvODVTQjNnK0dxbG5taUYzZUo2RTRFdFRxWGVuUkFtc1dpSTgzaXRLYWp4T3d0YU5wMHBnUjJSa3JKc2hMU01pc3E5WHNoU2o0Y1ZXMHlVSGdoVmJKeUJZUmJCMlhDbkJKb0lVVzQ5R1lFdVFZbDBTYXQxVWdwNFpJUHoxOXVMYmQyQkhnNUhvZ2o5QUMzRlNiRUNHbjdIZjRMeHpVUW8wWVErOFpYQWN1MkR6b3BVckRHc1hyVnF5UVlaNWJBV0pYTTllTHJtVWY5VjRhUDlNVTRGeTlCdVROOUV2dTVjUnk3aGVaOXh3dk5LMnpTMTJZY2FpMmJNTnN4Yk5XenhGN3RYbURZdU5oNkJ1TjNBMlByeWFWMXFsQ04zbWdZMDZFQmo2QXdobm9KWXVEM2FJMkpiYnNXejdpbTByYmVaeHJjNzBBTnZyQlR1WEw1TkJ4ODJaT1huS0tHTjgrTmJUU2lrSDFqZXYvdmhvK0R6c3RKdjd3RUdOWlR5Umk1OCtlYzcwK1Rhd0ZHYUp3eWRQakltV3dZSGJ1M0hOeHMxcnB5Y1NsbVJWMmdSRlQybDRVYzJJVC9HSmp2L2lvcmRReEttUGNaR28wdGllNjRCajJrTU1nK3ZWMEs4aGtmMExKekpYMlZlUXhPQWtUdWlNWnZkQk1JQ1FhU3hSYkxmRXRtQWs5cGxHYkt1MkJGdHNVTjNCd0Fxd2grUVpDQkkweTVhcTAwc1JOQVRiWDc2bnBHcmY4d2czSTNtYXNVUTQvcDJua2VWWHordm5Ra3ZPLzB3NEpmMmNRSEkySWprYnNUWGVEdENJMU5HSWxLa2daZnBsU3o5blp5TThqd1ZTSFFNVUtlRjNBdjMwWTMvMVYvUEVlMXNsSE0zQzg4TWl0dDZONEdRZlZMMzB0dlFyQ050K0pTa3pzVzMxQk5MUVdaYkMzMWxjWFdObHpxbVdrNXdwQkhjV3dWMmYxRnlmNEIyeFUvbzVnc1VmTkx5a0NWRXN0aVY0R2RXS2dWUldxTDVFaWlTREJFcTIxSkN4SnEwM2dtMUQzR3FuMU5ENkRtbS9RckFvUktQajhMdXNqVloyTi9wNWl4U2JUSW9aelQvUzg0YXNYVFl5RTgrUklQalpHTnQrSSswanhzRjROclp0eUR4aC8yTlBXdkNBWUlsazRmT2ZDSGIraVg2bEVteFdXa3NtRWNKay95Wk1WRGJhSlpHR2R5SUU2Y1RXOUliYkltNkZneGd2MWYwaEN4MGN3SlB0aERsbVBoNGwzc01VZzl1eUF1U1M1aVFSRXZVaEpHS2hMWTQwbDNBbWxPb0R0cnNrdHFhTEEzUXdGMXRBaXQzVmlyVWh4VnFUS2p1Q0JBT2d2azVWb1ZKVDJQVEdBMGduNm9GdGpmMXhTYjFBY2swbEJyS1lBa3IxK2U0TXRjaWk3NmpXQW9OK1QzVS9XQ0JpQStzM2E0SVh0ak02dGJrRHp0RHkwN1dQWUhPbzU5QTFDampDSE93NG5OVm5sMGVNTFBRd0V0U3RzQUdINEJCb2dSM0I1K1dmaFFkS0ZYM2NVREJ3QXN3a2Jla0tFaXduS2tQNzJ4SitoVzJoTmlGWGJRS2ZzakFNR2tBdENJUUFMSUtBaHl4UnV0ZmtpYXI3QmU3YjA3NVl4cEpYdjhZTEZVSGRiKzRSa1c3QXFGUDViTlFaSHJIUXIyWWc4NWtGSDNVd2c1OTRFWHd2d1JiYmtsN2FFbmlKdzExcnlPR28ycGZCcDQ5TDhKZ014ZkUzSnVoOEFjSEtteUowcnA0QjNLOFpUeVNjeWdocDJONzAweWVOaG1CZ2RiQ3h1bHpFR1hnckE3MStkUUcydWd2MElJWHZQakZCWCtDQVpQdFpERWRFZkJDeUdPenpLeEZ6MVltNEx5Y2s0dnFtbi8wSWtxNEVpUnBFMktadnRUZG1mM25qZml6TXdOc1lNc05YSDBRWHljS0xYM0JnRDNwMWJjMmFSNDlxMXFwcm9DN1lNd0lzSStud2dtU0FPdGkrWmcxSjdhU3VJYWw2ckdmZ0JhSG10MjBIVWZXcXhTSUpZRDFaQnRhb2F6dVJMRFZyY1IxY1YxUEVrM1RWZXJHSTYwSmRkUzFKSk5oSklqbFZZN0JXSG02WXdCdHNJT1NvVkIwRFNBZHpqNGpnclZJY05INzNEOVNCT2kzZjRrWUtEc0FjakdIdkhpV0hDcU9DK3lxNEJycXllQk0ya1JxT0V1M0trQXRJL2E1UjZnVGtpdEFGenRVTUFWWTlVZFBwaVdUTzg0Y2xUekZ3T21oSmJQL2dJZTdDd1NaSXhadkF4T0F1TlVOcVRwREdiRDZqN1dvSXJlNjhRRFZEOENOdExFQ3JCYnFvUTFRdHg0Y3o2QlpCb3E1VGZVVGNCVDlVaDJDdTVnUnh6ZWkwcXFwV21OVHZaSSswaW1RN3A3NFcxZEg0Ry9abVNWVnJJQm5Xa01yVXlKcnpaRUZvRVVMR0hqaklKNzl1WkFqZmc2ZjR1em0vRnBBaFhJQTdjelZiVkptUW8zbys0WXo1MEkzNzNXV09hRzVoTmpCQXBnbGRBa2JZRGs0NldLNitGejgrSVRZN0s1VmRLUUg1cmtac2grdDQ0ZWJZRStwNFEzM3dmd1B0SUJRdTR0SG5zWDVrajZ4d0g2WEttY2s3ZjJKNW52RTBYaW1lcmpKRjVTdGRGMGFTZlpKeDhLRDl0NjVWbm55cmtNMGs5Q2ZrZXdENk1nU0xOV0htQzdGUHFNblpoa2pjNHBvSG5IRGh0NDBJWGVLZ3JvVjYrQVVMRzhDRWwwTWFBL2VoSGhudXVpeXN4bFB4YWp5RkVhN0FYRTNkbkZPTUJxODFWUlBUU0hWWXRZdlp6dXp1THplem5ka1FDVVlTTVdnMTZPanErT3JWSXVod0lvZlRmdzNDZHZDRHdRNHNqS2dwWWdDeHNMWjZOU0hIL1c5Z0RVMkJwZmNEcjY0QVhxZTJod0J4NEorblk2OGFRZmZvd2Zmdm5SNWkzY0JoRVlOSEtCZEhEUzRlWU1TNlRwMmRuUjkxQWQyVmszc3VuRlp3UCtnZzdpdU1DUzVXUW1PaTRzT01BUWtGNWVWNWhWVUtZTnhVRElzdUtJOVc5cGNVRk93elZ1WEZrczFWWElBaVlEZE1QZy9WSFFIUlFPOURRRThWZzVPVG8rVUFiSHVDQmZiYVRXQVV0WXpidjMxN3NWd0phQ3lMdWI2OU1hTUlMemNpTlVzTkZXT1M0ak5qamVucEs5Wk1VY2J2WWdxa0NPWG1NQ1ovZThIbVF1UG16Zk5tYmxFT25rT2xNNHVOVjg2VVhDeFIrdUxHWW14S25GWWs3WGNSZmREV2lDanRRc2V3U0Y5ejRZSWRoWnYyR0xNM3p5T3FwNE9UR1gyT3FiUjRWcW54OHVtU2k2V0s4UDZrcEpaREl4RW9ITWFkZWMxQWl4OWRUa3U0ekFuaTJHRnVERzZIcWVjbHFHd1ZPaFdxdVdjaTBCQkpVMkxBbFBzLzdyOStRS3ZUM3VrMFZRbTgzaVQrT0VFMEZDYWlvVEJGS3RsZHhmdG56dHk4TmV4TVZ3VjcxelI1Q3hKWm4xeGkwV2VINnRIVi9yOUdhNkZGb0ZPbmdqWDlHVmcxRVd4MTFZY2N0S1FkRWdtL0ZkWEVtcWsxaWF3QXo4aklSeE9tOEs2T0ZtdThmMFV6MVErMDJFVmdyVmFUNkk1YWRFZExOQjRQMW1MTllCWW1xL1VZQVhTeGhGTVhTQ0JDTW1IQ1pGd1BKekY0RHlTSkVJcC9NTkNVaFZENGdVTUJOTVdWQUdjekNNcjF3SkFKeEtrclNJTktGa2c0R0RwaGJ3amVJa0V3Z1oxd01QbnI5QlRKd0pHTkJiQmdRMXduZ3NBR044S045a2pRU0NhSWxwdXFwNlRSbHVMZVduRWdhRUNEcFBCdkpONEVpUURuTFZuTFFBZWs3VEFSR0YxMTlvTC9WaFpFL3J5ZUlod0VYcVJjRVBuekJnSmx6RGhFejQ2ZG5pRGpBZENPZ2RFY2NKTmZOTWIyaHBvMURsRDMyVmRnZDhsNEZJZjdZMWRteHU0NWhYc01jQkd2RXFFM0J3SzJpbzROU1prdzB4RlB1eUpDTGFBWTNKdWJzRFprZTh3ZUcwSHRUOW96bGF3OTdhc2RSZTlITmJ0cnJ1TVltT2JWRmFyd1BVTFJKWnNPU2RWTjVva1BIeEU2RmtJdTVIZCtpSE54SHM2RHZFNmRJUjlyZjRVUE8wRStGRExDY3FRK0pEeFM2NnN6VW4zeGdISFNjZ1M4ZGt2c0pZa2Q5ZGtad2JWalRVamtlKzBHR0ZpUnlFQ1NGU0s3dUNCU0ZvWThnQnNrcnMwbkVqZThVUnN0N3AxMmJRd1lFanRPaXczM0pIdi81ZWp6STVqODZPTURHdVo4QjBxcmJENzBiVUxpMVhwUGdYdEFPeUUxRy9wMkpoVjllUUNwRHo0UUZkK1dqNjgvTmdlZC9pZEpZL2Exa3ZRMTdUVThqd21lRHdUUE91MjZFY0dmaFhzMWxXQzJaUUhYMW1ZZEpHV0trS3F0MnQ3d1RSME5YTTM1bWtqY2hiRHo1d3hnMWRVazIzRGcxS1ZnbzRObC80b1FBMHNaM0lFRjUwdUVOUTZVWjZXWHlNZS9NTGxqaG0waXRvTkI1aHVLUVFzVjNJYjlLWmp0bjJKaEdZN0J5eGh3WjdFelpqQ0huUU5EMTIySmtNYzBaU1lkTzVOeDNyaEZVZ1IxZEFZdzZwcWpVb1hHcWFRdWRTbmhHVTlTaEhDZ3M2V3lmYVd6cGhiSlZkK1piZU5Icng5Qkt0UFk5amM3QnhFazBNcGNHeU40U2xEWFYxcVJabDh1QWJFcUkvWU4zVlZCckJHZ2dacUZIMGRJSEF5QVBMUFJSMlZwU2FXc2YxUVZVVHB4RStvbXVhRjJFamtDNkEyNVJEQUxKNEtWSDV5S2twWktBcmFHSXFKK1hLS3BIM2NSOVdNRFRiYUNrOGtTZkNPamlIV3dtNGh0b2xsczIwbkVOcjBtdHAwa1lwdWtpVzI3aU5pMlVCUGJkaVloS0NkaTIreEVDUVpxWWx0T2xPVFFVOE8rYUtvRUtRVDU3Qm5TRHcxMVRySjBReFBiNWt5WHZtcFlaeWNnd0FScHprcEp0U1k0WjQ5R01KbWduSjJFVmpXVmFnS0lmbmIrTWZUa0UzVDRvb01CcjZSOTNLVHNFdE5CNC91cjk3NzlPL1MreTdod1UwcW1BbU9hMVN6allBUDBFb2VHeHdVR2h4ZWVPYnMzZjM5bGFmeFFZcEVCbFcrZy8xdjZOTUV3VHowdkhzaVpuTGhLK1R1UE9admhkNmFWMGFWVGQwdzVQZTcrNzkrbnpwemRwTFRielV5ZW5aSVlaQXdJTHp4OXVyU3dVaEVXSGtPbnYwS0hqenJvb0U0U3o1UVdWQndvalJzMkxDSTJLRENpOEl3TTYrRzUyQXlQWURmT21yUmptTEZGM3k1Tm5HOTEvMUJac25YWEJpVnJjZnJpMmZJSGRzR09oVG5aQm1FMFZENkhDWS9vRTUvQWhlQnpVOWVMdTVmc0tLb3lIdHNTRzc5WVdkVk9USnlabWhacURJektMNSt2d0I5RWRiQjQ0d1lEV1B0ZWNXcm4xUWZyTUhyVy81OFhKNCtjM1N3THVPTStDVFk4di8rU0J2cXJEc3JWcytMejdudTQ0bDFydG01Y3M0QTh2L0NNV3piVHREVGQ2RDNPcjRzU003TERLYnpoSzJ6Z2hEQndmM1h0RlhpOG9rbS8ybnpTbllaaWNkQ2FpME0vR01IaHhQTVBDcHh1RWM1dG5SbTNjNVN4ZGYrdXJxMnU5WDV6dUNCbjZ3WmxDamN3Sm5GVWNPTE80dG55WHgvRWliSDVoNDhVRit3dkw0bnpIeGNiUDFFUjBrbUx5QmxJcTdTcmtycFVMRnF5YldlSmNkK1d5WkVLRHZnQ0NkemRrUFB0NHNKbkpwdGtHTnkwWnRrWFRzQ1Q5MG1xQXJYb3Y4bm9qSDRsd2NlbStDTTNVeDB2eHVSTzJsTzBPM2RQVVdKdWRNeWtTZEdrdno3Zy9wYzZDZ1FhWkpKYmhqSXhKV3ZhNUt6cFM4aUxGNTdjZ3VVNWN3cU0xeW9PWGxOVTI2YmNUQ0FuL2hZY1JYc1NkeE1jaVRHeUVIUkNVbnRVTnhTeDQwMEoyekZRcERYakpWZGMrcHpzZUtFT2l4VUlZQVE4KzRRRWcxOUo2aktTekFrd1J1dldXKzBlb2UxbnNDVURSOUlnZ051VGs3ZDMzK2JKVVVRYy8yd0psdTNMTmdjL1FpcjNabENaYjBCVVpzaGt1U1E5Y3VzNFk4VEU5TmlweXI0V3BIKy82VVNJdEVBczNaYTdWeU9SL0p0RW9lYzdSQVpsUktmTCs1cmpqNFJDUTlEOGs0alU3UEdaVkF0ZFJmRGtUSnVLTXFwK1Q0RjdMbU1qVXBNemxOSVdOY2tjYklTem9wa3h5UXc0dmRmTXFNTmxZZTVKTXdOLzBxbWRDQUkxdVVVVXQybDJ3dTRoeG1ZK1haczB1dG50WThXZWpkczNLYmdqaHp2QVdjTGgrUlVIOXNZUEd4WWVHeFJFRUJIS0I1RDJMdjVDUHlCa1AzeGJXako3enVKWnh1REl0TGdNNWFEV1NtakQzYS9JUHJSeTFhSUZxMlRCQ1NydlF0d2RHaGE4MTUxUm00aGhTNHY3L1RDK3FUeDkra2pVZ1Q0YmxBbHJtS25MWnF6ZWFOaThaWDFPOFlaVTAxTDUyU2FtN0kvb0M4Mk0zVWVPR1RRK1ArVG1WS1Y4RnJOcjN1cXNhWWFwMDZjbGhFL1pzV09obVFNT3Y0WWVyNzZtMFo4Sk9TWld6eGJkSnJCeFU1SWk1U250ejVPbDJlZEE4STJDclN2SnVlZFRidUdjcklWWnh1VE1WWGtLR0srKzh1R0VRRGo0QmphUXd6L0xmZEI5cjZUMzdJS2NoVnUyR2FDMEtSN0hSYVJNRGc5TDMxMGlnMzlUbk1qMVBEVGthVW5aK29JdDh2UWxHWXZueUlMblhrbHRUSmpIaWUyR0ozbkRKQWJyV0dpRVB6SmZXQUdFdldSSVNXSWZIREVNSWhnbkZtaVM4cFc5QytuM2Nib21XbEx3a1hGaGgrR0l2aVJkOE40cjVSTXVZdGpzbllWSHNuZGVhZFlBZURiaStMZ2JFY2VCaDY0Tk1Nc09iSjJ4SS9aZzVnNUhYSXNGQWZka2hGNHczS1NtcE5IZ0QxMUVpRlZUR0V5eFhmQklkeGpKa0FMZ2drOTB3VDZNMEF4T3ZpUjZLeG8rdjVKZVltOE9QS0VYOHhTWGVFQnJEcnZocmt3N1RoQzBLMDd2b2VFSDdUeGNYWGRiY21hamNUdkdtUzBDNHByOWpWczhZUk53UTZaeHl5ZFY2SHNWQXZxOU81c0hEUm1nUDdpemVGb0w4YnVXVG5JTGJxYnFYK1JLQ2ppZStIeGtINEp2MkZyOHdRSGFjdW5wYThPcmtiZHhuVnk1blhhWHliUXIzMUJlVkhMaDBhNFIwU3RrRUlxbVhmWi9nSmtjUjZCZG5Ebm5xWjI2TlRhMHZ1enpJMFYrbmNZY0psZVpZZ3lCRWZHK2JpRi9ucDhyNDlvSnF6dGViZ1pTdXFNeko4eDVCT3hqc05KY1d0Mm1Gb2sxSnZ5WWFjbXBKbmpFMUhnOGlKUGdkVTM5T0VrNGhXRGFaYWtpQStIaDI2SGpkbkRlVG9Qdlg2TGYzckNUNjljOVFVUDh4dnZQc09uRFBWa0Q3RFh3TnR3S09kVjNlR0RJYUtLMTJnSHR0OUV3OUswNHNpcmcxSjlWVmFkT0JWU05HQmtRTUZJV0hxSjhVRFRiWmVnSzk4U1BLNEVIQnBpVm1HL2VmQTdtTVlPWk9jQi9sTEhpNExYRy9ZQXZ1VFp6SS9SdjQ5ODM5bDA4b0J5NHRPWWx1VFl6ODBYUUpmbFNVSjk5cmtiWDNpRytRVXJ3d0prZTVOck1HVExab0tIdVdUYkN0dXBvc01XdDFEek1jek0ybzRmU2lkOVhaVWFRcXpJbzkvZE5tV1FmNlRpQ2w5bVMrWjdNS2F5QUJNb2JRRzB0OTJTMmEvZGtUazBXc1M4THZ0bzltUXBVWmJrbVU5VlArdTh0R1FiczZGSm9BVW1hbEZoZ3ZpYmpyMTJUaWNMTmNUTThEWHU4Sm1pN2daUGxtb3hEdTVkWTM4VXZNanlGTE40YlhsMEdLK1Arc2xuVDgzNWZremxhZnZic1VYSk5abXp3MEdGanRHc3kvNzBsczQ4Y0pxN0hQRlN6aTNCYUVZSlJsbHN5bGFoaXJRVDd2VWxyZVBOT1BRcVFmUjRZSVA0T09xQmRremx2dVNaakE4NlFBY0dZLzRJbDNPZ3VBblRsNU83eVhRcm1aM2NlaUpFeGNId0I4ZzhlTm14YythV0xSL2FmUG4wMG1GeVRtYllOZXBpZ3JlYVNTekl3NG9tWXBPbGFIMW9uU1dSU2JZTlcyNkExVVFwWjBwL0J5T2VpZjNIazBYWGtFdFlJLzRrVFp0cjA1KzZ0L25FSjJoaXVoaDN6OVFzTjl5ZG1LWEJiSzcwVjNVeVQvbnRCSm0rZXRCV3BTOVBRUlhRZTlPZkpBdlBkWWlGNHhXSWhHRDB6Sm5qZ1MxVDErUEdKcWtzWGlNNTZyUUlzTVJBY2Nia0ZNUkJzcWhrSXBuUnh4YlVNbUg5d1E5cVB2bW4yZ2ZhZ0F6czN6VDd3L0E0VUV1QnJ0Zys4dEVrYUsrUDY3QkhOUHRDd2NoRXhFWlRCNVF2MjBTd0U4MmZtN1RFYzMxTjQrR1IrMUZDemdTQUlDN3l1WU1HSTYzYzlKKzFCdHkwR2dyYzdvUU1TcEdybWdWdk01b0dkcjVPei9DWWN1UHkyRHRUakJWZzBXd2MydzJ1WVZtMmhRMS9jb1ExMHVJRnU0V0N3cmg0RmpQMURxSVZyZ1NOME5Oc0QvZ0VyeE5kbWU4Qm1GbnZBSFdaN3dLTkZjWU5rc04vNjJ4NnduaEZiTmUyQmJZZzk0QkhOSGpBeWVLakI5ZkxFMnhIeTUwb3A4STZFNjVnWXJGdCsxMndQU0JGN1FCdk5IckJrcnVSeVROcXMyUU1TTzcyVzJrRlA5anBVSldreisyU1k5TnRtWjF5b2ROSUVJYisxM21GcXNwaU93QXZQRmhkS0I2S0tnNEtpb29Ka1lSY0NqeDZTSUt5em5HRGtxMWlzbVlhL2FTdkhOUGlYcWVtL1JjelAyWnE3ZTJ0YWZIeWFLWEdTS1NkZjd1N2djOHJ2NnRVL2oxMi9PdUtrVC84Um8zeGtzS3JwTEpMWWEwVUY2N2R2azFPMkZVd24wdjVwa21QNHlmNVJjWm1wcWNxMjFMaU4wVVlma2x1QjQwZkU2eWc5Sno5L3k5YmRDdTd0Y0IyWlNDQ0hCSVJNRUY3OVZ6RmhCUS9FZVlzeWxtVEsvZHM4WjdIeE1OVHREczdHSStWcjErOVc0c0NhbVcxS21CdHU3RGNvNzJ5a0FwNXNMbEZPSkxBTFZ5NWNzOEd3WnRHYUpldGxtR2FPbk01ZUtibWNkOFZZdG52dTdCeGxEekRNK3BpNFZVUzZVTERlckxMd2JIT1pYVGh0MGV5NUJzRnlxck85R0pIRGpUUTFsSnhVeEdmRUdOTVhweTlQWHpOaFY0TUNLVnk1Tll5OGpMS3BjTEZqOXBaNU16Y3JoeXlIRzVmUGFHY1RmWEJqclVobWpQazhKRjJaWUQ3Y0NJOWNFMm4wWFRnOE1tTGdyV0VOQ3JibmJ5SW5JMXYrc0JRdU1aK01GRjhpQnh2a1hHTzM1VndqeUh5dTBmUkhqOU1TUHVBRWs4em5HaDB3OVZjSldvVnVoMnBPQkhvZ0hTaEhCNGk4SHZNU04vbU9LZm4rWmFZWmNFT0FoZTRHNkhZTzJFL0F5VjJ2TU02WWNzZE5jYlJCZUNCQmgzSUVPeGRJRU8wT1RaMkJrcnYyWno1aDdoeG1jVGNEN2o0RXM4MHdKOThmd0JDcDlDVTBnUmlEZ08yaC9CQ0M4am5TRmNseW9ZTTJYK2dJdDF6b0lCL1FLNUxsNWdaSitObk9jbk1qM0h4em8xQ0NwbUJkNzFrbEhQdHQ4bXpIWVlkQ2RFa0JGKzRDTVhuT2xpOXVLcTI2YUlDbUt5UnM5MGdpQlJEbzZqMkRKMnJiMzFiT2Rpc1Fic29OSkZiT0dmS2dxUkVCZ3d6WWhmTXRrc0NCcEQxQ2VFVE9JZW10WnBVY3FzNU1SSnRYU1hBQVd2a2owdXBEcE5XSDVraGFWQTIwR29mV1psb3NLbmRka3lCQm5kVkZBbnZZVHc0NWI4QitvZ2krb3ZsL3ppRitDWSszWURGckI0bTNDYlNhalNBbkUvVGdDSGFRQWZYb011MzZUNHRNRWNLaERqU0hBVXVVell1eTUyK1NhMlJzQjB0WnI4d3UvbTJNMks3UkUzQ0hyc0RjQWhyc1R2WHczYVNBY1M4RGJMd3oyT0NSUnV5bnZkT0VVM0FLZE1aTmdWeWRHeXdsSTMyY3Y2VFB6cFJtSVgybzlpQlJTMktiaGQzVjlJR0l4TmlwWTRtdFNDaHVqaysxbEVoMm9zVnZ0bCtDdEk0a2N5WCsweHgzNUxkNUYwRVZkSnpnV243Y1RkS3oxUGxxVzAwSGIwdDVJeExxSlJFZmVmbEpPZ2JPeTZVSmk5QlFFUFU4QmJXSVVVbFlGdTVZVThkRjBxL095aVE1anBzZ2FiK2tOdGRNQVVqVkhXcWFrR293YlVLNXF6VTFkcEJtYnUrb3ZUMml0bVRITDlrYmNkaDRwS3pzaUtJdlBSSlc1ajh1UEh6OEFsbUFnRXl3aGZyQVRnVVdPZ05qZndxY0d2L2JHQXd3SEJwMEJGbC9LMHNWWVpwNC93KzIwL3l4QVYyTWJVTTB1NDU5MUl0YkJXZGxZTE80aUZFN3p4K3B5Sys4WEJneWZJa0NEVFl4bitiNnZzT2VSdXpnMnNtcDk4SGg1MDJLL2w1VzcvUmUvWnNiY08ydnJvUjJ2ZDZCTlRSWUppKzdCU3plVDhTTk14S016SmJLekJ1S0FXQ0xtNXMzRk5NM28yNmdtdDZCMWNTMGI5RFFIaHBERy8yOTdlcDJzZEh6RHQrK3ZYais3WnZIODBhTk9uUm9KQjkzZUhEMi9QMzc1d1ozNlRKa2NOZXVRODgva01HenRYaUdqYnpENUt6WnNIV25vVFErTDB6dWlNZWVaUFdWbDlaeCtuc3pLc1Y5bTdpTmErWmxUcDg1SjFNUmNKV2FaNEp4bXBuR0M0UWJzQWw0SFBPS0ZmQXg5WVRwK1JwcDEyMjBxN3FuR0xsalV2bkd0U3NXTHlWV2k1UC9TRWdqbDVDNVU4OXl2aC9ObGZBdGRTL1l2MGl6endabjdBeHR5UmgwVjcrSXhjbTV3Wmt6NWk1Y0tPdWY3VmlhdCsydzhSQTN6RHUyOWRqaXFDcHlRMk4vUVM1WlpEeTFJNUQvcjZjbnVKZDZHb3owUmpEdUFZTnVJK0duc0x5RXN0TDh2TExTK1B3STh1SnZoQXhkSEVoYzZWNUxYSGlFRmlmZ050WHpRS1kzZ1Z5VkxXMjZpY0x5NHN2S0N2TExpQlZiR0NrVkpzTWdCM05jUG9tTC94MG40SmdjQks0VENVZFh6NFltZEE0MEFSYWE2bklpSlZoTDdKY0YzTFY2NHljYWJsZHZGRC9oMDgwNFM0RmlZcnJibWtDbmJtYTRKVUFTc0Z3OTkybEhNTnJuZkFIaGkzNFNES3FlS3dKOTdQcWxKVXBUVmw4NmFXRjZjb2hSUHlra2ZVZnVRaExqdStSWVg2Q05BcjVjdmNrRTdwcVJ6RzN6VTNpVkpjWEVTS2FZbUVKRWFVWXlVZFVaRC81NVNFTkI5VS94OXBEamZmc05IdDJ6NS9uUjE2NmZPMzViN3VpUVlFcWZQTW0wSlM4dlozUHVycHdwQ2FTRW9YckJRaklwUWYzOTF0cHlZcVFkMUo5MHBUWnA4ZGlmU01SNmRqVFdNODlaMkF4NnpUU21Qd205Sk14eFVOMWlnakRDTTJNSXo4aHNIQTVqM3BMb216akQ5QkxzN1RmZFJwdWFFcDZaWEw1eHpmSWx5eXc4UXk2dWorZk9QTjd4OVZpdWxMbFJ6ZG9JalRaV2JtUng4RWFPQkZNM1F1dU5WUnR0U05BV2JCRTQ4ZysyYmJLeisxSmdWMHU5VTQrY1doelhVMzlhSHVaSFZHdkttOHFrVmxKbnFjczBRd3YwU0hvMG5VQXZwbGZTbStsSDlBc3JLNnVHVnUydHVwRG44UVBKQ3pJTHJEN29ocENIN2lmcVFuVUh5ZlAxOXRZVHJhT3RrNnpYV3greGZtNzlrNUdZRmt3SHBoY3prSm5IckdDMk1xWE1ZZVl5YzV0NXdYeGpmckU2Vm1ZOTJLN3NBSFlJNjg4R3N6RnNNcHZKYm1LM3NIbnNhZlk2ZTRkOXlyNWgzN00vT0VldUNkZVhHOFpONENLNGVNN0V6ZURtY3R1NFV1NFM5NVk4Tlc5clU1ZThSdU5pMDhhbXZVMFhHMThiUDV2eDVHV2FTSnZKTmlhYkdUWnpiVGFRVjF5UDJCeTNPVzF6MSthUnpTdWJmMncrMnZ5UHJXRGJ3TGFoYld2YjlyYWV0cjF0Zld5SDJJNnk5YmNOc0kyMVRiZWRaN3ZhZHBQdFZ0c2R0cVhrWGRjTHRuZHRYOWgrc1AxbSs5UDJQOGdLc2NnZXlhZ2w4a1JkVUMvVUh3MUJvOUJZRklvUzBCUTBCeTFERzlGV1ZJRDJvWVBvT0RxTHJxQ2I2QzU2anQ2aEx3anpPcDdqZWI0ZUwvRXV2Q3Zma2UvQkQrQ0g4YVA1Q1h3d0g4SEg4b2w4TXVpZEpGN25oSGdjQ0Y2NHMvbG92Uk4waGtBSXdnUmFEdDR4Z1RMZlJzS05GNHBCS0ZicUtnbmkya2x4eStQSXg2aHRaMnpBMUswaEwxNWZQbm4vL29qeVh0R3hNOUxTbGRNYmordzRadHl4YmQ2Y0xVU0ZoRDNFZ2wxYmR1ZnRUSTlMSUMraEprN2VtaWNMWnNPNVFVanhRakVJaU9rSjBMaVp3b3ZEVnAwWStaZngvZG5UVnk0RWx3NWJwZngxam5tTVM3MmdBK2N4Ykk4UHMzVGx1cVhyamJtN3BzY21tZEpqb3BPMzU4OVhlSEp1cmJaSFExZWY5WDlrL0hEeTdNM2JZeXU3VGs2Y25UbFYyWGlCQWM4bk9Ja053TU9mSkRIcjEyMVpuV1Bjc3owaktqNTFTbHpjNUMwRmZ5aENjd2xHYU5aZHZIaDAxWjhuVHE0YTd1OC9lOFFvdjlsL0hwRWJPd1NzbXJBN1FvN2NWWjUwd1hoaC84NlNYVXB1NmFxRFZZYXEyWWNtbGNyRms0TjNEVElPQ3BrY05WbEpqSmc5UHNBZ3ROWWVGQ05Tb1hiNTFZUEZPMy81ajVSd0UxV09rWGdSK3ZYNWRPUGNneUdRZ0drV2R5VkxOUFJMRTF1eTc0RmxlUFdNUTJ2RWQwQ1lKcm93blRLU1A0Mmc5bjBFNC9laDZ0VHFSdUpFWWhCVlJaWk9zbTRHVEl5TUNKRHhkZXdwNGhFbjJCWWtFK2xBRm41Mmd2djlOS3FWSWhCcHF5M2k5NjNmVmxSc09ETzYwczExOU1SaFVkdWk5MDJYZzZhVEY4WU52bjlPL0NnTGdSblJjWU5mb29PWDVpdndqZjF0U3UzMkhyZm10ZGRuSFhFWk55STZkTmpneElxVE1wUmlSeDZzdWVWWms1WW5Hdm0yV01lNkZDVjZmb2taMU9HbTM4V1hWOXh2SHZkOThYVlB3ak9YYU5LYnd4MGtYbTFxSFN6aFZxRERWdENNVDVneHpaU1J1WHJOVk8wMXpMV20xTFVKeGlIalF6c3Bwc2NjRHd2RTBMV1JtMlBsUHIwZmRyNTVtNWxTV0RLcnpGaGFzanE3UUxuWjYrSER2amVZTFlWclMvY1o5bVh0VFN1VWI5em8vTEJYVHlZN0xtcDFoREU4YXViVVdLWG5uYzZkYi9aaTB1T3lJa0lOWU8xd3JxTGkzTG1Ld0NGREFyVmZ4VGxaZ0x4RllLOUdnd05kQ1kySmtOTllweHJWdjhXdm4vcGdCOHg0OS9LY291QVJjQkxzc1EvM29lelZSMUFNTUE1M2hEcDRJUG5UWGhVZWg1V1h6VCtFeWRnSDI1T01JMWpQeloxdUFXTUFoMDgzdnNyQ0dBUldRSzRmZVBCK0tFWEtrNm9YZFNLRC9qQmp3TCs0aHhFYk1OTUsyenZkNmdWTWl2SXhqVG1aVlJBYll2QVBpZWpaYk55RjYrVDRwVjQwNDdMMkNhNEZ3NHpnL1pxZ29qLzFlNHJGblVyekxjeVlOVWtGWllhREZRZXUvRlU0Skd3bG1UMGpWeHh0QmMyTklKNS8vUERtdURNdHR5cDlOektUbGsvWnVNT3dlM2RPOGFtY2lBVE4wbWtuYzN6dWhGZll5ZWpjdFpkN3Z3TWovakVwbHpLWnZiTTNUa2sxVERhbEJBNVBLQ21iTHd0bGhRVmxaYkdGWWJ6YVNKeS9kc0g2ZFlaelJRZXZYZG9UUEdGaWF2U29HTmxwSUxicEc5bDJJV1lkMVJUZzhVVjJ6YzZjelRzM1FkMjdEUjRlcnJyNjFBQk0rM2U0S1c3Vm9RbG1NNWFta1Z1ekFoeFRmNHBqa2RKTTRoZUIyZGlENXNWTGZnZUhEUEdiNER2d1JNQzVjeWVxTHNvOUhKS25URTFKbVpxOVkyZDI5dmJ0bTZjbXlmemlWY1lkRzZablRwazZNemxxOHZZTjA1UWdQeVo1UzBYaUtlT2I0c05WUjBLTFJ5eFcrUDJUY3lmT21yTmcvang1U2RYK2dyMHJiTTV4ZythNlRzUUd3K2lpb09NSEM0cktaRDUvOWZxdEd6Zk95dG9zYTYreWJ0MlpsVzg4V1ZWNlMrRmhMaDR0d3ZucVhneHV4T0phdUJ6WGgzSUd0MkFodktZWHRzR3JHVDZ1dk56eVdHZElDQzhDeGJhRGxtWlRIODA4KzlMWkNXMDEyMnMreDJ4RkNnS2ZyQ2xDQnJ6UkR2MDl6Ym9RVVF3T3l6OTN0b3hjMENpTEh6b2tMRDVZZ1Z6cnhwMjdPMkhxWWZkL3Z6NjhDOVNQem5lYktJS0lXN051dUNYemcrWFZpZFVTZzIzWW1vbS9KTklDTk05bWNLcDBJdm9BZVdRMVJudGtGWHV4VGJDZUFZSGxjWkQ1Q3NvamNOSmZtNkU5K3BsSlBneHlCOFQvdmgyVkQ3VnhQdjhnWC9ybmdmMmwzMnErYnhCQnV1SUIxbmVCNXMydlNQT0RKUGpId2Z3bXF3VGpHR3pQWWduN1EwTThtaEZFa0NJUmJvajltSFlPMEREeTkxdUhJUVcrS0M0MmxEU0d0S0l4NkJuY2tlVi9vaEZJdXcxSGx1ZCthSHNKN3l2TjBYYUNQRTZISHRnWlJ2RlRHTzhadnVQY0RUd3gvbllBcnl6RVQwYzF2YUNqOXRLbWtRRnJEaGMrZ01MN0RGaHhoUDROR2FHRkpJUm9sc3kza0w0T3lRczdyRW4yaGd5MjVxQ3dDeTdzeW1BclR1MEZSa2FBMFZnR3N0cldYWTM0aDlPREpIN1B0SStleitEcUR4NmFnUTZzb0JVL1ZxTDVKVXVYeXdzQ2dtUENlUmlzbVdYY1Q2TVhXVmY3c0hpSHRsUzNaTy9nbGlLNDF2Um1NTEZCMFJTcDlOSERDTDd6WkgyTzFSNlhJSXU1ZTdVOWVUc2xzdUlBZWJ2eFFHUkpFSGxCaFp4NEhNd0VGcXhmdndlS1h5anR0eHlFQk12OFl6T0tJOUoxN2I3MGZCQjU3Zm9Ma0hNWC9uNm01WWFBeGp4WmFUeDhFRW5YNG84aURnN2p4cGo4R0Z5YlUwa1VJMHhHV0R0Z1VhZUJybVlheTBPRG1qcWN5cXVqR0JCclNnbkxxbHdOVXpPTXdacjVWaEFlSWNJc0xtYkhrVWxYamRvSnBaWGxzUUVyM0lTSEx5S21ZVGdlQzlZd0ZrWUFqVWZBR0d5TngzQ0M5cUE0cjJacHdoYkhReHVTajFSTkUrOWtCKzJhMlE2Smg5cmdTWnBkSTRBalAxaTZiSUtXUkFya1JXaElLQzlwbExjdmtTYWhTem1XQ3l5OFNUV21FZTZTU0c3TGJXb2UyOE9zUXdobXpaRmd6bEtKLzMxL3pKNEg1MnZnek1ORTBrNEhTSUVVM0J6cTQ0a0tYc2xqMnpJbVBDdDZvby9SWi9pUlY2LytQSHlWeDkzVjIrOXBPS2ZlRnQvam9wYWNNRk1TNEZyR0E1NkQrajNQWTE2T2M4bGpqeFNsREZCNEVPWWk3U2xOdFJWcENFdVllUndQZWtJOUhRYzI3M3JodHJodHk5N1lodVJyS01KcGNqcGxwZklhSmZBKzB0NExIRkM4S1YvaXY0SXVCSmpOb0F2VnJqdm44Qk1qeURkWEFGdVI5eGxxZVdDcEpiN09DZlltaVQ5c1VndElUZFdMUUUrVHgwZEI1dGVnQmJ6S2kwMC9jT1RGK0JrekRNTjVQQTFMcHA4VDBtaHkzTUhqYmxCTDdRSFdVQTlxMFR5dWo5dC9oa2VnZzRlZmFWNHpSa3hoQlcyR2dhTGpONjVQVWZRcW5JSno0a0QrOWlDd2t3cyt4N1Bqb25md0swd0hnWUlJb0E2UnV2R0FTZmlMREkzWlBIaklneWFKMUNSaW1oUFlRUzAxeTZFTDd4a2htOHhsMVoxWHIyMUFORS9mUW1SMGRJUW1PbDY3SE5EdUMvUWwvZVF6Z1lmUm42QUI4RFNmQVFoaXdlcXI1dGQ0M1BjTGRBYldubitNdmg4aHcxd2RSdW9GUk1OTFhqTTMwUEZzRVhSZ2VESVJlVGo0R2diOERScjVMYmZoMUliRWkyMEovN3JqQnRpV2h4RW1xUHNhK3Y5Tjg1ZE1NQmFJQ0VJeXFPNml4UkNXNWRVeGd4Ry8zQVJkZ0ZPSFdGNG5KVWZiSENkb3BqdHBKVHlMZDJVakhqam9ZcTZqV2lJQWtxRStYd2FOZVRCb04weEdrQkFlanIyK1ZxOGxaRTJ6di93SDRuZHZJY2VPNmFiRVJCNGJ3UUdNckZCOVVlUWZBYUYxVzB3TUJ2VFBlR2lORFdEUWYrTWJ0Y2FPMlBDMUl3L3RUREFHckFqUnlpVVlRZmo1OTFHSVBhRVFzUlF4djA1NnRXTG5uN0xBUm1OQ2dhVkxsOGtMZUV6TVd3Z3hXckc4Q1pxbDhkWCtJbThjTUlyLy93R0UwbjFtQUFBQUFBQUFBUUFBQUFGNEFlMjlEWlJVMVpYMy9UL1ZSVkZkRkVWVE5FMVQzVFlFR3dSRlJXTU1pQW9xOGZ2N0cvRmJWRlJVUkZGUXpFUW40L2c2ZWZNNmViT3kxR1FTTldnTVVVSUlNVUFJRXV3WUpJekRHSWNoaHNGTzI3Uk4yN1lORkUxVGRIT2UzOXJycmxyWFdrMEJRWjdKNUhuNnYvYTk1NTU3enQ3NzdMUFBaOTE3VzA1U1FpZm9Ha1VtblhuKzVVcE52K21CZTFTdHFDUjVyNGdFNWE5SVg2TG9MVFB1bjZHTUhUTjMzVHJ6SGczbHlGRXlmaHhCUkRGZHpWbFFIRXFvRjBnb0F0WHFGRW1QNnhsbDlKeWUxM0Y2RTR6VmI4RTQvUTZjcExlMVJ1TzFYditwVTF5Sks5RUU5d3YzQzAwMGphSktEVTFkV252VGFqbTN6TFRiRU5rUWFTaTVNZEplVWxFeXR1VFVraHRMN2lsWldmSldWTkVSbGM5RXgwU1g5WnJZYTM2c0xMYXM5K2plMzR3L0VHK0lONWZXbEU0c3ZhZjBHNlh2cEpjTXFLaVluNWphNTg0QmNYQnlueGwycnVqejFlUXpmVk1WUy9wV0RqaTU3ODJwcjZXKzFlL2lRZWwrei9WN3RWOUR2MnhtYk5tUkF5ckt4cGFkV2xiZi84TCtYK3YvWFA5WCtyL1Z2N0gvdHNFM3A1Vk9wVWVtajArUFRaK2J2anA5ZlhwMitxc1Y4OU5MS3VZRE1DQ2VYcEYrTDkwMm9BSTVGWGtNSFhEOGdKTUJxRmc5NE53QnJlV25na25sRjVZdkhualN3THFCNzRQNmdVMFZTWGdzcVZoVnNYcFFldERRUVNNcXgxU2VYbmw1Y0x5bWNucmxFNVhQVkg2L2NuWGx1NVViUVZObGUyVnVjSFJ3eGVEYXdjY1BQbnZ3bFlOdkhud3RORzN3UFlPZkhEeC84THJCVFpsb0pwT3B6UnlUR1p1NU1ETWo4MFRtNmN6M002OW1Ycy9VWlZxcVZEV3NhbUxWcFZWWFY5MWNOYjFxWnRYY3F1ZXFYcTErc3ZxYlZXdXF1cXJUMVJjVHZoa2lCcnhhM1hSWTVXSEhIM2J4WVU4ZHR2S3dYTTJZbWhOcnpxKzVyZWI1bWxVMTYycTIxWFFOaVF3NWUwaUxJanBXSmVvbnFiL1M2cXR5VlhGVm84TTFTTU4xakE3VEdFM1FFVHBOcCt2TE9nZU0wL25nSkYwRXh1dHljTEltZzFNMEJaeXE2M1VUT1c3UkhUcEQ5NEJ6TlZQMzZ6ek4xaHhkb0xuZ0lqMEdMdGFUZWtHWDZDZmdMcjJtUlpxdVg0Q1orcVdXa3FNT0wzd1FIMXhMemcvVXJLL3FFL0NrT2x4RS80LzdnaHVoNzdpUjdoaDl6NTNsenRJUDNRWHVSczF6Tjd1cFd1SnVjM2ZvVjI2Nm02NDMzRDN1UHExMDk3dEhWT2NlZFkvcVg5MTMzWGYxam52SnZhUi9jL1BkZksxenI3cFg5ZTl1b1Z1b2Q4Mi8vK0IrN1ZicVBVVlU2amU0Rlg0RE5zb29waGQ4MXIzaE8xV3FjdCtoZ2I1TEZiNU5nM3lqS24xV0dhNnJ1RnZ0TzBuVnFqaXBjcW9nZGhCVUNWa0txTnAzR1I5SGlpN1NsU0NCVUpDMlE1V1dybHZqL084MEdRa2xXcUF5TFlSK0JwVXI1VmVUZnBzR29tR0ZZdVI1bnp6dEd1enIwWE1JZWJQVVUwcmo0WDJ1M3dhUExacmljK2kvRlU0ajRKU0VVeHJiam5YRGtlMzBKaWxUOEl2Qkx3bS90K0F6REI3bEdrKyt5Y1JPVVl5OFNmSU9KVytsM2lSK3JXK2dITzNZSTJrYWJReHMwcWtNcGFDVWxPQmRPSHhFcWsyS29FczdQcENFYzlyU3Q1SCt2NUEySCsyM0liRVN6WnZKMXlxVHJBU2F0MnNLMXkvQSswWC91dWI1bC9XU1g2eVgvWEw5eU0vVGZLNWZneGJvVFAwVWVRdFZnM1pIYXBIL3RoYjdmOUVTem05UzZqb3NzaG9ldi9mMWFGM25YdmVyVEtjdktJYmtPRGxMS1U4U0RNUU9GWlNvRXNvUXJ1SmNyUklOSWMxUUpjbEI2eUR0NllSdlVGUTNjYjVGTWZ3MnJqbWNuK1Y2cVNJdTR0dmNjQ1hkQ0dpVTR1NG9sYnZSME5GY0g2TXk5ektFRDdpVjhNMG9DY2UrNUU1RDVYSm9VSUpkc2tpTW1jUUp2aDJKWlVpTDZUYVRsdEQ5MExNcVExSXprbUpJS2cra0pQSlNIaVgrWmQvdDNsQXBIaDNWNEh4NSs1STd6Ym5jNzZBV3V0R2hkeUN0VXFmN0Rzb1dSMXBDMHpqUEpPZjkwTFBRVXRKczhWMUl6U0UxNFVad1Brb3BwTVhkZC8zN1NPcUYvVTBDa2xLaVBOZy9nMDhNVVJJSjVTWmhtTTlScG1Za2xDTWhxdW5VeFV6ZllWTG0raitMY2dXU21wMlE0QlJENHR0Qk9hTllOSXJVdE11WEZib1ppOS9tTjdyYk9jK0FacEwzQVZyc0xQK2VleEFlajZvU0RkdHA1VEcwZEZpZXRxcDgzVU5wWXNyOVRtd1JRZHNvMmliUXRwejYzb08yT2JNTE50RjAwc3pNMjZMRGFzQnNBWGRzZ1ZaUnRJb0dObWwwQzYydXU2d0dLaFZEU2xJeHErK1VFa2pNV24xbkZBOGtsaUd4QzRsZFNOd1cxRUlza05hSnRHekk4Z2trck1XYllraEptUFhISVNXR2xBMzVjdlVWbnV6Zm8zeExLRTJ2b0ozM3c4UCtRNVZXM2hxYmJRenhHOUVnZ2dhMUdtYmw3dFFFODRkWGRRUFhOMUZMdDhEdmR1S21jVDJUZFBlajVSemZvcm1VNlRINEw2VzFidFlvTlhGL0N6WVF0b25nbGNNNDExSmp3em1QOEsrNmthSmRZSnZSdnN2c2REUFh0NUZ1QnA0NlN6WHVVVXIzZDBwU3VyZmM5NVUwTDE3bzN3MDhPYWtxeFpBYzkzc29aVHVsekFhK3RqTm9POTJxaEtvaDgyb2xzT2VmS0VtN3RhRmJLUm4yTk4vS3R4L0NRZTJoVVJTL3lTSjlIWkp6Y3Radk1UNnFFdXZWSUtOYWc0aXBKQ2FqazlBR0MzSTFEdDdqb2NsSzYwM3pzekliQjdLa2puRS9xb3oxaW8zMGl1MmtJZ1huUHFSb3lmZWRwQ1JWbGxUdmsrb2RUVWIrRktqT1V0ZXJOektqbExEVGVrenJuNUZCZjh6ZEx1UXg2c0FMTy9oZHdXaVNnOThlVlhFZVIvN3g5TGxJaHFjWEk1cG9EK2pxVkdjYzJqUWNpN1lxUlk2MDlVQWxXSzh2T1hQazdNYUttN0JpbHlaei8zcnUzNlFTODRucDBBUFFMR2dPNmVhUzVqSGZZbVBPUXRMOERNSWkyc3k1Q2ZxSSs1K1N0aDBlVzZIdFVBNWI3Q2EreS9xWGRqZmZ0K0xWZmFudlVwMm1VaVFuZ2JVYnZ3M3RsbWtJSElaQ3RCazhOb0hIZG1nY3FjZERlQzY1b21pN0dHMC9wYnhiMGJnejhPUld0TTVhNzNZSFpOckRleFkwbStzNVhEOWlIcjFZejlySXVZVnhwOTVHejUvQ1k2R3FLZEhoZUhzMzQ4bEtTbFZ1SHY4UkpmaVVmTzNrMllxZTI2RHRYR2M1NytEYzRWZHBKNk5ySjdTTGNNNC9SWWtYVWVJWDFjMll1SWNXNVAxeVdrd2Y5eEpXZUZseHJOQ001MmV4UWtvT3lSR2JENlFKOVVPSFdwMXBsckYycmdTV2FjWXlpN0ZNMXZxdVlVSC9OUTVOeDJPMUNjVFRudkdBRXF6UmFwYTRROUdnOUhGS242TDAyNExTenhkOVBxWC9HSWt4SkE0SlN0MmxYNUZ2T2ZScmFBVlVoNHpWUG9zMTFvU3NzVTFtRFdncnRBMHlhMEJtRGZqdjlLOWpqWGxZWXpIVytBYldXSWcxdm84MVZtZ1A4ZDdQczdIbUxueUIybkVQUWc4cDdXWkRjK2hYSDFhNVExZGFhUlpMZFdDcEZtWnNPYXhWcWNNVTlUbXNnenc4a2Y0Qi9STkJmNUFLV3VISFdPUTkvSVQyQU5FM21EYy9hN085N2VhNVM2MTlSQ2hacHpZVGJvSzJZNEVPMHVYTVUxdlJMb2NHU01ZS2tXQ21WcXEwWHFTSG5lZi9EZC81QTNPV2pjeFpmb3NsUitKREh3WnpsVEZZOEEwcytMWitRMXRmaFkrdHhvZCtUNTMvMHE5MHk1aXIvSXBaNEZrcUpYY1NyZnZhL085ZHBhbkRJZlFRUXluRk1FVjFPRG5IS1dHenBnbWtPYzNHcStWNGZpdWV2NE82YnNEelU3cUp2TGVRYnhyaE82emRadlVBK3M2QzVpRGpFVlhUZHJ1cCsxZngvQTZzOElGZUlzOThQSGFCaHFKNU5pamZjVnFLN0Rxcjh5VllKcVVtWkg5RVdxdHpyTFhWdkw5Y1djVzFnM09IL3c3MXZZajZYcUJkbkhQKzI5VDM4K3JpM0UzOTcvRlB5L3VuOGY2a1dmUWhaZHhzYUE3MHNJWlJ6MmxhUklwNjdtVEdIcVd1NngxMXJTaWFEVU96bldoV2dXYkg2MWlWb2xzU3VYMjVuL0lmS2EwRTlxckhYdTAyK3ppY1djWTRzMVVDVzlFbVNER1pzazVSbjVDdG1zd2JwdG1ZMzZiWmhMR1I1aEorRmo3MG5raXVSbW9DcVFPd1I0dm9SYkhCZXNyZlJkbWo2b1J5MEc2b0Mrb203eDY4eFB0MnlwZ05XbmdEWmNsUkZscTVwLzBHYzkzbGVobC9tVTlOdkFhWjM4QjVvYUpJcTJhTyswUG11RC9WTC8wUG1PZitDci81SXo2ekZKLzVoZnNWNStYK0Y2UWNqTHdGT2lHWTg5ZW9yNDFHQTVVSVZodnRzdkVCcXFLMWprT096YnV4M2hUT05xcGdpV2pRLzJjMW1icGh6REkrRGZESXdXTzVyWCtxaUszbVBJN3I4V2JORGZDb2xIbUlUamMrSmJKK0JQb1o1RndFSGlOVmlvNUp2d1dlRmZoMXZmWHExa3JoWXYyWG9yVFNWbHBwRXAvZWdBNFJPRWQxQTlkV1A2UzVnekMrb3JrcTFXUHdzSG00alpxMFhEVFlUTm1ib0E2L1RqdXhZaWUwQzhwaDZkMzA0RjNFZDFPM2V6aDd2ODc2bklYV2o5Z2F3TGVINXVqbHB1RXdKZEVzWXYzSDZhcEVxeWhhUlFMUHlla1dycG0zMmRneW0vTWNXdE5qbk5FS2JjclVCSDFFdU52bWRCM3VjdCtHdElTU1ZtZVQvRzY5Q1AwUW1nZTlCTDBNL1FoNkJRclhLZk1GZExJVkgwUU5vVWZLVnBnbDFFYVh4a052b2szdi9MbzFnMmZiMm96ekZCdjMzN2U3TmxPUXpUd0kyOHpEK3Y4Y25JTFZMR216WE9YWGlsQ0pyWENaamRnOXRDRVA2MXpUeUx4SjVkYTdSb1FYbVY3T3ZDOUtmTXg4a05VbS9oRTFLVm03bDRGY3dJK1ZvakxtblJzMUhwcmlPN2pUSkVjKytrVHVieUpQQzV6ZVU2V2x6UVlyeVRieS9KQnkvRkV2RU1hYkEyK3NKVC84c1dDcGV1bWJxdFUvcTl6V3QrYWJuR1BFSnZXMEtybFRWbmhIWmR4SmNTY2V2b1AyNGF0SWZ0NURPYTFkZE1obWZYWXZhQVA1RmhHM3E1RXlUNE5TWEtYcGM0Y29scC9CV2o5dlZteURVejJldDlaR3J0UHhZL00raU5XQzVuQitERnZZS0laa0c4R2dPcml1cGRZM2s4YjZhdUk2dUw4VHUzUmlyMTN3emRFV2RoUHVvZ2ZZd3oyUFYwYjhSa2EzZHV0cnk0T1ZjbHhwUlVQcjAwWmJFVSsyRWFWVmMyM2t5T1V0c05TazkwSjZEc2t4V3gzanZiWUdjK1JlYWUyb3lSR3Z3YlorNllXTkUxQlN0ZGJxaGtFVGRKSW00dmZuRTc0QitUY1NYcUJUa1RJU0thZG9OWkkrVUtYcU5VWU5uRC9VR0JmQksyOVIydDJHdE5zSjM4SDVUbHZIQjFLc1BDWUo5TFdWenpGSXlpQXBpYVJTWFdEU2tyb1Jzbm1YU1RzdGtEWWFhYlZxNFB3aDU4MnF0ZEdMMVl4Sm5RcmRhdElyVGZvMHdvRUd0SFZrOWFCRkdpMkdnU1BSWWhoYTFLQkYwdFlmcGdYWEx5a1dsUHNrTkprVWFESlM5ZVJwNFB3aDU4MUlvK3doVFpJRm1pUkRtdFNvbDNuVEI5UmpQZFFBZlFnNVlsK3g0MHNxdFZWS0JlM1FXanUrWVRNbzRvSVZpcTFPanJENVZsODBOZjh3UzFkYTdSMHUvSVBZS1JyMDJibTJvamJibkV1YXg2ekhqcHFmYkNadGt6SkZaNURtdlZBbnRBdks0WHU3T1hkQjNaQjVzTThHTThLTXRiYStRYjlacWtnd2xrYXRoT3VManJ0dEJ6THVtcHhLY3BTVG85eTROOUUrU2prbWxVQ0RHcVd3VmRxams5TEJ2S1FEUzQyMFVjWFczWVJQeDc2VHNmVVVpTG1JcUROTlZ3enJSVFVMd25wNXl6MXJQbkZrZmdkc3FXL0dpb3UwbVRSTjBGYlNiK2VjNWJ3RDZrRG1UdDhldFB0R0xMY0J5N1dxaS9odTR2YlF6M3BmSDNoeityUGVETjBPbVRkRGQwTFRvYnVoZTZCN29SblFmZEJNNkg3b0FXaUY3WUVNVmRSc3VsQzF3VjdkZjFoTU1waFhKb2xaSktkemxTQituSTFvTlhnTmV5aUtnWEhFQnpGNlU4bGdYY3c4S3hqUjFzdDhrVE04S0dIQ1hlV1Q3bXAvdkp2czArNGFmNVNic3FmQlhlc0h1ZXQ4eEYzdlQzVTMrSEozb3krM252VTdXTHpPUW9zSXJiUFEvSHpvMi9tN3o0dTRmR2lOb2hheUdaSnBZR092ZnpvWVI5Zm1yN0xHSWRpRGdXd2Ryd29yV3dtaE1sWEJxeHB5TmtaeFZNckNuUmFPZ2FUdEYyZER1NjA1bTVQRmc5aHN3SG0xS24wclBFZmFqbkMxejFrYnJpUEZLdkp0SXNXTHBGaE8vbVpTckNURlN2aDhBKzNLaVJsbzQzMk91KzFtVGVZSHFrRHZhbzdIcUZKeE9GK0l0Z2xpMkZVS2RqbWlwTzhrTm00YVJTeVdFbG5JeG40THdaSDRYdGFUWDJEajZ4aHFmd1MxUHdxK24xQmZGL2c5N2tMODVXTE9sMEtYUVpmRDRRcS9XNzFJTWM1ZG9JaTdDTG9NdWh5dUVXTEh1a3Y4SHBVUXFuQVh5aEVmdGF1TXU4aDN3NnZiVWgxbTZZbjMxZTVpeGV5cVZGUFE2Sk05RFVqZVR0NEluSnFRM0kza0RsSWszWldLbXVRQnB0dkY2R0k2d1ROT3ZxNUE0MTBtS2F6MUZXalUyMTFGNkdyS2N3M25hNkhyb092aGNRUGxpYnFya0RjWnVnNjZYaEUwbitMM0VMNWFqdXVvdU91N3lkdHQxeEd1cjBGdlFzWjVPK2tpNUdpQ2N6ZWNPN2lUZERjcUNtZmtraThYeU92T2E3TExPSWExdVFHSnRIVkNVNkZib2R1Z2FkQU1hQ2IwSVBRUU5CdWFBejFNamw3RTVvanRDc1YycVI5OGN2RHBkTGRDdDBHM2UzaHh2Z3ZQbU1GNUptVDgwSEUyTkFkNm1ESTlZbHJmYk5KTWtra3B0Wmd3UDNpRitaQVBxeEhxb29Tejhycm00TkRsNWtBUEUzNEVUaW14WHdlbkxuY3JkQnQwTzFLbmNaNEJ6WVRvV2RFcVZxaVYyYWJyZ0d3VG85ZUxoRW9ZaDFjRVhuSDFMc1pIcWFDME9YY3JkQnRrT25LZUFjMkVaZ20rMEd6SWRJVFFVWDB0WjlIU0JUbm5RS2FOSWtydEswZW9wc0k1NHlhdjY3UDFUS3B3M1R6d0dRNldVODdCUS9RWVNtb2daT3NJVDAramRMNVhyRk9sYnlKbXRPMWJWa01wMFcrUVBocWthQ0JGcCt3M0wyQ3B1QmY4N21XLytxeVYvY2JDMVNUa3ZRajlFSm9IdlFTOURQMEllZ1VxTVIzZ1EvNm85YVBOd1F6bjNhQUhaL1dnZnFxejFXK1h6Uno2Mmh6QzJYeWxmL0FiWG9NR2t0Tld4Y1RhM2pvNVRUZmZDYmZWY0hzWGJsbE5JUzF6YzdqRzRWQU8xdzBhYWZ0VnRxL04yZWJad0g1SElaeldVQTNrV0lFMDI5OVdzTktDcXBXd2VmZ3dwQitPeEFuKy9XQlg0d1RaV2hTNmgrdVozTU03OVJoY050dGNQRzVyMEMzTWtlUTNNUDkreHcxVHRSdkovSHlVejlvKytNc1E2eE8zRXV2M0N2YWVtODMyakZZMm9rV09lb1ZZalo1MzdGT2FxNk1sL3lsMWw4WW1PWFNQZWErSTN3T1lyU0c3bHh6eGhId250RWVIN005M0hGRHFOZjRKL3lmVnFoU1UrZi95OVdqWDVWdDl1OTlFK0UvK081UmtxLzhqWmRzc1VhTGR2aHZ0azZLdVNOUGh1Zks3YlhSYlRuMjFoemovenQvSjZDcHliSU5qbTYrM0dtNzJXZkJucmg1VUZBNnRrcUlCU1dZakswTVVDTjY3bElBejNrSGRKMlIvcE1rcGdrWmI4S29TeThuNjFHTEZ0WHdMZXNoM0IzYU9RTExZRmp0bkxWMFNzaXR5U0tYQjFiditPMzRIZk52OCswanViWHFsZ2dMMWh0OUdFWU1tcHAxWTJ3TlJpcURjK1hyRnErQWNsMVFXWEwvcDc4Y2E1VW9BY2JVT0NlejIrcldFVm9LbnNNMTdvTjEvYXVrLzhoOUp5RTZSWWlWMWtaWDljZjBNRmlHTjc4U3lqUks2cnVGY1lweWpsSzdCTDhjV0M4blZUZjIxK0p6Rk5tTHpEeVNKT202dzBUdE83RXJDWnBWOExVU01ZOWF2MncvZnFkZkIvTVg4TW16d1ExbU45c2kvRzJxekVHdjEvZk5yYW5BSngrWFlmN0hmRXI1VEtBWE9FZk9sM1lUMnppOXIrUTcwTDNVZ2lhbjFwL0xTZ2orbGUwaUlsMHRRWXI4NXQvcEZIRmR5WmkxWWFQK0M2NFNSK1hEUFZ2UGRvZGo1L2tiL2p2Qm43c3ZqWDVJcWczdU5QbXZuTHBOaUxXMy9lenphdzR1K0JmOXZ4Zk8zV1g5Z3Vwb1haQmxiVEJOMFllVmd1K0JjRmFtaFNENTBLUDJaZFQrYXJ2SkwvSHowaXZxV0VOZG1LNEhNU2kyMFFxeERqZGY3OS9mZU1zd3Z0NFg5Q1NRVUsrcHh5Y0tvSG53cDVEbjBxTzNXaTNEMm5mb2MvK0RZSlFYMHVmRU1YWlR2aHpYSzlzMHp6TUZ2OU12UmV3RzE4NHBudkRwNGZRKzkxeDBhZlE2dHp0aDVEZjF0V3NtUS9kTTk5TS9EbExGekRQVGNEMW9vU0dPNTRSdFRHbExCZmE3M2ozTVBPU1g1ZGp1dVoxNnd1dGhZWURPUVFQcm5QOFB6VFgrcnZsRjhMbXRXRGZRTWpVVzd3MWJ2c1NiQzExbS9rV09ENytDOHI3K0V6RGQ4OTM1cG1BVTU1YTgrZTY4bkg5bkxWV0dzSFcxTWFmRkxDN25sWmRyWUYwcmZYc0NudG9oMEcyVU8zRWVDUExIL1p0OG9zdXJ4M2ZzYW5Zck9QdDZWYVFvMTBsZTk0K2VKZFNIaHorYktTSDVidUU1SXRVakQvbExiK0UyZlp4c3VZdWxZV0VQMHB4VEZ2ZkVRMVdCSlFROVpFc1IyNHMvaE8vRWlMU1NvWi9ybGRSemY4azErU2JoR2VzNjFmLzB6dkEvMEwzcm9ldEcvWnM3LzF4cUhZRFZoTGRyT0ZjVlhIVXJaZWpCWk5GWDBmM3NOSnV3NFdCRTdPL0cwcWNXVzJKUDhCVDBTQ0dscktjc0Rpdi9WK0hNaVBCc3MvcGZ2bjloNzhRMks3Y2NLSlBaL2J1c3UwSC9iSWRNNTlsZmJieVEvdzNsWGFDenZrdytWa1NvR0ZZejR4ZWZ3dnRtOHNERzRUUHVOUGN4TkU4Rk1NQXJzejU0bGF2ME1udzBIWm8yRDMwOEk2L2hYMnZNbkQ0Rk9XZC9zdHlvdVlMdmZUZm4rQm4yRC9ldXR6RWFiU05kS3VBbmtDdXBvVW5nT0E4ZWRvYlpsbkF2blh1WWY0ZXM4NStLdEhzNkh2cDcyZTZmendPcmVyK0w0RGxaY1VjeFh3NnVkNHZ2UGg5Ni9mYlBOY2xmN0J0YUVPL1l4YzQyaGQ4dzhxTDJvekVPLzIvT0tTY1NPeGZjekxNV0I3SnFrekxlZlpNYi9UNVMyeWRiM253VHJ1M3FUYWJ2U2FOQmlyZVZkYUgwQmp4T3MxeXdqTlZZamJhUHkrMGgrUGJsV0tya2ZMVGIzUDJ2czlpOGVXQTNhS1YxOGRmaFgxVC9uTmQxdm5XMFg1Uy8xY09pUHZqbTQrcG95UGMwVDRaLzE3eXVhbjROa3FJWGEvZHQvdzIvcmd0Q2FRN1Q3MStNK0tDaUJlazVKR0ZyZ3Avbm43VG1vTXVGWGZsVytEYTd6ai92NUZwcm5QNkFsdGZzTmpGdjh2bGxFai9YVzlsb091anp2L0szdml4YnNlWEVPL2U3YzNVUHRKc0wxZWxEenV1eC84eHlweUdwa2Y4YU80cW44eGtNd3l6M1V2bEdqY3VhRDc5TGlGbGtyYkFyNVJWUFFta1NLRFg2VGIvVTV6ZzJGdjNkclV0ZzdQQ09tckEwZkttc2NzdFVFdXY4UDVMeDY3enl4Rk1lQ1BySngzendQZGV2Mjd4M0tmZ012ZmRvdjluT0xwbG52MzdKenc0SDlNdWEveHo3eE40dW1hRERQbDIrQjJnK0k4ekwvK0Q2ZWJGZ1RXT2ZBT1QrMXIxOVY4enJuRHNETzMvYnppdXRNejFKbjY4RzF4ZGRZUG52QTF0amc2L0xXNkNnK3l2bXV6M0IrZlY5MkRqaHZMR3BuN2hWeXBxeFA3OFByVnRoNTJ3SHJ2SGdmTmZqV0FlaWNDM05tRnZiMTRrLzRCVG8zSFlnMXdpT20zeXJaOC9XeTNZY092eWovYkUyMDhFa3AyMlBJNzFuaE5iSTBhU2oydDdEUDc3dk5oa2s3TXRzMVQ4aEJ1eFVCNFRVSTVEOEt6MUpzSHBhQzRuYi9iLzQzSUovN3E5RFphYTVLYk8zVkc4dVhxby82S21YdnN3NVVoUWFwVW9PVlVaV0dhS2krb0dFNlhNTTFTbC9VQ1JxbjhacGdYNEdhckNtNlFUZnFKdDJpcWJwVnQydWE3dEFEbW1WZmVIb0VDWS9wV1QydkY3UlVkVnFyeldyU1I5cWlUOVd1cmRxbTdjcHFoenEwVTUzYXBaeDJxMHZkMmlQdjVDSnV1QnZoUnJwUjdpZzMyaDN0am5HWHU1dmRMVzZxdTlYZDVtNTMwOXdkN2s1M2w1dnU3bmIzdUh2ZERIZWZtK251ZHcrNFdlNUI5NUNiN2VhNGg5MGo3bEcrOGZTU2U5bjl4TDNxRnJvVjdnMjNVaEYwS3dHVEZRWERGQU1ucXplb1VSeWNyVkpESC9BVjlRVXB3M2xLZzZ0VkRpWm9JTGhCRmVCYURRS2pWQWxHYURDNFNobHdoYXJBVUEwQkozREdrb2JSR2dZdTBPR2duMGFCaUw0SVNuUUNpR0poKzNZSTZLMEpvRC9XdHZlZHdjMmFEQjdRRlBBUTh1M2RSekJBTjRHK3VnVWNycW1nVXJlQ2EzUTdlRmpUd0VEZEFTN1hBK0JHelFMWGFUYVlwRG5nSEQwQ1R0TmNjTG9lQXhmcVdUQk96NE5lZWdFY3BhV2dXblhnUkswRlIyZ3p5S2dKVk9ralVLRXQ0Rng5Q201Uk81aXFyZUJXYlFPM2FUdTRYVmt3VFR2QUhlb0FkMm9udUV1ZFlMcDJnYnVWQS9kb043aFhYV0NHdXNGOTJnTm15b1A3blp6azhKYUlyc2RqaG1zc1hqTkNoK0U1STNVSjNqTktZL0NnbzlRSEx4cXQ4WGpTMGZvUzNuU01qc2FqTHRlVmVOWE5pdU5adDZnTTc1cXFRWGpZclJxTWw5Mm1JWGphN1JxT3QwM1RrWGpjSFRvR3I3dFR4K0o1ZCtrNCs2N1k4WGpnM2ZvaVhuaVB2b3duM3F1VDhNWVpPaFdQdkU5bjRKVXpkVDZlZWI4dXhqc2YwR1Y0NkN4TndVc2YxRTE0NmtPYWhiZk8xb040N0J6Tnhtc2YxaHc4bDlxd3I1U2RZbDhwRzJsZktUc1RUMzVaWitITlAxRzVmYXVzMXI1VmRoR2V2VUlKdlBzTlRYUXI4ZkZMRmNHT3ZjQndKY0J3OVFQOVZRYUdjQVlhQUFZSmYrVjRtR3BBTFhBYWJtMTloUG55RWVhZlI0TEIxUDVvd2tlREVoMmo0d2dmRHdZTDN5V003eEwrRWhpbEU4RlIraktJYWl5bzBrbWdsMDRHTVowQ2Vtc2lxTllrRU5kWEFGOHYwZG5vZUE3b28zTkJQNTBIYW5VK29MMVlpN2xRRnhGenNTNVJTcGVDZnJvTXBIUTU2S2NyUUVwWGdnRzZDaHlwcTBHNXJnRURkUzJvMEhWZ3BMV1phdDBGUnV0dWtOUzlZSWhtZ05GNkZBelY0L3BIT1QwSitNNGNHS3luOU0rVTdsdWdVdjgvR0tWdjZ4bmlud01aZlZmZnA2US9BREZyTTZQMG9sNmhkRC9XYStpMlFEK2pGSXRBUC8wY3BMUllTd2d2QTJYNmxWYWc1eHVnUWl0QnJYNERLclFLRE5OdndXQzlCZnJwZCtBb3JRWUQ5RGFJYVEzb3JkK0RrZm92YmFJVUg0QWpWQS9TK2pNWW9RWndoRDRFYVRXQ0VXb0cvZFVDa3ZvWURIVmozQmlOZGllNnNSekh1ek00bnVYT28rWDh5UDBJMy9xeCt6SHRDcy9qK0pwN1RYM2RUOTFQOVFYM003ZUl1ejkzUHlkbXNWdE1ETi9Oby8yODdwYXJsSy9uL1pxU1J2cVVLU3IxZVRCNXBzcW9FUkVYdDNuUnlleUVaWDI3ZW5QczRqeFVKWi9QN3JHOVY5SUVja2lDVk9hN1dldDMraFpOOG8yK25idUFtTGI5a1piWFYvYkdoNHluUWs5M3R4MzhyNytCdmp0bCtvTFFibWM0SFJwdjNTZXZSdnRkcEV1UWFTcXpya2xSakppRDEzYVRjYkY1dmVtK3dYZjI4SXR5VkhiMDgzMnU2QzdUMm9LMUVqcWl2ZVVuOVBuNFF5NDQvNnZmVGYzL0lyUzcwOW5EYzRiRnVhMzBid1gyRFVxRko3MWorOUxid0VjYVlWOGMyMERjWHp5enk5Y2JYeEtpUHVlWmhTd21meGIrM0dRbGVOazNrS3B6cjl6ZTk4dFpvM1FFWmVXSXBvMmNXNEwxYS9KZ2Y2OWtsVml2cEhuQ2I0enY2MFdmNUgvS3I5K0hkelVVdkdtU01zM1R5SWdyOEJEcEwvY09jaVd3U0k3UUtwOGp0Q2EvUHVzT2VFYkQ5dHRuMjIwcDhQdW9OMzNCNS9KSDY0MEdOZGhzK203b3dhNzcvZVFrUHJYUXlyNGUybWxXYkxid1Jsb0dNTytLSDVTK0c2Rk80L3hOT0s3ejMraXhUVm9ORVBxNS85aDNCNzFWei8xRFhaQnlXejZ2U2ZETm9mNzRZUFJkQXdmcmJXaHA3ZGpodWFLcG4vT05SWDROd2IrdC84cTNZL3hqZ2N5UG9FV1N4Wm5tQjJkanVIZjRwMmt0ci9pdklyRXRhREZ0eHI4SmE3N3JYNlZueXU3ejE3K1VyT3pRTzBHS3BQVnNHY1ZrWXpkMGNMb3V5ZSt6VkVKeGU4K3hTZEpRMDVTUXJQVXBnZng5NzlJK0U3VDhqSlhWUEVReVRwMkVFa0xmZyt6UjB2RC92VzlCUzc3YXh2ajFSTENUMktacTRuSytHNS9laVgxNVhvSTRxU1I0WXFobkM4Y0QzMktITm05eG1YMlRuMVAvOEMzelc4cXNtbUMrMG1DOVFFUWwvay9ZcFVPbGZwZnAyQVdkYnhyYkgvZWJldElYejhyaVlRdU1aMkJQMHpkbUh0YkZkVDQxdm56ZytxNnhXVmgzWHQ5TnR0c1hNMTlaN2QvbTNHMVhXMGcxdTJCMjA5Z0R4OTM1R1VhQ3F4MStkL2laWnV0ZFdzT3pRL3NtYlFKUGkva216bXRKSFpXQkVid1ZaSkhUNlQ4ZzFJNjgvWDUremlRV3REVm1BaDAycDJtMUorMmRqck52ci9kVG1hM0RxbTM5eFJlemRaZnUxcjJhb1VkdEp2K0I2cG05TitoRE5hcFpMZnJZaldGKy9tVTNsdm41eWU0VWQ2cWI0Q2E2MDl6cDdneG02YSs0K2U0MVp1WE15Sm1QTDFaRXc5UUw5RkVDOUZFL2tGQVppS28vU0dnQTZLZHEwTTgwS05GZElHSXJvcGl0aUtLYUFTSzJJb3FiVGxGOUFQcXFIcVJzZFpGVUEraHJxNHVVR2tGU3pTQ2hGaEN6MVVYY1ZoY1JXMTFFYkhVUnNYVkZMN1IrUmM2K3Z1MXNYZEhiMWhXbHRxN29aZXVLM3JhdUtFV0wvMDhsWUtDaW9NTEtkcmxpWUtUaTRFaVZnb3dvTGZGSlVLNFVTRnJKTDdHU255SktUamdOUmx2NXoxSTVTTURWM3FnSEtRMENNVldDcUFhRHM1UUJmVlVGU3N4ZXBhSDluTU0xREZTcUZoeXY0ZUFDalFBbmlOVXpZVmJQaEZrOUV6NGFmRkdzbmdrZkQwNncxZk1GbklGWVBSTSswZkJsdzFqRE9PQjBFbUQzRFVURVNwcXJVOEM1bWdCcU5CR2NyOVBCc1pvRXh0dXEra0piVlUrMFZmV3BZbFZObUZVMThlZURpM1FCbU1EVlJSQ3JhdWhTTUZHc3FnbXpxaWJNcXByd2xlQjBXMVdmWWF2cVNab00rb20xTlhLbWdESmJZWjlwSyt6emRDTTRYemVCdzh5VFR0RmpZTEN0cW8rM1ZmVTV0cW8rd1ZiVkY5aXErbXl4cWliTXFwcjQ1OENYYkZVOTFsYlZKOW1xK2dLOUFIcmIybnE4cmEwbjJ0cjZJaTBDRTIxdGZiRllXeE5lQ29ab0dUak5WdGlUYklWOXBsYUNDOFVLbS9BcWNKSGVCUDFWQndiWWF2c0V2UVVtMm1yN1JLMEdwOXRxK3lTdEFlZmFhdnM4clFXOXJGV2NZcTNpU21zVlYxbXJ1RUswQ21Kb0ZjVFFLb2hwQnBkb0N6aEsyOEVZNWNCeHRuOTFqS3QxdFRyYWRySGl0b3MxMVBhdmh0ditWYlh0WHgxaCsxY2piUCtxMWxibnA5cnUwRERiRnhwbExlb3lXNmxmYWl2MVMyMlBhSkMxcGN0c1hYNkNyY3RQdG5YNXhiWnJWR1c3Um4wVUdmVzhvdEtSMGFNYThOMXZTUDVOKzRXY2tjTy81MXNaQWRkelhreVAyQTV0NU00R2pqbDdpaVVMY295SGZDZEJTZC9JdWNYWGcxYnU1YUMxL2tYbW0wdUllZDkza1R0TGlDZDRtSE5YY3ZjN0hqNHFKL1E5UmdXK2phb2EvMjNDenh1K0I5YjdkYUNSRWEzeEFPZjRVYi9KNWtGditJL2hzbENsOXVXRkhMRTVkS2d6VGRaWUtmZ21CZmRXa3VOYm9NVi9nclFlWnlHazNjeXhMVC9EeTBLYktGVm4wU2N4bzN1NXN5MDBYclJCdWZDK1BsdzN5ZWJKTXNsRjN1L2FRTzRZRnJlUnpiOWw5cy82Tm1oWGozSjMrZDNHUDBlYVA1c2VuNW91TWc2N3NBQWxCRHVKRCthVW9CTUpIZHovMFAvR3R4RnFDYjA1VmdMTUdtSHRTR1V4UGI5ZDZuZW9iRysvRm9aS1ozT25FSmREOW95MCtRRTJVREtZMFNWOURoMU5JbmU2SUdZRE5vTWluanVTM1lGMmdteFBUOTVnZ1c2Wi9VTGYzYkIyVVBROXg5VCtQOG5IT1o2L2lvUThKVkc4ZGZRY3B0enh2ZWJaWVRiNm9FQStaYlZXQmNJOEtXRWlQLy9xS254SGtoYTIyVFExdjdCMGhmUCttRUZRSUF1T2hBdlNGTXk2Yko1T2ZLZ2Q1VG43cG9MWXd2VWJLU3kzdFFLd0VRL1BTbGF5RXZVdGFNVVJVR0l6YU94aXZkMXU4MVhqUUNpcDB0QWVSUzhMTjFxNElpOXRNYW1KVlR3MEl3L2toM1gwYUZOa3ZibFQwV0xQNGhadklRZit2cDl2cHJRTjF2NzM4K2tLV2s2dXh6ZE83VG5UL1pGS0tudG15MlN2c0xWdFRrbU82NGgvanp0dGxxcUJVTDBzUGFFbVc4Y1JzdU1xdkxRRGF2T2RObnAxd0lzOVlFVzQya1RzTmxXUWFxUFpQbVg3dlRGSXlsRE90ZEFHVDE3T3YxRmVKOHZkMFlOMWU5akw4RWlBVDczZmpzZnNzcnN4eHFVTmNIZ0xYWDdKV21zTE9pNFB2b2Z4bitaSE10My80TjltMy9KWDhFVGVaL3QrdndLcXN6MmI5N0hNTXIrRHExZkkzMnl0c2c2Z2p5S2NyWTF3WGtjb2JYYzIyckhGMTZFSkliUmJEVGI0OTZ5dFJXMHNzWEhhZU5aSkdtYXB2Z0hWcVphMHIvcVZZSzJCdWpDODV6Zm0zN0tMOXZ5MnhHZDN1Tldma205VENkcDMrSC8zUzVXMkhpRktuTkN1bWRqVy9CclQ0VXZMTlJSckxiSDkxai9oQWZHQWQwS2xRTlpqZk9UL3lKRlJrTmlnSDZKYzVvdUYvVXQrZDNocjRYT2hSdGdpWE1kNGxlVUw3d3RTNWk2YlRYVGFXTndKc3NCK1p5aDREcWRKc242bEhscU0xWmFUZHIzNWJLK2VuOXFrdkovSTN1ZzFMVXJnRUEzczI4ZHFxY05idktWOUI0dTBxeUsvajdxSVBxYmI2c1B1RzU4R2p1aTIxLzFDU2xmUVYzKzhQODhEbzFmZUd1RlF2a1ZzS0xyajJ5VHJyUXpOQVpuMUZDbjJaaHpwL3AzV3RDY3MzelMzZVZQUHp5clN3bDQyZWFGWSttN2phTFBHTG1pbjJRclB5Kzg2c29Jcy9GYUJXUm9yNU9zdDFzT3pqaEcvSitRL2lmMzRNbElVeUVaMTJydkpOSjdBNXMvR1BXb2FGL2IydGd1Uzk5a1NqbTJLQmlYcjRyck5lb29jR3RHWDVkdGtLYjJHL1pvQjUwakJyTFRiUmg0b0ZOZmkwYVNIZlJBNEIvNlN5RjhwN05PK1BWUW5QWHdqQXAxQ1BlamUzMmVpdlJuSFBGZm1aVEt2dHBFNlVtaFBtOWVoQmVpbU5jVTRtM1N6UkpjZElhNjNjdFdWSHpkNytlM1lvZ1g2cmZBUTRveUh5UzVIRGg1a1ByaFM1ZlpjVXpYWGpWd3ZNQzRaVmRDeXU2eTlOVXVFNmhVUHpZM1g1dWNLMVpCNW1CM2p0T0xWbkZOK0VlbHJMT1lWbXpWVVFveDVwRThwVFhnb1ZPM2Y0bXhRcFo5SDJucjJoTDluWUIyVnh6cXpYMHJsSVM5ZGFFOXJXVm1nY25qL3hLK0FRd2VqelFybStPM3MzczlqVEdxbXIzM0IvOVQ0MTZnR2k3ekdPUEFXNjZxWmFGaUN2R1dVUFBBSm0rOXVDMnJkV29MdGZEV0ZhOUR1ZEFmelB6dUc3TEtueDYrV1dIdm1YcmpmSlJUeXVyWWV2dklVQUl2bWJIYUFIamFhcjJlMGFyZjNCOE4rMkZVd0J5a0p0UUtyZld0ZnBqRkFONjZCOVcxaC85L3NGMXZxVGFIWlRBSUlTN2FiSFJJUWRyZmRZL09PNEl0OVc4d0tnVi9nT2NrUTExWUxoY2ZSL1A0cktXMlgzYTR0WkRuTG9XVGhVK3ZVaVBrS1ZPYnJiS2Q0TVhXNURMRHFwcjVYK3dXZzIyU2xRTjRHM05tQy9icU5id0tVMkNvNWJ1MnUwYmZZcmpqekt0REFiR1E5ZCtZTERyU1lENGo3Rkt0LzNYcTFWNmlIM1dHN01BcG1BVjlrczUzOE1tcW13ZElGNjJva3MrdkFtYklRK2pjcDd6ZFdha3ZkYVpxRTlxWGh0OHI4NzN0UTF0cjFkMnhXa2pTN0xMSThsaElTWEpPR2NzSXZLNDVONXVML2ovdW4vT1BnUWY4MG9hOVRQbVFFV2x0dGNQMHk1ZjRQLzBuZUxoRmExay9nc01IL0Fuc3V3emJmOE0vNU5WeXY4UDhDNzZoL1NuSHVmOFNjN3ZmK0Q2U2V3bFUzditJc3BXZnJERnBBVlBBdS9GM0J3bFp1V3pmbGV0cDdEdlRhbVcvcDVZWHJYTnNWaUJSOEY0cXduY3NLMXdHcUFHbEJ4WFk1ZWxyaisxWmJKYWREYTFNNEJHMXh2VXF4VEg2dkkxd1dybmJ2WFJaM0dZRUMvaDFjMlM4SDVxR2RnSFlaeU1sQ2dRZlpuVzEySlR3QkNyN3BtUTJ0dWkwZE1UYVRJcFZkays1dHFFdnBmTDVtTys3MHJTQUhqNjZEZjRiVzVOdTVjUGFYMzJOcXBYeTdrTGU5K0R1L29WNTRaZkcxZnhFTDd3elNGUHVOSFowTzdqc3hCLzRlWXFpMnVoWEVXQS9hRFhZWHMwdGdsWGF6NStLLytCbWQ3YUg1QzNMejgwejhSUlpuL3JXbXgvbkxEdk9pZlgycGlmejd0WjdlN2JPRjFyWWVZemRvdzA4YWJjN1JhZnRVZS8zMWw1UmRnZCtvUjd2RVFqbVJ1bGU3dElWcXBpVS9TMnpOMjJXbjJjWDRXeXNLUyszNExLOGV2M3hoNjlIOTNjWGIreDNmUVR2YUlObGU1cTVBSGxTUXNOWktua0hMa1NwVnJWMmI1aFkrUVdPQ05LeFRnN3RIMmpsalIwSGxFT0Ira3VPUmxyMVNNZU13MUcreXVCb2taTVcxb2RiWGN3eWpMNUlNSmcvcHZnVTBnWTIybDk3b09RYS96OWVncVpRcDh2elRMbFVvb2FUNWx6T2JKeFdSekQrT1o5UTlSaU0wME85QmFtVSsxeXJGeUNVbFF1MG81QVBrNnZIWHozei9tOXZyUHR1bnZydXd4Z1B2YWNqWHQ0VUxWNXZoNzdzZC9COXRwU3Zjaml4Y2FMazJTd2VLdEtOUVB0UGIwaHo0dCs2SzVJbnRLOStoZjIvaHdEVUliR3ZycHNKY050TXFxQTNpZERCMk8vVGZ4UW43djMxdHQwanVJdjVpYzNtYlcreTJzZDA4TzdUUDBGR3dZM1pNd1Q1THZNQ1NDblpQMmd1K2Jsc2Uydkd1TGV6N2U5cDNDTUd1d3pLS2pveXRKbitIYnpDN2JNenZ3dGdPdWxMVzk0blNGdG9sVXFRZDVmWTJ0eXc2SGdXMktOaE4vKzlwTjkyRm5sRE1xNHIxTDRHSGRGbS91THhnOXorOHBpNzJYRm83eUJacTU5c0t2eEhnbHhWNmExak9BWDZoSlZ0MEZ0Tzl0OWJPNlBhZWxiY2J1VVhXQWFaYnpEZmExWXZLM3dFNXhSU3NBMEFud0VKMk5oQTJBczMybEJGWCtkWWlZcGxCY1h6UFVqVlp1dGZ0YU9FUXRucnNtdWZVSFBxTkl4djZuZU1UeGZmdjNXbmt3NnNuYi9EMjFRaXdCMnozVzJRV3RockVsbnVmQS9uRnhmdDFzMVR4OWhHYTF3WHlzdUg5dWg2L1hyTzlaMmtLZmswVzEyQ0hJbi9adkE0T1lUOW9zajYxRzd1MDc3MkhzNWhLYUtReW9SSlo2VlVMMGhLVXp1OTYxQlQwNjhsd2YyaTlzcTNSZ1ZSdWtzdWhOSEU5MmExTE12NkY5cTlIK3dhTzYyMWVaMDlQcURLUW55N1c5MXF2R2c5U1NSVlEzSEtXMkM1bExkNFJzNVY3UkdVV0w3dTNTREd1UzBDNDM0MUJDZExLZnhBcXNka2ovQnhqOEdSZXNmN08wdnNPdUZrdVNzTXhQN3N6YVQwOEFac29ISnV3UmJNOTkxSG5OOW1UbGcza0w5dS9yKzJoU1FTWlNkTW9iWGFPQSt0UjBLaFJVYTc2RTA2QS9IZUF5Qk10SEVkQ081TjErNXBOS3JyWDllZTJmSGhyZUw4QlRhdzhoZlBwd2hWaHVKNTZscjJmMzZIZlU3Q2V6dmZGb0F2ZllJMWs2UXFmYUNucGNaNlRMdDV2NUhXdDNQYzNVZksyUzRWS0dGN1IxUHhGWDF6TTdQZU1MNm9ZQ1BNM2U5bmRLS0VPV1FqOThyK0tFUjZFWldJOTJITjM4ZmR6aTllWjN4Yml0UE96bm5Tb3YzOWVaSXd1c2FlZTh2NWk1NDc5K1VxWmI4bnZNSllXNnEwYURmTzVncThZbTBmazQ4SStYeHB3TWk2bVc5THNuQXJpTEVlUHZ6ZEdDdmVSNkc4M1FuekJ3UDZqVENQSE5VR3FGQ2h1bGUzVVJEUm9uV25HdXZ5b1I3ak12NnNZU0g5V0xyRlNyNExhRE1ZVjQ5VlE0TG1aUXJzbzNVUExLYmp5elVHdWhGOHZqalpLYkNyeU5haUlDdnZkWmV4bjg3dS9mYU5oQWVFVmZvVUNXNnVzcUYyMk1wTnFSdDVPcTRteTBGaThoZmFTQ0hZa1UzaCsyQzdmOTd2MnNwNk8yZFYvS3Z4WEJnN3NxMHF4Z2xDc3dHS0J2UXB5bGV6WHFwQXgwZmpFaW12d21SS204MWRZTmNTN0gxUUNDcldRamQrMVFCcWhrWEk2VXNjajkwc2FxNzQ2Q2ZUWHlUcEZhVTNLdi9FNlN0ZnFPdEk5cm1jMFdzL3BCenBETDJxSnp0RXl2YWtiOVZ2OVhuZmFVNlQzOFd6b3IvVWdNaTdTQ09CMEJJaHJKSWpvU0ZCaXp5LzMwdEdncjQ0Qk1SMExlbXVNUGN0K1BJanJTeUNoRTBFZmZSa2tOVGF2WDBvbmczNDZCWlJwRXVpdnI0QnFuUWw0RGh0a2REWW8xemxnb000RkZUb1BWT2w4TUVnWGdFcGRDQWJySXBDeFo1YXJkS2t1ZzgvbFlKQ3VBRFc2RWd6VlZlQUx1aG9NTTRzY3JtdEJyYTREdzBOdjlqbzlwZitYOERmMXo1VGxXeUF1bmtRbXpKUEloSjhEcGZZa2NsLzlBUFREamo5Qy8xZEF1WDRNQm1pK1hpUE1rOGpvc0FoVTYrZWdTanlKVEhnWk9NeWVRUjZtTjBDdFZvSnEvUWJVYWhVWXBEZEJiLzBXUlBRV0tOZnZRQit0QmtQMU51aW5OYUJNdndmRHFibXpOTkNkN2M3V0lIZU9PMGNaZDY0N2wvQjUxR2pHbnZhTjJ0TythWHZhZHdoY21mT0FRZW9GSGxITVptU2xJS29FZUVSOXdHZ2x3VEhxQytKS2dUSHFCLzdSV3QxOWxMby80VFFZYTI4dXlONGNtS0VoWUppR2dncDlBVlJyR0RoZWh3UGJRZFhmYXppUWVkaFVlelplNWx0VHpiZGt2bldMUFJzdjRVL0VmeEZJSjRDcDVsc3kzN3JOZk90Mjg2MXBvV2ZqN3dnOUczK24rZGxkT2hWY3J3bWdqeWFDZTNRYWlPbDBjS3JPQURKZm5HNisrSVE5TFQvSC9POSs4Nzg1NW45UG1QODlaZjczVC9hMC9CUG1lYk4xS1ppank4QnM4Nzg1NW4renpmK2VOUC83Ty9PL3Iya3lPTk84OERGTkFaUE5GeDhYdm9nSFhnK1N1Z0ZjcXh2QlBib0o5TmJOUUxvRlZHb3FaWmFtZ2V0MEIvaXk3Z1RTWGVCZVRRY2pkVGQ0UVBjQTZWNXduMllBenBSSGVnQ2NyRm5nSkZyN1E1Sm1nNk0wQnh5cmg0SDBDRGhDYzhFb1BRb2UxRmZSWG5vTWZOR2Uzdjk3YXpsZnQ1WXoxWjdlbDdXWm02M05TTFFaNHA4RnRkWnlicldXTTgxYXpwMTZIa2d2Z0NwN2huKzZQY00veDFyT1U5Wnk1bGpMbVMxYUR1R2xvTnphejhQV2ZyNW03ZWR4YXo5UGlQWkRlQlY0eXRyUEZOV0JhNndWVGJWV05NZGEwVzNXaXA2MFZuU250YUs3UkN1aUJHdkIrZnBYYlpUc1NmNzc5QUY0VlBYZ3Evb3ptS3NHOEtnK0JGOVZJNWlyelNDdEpqQkFINEYrYWdiL3FDMUFhZ0VQNkdQd29GclZKdWxUTUVIdFlLSzJndE8wRFp5dTdlQU1aY0VrN1FCZlVRZTRTRHZCeGVvRWwyZ1h1RlE1Y0psMmc4dlZCYTVRTjdoU2U4QlY4dUJxSitja2U1dGd2Q3R4eDByMjFzMjk3amozSmNLOGUwTjRuRHVKTUcvZ0VKN2t6cFJzQkxqZm5lOHVJbnl4dTFnM3VVdmNaWko5SCtOR2Q0VzdTYkt2WkpUWVZ6SVM5cFdNTXZ0S1JuLzdTc1pBKzByR1lQdEtSc2Era25HWWZTV2p4cjZTTWNTK2tqSFV2cEx4QmZ0S3h1SDJsWXpoOXBXTUVmYVZqQ1B0S3huSDJWY3lUckN2Wkp4b1g4a1laMS9KT01XK2tuR1dmU1hqYlB0S3hqbjJsWXh6N1NzWjU3bTVicDVrMzhjNDJ0NkR1TURlZzVocGJ4YWw3RzJJZjdEM2kvcmFPeEgvWU85RTNHRHZHczF5Qzl3Q3lkNDRlc2krcEhHaHZTc3gwOTQ3bW1YdkhUMWtQZWxVNjBudnRwNTB0cjAzMGN2ZW01QjliZU5ML3dzQ00rRkRBSGdCaFpacmNKUlhIY1ovdi9mZGZiT0VGRUlJRUVJSUlRMFJFQmtFeEJrSkFVS3NwVUs0aFFBQlVzSzFhQWhJUXNWQ2F5K1VVa0N0dHhZcVZxVzAxTjZzMVdMckJUdU8xbjd3VXovNG9ZNzlVTDlZTmZhdTlWWThzN3RkTnpRenpqUHY3em5aOHovbjNUazU4L3dYZ1ZKdWpzWVN0VjYxckowUlBkMzl2YlNRQXJoMGlURkFSSXFFREtXVU1ZSnlLcWhrTEZWVVUwTXRkZFRUUUNOVGk5WklUSm9TaGpHY0t4akpLRVl6aG5HTVp3SVRtY1Jrcm1RS0gyQWEwN3U3ZS9wNU44ZHRnU2J2c1crSFpUbHU3OTI3eDRvY2QrN3YzbVpWamoyN2QzVTdMOGZlc01xbVBBL3MyVzlMam52M2IrLzE2aHo3d3F4dGVlN3UzV2w3bm4yelBteG5nYlBkVXVBY2R4WTQxNTRDUCtMK0F1ZDVzTUNQZWxPZUI3YjJlZVE5N3V2emVJNzk0V3Q1VjQ1QUJBaVlIMVVCa2dHdVlCaWxES2NzakVZd2tuSkdVY0ZvS2hrRHlIaEFKZ0JTQXNoWVFLb0JTUU5TQThoRVFHb0JtUVJJSFNDVEFZa0JTUUdTQURLT0JxN3hvZWg0OUVMY0dyUTY3by9QeGsra3BxWmFVbDJwdzZrenFZdXBsOU9aOUt4MFovcGsra0w2TDBsZDh0dVNxU1hQbGZTRTU4Vk1rcW5Pek15MFpEb3k1eENRREJHUHNzWWJ2Y25QZTlFSGZOQ2J2Y1h6M3NxQVgvQ0xmc203L0xKUE9jdUgvSzdiM080T2Q3ckw2OXp0cC95MFBlNngxNzN1OHpQdXQ5OERYdTluUGVqbnZNRkRQdXdqUHVwWC9LcGY4K3ZlN1dQZTQrTSs2eW0vNXhPZTlrYys3VFArMkovNFUrLzFHNTd4bTM3Zko3M1BIL2hEQnZ5VzN3NzhqbWU5MzNQSUdoSkt5R1R2YjFuUjZVK2tsa25VTVpucHpLR1pSWHljcS9nRVY3T1VhL2dreTFoT0d5dFl5U3BXczRaMk9sakhlamJReVVZMnNaa3V0ckNON2V4Z0o3dll6UjU2MmNzKytyaVJXempOV2U3bkhBL3dJT2Q1aHQvd0lyL2o5N3pFSy95SlB6TWdUckhSRHpyRER6bVRHSkFNY3BFcnFLT1IyYlN3a2k1NnVJRmozTTA1bnVScElyczlUTnJscnVOVmIrTnZsTmptZWc1NWhMODczNStUdU1JTjlIczc3OWhFNGtvN09lQlIvdUVDRWxlNWtkZThnMy9hVE9KcU4vRzZ4L2lYQzBsYzQyYmU4RTcrN1NJUzIrM2lUWS96SHhlVHVOWnJlY3NUdkdzTGlSMXU0VzFQY3NrbFJHNzFRbUNmUHlNaVJSd0VvNmxCV29PR3N6YW9qQVNJS0tXV0dPTm1aRWJlb1o2WWlOcDRPbEpWR0VFOUloc3h1Ky9XN0JtbUNpZTFQZXZEcUtTR0JtWXdseVphV1VhNzg0bXBwTXltNEdPQ0x3ZytObmh6OEhIQkZ3YXZDcjRvK1BqZ2k0TlhCMjhKUGlINGt1QTFsQ0V5dkhEempZN3loOEpmVVhTUVVsN2xFUDBjNERWZTV3M2U1QzNlcGxCQkRjTVpjTGx0cm5DbHExenRHdHRkYXdjUlVrRU5GTzArMVZZU0lFMDU5Y3lsbFU1aVFGcUpvNHFvSWpqRVlVd0VzekU4UUw2bWpzaS9Ca0pNNUV1VVkzZ0FSQ3FJMGVlUnlyeERQUkpUd1lDTkpJQmtpQUU5aTNia2F3YlBIQ1B5bEUxRHp2VVFlemlvYnNqWk5sSjJaUlVOT1QrVHRNMDU4ZktRRldVazFwZ1h6dzVWd3g4cDRaMGluUm15Nmhka2VHR1FyaCt5N2w2RzhmQmxhaHV5Y2graDk3NVBEVVczZUtCb2hWUWd6WURBbFVSQkEwRzR6aTA0cUxJU3FjWENYaEV5bWhwQUpDWkNsOXNCNzl1L3Zuai8zQnEzZW9oU0lxU1Z6VkIwVjljenpjUDVYQStKN3EzZTVoRnY5NmgzZU13N1BlNEpUeFlsL1A4eStoNVBlYnFReHZjWk1yZ29nYWNSNXpNNHBDK2o4bjF2TE9Pb1lqelZUS0NHUWhvWDVXa3ZmWnd1Sk9jcjRwUkNXaGErTlkyVVozdlFlVU8zeVhlUHgzdzgyeTFDWDhoMkJTa25wSDlneVBsOGJ1OWhMeUduczRrYzhyZ29WZVpsUFUxWk5sZnFtZXF2aUZuS01wL0wrZ3AvU2NSU2Z4MjR6T2NEVnlDeXRDakRXeWlsbWxycWFXUTZNNW5OUEQ1R016b2ZiVUlYb00zb1FuUVJ1aGh0UVplZ3M0aUN3dHVCT1VIRHNMQno0Z2xFcGhlZFFTVWxYaWp1akVSQnJVRndsdk00YVAxMWlLd2Q5TmxUaUplOTV4RkVLZ2Q5dGhLUmZVWHZibUNrM1F5ZGNhY1pDSktSeEZRTStYL2ZTTWllb3QzYWFIQ2Q2OTFncHh2ZDVHYTd2Tll0YnYyL3Z5UDZMdjhsUWVIT1oyOTY2WDhCUUdhZXVBQUFBQT09XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9zdHlsZXMvQ2lyY3VsYXJTdGQtQm9sZC53b2ZmXG4vLyBtb2R1bGUgaWQgPSA2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///63\n");

/***/ }),
/* 64 */
/***/ (function(module, exports) {

eval("module.exports = \"data:application/font-woff;base64,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\"//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc3R5bGVzL0NpcmN1bGFyU3RkLUJvbGRJdGFsaWMud29mZj8yZGFlIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmFwcGxpY2F0aW9uL2ZvbnQtd29mZjtiYXNlNjQsZDA5R1JrOVVWRThBQUxCa0FBd0FBQUFCSDdnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJEUmtZZ0FBQU5iQUFBWDY4QUFIQkdpR3N3NVVSVFNVY0FBRzBjQUFBQUNBQUFBQWdBQUFBQ1IxQlBVd0FBYlNRQUFEMjhBQUNPOHAra0FISkhVMVZDQUFDcTRBQUFCWUVBQUFxNkVKd1EzMDlUTHpJQUFBRjhBQUFBWUFBQUFHQlFPbEc1WTIxaGNBQUFCY0FBQUFMb0FBQUVYaHdVM05ab1pXRmtBQUFCSEFBQUFEUUFBQUEyLytzc0htaG9aV0VBQUFGUUFBQUFKQUFBQUNRS2VRbnBhRzEwZUFBQUNLZ0FBQVNwQUFBSFJPUjBGSnh0WVhod0FBQUJkQUFBQUFZQUFBQUdBZEZRQUc1aGJXVUFBQUhjQUFBRDR3QUFDR0hBUEJXNmNHOXpkQUFBRFZRQUFBQVZBQUFBSVA5Y0FGQjRBV05nWkdBQVlxZk1OTk84ZUg2YnJ3ek16QzhZZ09Cc1R6VXZoTTVsL0YveG40M05tZmtKa012T3dBUVNCUUJDNmd1aEFBRUFBQVBsL3ZRQUFBWXIvM2ovWEFaREErZ0ExZisxQUFBQUFBQUFBQUFBQUFIUkFBQlFBQUhSQUFBQUJBSW5BcndBQlFBRUFvb0NXUC93QUVzQ2lnSllBRW9CWGdCUUFTY0FBQUlMQ0FRQ0FRRUJBUUtBQUFBdlVBRGtld0FBQUFnQUFBQUFURTVVVHdDQUFBRCsvd01wLzBFQXlBUGxBUXdnQUFBQkFBQUFBQUhzQXNVQUFBQWdBQXQ0QVpXVXkyNGtOUlNHLytvSnlWeVNBUmFKWmpib2NCRUxrbFE2eVlxRXpTUlJva2k5eW94bWllUXF1N3F0dU8yUzdVcW5od1ZiZUFsV3ZBUHZ3THV3Wm92N1lCV2xtU0JFZWZQNVhIeCsyOGNGNEl2aUZ4VGdEOThWUDJRdXNJbVR6Q004dzFYbVIvZ2F2MlpldzRzKzVpTzh4RTNtZGV6Z3E4d2IrQncvWjM2TTlUNzNDVDdHZHVabmlYN1B2SWt2ZTk0cUxrWi9abjZPZzdYTnpOdUR1anZZWUZYRjJoTUE5Nk1mTXhjWUZ5OHpqMUwyUnVaSG1CUi9aRjdESGpJbi9VZkZkZWIxZ1gwRFo4VnZtUjlqczg5OWdzOXdtL2tadmhsOW0za1RsejF2alg1YU84MzhITit2cTh5ZjRFV3Y3VlBzRk1lWnR3ZWFkNUEwMzZocFo0VEhEUlNtNkdBZzRDZWk4OHErb3pQZldhdjh1ZmIxS3VoMWxQdG56c2pyS0l5dXM5VlRNdFBLVEgvYjN5b2Z0TE4wV0k3SGg2ZFVkVHE1eHVQeEVTWVE2T0NoWVBFT2hMUEVYV0lMaGI0STZVQ0NvaGRTellXL0pkZlFSRnNWM1FrTksrNFBLcDdRMGZqd2VCWmplM0p3c0Znc1NzTUpaZTNtQjI5bWF2ZENCVDIxU1JiT29lRlJJKzhUcnhFaHNZOHpPSmhFMTRnUWlUVHFEMklwUjFNZlRSakd2NFdDUjBqc1lFRTRSSWx4R29jNEJhRkNCNTJ6eGp5T3JsVFNKS0tTcEMzdmdLb2xYVG9iSjZKS1creWtkaVdkdTNicDlYUVdVMURqcUZWV2Fqc3RIMUNuRVVDSkNSRWVBaElLYy9iZGd1RFFnRENCNXRPT2NEZ0IvZXNlOXgvZUkrY2M4WjZPTVVOTW8wMjJnelFXUEVxWVFZVVNOUnpteWZzR015anM0Z0tLVDJnS20wL3JDaXF6UUlUaWlocDJVSWRRWVFuQ0paOXI1QzZxc3RJT2tzKzc1TDA0dEZqQzgvcEpYVjZwZ1V2VWNoM0psaW5LaVZnMG5hRXVxRldEeFptaXh0a1l5SG1lU0JFRjFja2l0RldTRmpyT3RPM0RxTkZHQlZMM3RlbGtncm1UdWxtbWE5a2pyMFFJYWw2WlBMTml6aFNpOHduSVdXcTc1SzNOa3NTZDBFWlVSbEZRL2s3NXNFcVFPa1JkZFpHamhaWEpaMHppa2w3WkpYWFd2Q2RjQjRyTDFrMjlhR2U2cHVDYXVCQmVKY25HVUtXbzlTNm91b3RLbHFtM1BBa3BkZFRPQ3NNTjVlZGlOVXRWMU5iVGgxL1E1QjljTmVmdVJOZktoaVNKYjJLQmhydUgwQ0ZBOVowV01lTlprMjh0c01jUFBCSWlzVWhVNXhpUmUwZUNzSURteUdUNWNEVW1EUVBGNnlyY280WkJCNWt0YzdqRUdnMlcrY2IzUVBCUUVBaXNjNDRLNWoyZmhjQjhZQXZjeFQ1YktML3JGbDNPVFRXNU13WHVJRmlQWUkvaVhBV2Y3TnpsZlFVSnphdHEvaC9Fd2RvQ0ZqTG5tVjVaQ2NJcldLN1N3Y0w4eDRsckJLWWxXamhNK1ZXMWJLOUJDQndac2VDM3J2SXBHMTZyNG5rTEQ4ZXIxdWp5ZXl6ejIvT3NVdkllWXY3TENaakJLL1A4djhtK3ZCZUZMVHo5WC8rS3lVUFcvdlh2c3IvbTJ3cmdVL29MN1VlNHZRQjRBYzNPNjIrVFZRQ0E4ZWU4Nyt5d0UzQjBVemJyT09ld3R3VUdGVlFVNXBVNlphaFRCL09HdDZJUWhLS0NHQVFEV09ZTjhNWUU4WW9CeEVzUkZRUXZDQnBkMHBJaFhoQk5oTHFlby9OdTlKdUpDZWxlbThiMEgvQ0xUL0o4L3dIdXY0Y1JBRTRITGdJSVUrRk1BRmFUSWtBUUdNaHlmREZPeE1VME1VTXNGc3ZGRTg0K3A4ZnBkZGU1YVhldis1RWNJS3RramF5WERWTExpQndybTJWY3RzaDJPVjh1a2F2a05oVlNXa1hVSEhXSFdxdWVVV20xUzJXMW93TjZzQjZpYTNXOWJ0Qk51bFVuOUN5ZGFjeDRtN3lkM2lmZTU1RllOQlN0amE2MHp0R0tmdC8zb1dTUmJDeGFKb21wSWxHMExDdGFza1hMTjJWTFpkRVNra05sV01xU1pXTFpjcGRNbFMwSk5VK3RVZXVMbHUxbFMzWFJVbGUyekN4Wk5ucHZlZnZMbHBUbEtDV0w4UC95Ky94dXY4dnY5QmY2cy8xMnY4MXY3cS9zRHhUK0xzUUxzVUs0VUdjUDJZTjJ2OTFuc3paanUrMXV1OE51dFdtN3dkNXJsOXBGdHNQOGFhenBOVnZNWnROcFVtYUJTWnJwWnBnSm14b1RNdFZta0tuSysvbSsvSUY4VDM3dXQ4bGNWMjVGTHBtN05SYzhFam5pSGQ2aldnS1RuVFlFLzU4Q1RoQkE4SjlWTGhVY1E0QktCbkFzUWFvNGpvRU1ZakRIVTgwUVF0UlF5d21jeUZEcXFPY2t3cHhNQThPUUtEVERhY1FqUXBRUmpHUVVUWXhtRERGT1lTempPSlhUT0ozeG5NR1pUR0Fpelp6RjJaekR1WnpIK1V3aXpnVzBjQ0VYTVpsV3BuQXhsM0FwYlZ6RzVWeEJPMU9aUmdkWGNoVlhjdzNYTXAzcnVKNGJ1SkdiU0RBRGVKQ0hXTVhEck9WcFh1QkZOck9GbDNtSlYwanpHbHZaeHV1OHlSdHNad2M3ZVp0ZHZNTjd2TXRlOXZBQkgvSWpkektUV2N6aFp4YXppZmtraGNNaTVvclJyT1JaTVpLRllveUlNWnU3aFJLTllqaUh4U2ptc1ZTNHZNcjdyT0FXYmhjak9DQ2FoT1kybHZFTE45UEpBenhGaGl5OTVQbWVQZ3lXM1dJOEg5UERId0orNDNmUktxYndFMHY0amgvNGxmdDVoUHQ0bE5VOHpocTZlSXduV1ErczQzazI4QnpkZk1wWExPQUxEdklsOS9BMWgvanNIMUI3QWhoNEFZV1RmV2lWZFJUSHYrYzg5MTZuam1aYlhwMlQ3dFM3NlY2OGUvUE9OWGR6bXpPMXBXWmFSbEYvYUVackNlVXlyRDhTakpwQlkzK0liNWhvWld6SlJTeElBODIwc0JCcUVJbTJFVmNUbTIycDJYeVp1cm5UOTNrWVk0blFoUS9uOXp5L2M1N2Y3M3kvOTJpTkdRQ0lmNUFZMHFRRnRmb3JNblUya3AxeHlOWVdKT0VDYXFVYUU2WEdkc2x4bE9zOFRKTkoxaTZyTVZyU3JWOU9XVnhYSUVOZXd3U2RZbWMwWk5kMXFmWG9ST3ZUQ3FScE1zWm94RXhuV0pma1FDVEhPcVFIUWEzSExNYkowb2NTSjR1MXJYWlFWeUtnYlR6L0dHTU5LU0hYK0h3U0FZbHduV3VtbnpOT1E4Qng0MFZ5Zy91TEdYc1pYMmVjejV3bHFOSTlpT2htMURybnNVdzMyVkZkZzhmMVRUc25sZFlwUjFBbWMyMnJScGtqZGtpQ2NIamVDRjFtdDNRVS9EcVA2d3lNa0hyZWM0Nzk1R29sWSsyT3BOazZMVEpqN0hkZU50TWFVc0RjSjZ4Tkg0RmZtcmwzMlA2Uk41Q3FNMW1yQ0RsaGhOVm5CelNaZmY5bFo2alRXT3JXS1EyMlhac1FvZmFBMlJITndTU2UzNnN2c1k5NjZza2NyYkNiOG81ZGRmSVJraDlRcEVrSXNJOFNWM3Z2WFl5YXZzY2VYa1NWckVlZXhGSE5lLzZ1eXhIVm5jekw0UGZIVzVzVVV1dDlyQS9ZU2RZbE93dkladTU5WTErNnV0OExYNllkOEx5Z0Q4T1J5SC9SMHhnNTVNUGR4SkRMZUovbnhYQmNMeGF3WmpuMXB1NzN3cW0xWHM4TCtqQWM5dGMvSEowT0RQbHdOM014UlFzczRYa3hISHFoejlwcE4zcmZLTGZMVW1HZHZvZVE2VFN5YnI1NVBnNzlaMXpmL3JZVHNzSE95Z2FvcC9zTFdJU3Y3SklrMlRXME1XY3RDdVF0bnZXaEpad2dJcDRIRytuOUNrRFM0ZjEwTFVLK0l1U2dIV1g0QmNWSTJGSFppVExaam1MWnhmV245T3dBK3c1eEpsWUJ6Z0N5WkRwMW5rcmZwdHNkSFc4dEVyY0IrUmpNUTFTYVVDU05ySzJqNzgzOHpnN2tjMitNRkxKbXZWMlVPT04rdXlKTnBKSFV3U2ZOZGx0MjJHMzlDQ25TaWJEekNtYTU5NVh6dkxmUEVyNGc4WE05eWpwOFNkYmh6N1NPUUI2ZnU5bmJGZXIyTnVOSjl0WGw1cEZzNjVWTzloVkR1aVNzbDkrcjFPdDJ3bm1HR2x6azk1K3piczVBdGw3Q0ZHY3BGbmlFRVBNMU0yOExZcTVldWcrTHRCUWhlcE10dXkwdUdheHRRYllUUTFnZXMyN2RobGxhVHlwUjVlTHV1LzkvWnkyZTlpaXpReTY2RWhPY0V0YTU1R0d5czlDdU8yazhONS9yLzRIOW1POHAzdmN3OHJVVlFXMGdheEIwNHVRTEJBR0Eya2FvYlNGbkxpeHg2cjJmejAxa0k2bERPVDBvb0FjNXpKdkF2RlI2ME0rOE1jenpNeThnamFRT0tjd0xNQytBR1lBNzE5S0ZoYktIOFJqWnpQcEg4YVQ4akZ3NWpwa3dWTWhJdXlVSEVjVU56TlRkUE9jNDRUeExBbG55STZJeUZUUGtWUlJMTVdwNFZyV3NRNkV1Uktuc1FwcDh3THR1UTU1V0ExcHR4cGhLN2lmcHBJRnNJaW5Fei8xejVCYnA0Zk5va2tieXlDaStPOHY0TGxsRll1UkI4akFwMVNWMnhjMGhJNGlmVEJxc0N4T2VZMzJNR0NSbEVPWjRkU0ZTU1VxbENoa3l4MXBsTmNaS3BmWElYUHRFMXZCZEEyUFVCalFKQWU2TjA0Q2RrcHQybGZPVXhYa3FHSnlSVTNvWm1iTFZUUGV5Nys4NWsxdVFpKy9zREw2MkxyUmF0N1lPK1Rua3I1VGJCVmxzZjBxcVhaTzluT2ZaZHBickRubmZmaVA5OHJ6MVlUL24vUUd5d3Y2UTFkYU9iOGxuMXY0dmxJa0xId0FBQUhnQlkyQm1ZUGovQlloVEdRSVlzQUFBWGFnRHF3QUFBSGdCYmYwSFhCUy8wemdBNzNGa0Q3SzRLdWNpM3JsM0N2YU9IY1NHdldOWEZPbTlTYnNEUVVIc2dCMFZDd29DMHJHaVl1Kzk5OTY3WDd0Zlp6SDRlOTdzbmIvbmVmL3Y1LzJjWkxJcGsyUXl5ZTVNWnFLQ3NiUmdGQXBGd3dFaE1YN3g0VDR4NCtQODI3dEZoZnNQaS9NSkQvR1RzN3BMOVpnYWxVV05TaWsxc0V5eHNTQ1RiWlFQYlN4Slk3Sk1aQmgyd084RVJHSERGM1dQVStCVFlFdkRScFByTTU4b1hvWmw2akFOR0MzandMUm1PakU5R0dlbUh6T0VHYzFNWktZemZrd29FODBrTUNuTVFtWXBrOFZzWkxZeUpjd09aaDl6aERuTlhHSnVNbmVaSjh4TDVnUHpqWkdZLzFHd2lqcUtCZ3F0d2tIUld0RkowVVBSUnpGSU1Wb3hVZUdsQ0ZaRUtReUsyWXI1aWd6RktzVjZSYTZpU0ZHcHFGSWNVNXhXWEZMY1ZqeFN2RlI4VUh4WC9MWkFGblVzN0N3Y0xGcGJkTEp3dHVock1kaGlsTVVFQ3c4TGI0c2dpMGlMZUl0a2kza1c2UllyTGJJdHRsaHNzNml3MkdOeDBPS0V4WG1MYXhaM0xaNVl2TGI0YlBITDRqOUtLMlY5cFVicG9HeW43SzdzcXh5cWRGZE9VZm9xdzVSeHltVGxRdVVLNVhwbHZySkV1VjFacFR5b1BLNDhxN3lzdkttOHIzeXFmSzM4cVB5bUJPVWZTNldsdFdWZFM4RlNhOW5Vc3FWbGU4c3VsczZXZlMySFdFNnc5TFFNc295ME5GaW1XQzYwekxSY1pibkJNcyt5MkxMU2NxL2xFY3ZUbHBjdDcxcytzM3huK2QyeUJsbWl1a2hBZXRRTzlVUUQwRWcwRVhtaEVHUkVjOUJDbElXMm9ESjBBSjFEZDlFTDlKMVZzdlhaSm14SHRqODdpdlZtbzlsa2RoRzduaTFuZDdINzJUUHNGZll4KzRiOXh2NW0vNmdzVkNvVlZ0VlJOVloxVUhWWDlWY05WNDFUZWFtQ1ZGR3FKRldhS2wyMVhsV29xbEpkN2hBWkh4NGVIeG5TcVZPbmdTYlF2NU1abUo0NkQzQ1dRUmZucmliUTMvemtObUJtQ0kxMDd0U3BoeG4wTkFNM0UramEyUVM2T1psQWowNW0wTlVNdXBsQmR6UG9ZUVk5emNEWkJIcDJNZ01uTStoc0JsM01vS3NaZERPRDdtYlF3d3g2bW9Iem9QaVlLRG5xNU5SbFRFUkFrSThwM3IyVEdUaVpRV2N6NkdJR1hjMmdteGwwTjRNZVp0RFRESnpOWUlBWkREU0RRV1l3MkNjbUpzb1lIaEFZWjRyRXp6U0JtSkNnWUhPQ2Y1UXgwbFRTdWJzWjlEQ0RubVpnUnQzZkROdzZtWUdUR1hRMmd5NW1ZTzduZ082MGdiZ1FuM0Qva01EQWdRSGhjVDR6WTZMODQvM2lZdU1qSW56aVFxSk1qWFYyNm1ZR3pqRSsvaUYrZEErSURBeUpESWxMREltTUN3aUs4UW4zbVVtckpRUkV4L3VFUjBiRm1XQjRRR3lzS1JJVUUrQVRGeEJqaXZ0SHhWR3N3VEt5cmdPNkJZYlFVdjYrVVFsRE85TVo2eElYRStJVEZEOVR6dXptMWlVOGFsWkFaRkNBSDkyQndnT0dPdlhzMXNYVThlNmRUWVRxNGRURkRMcVpBSjFuRTNBeWc4NW0wTVVNdXByQjM1TGR6YUNIR2Noa0cwVFoxVXlUYnVZbnVmcGdONXBvQWwzTW9Lc01CZzBlUENzZ0pvcnllVVJNVkdTQUNjWVpvOHd3T0NiQW5CSVlGUjlqam9RWXpDbXhJUWxtR0dBSWlEVEZBdVFaTmNVaVEvNGlNbUgyajR5S29KaE5rR0kyUTRyWm5DSmpOa2NvWmxPRVlqWkRHYk1wWnNZc3gyVE01c3laUG40QkhRSmpmUHg4T2tURitFZjZta0kvVStodkNnTk1ZYUFwRERLRndhWXd4QlNHbXNJd1V4aHVDaU5NWWFRcGpES0ZNMDFodENtTU1ZV3hwakRPRk1hYlFvTXBOSnJDQkZPWWFBcG5tVUp6TCtNQ0tTMThBeWpKZ2lMcGczOVVPSDMvME1qTWdCaS9BSXFOeHNMall5bndpNkljYXM0SWlmS25FWmwrRkZEcTBaRFNqb1lteWxGb29oc0ZsR29VVUpyUjBFUXhDazMwb3RCRUxSbHRlRlNrS1RzaTVMOXhtWmNwTUxFd2hYODVtc2IrOWlpV1B0RTFFU1NueE1mRUJFVDZKZEpvWW9BWmoxOWNpQmxMVkZDSW4ybUIvQjFFUkVpa2FTUVI4ZUZ4SVRQRDVUcitJWVlRZjdrYnRIUk1pRnpyNzk3NHY3R2U1aUhIQlVmRngvcEV5dU9XOXlnSy9vdnQvMnN0MHFmL0xzZS9vL2ovR2NKL0gyZjYwRTdMbTA0SFA1L1lBTk9Udk9XWUg0TVRad2JUb2NoUlg4cENZUUZ4NXBMLzl5eVgvYitFZ1A4bk8rRC9NZ01TL01KOUl1UWR6UFFZRkMrdi80aW8vMFAzOTJYeC8rYitiMzNhMllCWW1aYi9peUVnMHQ4bk50Z2NqVEJILzlhTXBiTVJMdVA5ZjFQK0Q5ZVFEckd4blp4aTVMQ0xUd1FscUltWTlLbXJ6RDhVZG9zSkNBcVJKemJBbE56ZHp5ZUd6cUpQZUp5Sjczejg2TlNibzNIeE1aR0JYb0gwbjFlSUhJU2JJTjFRYWRYWWtOZ09rZVo5KzcrUDhYNS9VK2krYVFpZ2ovOWZPUkUrZnJRUkd2SHhpNCtUOCtUZEx6NkN6bHlDL09Canp2U05DVEJYaklvemQ0UEdZK2pvS0lnTENmZVhzK2dPRytRVEV4OFI3aE12NS81djMyazhQdEtmcnFUL0c4Ti9QL0dhMEcrOEp2STNYcE8vSDNuWDVFKzFPa3g5cGlYanl4VFN6NitMQ2h1RnEyS1N3a094V2xHb3FGQmNVRnhYZktBZlRvMHRtdE1QcGlrV015MFNMZFpZbENodGxCSEtlY3JseWpMbFlmbzU0MkxwWnJuUzhpbHFoNGFpVVdnNkNrQlJxQkpWb3hQb0xMcU9IcUIvV1V1MkxxdG1tN0J0MkVIc2NIWU1PNUVOWkJQWVpEYU56V0QzcytmWm0vUURSS1d5VVRWVWFWVURWT0dxMWFwOXFwT3FTNnIzcWkrcUdpdldxcFZWTDZ0K1ZnT3RSbGlOdFlxMHlyREtzdHBzVldoVmFsVnB0ZE9xeXVxZzFTbXJpMVpYclc1YVBiVjZaZlhGNnJlMXBiV3R0YU4xVDJ0WGEzZnI2ZGJlMXJIV3lkWUxyRE9zVjFybldSZGFsMXZ2c0Q1aGZjdjZrZlVyNncvV242MGw2MXJNNEhxNEFYYkViWEI3N0lJSDRLRjRESjZBUGJBWDlzZkJPQndiOFFLOEdLL0JXL0YyZkJDZndkZnhQZndJUDhPdjhGZGN3MWx5OWJqR1hET3VKZGVXYytKNmNMMDVOMjRvTjVKejU2WnhnVncwbDh3dDRsWng2N2tjTHA4cjVpcTRuVndWZDVnN3kxM25IbkpQdVpmY1crNHJWMk5qWWNQWjJOclkyK2hzSEcxYTJiUzM2V3pUM2NZbFYyd3VEaE4xeit5YVlrN1pCSE8rWW9UWVc1UU8vU01RbHlYTmlJcW91MkU5THh6YnVHZmZGZTIxL0dtQlN6SVdwOC9YZzJVbllYWGh5alhZOVFVUmlUMzlJVEtjNkw5M2dicWd1blgyWXBsdUpoNFFjUGlpbmhPV3JseTFkSzIySUcvMnpIQ0RNU1RFbUYrVW1iRXNjN20rdzBLVXZpQmovaUxOOEpQalg3Mi9lUDdhNGJDZG5sbTZiOGMyZjBDa25FM3NpY0NaSmN4NHhCRXY2RWw2Z1RmOXVVQXY4QUp2UWlIeDVyYUk2cTJRSndtT1dHM0RDWnNpZzFmUDBCSmJoNDVFMy83QzJFZlBiNTUrZWNGbnYxdHN4UHprUlAzK0xZZnlxN1dWK1dscE9YclNwcmxRbEpNWUV6VFRHRFhUbUZOVVhyU2xTTS9uUEVPa0c3dDA1WXFWYTFmY0xiTy91SzFxN3huTldjK2pIWnpjM1YxMWJ4ZWdYVG41MjB2V3hNK0tUMG9LbjZQakMrZjRWM1Z5eDZUT2pkWlE1L0xleW9xdCt2U1U5T1M1R2k1Y2JDVUt2YzlQZi9qMjRzV0hGMmZzR1RqTHVDZ3RXWmQvQWtFSGR0TVRSR0xZdnFUdmd3Q1V0WGI5NmkyVU5rbFJRVE1UWjhaRlp1L1E4eUdGa1R0MjdTN2JWeGxkRXVBZEhPQ240OXBpMHViUFZNUkwwNE14ZExIcmoySDhPSkdNYjQvVjF6SkU5Yk9PRkNiZ25xSTZzQlhtNW1mTXk1eW4yNFhUc3pKV0x0Y1VMU3RiV2F4N0pEVkFuTkRwL0lUWG9Ea0JEWUc1UC8yS0l4RW5FYkdGN3N0UzRVRHVqMHRWMlZHaFkyUGJqL0pPS1MzVjhiYnFaeDB3TndKL01VQ2JGaUlINGlnUnJGYytFbUZzSENhMzJiWEhVZldhb3J6ZDJ1S05ibUlYREJkT1laMzYyaGxSR0l6bnRVOFMwMFE5VncwUmlDaFo0a1hHSStnVkxYUmt3UnFVdEJkbkt2MkdEOFNVTGNhU3JXaGUwSktFUkUzSGs0Ti83aithdDZkUWw1NmNNWCtlaHBNT0NjL3VIT3YzQVBlQ2x2TXhhVVphSW00MnJSOEJTckRZSUc0R0VXS2dpVko2WE1NSWVXR2pOdmJYa3Zta001bElacEgyMzl1Q0JwcUQ5VTlvQjhyKzk0anQrRW54UVdGNlVGUzhQL05OdTM5ZldtS0ZucXdpazRRTHUvekg5aHMzWTlSb256Mm5yeDgvZUZuUHc3RU1zSlZDd0U1UkRZNVNHM0JVU28ybHQ4TDNMd09KSFVIT2J0MFQ5V1FjbkFCYjRxYjZ0T3ZwWjlCcndJUDBnSHBrQlAzMUlQV0lCOUUvYWZYSlgwZmNpQzB0T0k3dG51TnlDNUFHN0w3YytLN2o3MHRLMUpsTkR2SUpHcE0rZTVqOUs5YURKQ0FPeHBKNjBJQ01uWXAxbkVCT3NiTjZ2TWRwQzRqTzBZdTRXZjNMSG9IZXY1NGNLTGZpMjhKWUdBVXpRakVaU0NaOUlWTVJ0MDBZTnNkcjdreHRUUHl5NWJSdnJDcHRXODdDQTlxSHp3NkFSWjcrZ2RRWVFST3dKTmJzMm1Qb1l2Yit0VVhhZ2syTEYrWG9RYVhLaXBxOWZMcTJWM2RQb296WEozUkVwQTZ4L01UeStWTlI1b29WbWF1MGVUbHB4b1NFdWZGZWhyTHNlZm9KbmlneGEvL1VlOXBudTQ4ZTNCbFZQbTJGbnB1YnFkOEtDc1RCVVdIbHhnMlphN1JIRHM0Y09kUmp4dURoQVFmT0xNdkl5bHlsSjVwa3RHUmV4dnpGbWlaUEhLRURkUG9HTFBBZlJseHl6dExCUktpM0RiU28xcHVOSXhqQkxwYk1JQUxpaFVYZWhpalA2T2t6N1YxbmpCdlpVdFBsUm1kb0RpMC9md1A3cFRwU2J6MGFHakN5ejZpWVhidTI1MVRzM3FvN1dmYnE4T2JibVJjYjdZRjJ3dTZJVXU4WnZ2NGUvdHZDOWgzY3ZmdWdqcmVUWnJJRndDRnlqZDFZWEZSUW5BMjY4L2IvSHJ4eUhSU2FyNE5la3JiRXFTT3hJSG9kTkppTm51ODRlZmRLZ1kvdjVLQ1E0WkU2d2swaWRtUEhPUm1JVmFORmk0eUxOSHpKaXZYWm03UWJOc3lkdTBtL1lqRksyWnlmVXFJOWMyajcxdzE2N3BuWUNYT1YwQk5CRVZzSWRSRXBZam5pVFhvU2VadHk4U2UyTS9YSi9SRTNCdmEvZytGdkZZZStRVHNxc2MrVkxncTcwd3RqcG1uNlR3L3hDNHphVm4yNjhzZ1JIYmdPRXQ2T3V0NjZxWk16cWR2eDBxQVBZUFh3QTFqb2VJRjBaNGtOYWJNZGM3a0dxUzRnNERtMjF6S1JHNGV2ZzdxenFLN0hRWXMwVEpwTUVMa2c4VHpzUkNmV1ZSNDRwVDFVR09tVmxqNTN5Vno5YUxJVDhXeXZNaEU2MUFTSFlnK1NqRGdFSGRrM1h6QnNZemwyRk9ZRVVvZXRmZjFIUkZDSDVkSkExZDBnQ2NCeHRNOUttQ09kRjNZVXhNN283eHZnR3hoZFdIMjA2TlFKUFRkVGpNSmN6ZGlSSXUxVnpWUWp0MnhMUnQ3cUNwd1JQdGRUMTYyMjNWZ3h1REJtKzU3SzB2M2xNVVZCM2lHQmRFdGpBekVIbFlLcnlLM0E2bVBmN2ZwZ1htaTcxUC95WmMzcWpPV1pXVG9peEtNbDh6UG1MdEswdWtFYXdSUndldmNMbE0rOEx6bFU2NXkzSTA0b1hibGhYYTUyYy9iYytldjBxeGZTQk9JT3RrUUFkKzZnQU03UUMxeUk2NE9IeEFWY3dRVjY5N3BQbk9sVTlJUmV2VnpCbWJnUytvZjRaK0owRVViWlRSZjUxeG1CSWdkMjBCUHFRbmV3NDlBY2tSTkdqZllZTUs3YSs4ekZzMGV2blptK3gxMC9oYWlFYlZzMzVlVnRTRFpFR3hOajQ1UFc1K240aE5VcDJibWFiZmw1bFNjMytvZnJRSldEVGk0Si9rQmFhQW5xMTdmcm1CTFBPMkg2RTdHSWc4RVowRUM2YjFSSWdkQkFJT2RaNkNBTlFPUlQ3VW1oWmdoTDhtdW1JdEtHNWFHOVVPdEdGSkliSzlXenJIV0R4cCt3Q3NwY1NWbHZSQ3hVa2h0bzZTcHhEZkVaczlqWkNpcFlEaWFBTzdTSFBHNGVKanEyUlcwRWNaY2lFT2t5UVFTUi9WZGFBajYxU3hBUHVjbkpkRXkrcGVGVkIvYnRPTW9KaFlBUjJjZkdFRXpSdFdGSjQ5cTVDTHF4SU5Sb1RBdkp5NGN1cENLNmtIYkpDMGs0c1gvZjhYMmgyejNHZTgyWTVGVVdkRmpQclo0VG1zVmRTeFc1WGFMVUVSeGtqa3cxY3ZDSjloNW8rL1ZWY0lnNEV2cUhTRjJWSktmeHNGaVEzRWc0Z3ZvcWNnZ2NnZjRocUt1aXc2V1pRL0czR2xHZ2ZDRzhmbjM3NStPUmw3dHowRWlLZ29ZYzJ5VmI1TUNlNVRxSmZISVM1a0N3QzhOYysyNTlIWjNQRDMvT2dmSnFQOEp4aTBSYmpyNGxPVklmMHE2SWNCelNva1g2L2pKeThlSWxDbWRoZFNjdUZsK2FMNjZDZXZkRjd1dUVEeGMvOWYyaS9zREZpU0hhcnNORk1wSmRkeFp4d3pGaDJLWXdBNlpCQ1BvK0hIUEZjMWJQU3RURUpNVDZUSXVvckZvcWY3dm8rTnE2aUlQM2dwVDRxemFSSldjc3BVUmdhSXhmaFNkZWJqMWxRdUtNTUIwbjlLVUU5eXNKMzd1dmF0Y2h1bXQ2ZS9qN1RkUHhyOTBNQjE0dk05cHlUM3BDRTJqL1JNR3hzVVNGdUZYUUNPWndVYnZYNDVRWmswTjlGODRaWS85ck9WZmJoVFprSnpXY0tQSmdyZURRU3hac3pnd2lGcVEzNFpvVGxaN2JXcW90MzJTTVdwQk9mM3B2TWcxeDk2Rzk4Y045Vzg1dzZ6NUVHQldjMFhZVjJIUHdTK0R1cFlDMXcwK3BvWkZEbDBVT05DejNIWlMrZ0hKQTZRZVd0dXBjVHFMTjJhYURYUURvb1JrNGpBS0JPeXZXWnE4UitaR1kzNWV3Y1dhb1prcTZiOUFRTFE4KzRFeC9QbHh0M1NDUk8yU1FTazFOcVo5eDRIQ1ZzZ09kZFphRGNia0c3bVdoeUpWQlU0cGJBTzFza1doWnpqWVpMTWRDL1p2UWNBQ291RERNdndmOSt4U2o3WjdQWVBlWlk2T0lGb0VkV3dSYXhNR2ZGUVp3QlpVMG11SlBCaDVVWUFHaFZ5aHBuMGtPOTNHUFdnZGFab0ZBR1VWUkc4WHlSekI4cGdYdllpVUhPcFlEbFlJTDB5WVlWNnhOMEU4dlJCeWJWYmhpRGU3OWdtTkRTTGNIdUFLNkljcTRvSDEvN1Qyc29mVXl3QXFjdnNGQVVDcTRKS3hZQWZaS0xncnp3ZzdNR1dwOGFJSEhFUFZZd2RWa2dKck8yd3M2c2ljUTlVakJFYmt0TE5lM2hudHZ3SnFXRkhLVHN4S05tckNFT082eTRSOWczdng2UzFOdmE2RWxLRUNBb1p4NzBQQkEvVTEzVkpyUEhUaVhybCtXa1ptNVRFZDdESzR5SlVVRlI4ZVM4NFpqYzc4aURwS2dQZ2RxV3c1WWxxc1FZWjVVVitEU2xxU242OWJ0UFZqQnlaaHVtVENCWXdZMGxNYlRWVk56VXVDZ0g4c1JPczN2azhGR1dnZzI4bGk3ZllBbUgybEhPY2tWNmlnNHI4a2h2b3ZtakxibnBuZ0VCbnJxK0RucEtha2FqbzBnVFJDM3QzSjdGZmY1eXpkS3kxYWc1bjVLcVlnanZTbktoaXluVUN4U01BcVdDV1lZNng1TU1zTzRpWW9sRE9OdHdRUXhqRC9ENURKTUlNUE1ZNWhTaHNsZ3FFNmVXY2NvMGhrcUJ6S3BESlBITUpzWXBvQ2htbmxtTnNOa00wd3N3OFF3ekFLR1djc3d5eG1xdjJjMk0xUjN6K1F6VEJMRFZESk1tWUlxOFprS2h0bk9NQlRQVG9hcFlwaGRGa3cxdyt5MVlEWXd6QUdHaXBqTVFRVnpsR0VPTTB3eFE5WC96Q21HT1c1QjlmNU1Ec09zWVppTERITk93VnhtbUFzTVBRcGdWakRNRllhNXdUQlhMWmc3REhQVGdpbGk2UEVBODVCaDdpbVlSd3p6Z0dHMk1NeHFobm5PTUU4c21CY01QVXlnWndmTVNvYkpaSmhWRExPTW9VY016REdHZWN3d1p4VE1LNFlKWUpnNURMT1lVZEJSejFVdzh4bG1FVU1QSStocGhDS1RaYUlZaGxLcFA4TllNVXc4dzRRd2pKRmhEQXd6VThIRU1VeWlnZ2xUS0doejlJUWtTODJzWnhURlRabHRqT0pDVXlaQ29maG5vZUs2TEZLM1l0b3lIUmduWmppdHZsOHhUcEZpNFdqUjA4SmdVVVZQRXI0cW15Z2Q2T25CWkdXUjhwanlpdktGcFkybHhsSzBIR0U1MGRMZk1wVnErMDlaWHJPOGkxcWhLK2dXMjR1ZFFZWGtkSGF2cW9WcWttcTZhcXZxc3VxRlZUMnJSbGJOcklLdEtxekFHbHQzdHU1clBjTjZqZlY1V2FURkZ0Z2U5OE9CT0FHbjRXejhpNnZQaFhDSjNHYWJoamI5YkR4c1Z0b2NzN2xiWjBDZGlYWDg2eFRXcWVWZCtmRjhGWCtPZjFXM1VkMHhkYWZXRGF6N291N1Blc1o2WitxZHIzZTdmdXY2UGVzUHJyKzAva1piUjFzbjJ6aGJnMjJLN1hyYmpiWlBiWi9iL2xKYnFPdXJtNnJicU51cEE5UkI2aVQxSXZVUzlTcjFidlhEQm9vRzlnMmFOdWpjb0ZlRHFRMlNHbHdSTk1JZ1lZSVFKQmlFYkdHTFVDSHNFYzdhc1haYXU5WjIvZXhHMndYYkxiTmIzN0J1UTdHaFU4TStEV2Mwakc5NHdqN1FQdEkrM2o3VHZ0citpZjAvalhJYW5XcDB0OUU3alZMam9ISFM5Tk5NMG9ScG5taHR0S0sycmRaTkc2eGRxRDNVdUd2amdZMG5OSTVzdktweFVlTkhqZjl0VE1TV29ydFlyTlBvZXVnOGRMTjFLM1FWdXQyNm83cEx1aXQ2QzMxVGZTZDlxSDZKdmtSZnBxL1FiOWVEL3JmK1R4T21pVTBUK3lZam1nUTJTVzF5b01tbnB0MmEramN0Ym5xbDZiOE93eHdtT0hnNXBEZ3NkU2gwMk9WdzJPR2l3MzJIMXc0L0hCbEh6bEZ3Yk9yWXlkSFpjYkRqQkVjdnh3akhSTWV2emFLYkhXOTJzdG5kWnFSNW0rYWptMGMxMzl6OFZRdkhGc05ieExUSWF2R25aYitXaTFzV3RqemI4bjBybTFidFdvMXFGZEZxYWF1THJUNjNGbHAzYXoyeDlaeldWVzBjMnpSdk02eU5zVTFxbS9WdE5yWTUxN1p2VzBQYkMyMnZ0NzNiOWtuYlorM0VkbTNiVFdnWDJtNUp1K3AyLzlPK1hmdDk3ZTkwVUhWbzJXRlpoenNkbFIzSGRDenVlSjJlaTZ6c3RNK3BpVk9ZVTRSVGxGTzBVNnhUdkZPQzB3S25GVTVibkxZN0hYQTY1M1RINllYVFY2Yy9uYTA3TitqczBObXBzMHZuSVowbmRQYnFITjdaMkhsVzUrVE81N3FvdTNUdk1xZkw2YTR0dTQ3cW10TDFiTmR2M1ZUZHhuVXpka3ZzZHJsNzQrN1R1Ky90VWFlSFQ0L1pQU3A3M08zeFB6MWI5MnpUTThJWk95YzVMM0ErNEh6SHhkRmx0TXMwbDBpWE5TNWJYUXBjcnJyY2MzblRxMkd2d0Y1aHZlSjdKZlc2MHV0eHIvZXU3VjEzdXA1M3ZlbjZ1SGY5M2cxNzIvZHUxSHR2bjNaOXV2Wko2RE83VDFxZnhYMU85N1hzVzY5dno3N2VmUi8yOCt3WDNDK20zNXgraS9ybDlDdnBWOVh2ZUw5TC9kdjBEK24vMDYyQjIxeTNiTGNiQStvUFVBOFFCalFjMEdpQWRrQzdBYjBIREJvd2ZVRDBnSlFCQ3djc0czQnh3SWVCdW9IZEIwNGFHREd3NkhVR0tLUVVVQ2pTS1dSQW9VeTNreDdVVEsxOXdJS2k5aDlCU3BHWTJoUVZYenVISjRtbWYvMnp6NGwzSVZ6NGg0WEcwbHhaRFVHRVA1cFY0bENwaVFGMkdtM3ZRTnNkMEZiOURPd2tUaGhQNVgxSXNSdVBlVWg3SlVJbm8rS3gxRVNBdXU5RjR0Z08rT01ZR3A0UW9kVUhvbVpMb0FtQ2xoOXByQUk2SVVjMmhIUkNYMFE1N21DS0UwY1dFdG9LMFBDOStFWGtuN1V6ZkFWV21nVG9oOUYySGRUM0JTM1VBM0VFMktwL1FUTmlKWURpbmdqaXlrY2ZQbXZ1K3A1dHUwL1h2d0tGcjAvWVdxR3AycjdqdUU3OTc4ZTFBMkwwWUp1SFRvYSthbHFtMjRHSmdqVTRJb0xudGV0RnJEU3VlOGMrRGRDdFgzZzRkdjBDSy9YdkhRbWI0aUkwbnVtQjRlN2FicG5CNTg1cVZ0R1AvOVZVekRPZzlJWHA4OU0wL2ZlMUE4c3dIUS9INTc0ZmFZRFk5NXYyaWlma2J3UzFsb0dwVXI5dW9qcjNtS1FseTJoa0lBTkRhMXJLMzBsajU0RlZWNFAwR3l4c1YwT2pXVkFmbXRBaGhFdmY3QWdESFVEMWFRZTRrVEF5dkFmWUZLeEhWM2ZjUFBaZTgyckFMYUpzM25Ra1VVOHA5TndhcWx1ZGtyb0FxZmQwbURKNFhGTk54MXRkUUgzamRPSCtZN3JzdFVnZGQ2US9JcGRocEhDa29PandObDNoK2sra1NkcDhXam95T01nWXFQVUlyZHlqaDlhd1JaaVZqOVRsS1p0U3R1WnJqbGZsbHU0cWlnME9UNGp3aU5ieFpKMTVaaFYwWnBWL1o1VW5ycVM1NFhlWVVWRUVTRmtFdmtJbWFYV1MyRi9zK1BxTS9lZzNnYUFFVGdOTEFJTUxkQVJMM1ppSGlJUVNSMkpKWnBETkdwNjRrSmFHM3lGR0JRejVqR0dmTkVLQTFwTkJQZVNUenNrZG5lKzhuU2pwREpCMFVwZjBKTzJKdGU2Y0t3Si9hQVVjZUVHV2hnK0VUMVRRbzdVL1hjYkVnbzBuYXFMWTVka2VsQUd0bTkwZTlmSG5XY2ZYWjhkK2d2bzdrcitRdWdHSWYzY2RReUp0NlAxc1REeEphd09NTVVBdm8yTEpOY0czSkt4NjlSMDhmclR2dElXemg5aURldlhYTDlCQWN6Snd6NFFKWHY0VGRQeENrUVJzTU1Bd28rTEJBdUZrOWY0VCswSjNUQjAzdzNPaVYzbmdZVDF2WEdtb01WSXA2V1JOc0VBYXNMWHIvaGdSMkxJODJDUURMdzJHdW9wdElFSXhpRXJvQ1drQ1dPeUZpV0Q3Y051RS9vVHhJbE5KL2I3aHgrL3B2cENWQXN4NkFodkFCV3hIUUgzU2o2UzRrczJrTzdHOVRPcERYejFQNmxDUlpaVHBZdzM4N1VDc0VYTngrOXBSaUQvMVdyd01EY0NIdGhBNlNEeVdESnpVOTRxWUNscUlCcjBTZkFhSVA3ZGhPRk9OUWNrV0FKWVZYVStwc29XNHNBUnFGUWlPenhTb01BRnpZVEhpRDEvREMwR0FlRnB4b1J0KzdDSlcwRWFMTjRqU0NTcnMxS2F3TWNRYXdYM1dPNHpFa2hIZHlYVXJhTTcrQXc4Z0VucWYzbVhGWHoyQjB3c3hIT2lCYjFlTFZTQkNGRFJWd3BBQm1FeWtGQnhzaEhGeWFLcys5bVJCcktqdWRCMGV4b284bVVnY2pISm1WeVA0MHZ3S2NmRmx3Yjg0Zk4rcU8zalNXRC9QUlhPRzIwT2RWUjgvQXE4NUZyeDc4aVNmZ01rNnRUMTBndFcwOXVweU1TOVJCQUVjNUc5V3habmxJazJSL0JQRVRka0dxUVk0eFJHb0J6TkFwNFIxRUNxczJKZFh0TCt3ZXB2OXcvMm5MM3pSdkJyNGtqUW5yVm8zSi9aTGRGQnZOcnF5NC95OTg0VUIvb0VKb2I1eHV2RmhYVDJNL2RLSE4vSWxiVmVKY0hYYXE0K3ZJT3IxNXplS3dxOVB2MHZzQjZYVWI1cnc0SFBwb2VQNmFWZVJ6L2poczBacXlWaGlDYmJnQWtOcFdBZDYwWDR5clVuVE5sTUhlQmhTTjJ4YXVUU0xhcE9Qd2hMVWpwM25nM1ltZVc4SzBEYnQxSjQwYkg1cDRJdDlCL0oyRitqRDFwUkhIZFgrL0NKckJkMUpCMmhLZkVrWUdVeTZrZG5FQ0s2a0hjelJuNUE2QzcyVytMcFAwRTR4N2pwMlpjK1pzL3Z5dzZmcCtYRlkwUUh6VUNjRFZEQUdXQmdFVnJaU0N4QmJmMm9OZXZVNzZIUVpqOEt3bTRWbTM5NkErcmJIMGVrYjlPcFhEL0pPMzMraStUanlCckhWVVo2ckZuYkNJUFNFUFZjU05XUFVOSitCZXRLSkhCZDJ3UmowblZWL3ZWUWM1amxzb25kL1BROEpTZEJJbW5sWWxMcFQ3citLeVdoUWs4WXdHb1o4QmNzZmUzVmV0Q2RoR1dBblRZWUdDcWxZWm9iZVlDZDhsQ1p2RkJjU08yRWxKcTBYaUh5QXFKQW0yTFVYYitVYW9CalVNQUFhS3FDWjNSa29SckNOTFFRMUl0dllIVEFBd1RtMkNCcWkybkZ2TUd5ZUEvV0pKVmlDQ0RZUUQzYTJ1MFQxZnFtdDlFWUFkSGp3aUd3OWFIY2pZQktjUUVYR2E0a0hjU2Z0NklJYUQvVklBeGo4OUhMRjBUMTZkY0ppTjNvZ2MwOUNpSHlsekcyRFlDYmJLM2JnT0tvTnNSNzJtQ0x1QndwZ29ENGQ2aHphdVFOZ0orK0MwcVUwVFBUc0dMSVRrWjNzV2FCQU4wRThJcDZIQXdoMnNxUElBY1RuWUlXN3lGOU1wb04vWTFTa1U4bE02bjRaTjYxZGdNYW1oUGhQMW82TDNuVnc3Vkw2MDY4OVFiUUpDNkxSd3ZqMHVBUU5RWGQ3Z2ozVWYvME0xTnQwb0pDeUVBL1RJckEweWc2NnM4UkgwZ0xBRFVUR3NlUVpPWG9CanY1dHV3bzh2NzlEL1BrTXNKZHUweTVPZVltQmwyN1QzRGRZb3ZWclNtaWZwN0xrZE8xS1lpbXRSS1QzQkJIczJSOVM4cy9hWkFRS0ZvNUxhWTYxYWJTMXRiUzFWM2FSWXBTb01JaktNampoSUg2bGc4OEREanpCUmlITkFBZWxtWStPaUtjZ0QwRjlGcnBtQXZzRzJtbEExZTBSVWV2Q2lJMXdveXg0U3Q5eC9uMzFyZGg5NEVueDVvMDJYREhyU1A3aTlSV1BIRm1iZTBCM3ZkV1BLd08vb3JzM2p3SURUVFc5UmRnWkpud2hEbWkrSVg1eGZEZnNNbk9JLzFSOVc5QlJKRHJhazIxZ0E1UGxuZ1JRanBLMGR0Q1NKUmF3SDMwdnZmTVViRFEvQnQ0bjlqcVNJWlBsTkd4RHI5bmhZQ05Vd1dUS3ZSZEt3cVlObnV6WlM4Ky9GTGVKZEQxcyt1a3RxbThGWWZXN0V2RTczZXp1ME43VldFcDNCQk9qbldTalNFTUVZU3poYSsrZ0l5SWw2UjNFejhXS2FsbWp2Nk5tYW5NTWZTTXdSRnpHeElIOXRVQ0VwcXpVVmxhTmRXVEpudHBDeEV2TEl2QXZhS0NVNXRNaUdiVnpaa3B6dG9vSGFNSG1MR1JKUzAvVUxrV2daK0dWWEljT0k2WTJkU0tWVzNub1RiR2VodG5DZHpJYlFSZVdkSWR2Y0FscUVlbkhVbDVPY1lRVVJKeFk2RVora0l2a040TCtMQStOYVoyNWNIUU01cC9TRmJYV0xocVRQcVRuOTVxMVh4VkF0YnRDM25kRTZyRFFvMll0QXY2ZVNKSlk0dnNmWDhSN21WOWhzRFZaZUNpUzBCb2pJaXpMRStmLzFxMVA2NExmYjE5RWF4aGF5SnBXMHVQUFdobFhmRFBFMzVHc0RQQ2JWbDlNUitnaDkwWE5RbDFJZ3Jva1NlWU40Z0cvRWIrVktFQ2hHRXdVZ3JRYUZMV3JLZjdndy9oZjZXQUE1a2RnV2VlakxsNk0xZGtHckM1dUxhcW5wSWovcGdDbTJsdzdzSVpvbzYzVUhqVHFCT0R0Tmx4RDZ2MSttNDc3M3ROQ0s3Q1FkUlBBRG45TDFPTTlEQkV6OWFlZ0FIMFIxUW1rM1o5Z0JKY2tPK0hjM2tBM3ZYby9zZXcvZHVSWW43M1gzNSsrZFVmSGx5V2ZGcVY1OEVFb3dFVC91U05vQU4rOWRhOVN2d0R6N3lhSk1IT0x2SnU4bE4vcGplaEMzNEdLa255MzkzVEhoTC9SRnVxazYvOGVvS1dtejU1THV6V1BIbU9sNlNoZDBwZG5yTTdTWkc1ZFZyNnExSXBNZ0JMVENSSnRmU0RXOGJGWVlWTG1LYUU1bkhBVWVhSWVKVzRRNFNOVmp1UURRbzcvdnlkVkQ2VzZpSDlGZkVBRkdKU1FEdFp6amJaVGdIT0hSdXBYa2dMMkNCM0dqeDh5S25EUDJaY25UdDA4VitrOVVhZStWOXVWbkJFNjB6Tys5dUQ4bE5ac1ZLUjdMMDFFeEk1TkdZL1VyeW9TcHBYMTFoSkhCMWt4VDZ6dTBoUFFrM3Z5Q3picjU0V2lib1laMC9wcTFlL2NRdmNmMGZPdjZXSm9DQmlpNkdaaUJYb2wzWUJXNFFtWFcwM3pTQW9NMDFFeWgyTFMvay93V0RFRlF3NmRmYTZtOFJSeHpaL0dBdFc3ek1jT3RaU0pTUmp0dkxWMHp5Z1hTQXNUNXZzYms4TFNyYUlUc3RLMThZNW9RVlpaMGtIdDR3c0hQMnpSQTVhT3pNZWJvTk1Va2I5aEZHRUZ4ZmpBRGxxenBBbHNoeVVRZ01nb2xrd2gvWjVMcmN3TkI0bEYwT2pPUmJrVnFzY1BwdVViMk1uSEJPWmN1dkFhMEFIWS8zQUVhOXVhamlDcWQwaUQ3TTdEWG5SeVhYblZNZTNoL0hDZmVXL3hLRklWSkY2QzQyalp4cVViTjJnK0RqL1hZZnJ3bEZFZXVuM3hYaVVqdEpPbkduM0Q5T3ByOUlnZ2R4VTlJamlLTDBBVk9yMnViTTl4N2FIOGNOKzB0M2cwcVVMOEkyd3IwNGkyTWNwdWhhaStOazJNRnhWclJXaWtoRUxKcmhubWY1ekVkTzZrdHFDaFc4NXB5VzRkN25oQ1VOOWJ0am1qY0NYRmV3OFRkZTJISVBFb0xFVUJXNCtIM2hEMXRKelZpRmZFZHV6a21LQW9IZitXOURIQWNGQkJLZGhRemVNS3VsenVTVHVsVklFSWJNb0VwSDVYTU51dnlvbnlwODJ0MWpKL0h0cTV1YkJRUDQwWWcwVDFQZlU3SWtnM2hYT1Yva01KTTJiRTBORUJWVmNlVmI5OHF1YzdVUm94MEhDeC9FMG1zVkFqRklFR0xVMmR2WFNXZHBEdnpNQm92VHAzeFpiTXNxd0tuSDRVSHdJalVoLzd0ZlZzeVJudHhvMkxGMjNVODU3SlgrRHU1ejEwSTAyR3RzdXcrbFlJalM0VmlkVUNRTEFGTUxRMEtrNUFZeVZNWENCVTVxNWV0a3EvOVY5NnlEWjd5Unh0cUhGZHljck1WVXRYNmZlQ0QvcG8ralJ0eTVaQlMwUnMyT1NoYUdwcVZNUTRyZEdrOG4vQmVwSlF0SGgyK3B3VVRlK2pIczkxZko1b213ZU4vNkdMOUxXVTJwT3VkdytjZjBlVXltU0t0R0xKUVBMWUd4NGpJckl2YWxPRFJCNnUzQkhoWHptekI3a1NBMWNRSmR0QnlxTFFtQVUzZUZsRlhpSm95TUpLS1hXclNOcVNxd0Z3RmZHRnRFNEV0Qkp1azFZSVdyQ0paVzFoYUdJWnpJSk1lL2xreTVZMEd3ak5FR25PUWdNeW44d21LeEIwWmZsRFdBRUtNbTRzNWpQbGI3QU5SMFdKczR2QnBBN3AvQlVlZ2lVOC9HcDdCU3pkd0xMQk0vVzdYTmdxVk8rYU5ZM3lZaVRSSVBYWGhZWWxDYk0wN2M5TS9xb3J2aWZHc0RPaWNnNWtaY3JmQ2VYUUhsSGlyczFjczBaelpPYU82ZXQxMTlkVkhWNS9hVHU0Mmw5WnZ6M3Z1TGJrbnVqTGtqcHUwMGl6Q0gwRWFZYUd6cDRjTTE3TFA4YlBTR2NCZkg5UHY0K0p6MyttSTU1d2NtOGVnQ1U4K21vckg3c09BRXYxVjNnajFSYzhBbk1PcmM3TVdwcWxMd1VkYlhENWxxV2JOMm5lano3WVZoY203LzdiMlAyRlNhYnp1UlI5Q09sT3U3eGtibnBxbW1aNlljQ2hPYnBCczcybnp4a1pSRnp0Ujh3T2lKeW9qV0xqVzZCS0Z1bzhPQVdOU3loS1IzUjl3OUhjNDFvZWVvQTNXSHJKaXZ4VUtWTlNDc0d4NFVsQjJxVEVGVmxKc3ZKYjNXOXpjRUJXcUhhSXUvK3dRUDF0ZDFTK3RYUnpoWGJUcGtWcG0vUUhvcEU2MWJoOVIxcUY5c3JaSFZkMjZFMTZpUlF5OXB3SXZXQjdqSGdoMTNBUFdHbUdVVkVPdGtwb1ovZU4zWGp2M3hYWExwZGRiK1N3R3dVbGhJYVAxNDd5M25YNXg5VWpGOCtVQmdXczBvTlZlZW9aM3dzdVd4dHRlZjhjSjNaRFJKaERGSTZrdmFiZDBkN1BJM1g4djZkRTBFQjk2QU4xbEVlN1k3RGRpKytBRWdJLzR6dk9HSVNUNG5rNElqd1hrd2NqMHBjMXRFZlFiNThJZzluYzk0Z01ZZWxyaThhMzBMaUtCUjlZSXgrZWtlRmtTVTlZZ2tnejloOUNVeGlXVGhYNFNwME9pSE5ycnh3UStjY2tBQ3hycGxJYXpZTUd3NkRCSU5CV1F1TkJvQjRHZ3ZyVnduUmh5VHV4M2ZVK0lJQWxxTzZCc0R0cGIwakZRM3pEWTkvWVBUcW5DOGk0UGpVM1Y3Ti9aK2srbmZyOHdiTG9hU25wS1VzVzZFSElRa3ZYWmE1YnEva3c2QjZ4SXdwaTNZZlV2NExIZTdsb0JoNmFmdHB2RG9aSlVIWk5qTXJIK1VVYmRId3o2UVEwVmN5cEZKVnpXbUorRVg3N0ZzSmV2MytnZ0tEUHl0SW1vaFIwU3ppYk11MVNjeTFSdHVwSzZDRm9uMzlmblQ1NXVsRHZVbzRpazJkR2UybW5ocFNkZUhaODcrR0QrUkZocS9TOEt5NHB3N1pnK09xSm9mRUxMUFVCbG41T1FXTUJUdGZPSmhZU1J5YXJxT0M5Q0VQUzNWLzMzajVRMEZaZy9VWWgveGZhdzVadlNwN3BHeGJycDk5QVFxZ09hakswUUJkeTloNi9yRGszL2VoQUhWMlAzV3NkMFh1MkdQU29oT1V6Y1V0NExSL1lLS3BsVll3U1prZ0R1b2s4MUR1TllkRm5EQkNDbThEN0xBeGwzNVRRUzFyZlJod0Z6N05FeVAycWhLbFNaak9SSnlHSE1TeWZLdks5TVF3aC9RMDFWZDhVVWd2cGgvQ1JKWDMrVkZFQkF2clVWS0YvMkx4dnFMWVJTMmdYWEVqbmRyZjdmOVpuc1UxcjU2R2ZMRDhhazBEaWJ3RDFVZkZYdGpCNGFIL3gybVhFazlId1A1VVlQT0hEUWp4Q0xLSWsyU2VsZW9sd0oxYytEV3RuZUc2RTQzUnJiZ1ZUWnRDM0NsU1JnRFpZdlhpOUNEOHlubzJnNHNpakFRWkphYlN0NmZKTlBSMm16aEJyT0VrNVVhVFVIQmd1cXN0YmlWSmZFeUwreVRvalJENnhoY3l2Nm45Z2tPVGVUSVRYdGNONll2V2o3dUo2MFp2RUE1Ym9GMXcvME1FTXFFY2xkdGd4VUJ3alFuMHBiRHFtSXVVYjJuRWpQYkMzbHpwS0g0cmxIRllLNnlYblhEV2ZEOHFaTmhJcmZSYTZzMnJiZmxodE0xaWt1ZWVobVMxTWgrYmdCczNWaldINkVCRnUyblhDNm1jZWYwNEtyZVg2Z0I4cnFOM0tJV0VIMlNTLzRtR1V0RkhZdGlVeE9uU21JV3Btd3FiQ3NtMWJ0K21KZnFRUXNTWTZ4NmlyMWY3cE5GN2NTdmNkY0dRZGFscWc4c0t0dTZzMVY4Y2ZHZVE2ZUlTTGpwY3VVSG16RXF5eXpXZmppcHJHWUNjTUZTdStZRGpGYmdNN1ZGdkkxdjdQQWhFR3N0QUVuR1VMaUdEaWpLVFJiSkdjQ2RCV2dGeTRNcFJjUVR3a3lGTVdDdmF5aUF1TEpncjl4ZDA3b2V2YXQvL3UrZFRJQzFONTErVXJVVU9IV0IyZmplSHJERG93Q1A4UEZ0cUxBZUtOTFppUzYvMFVtcmJsVHdaTm9pVnU5WlZMckpRZmFZbTk0R0JMa1RlN0FjMG9iVUtmaVJzeGhObHRwRVUyVStxMEY0MFlCcy9BVkpCOHN3VlBwc2ZCa3ZjVXpOUEVubjNseE1zZzJqNEMzUUhRMGJ5ZWQveEZtRXNIRGlPK2dZc3NheCtoa2xFV1hCYWVzY1BJWlFTNzJaVllGa3U3eXhMRFRtRVhqRURRaHMzOWhraHJ0aEpjTm9vOHJQVVFyNjZtVTF6ak9JemFPSXo4RHk5RWl1bFlFdW1vN3BFbHRZOGNxRHg0VXVhRFY3UXZOUjNvd0M3VkJ0UjZPc2lGNnZTVkM4MmtUN1JRdVprbGFEbUt6SjRpTzFrcjFUNlRjN1pSZHRnbGxrQnpDSVhtcEM0NHFOdUJGK1VKSXZQRWpkcHR0V3NjeENkWERkSThvd0xxK0ltUU85TlFuaXhXR0UzaTRqUGNOM2ZvanNtNnZ0MGZEN3I1Q0lVZk9qdnJtalpDdkpOd0plaUkvdjdMWHRmNzlVQmxIcU55Qm1tbllqMDBYU05BeHk5Z0MvWTd5dEtTdCtuSVJmSU5wUll1S0szVVNCMWYvSysxb0RZa2ZOWDZHRDJjaGM5b1RjeUt5REFOdndGTGRlbVlyMEVKR2RRY3o1V3BUNFU5T21Rck91UnpqNmpFdHdIRHYzM2xFcGZvdzF3VGs5TVNCNkg1ZTJoT1J6U0hqbWllUEtKclY1bzJ4OURZUTZRbzFNZk1raG1keGswd3FGajhRTVhZSm1hQkdnU2pRaG9zeTlSUEpXOHFOWWRNMXZkSm54RFFSOXZDSkRlM3F2VVdUSXB4TlF0ZGdYMEg3YWlNL1pBMDBMZW43Q3dnb24rRFFaSDBkWVJCK2dIV3RqQVNMRUtoMFNxd2RZS0c2bEJKQjArRm5PeXN6Vm02dkRYb1ZPR0ZJNTgwTC9zK0pVMklKVkdNSm0zQ2RVMXExOGlmUHQrbE9laGx6dUhpdzlwTDJ3SWpBdUlOUGdaOWZDcnlNVXdMNksrWnN0TzNLbHBYa0VSMXhnVkphMlliTlhHellvTzlVa3NMVm1Rc1g3cENSeXpTVVBxODlIbnpOSU9PRGZrRkRZOSt1bmc4L01DME1sMzBKcXBRVGx3M2QwMjJodThpa3YxbkFqQ0ZNeUdnR0kvQVh3M1FrZ3BaTnJEQVdiYUxkQ0M5SEdWSjhQSG5pWjh5YVhvZUZRWlhVbUV3andxRFl6dUpha3R5NzZLUHFNYmxXRzI1R3F2eElMbndjMmdxUzQ2cktrVTFCeTFhWW5WQlY1TGFRMVJuR1dpVVZweVFJbzdBYncwUTNVSWtRVkFRTE1LL2MwRGhaQUREUTFEOHNrMkRodEllcUs4K0JQdmhnRURzRnFLV2l3YU9hYXZwZDJFbzFIbDVkbTkxcFU2ZDdMN3JjdGdkTGJDeW1haSt4UkdrUGhReUt5QmlvbmFJN3kwUjNoNFhpVGgydk1IZlMxY1pPYm5BVlV1c2VnOGVFSzhIaXlDMGErMzIwaVBhTTBYaDRkSEpzeUxTOWFRUDZTanNxOHpkc1ZRSGVNV1NPY2g1enNod1QyMWc1SllLdlRRRnNvV3IxRjUxY2NiODlDVjZFc29lMjdocjMxVXRYMmJhZ1U2TFlDdnZQcnQyL2xwMS9YcjVyVVlMTU5oc1J3V1lXRjdxK2lOV3p5OFIxVy9NVXFYYUh1ckIrd0FzSjlsTEs2YlNEREtaTEtYaVppeStURWx1dERYSm9MUllralBOS3lMTFRGbDB2NUF6bGxhS3BDNmxpQjAwb3RSOFR6eklUWnE5aDdMdlhLcXZoWVltY1gyUHpNVXRLT1pqRHJVSGkzQUsvbXJDUy9NdG5Ha2lOS285SktlK0FvMXRGVFF1ZzhhbTJqMnIvZkNWWkZCQkJpZ2czNmlnaWlwSWh2WktLYi9HUWdpOVQ5aXBvdys0RlF4WjBTaWc2YzVGTytlV0p6WHFFbERXQnpSbktvSzJUbHM1b1ZGbDdKU0NvVnJLdVV4VDBvSllQV29HTGFFUDBHbUgrQTlSOTJhYzF2Y2lINFJPSXljTkd4cDA1TVRyczBldVhLanlHNm1qb3RraG1hT01aZ0hOQ21aSnh5Z2JOYUJzWkVYWnFNRWdUSG52Y08weGdZcHRKNmFKaTBWWUk0OVJmUWs0Y3BVS2JvdEZhUjBkNmFYK3hKayt4WXN5Q1dYYkhFaHpwcW5RbXJpWWtnL0liZEQwTTJaNVQxMlBuSUpTMms2cmNocW43YlFhSkpjeUU3blJFa3BrSzJoRXR3b2RKZklOcXVtbk9ON2N4REJOaWhWOEtvUDJmaENyZ2l1OXZZT0RmWFMxU2t0enlsNXppcmVPOUlRR2dqUWJsTFd6V2Y1YU10UWhuRUhxQ1hWeWFmUEp1U0hDdGN1VVJTTjJISngxU2h1Tzk2ZnVOVmJxYjEyZmNHcndVRlFjT0czVE9LMHY5bHpydXlWSVAyQXdVaWRMN1dDNW9ENUVMQWRPR0JXZnNHSnRrZzdjWVFqS1RNdE1tNnRwQVVnbzJqZy9MVnRQeHBBaGFNbnE5RFZyTmU5UDNieXI0ek93ZWhzVnZEcFNQanBFVjdYOGJDOWxVMEp0STJ2ZE80cFVQRFB6aEZsR3M0Y1Z6alJyMmhoVERsMjBjdnBpY01nQzlSQndVTk9kbXRLaGxCUVJnVXB5b1I3NEVQNHluektTV1l5aXZKYjN1MjR4Qm5RU1F3emRLcnVDUnVsTHhnbHpUT0t5LzliallUZEVzNnc4YVdwOFdLVCtOQlNIWXVoRzNxekRWQmlUVzRNNmRJT2dKS0t0SENNeGY0NVMyU3dGSythSy9NUC9ha3REWCtMOUVBTHRMbXdGQzlKdTVIRll0VlVjU3E2MThJMGx5bTlWWThoMnhCTzN2Mm9HbmQxdCtQS3RLaDhzbXZtY2dpMmhlREI1MkRHUUZueTNjelRaalhqcFpUSTBJamhRbnVTR3NsWTY3dmN3dTdiWTBKWnVobWNpaHg4bEFuMURrZEZRbHpTRW9UZk9GK3c3ckZmSHBVNUU5eVJIUVYzK3YyOG13Z3k4RFRiUStqM1lnMjZlcU9jbHAyUlFndXJOVXpybEREQzJhMFdvUXhmeVorbERzdkIzZTVxSmgvcmNFdUU5M1pWMHc0WkZUdkhRSFFvZVYrcXFIWUx2WHl3N2ZFQS9lYy9GaUp2YXpuQmRVRDg1dG1tM2JDUC9mM3ZPajBqQkIrdlVuK1VaUHJmYmQ0Q09xa2kzZzVwcVNadElmdDVVdGljUC8rUlJaZW1GSUJvdkVjMmlQMTBQcll4NzVMM2hoejlXWDZpTnI2Mm1hb0RUSWJUWVVsRis5NWsrQVQyZytWTm9UcWZBWTRnSWlmSzc4UmdaVjV0dFVsUWVmaUEzTU1lYnBqblNiNmRvYkJhYlFmVklSbTFMcDkvS1h5NXYrY2RkaU1FcmR1UDMvVVJINmJyTVhvckh6aUl2eDJsQkJTendweUkzSmhxcCt1MVoraGdoVlF2QW5MbjFJRWZmbXAwNUx6NTBxdFpyOXJZQ3N6Vi9WNWErc0JhbWFJWldqM21uNDhrWjZaSUJ1aG9WQ2RML0NQNGxvWHNQN041MVpHZEVtYy9VQU84Wk5Oc2duVFJBTk1XcHJNa0lGc2tPRXZzRW5JMktpTS9LaHlSVzJKeTlkUGs2L2NZSEtIMVJXbnFxTmpyVGtMMU5jK0JrNWI1TnVpRUZhSEtpcTFjWHplakRnV2NwSW12cGlIa3pVdmVEUnFhTktKZHVFUDNvQnBGTE53aGllUmpEeUpxeHdndXhCMmtqMjg0ZGdUWUMwYkt0Nk5NcmxnOFZlNG05TVhTZUJ5elZpL0xBMmdJSGplalBYcDBnclpkNDRUNnd0U2NKKzZTV3A5anBIMW5FcXZmM3FIYi9XSkczYXVWNjNROVYrdHlGUzVLME1iRnJ0K3Q1c09GSmdIeW9EM3FZUjVVVSsyQmVrU2c5bE9PL1EyQmVDU2FGa3B0c1ZVZkhIU090RWNyaWluMVQweGJMTmx6N0QxWlVyOGcrYjArWWhSMDdPbXFtRndjY09iUmpSelVkWUprMDJRQk5vYm5pYVUyZC9kaHpVb2pQb2x1NE9uTFhXNUhra25ybXJJalQrL0VNbXJQd0ZqNFF1Zk90MkVmKytJRW1kQlYybDdKcE0wVitxWS9GL1N1eXo5azNlWW9QVjI2djFoRVBPNXJzTy9leHVFOU9idm9VSDlwT2sza1h5Y01BZW5CUVBLbXBJNFRtcnhOZnYvNmgyUisxYzZwSFlOQU1IWGphaFc1ZEo3NlIweUpwV2hCTjQvc1IzZ0JOYUpYd1UwSllmdFR1dFZsTE16TjFLVy9FWHl0ZXYvNnVxVFpYOXRUQkZMdXdyVkY3MXBpeVU5K0kvNjU0STJlYjhOQnNmakNNTk1DeEh5YnFHQzdqQ09Ld1hhUXF6VjE0QkRtR1FNbGVoR1AwSWUvSGRyRVVIQkEvT2RjQXpiNUQySGRvUml0TXNpdUZaZ2g0TnUvN2RyRWF3bWhKT1VZVDcxTk16U2ltWmpUSms0UnRGdzJtY2pRUjhjZEFhWkM2R3hWSDRLaEEyUGZ0Z0FYVnV3OXkyT0U5VVJHMmZYdWlvdkpQM1RVR29LVnVwd3FiTUJ5Mk83eG56OEhka2VXZVUzMTlwdnVWaE83WDA3Uk5tSmVLTTU2N0dXRDIrdzE3eFpOVUx2NGtXeWtjZkdhMlVwQWFrMHhoTUlZRXU4Rll2ZS9aV09uc1JGR2Q5S3ltNGJ3a2NZYlByTWhRZlZGMFFJNlhOazNjdTNkVGNiaytzbkRuclAxYW5vd3R3NVFhWDFlS1BKbE1vMVNXWFlGNXVEdjdBejc2QWNzck9idG1TbWQ1TFM4bEpaMHg1UzZMenBpdnB0dXFhRlRVb0JxUldrT01TdjJBRDVrS3cwdHo0YUZrR3kwMUFKNmZ4MGN1NENOU3JKTTRHZjZ6V1R3bWRXNkQrUTd3OGlLR2pDL0tRNUozVzdFVlBEc3ZIdjRIUzVxYXdTMUZJc0Ivem1KSlh6TzFqOWdKbnVXSUo5TkZPc0QzRHRnVm5sOFNIMzhVOThGL1d1QUJ6dWZ4eGd0NDQwVW5rWXp1V1ltaGxlTkMzTVF4QzBQNE4rV1BtMVFmUUpSWkl2aC9WWUo0bHFvRHh2YmNMQ2FGeTIwVEM5cjI4Qy9LcEEyMGFXSjVYa3o2QjhNOVNKZWI3bkVXdzNQWVNGc21LRWRjUUZ2V1FqdmFNbEZlRXNzK2lndWNXMkFZa1F6Y3U3ZVgzMzYrSWg0Q0VHNnppd3hMNHVNMHpxeXhJd0pMbHRoVkFPc016YlNYenVZVTdkZjdmVWZVVDNxdXQ3YmZpSklMa1hwb3g1NTVpMGdpbTc4MGIva1dIYXhuejlMSEhleTE2dHNsRjdVbmp5UkdsZWh2ZmtJN3ZVY1VkZElTa2VqN2tDWWo5UzRzdnlnTlZKSXZzSXB2VUJjMFVFZjVEYlJDdDFOamdUbFF1SDdWR2wwK0tOR2l1WEZ6QXJSeEU1YWVXN1YwdzdJTit0VTdFTFM0L2hIVW9OVGNuM2FzYys5aGsxdkc2N3lJZi9UOG1JWHhpeHZGRXF1Q3Bmbkw4bGMwU3ArM0lDSktROG5jU0toWXRYN05CdTJHckxURTZMU1lGS00rS1R3dU9qTGVpcGZzSklVQktwNHE0SGNORW5LZUluS011cEU4d0dOSUJWWGJuSUVLSk9XU0N1R2VwRUF2Uk5LQWhNNkFVRVI0dGsrdEFyMWhEMEo4TllsSFYxaG9CUEdlTk1iM0VoZk1Fa0V6V3lRYVQxRnF2UStEZGpqbW9aSW1OcWFKalQzRm1tSERNV2w4Q1lNNEhOZVcxQllMTzBWb09WdmtwV05EY1UxL3NENkdheTFxdTlBd24rYjlua1lMYXkrS2N1SC9UUGVrU05pdTJTSVJXVjdhbm9wL1Q2UzVDMjlqWUdqdVJCWVdFMnZoUG51UUZnaGw0ZlFTREh1RzR0bGdMUVRpbXVtMFpOcHQvTzl3L01mYlUvekdIc29XM3l6QjBxNmgrTFpVTFB5UW44a0NUL0gzT0ZyT25uYk9ubUljeDByUEtNWjd0TjlCTEdteEJOZGNHSXJoSjdnSXdaSUZnbmdXTkxWZEJCSjhHOTlqd1YyTzZpNktSMFRvUmp1ZUQ5YkkxUEhHdzNGajB0WlQvTWtlb0UzTTl4VDUzN2VINHZ1bVJ1V1VlWjVpWS9TWTBrbERDLzUyWktWSDhpQm9rNEdzTkdTM0NMVzd4VDhyWlB2bmFKYTQxMW9nWHNxaUEzZkpGUC9qd2txRHlTT0JUQ0xlcU1jbC9KQ0Z6bmJRalhVZ0toUnlFTU1HMnRkZGNGc2dFMmwrRTByM2dabmluNEh5Mk1GSlByNXVTc3VGMG5LdDZOUlkwL2FzNlh5ZFljL0JmdlJGRENRREVCbEV5ZEJBbnJ3NTlQaXd5UzlwTURDRWdicTIyK1hqUVdrTkdBU1BKSTlCVGJTdCtsOEdKUXdGNjN2L0FON2JZK3hTZmI1NERKWlJma25xaDlUWis2T0g3MittSllPSkcybEJGcEwrVUk5dzBQN3U4ZEtkRlhwMWNPb2tsRThYWEFvdHpjUHFvVmc2Q0RwbGlCMzhZbUU2OUFaSHlJRHVEditRWG5weWxZMlREVjU0RXdQVVkrRWJKY3BKOXUzRnlTM0lBRktuSzhINlVUSlgwRkZmcFZQdXlsNkRSODlxUjZEUExCUklZd2VSRjZnSFpaL25kSG90NmF5d0ZGNW55WnJhUVM3U0lFUU8wU3hMRTJKRVkvY3BubXZ2RE5EcnRnaXJiZ3JRcXlZRlZIOVN3RlZGTnNvOHZvallHbjRQTVNyQUIxZ2xiS2paSTVBa3NnV0IyeDlYWUd0Y24xTmVmdnZFQUlOQUJiVFU3MG80TEpBRGtJcklrRDlSUkZVVFJRYXArQlRTMFBCN01NWFJtK0tRdkdtUHlhQWFaOEwrY1NhRFdVZ2hlWWd1emF4eitHTE5GSUc4VUlFdHFLVzF0V3NlUGFwZFMwbGZIMndSRDF0b1ByeWdCU2hKYld2WDBGd1hhUTNOVlJNMWdoY3FYckxNTzRkclZtY0s5SUdvU1lQYU5kSmFGMXFrZGkycFIrckx4Z1UwWDdMTUZFaDlxQyt0cFprVU84MjBoUWFJeVBWVk53emdERmJnZTFTc0NRV3NoQVdIQlhDV0dCVTRmdndBOWFCZW0vZkVRVTg4aVFvbXMzZVArSTBjTzJXR201NzhnZDdzR1F4WDZIblc2TnVpOUs5TXBlT3dUUUJYT0ZjN0dsanBlSzBMSlNZdHNzNWNwQkpVU21oako0MkdoOFJWQlJzaG5td0VBeUt1dGFOcmo2djQvV0pOVzFyaUZnUUtzSkVZRUxoS282WGpSRlU3bWp3RVZ6bi9GczJXMWtsREJPSktIa3FqYWRaeEdwcFFHZWc0ejY4MFNQL1N6NnJWdE5nNWFwUWlUU0kvaVROTG0xa0RzYkNHTmlRRjFaNW4rUnBuWHpycm9JSVMrdGVIVHQwLzBGMzQyNVUvUytqVUxTRzlWTFdiSlIybFFzMWl5aE9Mb1k4OGpINTBnY0E4UU5BVTZpak9nUmEyUWhNbGxFai9DSitmVENBT3EvU0ZjWjRsSGJYRWh0VHJTVnFSN2xEUEdSckMxSGZnQkg1d2tVdzZUOVRqKzZVR0RORlhOMFhGNTQrdktOYWVKcXVFMDlXRzRCSjk3L1FnQjZMVWpocFpkZXZhL2hQdjlYeW9DRk1vMlI2QVduRWZkSkFKT3FYMDJZNmFpT2IrbVFvNm1wNVorMERGMzVVZGhxWkNBMFdwbmJRV0dwQVhMS3dIQTFrQlJnVDNvUUdkNWZvc1pKRlpKSXNrSXY0ZUxBQ0ZZdWRCc2Y5YVF3MjFDcFhxMTdRUWFnUCtkRUs3c0JSWTB3bFJuVG1NcFI4SFdhQlUxTVRXWkFtZ0pGRXFrdkJuSkxHQlgvS0pOb3lyclVDQVdWaGJJMXZKdlAwSmx0QWNXTVYyNEtTVndDbTN3MTZoNlNOWFVGNDVVWEhodEc3NHFkTmhWN1dnZlBUZzMzOWRIaExsQ1BmQVVlUDBGeWVNcWh5bUpVcVhYazMxTU9tbXNMc3MxS2RTN3hjYUhPR3Y5WXdzM2JPbnVLeGFENFEwRi94RFNxdEM5THNyeThwMmE2dUx3M3g5SThNOTlUenBUS2FEZFUyUEsrSmphS1I4UEV2d2lZME4wWGtTNitNc3NOZHVBdEpMdTFSVlc3ZFc2dllEbnNJUzFhQUJCT2w1Y0NzUXBZMlNueEFXRjU1RWZUNFNWcTVKMEU4clJPb1ZXd0tEMWdScmg5OFVTemFWYXpkdFhyZ2NEeUtPY3JGa3VkaUt0ZVppM2xzQ2cybXhZVGZGMG8xbHROaWk1WmdINGJwNFpnSit2aGxmaXBSRGFWNllPQm92d2pEcm51a1FSVnIwUVQ2dWdieU53dFpmcUlvdGt3OVN3bU45OWV2N0NLOHVYbmwwYnRyUlFmcS81eWZ2MkdMWjNrYlNSK0NYZEtacnB2Nlp5dEtuREZCS3M4QlM4UkpZS1Fhc2xUVTc3V2dXL2Fsb0F2VXdpcW1kVlJ2RDh2Q0NUcHhzM1BtekprU29kZjRUZ21vZXlLa1pZQ25WR0JXRDdlaGpiWSthRUVRU0xTR210Z0dxZGFmWmRTSXduQUY3Z1FnUUF3TEVVaDZLUmVQSkx3SDg0QmZ4QTBDMGM4U1BBUGlSWDRpSHgwa1VYVFlneFU3YStHcXdVdFpzZVlLSkQvRTVnTUduVk5RUkt6dmlRRmhpUlpwUXFBSXJjS0EvTTJ3Q2NycURqbUpaWWFoSk5DcDI1b3JFQjV5Sk0valFud3VZSUhFQkZ4a2hjU1lVMHNLM3pZVXJRQW5Ud0JKbUFGTFdyS09OZXB2Y0orV3kza0NoeWZ2YkdTalVFV1FYc2lBOE5VSkhSa0VuQkpOcDh6SFBIWWxhVTd2R0R1by8rd0Zzb1k1TVVwRVJwQU9hVzd5Z3RGd0RGd2xsOWdFcXFFZVlrQkR2dU9sekc1RTUxd1RnZnlMaXBwcSsxaWMvdE1LS0I2QmRtVVUzaklZMWpRVG5SN1ZGdGRkSktNenUyUnVxeVQzRXcrR041MFJRTFJTZ0JNcWduSlE5ZkVqS29SeTJRVW12aDZTSWxKQmlHdXNGSlVUK2xkTTNESlllVWhaUmZtc3F3bmN5WEpDVW5WUkI4ME45UjJxSHZpV3hLcG9QM0RNSWVQeVNGaHI5UlNtMW9ETTdUR3d1NnNuMldwWFFGRVBjWW1HWWY5eWs0Wm9VMlBlTTlGU3RwSzdweTNYWHE5RGhrdUtLZzVyTGswODZ0ZmNZT3l3MWM5N1NOTjFiZGtsVytwcVZtbTJaT1RrbDJ0SnNRMkxDN0ZreHlYcmF6RDlQSVBBSldOQm1wc2g5c1hVVjNGY2ZILzlHKzgrWjAxY3UrT3dZdTFyLzZoeDZUSGIwaEc2cXJ1N2xROUNLZGRuVUI3aW9jRTVZakNFaEpEUm1hOGxpR1ErTWZnQTNLSlptWDV1S1B4d0VHRFR3NjQxekQwWkRCRkd3cERmeFFqQm90dENGZmZtdlBQYVBUOEQvQ1NCYWZOd1gybWk5N3NLWXJMTlRIMmsvblRoNzgvYVUvYjJqbytZbHo5SnZ1SUNnK3hNU3czcVNzVTlpVVBhNnpWbTUydkt0U2NFUjhZbFV6YnU1ZEpIYzhOZEhFUDNvOHdNRkpQOExEQjJDMUFVR0NXdG1ocTBNMXhLdVF5K2lJY3l0MFMvZVhEcHgvLzc0UGYxRHcxSU1SdjJaRFlmemoycnp0eTZjbjZNbmcwaFhvYlJnYzNGeFFVSjRSRXhDWkdUTTVoS2RQRUVObm9McWdhSUpsb1pRak9Sc0R4akZaaEMyeFJ3eVF2ZUwzUWo5M3o2cDJHWkZDMzU3QVBFUFB0RWVyUDM4Qml6b2VMYnZGaUtUY25JM2JkaGNVcm9oWVpZaEtURkNUOXBZQnN6YXNuVkx6cFlkT3pjWmpYRkpSbis5cStYWEU5V1hkNFdWKzJicmQyZm5WVlJxemt6YTM3SFRwQm51d1hraHUrZm92T2ZRUzJJMHcwL04rQ1QzNThzVE9sQzVtZVZmZmdGRG0ybExCZ2h6dDVVdktOR0M5YXY3SUFJejhIeVg5cU1tOU81endlZHFSZm02TFZ2MFkrWk1pWitralkxYnZqcFJEMzJoaXhBUmE0eUlqTjFTVXBLL3BiZ2szeGloNDJHMStkMHB2eGFWRUpNc1FMejh3blNHbjlJa1VOV2VyNlhtQmZURnlTUUJLMlhSWXU1Z0pTMmpxeCtXL3hBZ0ZKYkpEZ212OGQ0OXFRbmJkY2Urb1cyVDNUZFNzMXh2NGlLN042ZnJTVHYyTjA5TmhWZ1NCc3RKS0ZsdXNxOXJTaEJSa2FaZWZ1czJCK29tTjBjemo1NUpPcTh0bGZWdWdVbUFwRFZIeFgyZ2tsYlNkcVJsdVNKME4xY3hieTBzV0VIVDEzajNqclJaRmJycWYxSGV0RW5aNDJpVEJ6QjRVeFRRMXRRVzRwMXdWOUVGdDhNZFJLcDNHUUNGNTNIMUJWd3Q5WkFsVHpoWmlXSGNESkZ2Q1JWWkdBcStLYUdyNUNtZlJoZG1pYkNXU3A5akpIZFovSVFUbThWcStHVVNmb3N1WWxqOFJWa3ROV3NydG9hQzgySTFGWDd0YXJCSitEMUJoZCtHTmFJcy9CYmtpQWZTS2FXa0NsbjRMYmdrUHZnbzdvSGpWUGhOTzQ4TEwrQkNFT1UrNU5JdWRMVnpGZmttR2JRTHliUUxOakNRZG1FZTdVRWs3VUZMNkNIM0lIZXp1T0tXM1A1ODJyejNGK1ZLd0ZRQW5uZGVYUGtQaHMvd1hXNDk5eXlHZnlSTDJuaGFqcmlTdHQwU3NtamI4eTZKK3o2S0szTmI0TnJoMUFvZ0hRNjhnZUV2b1lOUjNubVVNT0FaWHJNZnhhM2RIbkZTKyszQmExQS85THpZMlQ4ME9XR1dmaGU0b3hiME9KMU9Wd3prQ0x1S1l6M2NQSUw4QWlNS0RwN2VjWVFhckEyaTN1cHVCaWg2WjN2b0s3WEVjcFIyQ3FmblRqdmJYdHVzblN1cDMvbmMwSmZ6OWVxWksxYW1yOVErUFhIMFpMNitSeGxTNzRoSmlUVUVhWDBpdHUyL2RYQjcxWjdjbU9nVmV0NFhEcjJFWVcraG5YR3l1SWZFQ0pQd1cybkljK3hMSnFGTmMyY1d1Q2Rpdmp2c2Z3b3pIaW1nT1ZWYVZhNHQyTFpQVzcweExDNDlZMkY2dXY3WlVHSFZsbVVGT1pwbjQ4NjM3dGpCbFRSb2UzdkU4NmVIOSs3UDA3bnVRSEdwTVltaDJtblI1YnYwUE9sNkJFUDI4M3V2RkhCZE9pTnNmbzRHc0N0TFVjbktuSTJsMmpWcmx5ek0wbTkraWxiTmlWNFJyeDAyTHN4NWxqNTFNbkpucVhuS2FYWUN5VWJmMkpPUWpmZ1k2UEx5em5Qby9Gb0JvNkc1ZkpTWUxyZ0hCSHY3eHhUc09sRzU2OENPd3VnQUhha2lnY0xJdzRQQUVwUVg3MzNZb3JzQzExRXJOaTBRNWFhRzVZL1R0dXpmM2NINTJLZ1hPN2R0MnBpdFh4aVB4czRPaTVxcTlZd3RxdER6Z1hmcCtqWXE0TnBQcFdSOUEyL00wbHdJUHVnV0hwUVNIYS9iRFdPZjR5YTF5NU14U1RtQ0pRZmdGTkFDNmlpaFJjMENJV0pyWEdsbFdlSHU0dmo4c01DSWlDRGR4dHJKd20zNC9CejNKNThSVCtLaHkydHBzbHpGalZaNUNqdUZxRVd6NWhtMWFTbVpLMVAwczNwUk84SDgxRXJ0MmYwVjF6Ym9IMHQyejNIMlR5RWlMNjdzTDlMUXdFaUtsSjlDRzE1TysxZnhERDhVMjRBSDlJZFdIekZSRTh2VFVHanEzVTY4K2ZXQjNiVEZ4WCtMT2ozRHY2VGxwanpFdy9DN29rTGFSa2YzNUJuZUR3Rm8yVHQ4eWV2ZzBJaXBDMllFNlVxU3duTTl0Y0ZCczZQaTlVdlhaYXhmbVlmSGtEMDc4VDZZZ1habmJkMGtmbWZOMGJ4Tm9rd3FCZHlrbUd4dTRPeDFtZ3RCQndlRStzK0ppTmN0WForeFlibXBaakllSWFiSTdoRDFaZjYzQlUvb2tQRmQvUlgyU0JlRlhVV1V0YWRSMW82a3JMMmRzdmJZQThMUzdJd050TTNPdGM0NzhYYm9pK0kyYkk4N1JtMDF2OTk3RFEwZXpUanY1QmVjR0plbzV5TmdyQUVhdklTaDcyeVBmY3VBRnVxdjBwQ2F4a0lyZGw0ZzJqQXZwblNZdG5YdmJzU20rOUZCVDhzTDFtM2NwQThsblNnUHRaT2FDT3AzTytsZENXNzByb1FBK2E2RTRwUEhLWGRPcHR5NTlJc0Nia2g3aGJ3djFEUXdaZGtzYldSSWFyaEJ2M1JqQmozWWJjM095NWcxUDFRM1dxWkdKWFJCdHpmdTJyaFR1eTU3eWVKMXRENFBseXZ4ODQ5N3ZpZ1BTKzBFNXdzaHQxOVhuem01TjM3NytLMDZyeHlVc21KK1ZyWW1aME4yM283Vk14TjBMOWFoM2VseFY1dG9lMDJjTk5KblMraXBHSDFsTXNxZHQ1dzYrU2FsSk0rTVNNZ3JYSnF4VkhacEp5UGg4QXNZOE9xN1VmSHhoeEptU1NlRksrem1WMmdJdS9VNzZzak85VVJCOHhJTS90b2tOcUV6T3N0R2tpYUkycW5OVGRPTTJ4bDBvU0JuMWRMbHVweEgxQlF4TFQxTkd6ODdLM2RsNWtwNkxzQ1BoUU92Wkd2Vnl6K1Z3RkxDZVJFdnRQaWRPSHpYMUR0bDI5Y1hiZFNsejh0WXVFaXpNR05oNW56ZEozYnJzbHlxZXpzRGxYUnI4aUxUVWRTQ3BFQmZiV2pTbHVLVkdiSnBZeFZNUVR4aEQ0bFNKNHFNc1BJM1ozUVVSS09tN0hueWVTZm1QeDhTb1ZUT1VwQ0FaQWhBTGRseXVpaCtzbUFOQ1VVa0FYMWhZUkI4Umc1c2F4SVlBNEdJNzBjcnhFdk5oWU90WkJWaFIrZ0wzV0RBZHRHNXJlZkgrL2dOY1NVOXlHRFpRcHR2VDdsTGlxVmMzZ3A2QzNCU2lrVUVzY1NDalBhQjBhZ0plNHZzcDMwWmczaG5PUEVDK2o5WHdQTm5lUE1MUkhxd01BVUcwRDJIVkxJSjNaQnNXKzlPK2lRNElaNS9KWUtUVVhHSThzclQ5NkpqdXljbnhCL0g4YThQM1V5T2U3OCtkbVVyd01ua3F1ZUVIT1U0RGMxeGNHOHIvS0JWV043SjhBV1E1QTZXMzQyMk9WRFhEeHBCWGRDT2hIcnFYOUNLS0FWZzJOd3ZDTFFySDc3L3BMbmpkNmJkUHAxYnVjbHJyNXg2N1cwL1JyMzJQcXdkR0t1SGVybm9aTmhMaDFKZFByQ3k1UnhWbEJPcmVlMWRDYXR4clJyM0pORGt0NWY5MTI4djN1UzNGekZXMnoweitPeVovL3J0OFNhL3ZRVnBHcmU5N1VGSi9mWVdQQVRyaDJBaGh3cVlMUlVJUHVFeEVSR0plVVY3U2d0TFNuTGlvM1MrWUNmMGNodlJaZEN4Q2JmdTNiM3c2dHFrazI1NitFV3dVTHVTUERTMmtsYkFmZFNOSEJGOEltTENJK1dhSllXbEpadG96ZWNyaEdzVFR3NzRXL25tZlZwWngxL0hFUG9adzRQWm1JemJDajIyUXRPdENuQzZKM2lXQngvTldyZVUybFlranh6aU9YRmhVbDk3Y013Q091UGdxTG5nVXoxNmxJZlhLQjAvUHgrYzhoUXdiNzV3NGVpUmM0Y0Q5NHdmTVhYeUdJL3RQaWYxdk94OE5nUjR4UWJRd2lyWkFyY056QmFlbFVFYzFIK1FNM2FZb3kveEkxWjlEYWV1NlY2VFRBSGk3c0ptNkMyN25tSFNuY3dhVE1wSVoySjduckRRWTRtZXZ5b1dtMVNhVWhoYkFOYXlEd0pZU3NXSWNPek1vYjJuZDE5czdHUVByZGdoc3R6eFdyejIxeGt0WXBENDF4ZHQvbjk5MFFJR2lOc3dIS3JHNzB6bXZoMysxeEh0ayt5SXRtK21RTnhZTU1xT2FOZncycjkrYUd2ZHNJdG85a0k3UURXWThFWDJQb3NqSTNxWXZjOCttcjNQenV6S0I1Vjk3VnFXUDRIWEZHSTQzUU5YaStYLzlVRHJNd0N2TTBncmpRcUlUQk5PSHpoNG9qcDA1MlIzeitrVFBNdjlqK3F2d1YzaDFNRURKNnREZGt3ZU8zMzZoQmtWTkpFbjdRMHczZ0I5RGVDU0J5NEdlbFVFNkc4SVBxV2hCNmkzNExoUlBsTVh6aDVrRDNhcmYzeUhocHBUQVZYanhzL3dHeS83cFhXRUJjTHBnd2RPVllmUU5xWlBHKzlaRVVEUmxZdm5Fc1cvVG1vbHk4VnlVVXBOb01ONkNFaWFibFFjbDQxVSsxSWoxVTBQZjY2OGNybjhhaU9IWFNna0lTeHNnbmFVejY1TDM2OGNQWCsySkNoZ3RSN1k4dFRUdnVkY3FaSHFSMnFrMmhVUjlSeWlhRWJhVWlQVnZzK29rZXIzVXlLby94cXA3dStPOStKalpoUFZZODc0cEZnRlJ3VG94c29XcWwxTkZxcmQ5b25ReTJTaDZtcXlVSFdWTFZTYnN1QWhmM0MzWTRrYldlSm1ObEI5VGRhZzFpeFBmRUJaTXdrc3FRVzZlamlvVFFhcFdwTkJhZ1AxcTlWTFpZUFU5dFFndFFFb1pZUFVCckpCYXZsRGZOMWtrTnJaYkpDNlJUWkkzZnZYSURYVmJKRGFnQnFrdnNNZkJzdldxSXhzalZydkNwN2cxVXN6OE9EMDAvNXpNRXlFMG12aXpIeThWYlpHcGZhaVRXVGwyMnF6dldnTXNZRC9rZTFGVDJPSXBxdnBlUWorYTBPbThoTnY0Z0tZTDBqSm9LeE5wcnhNNWdrKzI0T3F6T1lVUGtIVW5FSlNXcHBUcXN3cFZNamZqYUZaUDVIbjE1bjBVakRya2hDVHZLbWdvbkJyUWNHR1dURWgwWEV4ZWpKTzhoRkdWWHRjdW5iNXhJUHowdzZPR0RSaWZCOGRqS3d0RThwS3MvUHk5WWJOMjJaWGFLOWVQdm5nL1BTREkwTERVK0xqOUxrSk03TkR0UU5Iak9zajE5VERmV291V1p0RmJzWTNsN0prbHk3eWoxQ1F2bUZXckNZdzJoZ2RLemRac0xWUUJ3bTFtNFhvMlp1MzdpallVbGk0SVNGT3p0WHpTY0MvZm4veC9VZXdVUnpLRmMreWl3MkxEZkdhSWF5eFBWVS9FNkVTVkQyaHFiYWlkT1hxUFAxOFVLRkZTWW1MNDdUOWhoZWZpNURsa1FOMHlpUCt2cjRnemZTWXdWN1pmN1A0blBiZ2p0UTV1ZnBUb0VBNXdmNmJYTFdrQlduUWpkaU4wUTltZVpQT3J2eWdTSFZYN3JDZUtxVWlrbytKVkJjVkZMZ21SRHRzekJPek1pcG5ZZHBhUEJDeTVmd2ttdjlYcFRYTS9RblZhWlZwYzNJV3psMkwrZXRpNlFTOEdWK01wSUdVRUNhUzNpME12M3NiRmR0QXFkd0c2UUpwZllZMHV0aE45L3djR3Z2Y0Q1U0FOSkJxOHZmckFxeHU5QU5FL0lsQUVQRWdDelU4NldXdURDUEFRZ25WMG5nQldydERvNUhQZFYxSG96UGRkaE1sc2RTUXVjU0thRWxIWXFVNzY0ckFCK3pCQ2lhRFhMMCs3TGtpd2tYWUV5MlNQa1R4dlNiZ213TENpY0xrTTJYRFFvZWFBQVNjeVdKeUZrdW0vS2N6NG9uemY4dUp0QnhNK2QxWnpvdHZqc0NHSlIzK0JDREN5VzhsbnRnMCtRcG5RQW1udnRvK0JNdGVRSTNxdDhFeDRkRDJoR256MHRQb05WZHhSRUhONkJjWmx5VE8wclE3Ti9HVHJraTIvUGVOMkZTZFJRM3gxK3EzZ1IydFF4ZklvZGpkSHRtNjY5bDdENisvWEFyTnFkbi9ycnhEMm1JMjd5c0tZWW1OaTRkcytDKzdNUTZaUFNtV0d2NFRqalo5aWpaOWhscjVOd1BrYXJMeS95aTFwMWIrbS85YStlZURRcmJ5MzJ5eThoOTFvbzB1U3JieUwyRDNsTXlhUHM5MEM5ZE1RcHYvdWpnbFBUVlZNN1V3NE9CczNhQVU3eW16aDRXVDV2WkRrZ01NSHRvSXVVb0ZDL2pKSVdoV29pOEFHM1IxL2JIOEU3UUh3M0xQaVpBa3pZMFJTMHBsaTI5bzY0a3B0UTlTYWwrR2c5RmlFVTJ0bG5aNWlldG5tNDJRNS96WENIbUJORytnQ0hxb29scjB3MUJsTWs2ZzhkOVJVRldDeWRoU3JKQ3htUTZiYVp6aWtBK2JzNU9nSWYxeGtIQllsTHJKN2x1VHlUaVQ0K2RJMEJLNlFvRXVIT2dQL3F2MHRkWnNOT0VRekdlSEpRd2Yza1JMOEtESFlBMjlmb0VscUVGNWRQaXd2ejZraW9RT2dNaFlMZC9US0c2anRodTVjQnh1MHl1bTloL2JHN2JEWTdwL21HK0tmaVZWeVI2ajdweWIxMmpvR1ZUNjdFVkdYZnZhMFVIaVM2a1RTbFY1bHdVZTF2RXdJUmt3YlVHVkNTeDBBOVoyTXppRTA4NjZRU1AxN3hvMXpCUzJnZ3FSQTJ2RTU2emJMSGV2d2RwdUFVZVBmSCs5N1lSK0kxc0FMRkwvbXVHYmYvakV3Yktxcy9uQlhnc3k1aTVKMDRQOUN0bVdQMmU1NXQyZzU2UTVVUkMyTCtIR2xVODdFS2RULzNaT0pZcGhSS3NoaWxkdG9RKzBCK1k3MkJmcStLQ3I0a0t3Rm1SM2JxbTMrWjNlaVFVa0ZlZml3ZkpidkFkSWhvOWdNY1A0TDJodDFkZXFwSzJDdy9OdVAzKytlUDd6WjlmbkRnN2R1am5vanRrOU9IdisvdjJ6bzF4ZHg0enEzWHZNK1FjNnNOc2daTzFCRzlqMUt4Zk1ucE15TDBtL2xGZ0lKMW5EYlZTVXRibWdURk1XbngrbzY4MzZrQ25vSkt2ZXNmNFNXc2Z5NUtCVWJBQVBvd0w2WDhha01UdUllS0IzTlBtNGRNcndGT29wRmtBYlpSeVY1dE96c3RKWGErOWVPdngwWDFTSnAzZG9oSDlrYmpTMTRGaVd1VlFmUGp0c1hxUjI0Y0tNeklWNm50eVJkb1B0VTZNaW50YUVCbEtOVUp5d3pUYzFkUkUxWHRtNElqOS92M1o1Vm5yNk12MmFReWh6d2Z6TXVkcEIvVDI3ZUplRTd0dFhWclpUenp1Wk5EU3lwb1lNbEU2RFJoRmpzbUpVeHZoaDByRm1FWWlLV0pQaHRUTFdYeVRoRjhRZk02Z3RhczA4YUtaSWtJOGZxUGlkTUVTRWRkVE1pU2Q5YXpaUTZhbWdab05BUDJ2SmFkYllFdkVrdkNaWE5xUld3RHBxMGQzbWd2aXFyd25BRW05YW8wbk53cWM5S05VWC9xUDJCdm9nL0R4Ny9WS08zcEZWNTg2Y0h4dnJvdzJjdFRsUHIvYVdyL1phb1d2THBpOU9wL2ZPdVoyZDhVekhreXMxR3czUXhhaUlxN2txK05FQkhkaXo2ekExWlBMMjhQUHhvdG1oTlVrUFpiY041ZS9XUXVIbVdURmgwY2FaMFlrYkMwb0w4d3IxUkROR0dIN000OHJORzJjZVhwcDBhRWpmWWFONzB6cU5hNWFzRm1sWFB2em1aZVArRmRTNDMzdXdTSGRNMnVFK3Y3SHdSZXhOMUxLeDBnRlFDOFNlN1VpZlh0UFpPeVJ0Tm9BL0hlUkFrMitzRy9GSC85RGsyeVRSTktsMDZTb05SQ25JVTdnZVI2U0VwRVZxbDh5WHB5OTFPa3Bmdm01SnR2YmFqWDJ2OWthV2VYcUZSZmpURDlvTlV1b0djTml3ZndOTGZEYW82R1A4Qm1pM29YcURGWDIwQm12OG1YdXdjNzJOemVmczNIVTJkYVE3RGFRNXduRzErVlpmeExSazBwaVZUQ1h6UnRGUzBWbmhyWml0U0ZPc1Y1eFRYRlhjVmp4VGZMZG9aT0ZDNy9TZFpCRmtjVTNaWFRsQ3VWMTVYZm5XMHRMU3d6TGNNdHB5dVdXMjVWdlVEUTFBWGlnYXpVSnBhQVZhaXphaFlsU0JMcUVQVkY2cngycllIbXdZRzhNdVpWZXg2OWhjTnArdFlvK3pGOWxyN0IrVldpWFNLNHVjVkVOVjQxVlRUUCtCd0U3Vlh0VXgxWGw2Z2RFM0ZiRkNWaTNwZmI1anJDWlpUYlB5czRxd21tMjF6R3FOMVNhcmZWWTNyRDViL2JDMnNPYXM2MW9MMWhycnJ2UWUzOTdXQStsTnZoN1dBZGF6ck9kWVoxbVhXRmZRRzN5dldOKzFmbWI5eHZvMzVyRWRGbkVyN0lKSDRyRjRLdmJDVVRnUno4SEw4R1pjZ1EvaG8vZ0VQbyt2NEp2NEFYNkczK0FQK0F2K2dZRkRITWZWNVJwempsdzd6cGtiekkzbHBuSmVuQjhYeHNWeHFWd21sODNsY0NYY2RxNktPOGdkNTg1eWw3bnIzRzN1R2ZlUisyV2pzT0ZzN0d5YTJyUzA2V0RUMWNiWnByZE5mNXNSTmhOdHZHeUNiV0pzRERhemJPYlpaTnFzc0ZsdnM4bG1xMDJ4VFlYTkxwdDlOb2ZvQlV5bmJNNVZOQkU1NkFuMW9BRjBvVC9xb0U5NmtoNUVobDNvVDA3dm9lT0UzSTFiU29yWEppYkhHR2JOakV2ZW1LTlQvL1FqcllXOExmbVZsZXVOaVRFR1EzQjAvUHA4M1VGaUpieThmUEI2ZVV4WjJGcTkrc09oOVdYYjkyaE9UdC9idWV0WWoxR1JXOEtMVW1qVmlhbCtBZE0wN29kbWZOSHgxR1I4bFlGYUFsT1Q4WEdkUkU2UXpSOTlzR3dJcVljNWhCR2dRWSt2cE1rUUhJNXBOOXJVK3FJZWlkTzlCbWg3Qk8yL3ZKN2F4MnpVdjVFR2J4V2RhdnVoaGJHTDQrSTFSUCs1QzdRQkhTZ2ZnMU81N3J1VWlIZ2hzV1JuYXJVVzFKOWVRN04zbzA0NmR4czR0dXVvNmhtMzhvdFdVejJNUi9Ma09HOXRTTlRxZFVZOXRQb2tSQ2RzTHFnc3pDc3UySklRSFJvZEY2bm5heFJDT3hFQzdkcUozS0tNMU13Rk9sQ3ZaUXVXRmEzZXJuc3NOWjZQUjVGZGFIeEs2QXg2STBSY3liNDFTemVzeU5PZmdzMklBMGVXSU5tL3ZETmIyK1hQMVBIaUJLbXhzSU5zbHYxdHVKNjR1OGpKSHhqa0ZEdFVyUHlDNGFUWkUyWTB5MG1UUm9sUVYxR3pWWGJ0L2FPa3ZyMzlNWXlLdytSNmU1d2g3bDlUdm1tN3RuajkzNnRWRTdCOElXRkh6RW1oZHEweDk5OWNONUVMM0RaejE1NmQ1UWNxbzR2OVp3VDcrK280R0dmeWZKWXZCLzdCRmdCQ0R2OS9FUXJ0V0NPeGFGL2g1L3d4dEx2VHhZbFAzeDd0OU9Eb2xPZWdLSnZ6b2trbzR1TEVZRzIzWHY3RUpwcnFDYnRpMExEY1Vrd1FlakphNVA1clFHdjJBcGtuY2xBb2ZHRVhEUFljMGlPSmZpTFp3eGNXbUFlM2dNblJFMVV1bWo0LzNIK3NsblJqTDI3YmVYN0ZWU3RvSnJ0emtVSHNvcnhGZWJtYSszdkxqeHpORC9HWm01Nld2a2dITnRrb2M5blNkZG1hbHhNZUVSMXg3TldNY0xITERNdU51cUVzVDUwb1I4L2N0ZVBnOXYzWFRtOExDSmppNnpOYXIvNUp1cEpwd3JGOUI2N2ZMUFgxbXVRNWZjZ1k3NG9qT3ZoTzdhOC9uQW85T3lGWDk3emcyS1Y3bWc5OTdoTUgwcmlwSzdGMjN6MTV2NUd5YWp2ajhLSGROY1RxNndnUVpJdXQyNkRXOGNKek1jbHRKMTVabkxVM1UzT08zWFFmMFJtREpZTGZtcURONGJvQmJnOTczYnFORXN1MnArM1U3dGlldGFsVWY4dnQ0Y09CTjlDVzByVTc5bWgycCs0MGx1bHUzSEI1Nk5ZZmJRb1B6Z3JVQmdUTm5SV3U3MytuVjYrYmJpZ2hiRzZRbndhVWR1ZjI3enQ3YnAvWDZORmVYcVBIek5oM1RzZEQ0MkJzdXRFUDNNZUp4UDMvOVZwWFgrdUNlZUh4cGVQREVWaXg3VUdOaU1pU0ZrU051R0N6VW4yeStPbUprRWExa2ZPcE5qSVJUOEpuWUJ2aVFVRjZ5K1lyUEZHQVFsSWJiWTlCSXhnQmpkU1BxS1d3UU9OajJBVWJjeFp0MFI0OXZhVzZVSzgrbExBMGR1bGNIYWpaSlRtTGQxUm9wSmFrRWRtbEdoZmk1ejRxYXQ4Skhld2dqVlQ4UnpLV2pDUXpna1NLZVdJTDhFQmNUVVl2eklVdm5KMlNxRTFPWGJVdVViOTRLVnFYRUpzZHJuVWZGOXhpcnY0Wnk4bHU5ekJpSXVaZ2trQ1ViMXRCVStqeUZWU2dBMVgvVzBRZDRUOHZLVnAzR2dRRU9hYmJlbXNWTE5HU2M2QWFoN2JrbGF6ZnBUMjlQM2kwNjFqZjBZT0NqcDFZa2JHU2ZwMFF1eGpFUy8yRU82ZjJuanRUNWU4K2VNcjBZYVA4ZHA3V2tSbTFXaUhvOE5Xa1M3S0dwRFAwaHZYUXFlVTdJcEttaEd0UDJoSFZVeGV3T1hVb2IyZXB2a2xNbHlGRW9mV2FzYmJBVjAvcE5HYjRFUGZBUFZjZjduLzlqSXRhT0NjcFRqdHJUdGFhWlAzQ1pXaGRZdnphTU8xb2QvOW1xWG91eUZCUWNXaEhhZVgydk5qZ0tZR1JRWHJPRjVNR0wxdUFLTi8vS0hYWklITG1WM3N6K21xM0h5eHlyR3hJeHIyZUpLWVlPZUd6YklHblJ0Q0E1VWliQlNKSC9DRGRBRlRTcW9ialZCc1NjdUR3M3QzSDk0UlhlRTcybVRHTmN1VkljaFFkRVMvQVliZ3FkVExwZHFhUzBoWlFpa2dMbHROU3psWVFOZW5GQ2RMUW1qNnk5eGx4SWNYRG9QZ2pCcWEyTStsRGNoRzNRNFR1WUNzNUc3bEgwQXV0V3JjNkwwZXpNNnJJWjFwbzhQVEZtWWJNR04xSzBzRjBvU25NWk4xcEk5MEk4NW9kMlVZV3ZDNzhnNkFJR09MTm5ubURvUG12ZmlhclNCdDJURWRFOXJKOFBKWm5sMXRDM1pmbmE1Wmt6S2U3NkRzMmZYWEcwcFdhTGN1MkxOK280OVRIM0NrOTZKdVRJeE9KTzJsUDhyaFdtQS9kT25QbkRxcTFLSS9aRnVRYkV1eXY0d1JRc1gxbDl1N0ljaXRsWjRXM2RuMUZ2aVpqT3ExWTd6QWFHamx1V0FzdFlRYzlBaXZvQll4WnBqalVYNzZYUm1PNmw2WXIxQ0hqdGJRcHdXWEVwSXV5Vy9CYm1jNGkrNCtJT0pORGhydlAzaHNjNVlGNmhDTnVITjMrcDJGd3RadUcrUnAzd2JuZnhEdW9HZnRBZGsxdnhJSUR0RUtjOEowZEMyMFFhY1Z5c1lUT1lOajYyTUtkbWdONzkxNzRkMTJ2bVRvUTh0Q2RTV0JIUnlVU3RoTnAxT1hBcU5kK3V1Y0JpQnNsZ3NXcUNwR0R5d0xJSm5lRG9TNnhKSFhKWU1MQVlGSlh0a1hkUzFvSVVqQW9hb05aSHBGR3JIeTlacWpwbWdkT2xtVkFBMTA0RDFIQjdSTWtOMXJLallVZWxwSWIwU0t3VkpHeUIxQjJINEdGZkhkdVk4VHZqaWp6OHZEMTg5Qnh6WStna0VUWm00b3pYYmZDc05JMGFkSTJvUFlnMjh3M3IvekQxazZvSFJ0RkdpRitCeVlMV05nUE9mbGdpV3IxYTBRNisyUTdXV2U2RS9pUTdCdkJ2djBIR0k1MUtSTS9pZHhvTVYva29Oa3ZnZDU3d2VYZzZ3L0V5VmpkeFB6SytPOFYxMTB4Yno0UDZYWms4Tk9EUllXNUcvU2NVWGFzYU1SQkhTaUhPcHg4d3VPSnRxL09MZHFoTGNzeFJpejhlM0d0QitKaHZnQmpRVUhHd21SS3JNbGtMRkhBV0RLRkVvdlh2Um1KTnM5WlN4VXluZ0VSM2pyMUM0K3diUWV6TXRjc1c2dm5TSWhSNU16V21OQnd0a2dhZW9vY2pFNEdqZlRDeU5uTnd4eTBvZTlxRGhGN2xpTVdlMUZnUWtqd1dPMXdyNm9ib0x4eDh0TDVNbi9mMVhwT2NCVjV1SlAwZ0lNOFNlZ2htbTZyaldYSldObGFNMHFzQlBVcmViQjVJbldrTWZuZ2NLUy9kUHNmS25GSXQ0VXQveUJTd1JyYUlMNEt4M0xDeENKaUNkU3A2UHp6TzJkRGovUXQxNDNjaHJpNU9TWWYrMXpxWXorWCt0aWZxYnkwZ3piYVI5NFVZVFMwZ0Z3WVNGUkExNGllQkxMY1JUaUNsdWNzM2JSSjg0bzdjMnozOXczNmJpejNERnBEVTVkSENxNmlXQU0yWEk3K29Cbmg5cm1WMnN0bnpRalBWZ1VNSUpZRDZNVXMzcnR1MDR0Wjd1cTVBSk5IU0QxT2x1c3lkZHhjZWVaa0I4d205RHNpZW1mVmp2THF5dWlpQUsrZ1FCOGQ5OWU0ZlliSnVMMllHcmR6eE4xRDVQYUJRcUpIbFp3c1pObHlaalgxNE9rOVpEWDFFWkhUdEdJWFpoanBrUlZua0xSR0xsblgrU0pTMzRyZk1HOVRycVkwaDN1WVBPSVowY2hhcjRaRVJRWnlvQjBEOXRBY0duVUIraTBwWDBtckJ5dzFOaXBtZzE3Z2hDcHhwTWlmRmYvVGI0M0lRNyt0bUFPZUJpbWJDMU9MdEp5R0NPeDgyb3lTZGdZOUZMbDhVTkdaL2NweVVKZmxDRlhSU3YzQUVocklGOXVtWURwVkhPcEJkeFBEQVdBZ0VKaUR0Tlp3VERTWE1DZUVibzNjc3g2bmNuUlY2QkUwWm90QWp6amlRa3pXU2VCQ25Ea3lRVGhHR0VUYXMzd0ZmWmZXOURGeTByVkZkRVhDWFFOM0Q5T2J6WU5FVGlBT0YwVndZRTBYQ2xPeHhYU2pjREpZd3FqUHNsV29MVWRyd21EQVVBNVdYRTNqbVNaYVFsZGdvQzd0REpFdElYa0Q3SGhLYVZ2alQxT2VROGd6QmZjRm1uNVJjay9CVDc0ZGVxZkkxVXdWT084TlhwVWhPdld0eVVhT1RFNG40MGxic2xuREpRR0c4RjgvZ1ZOd2x3d3doZUtlVExFOG80dk1EeTNMenVST0dNQVhsT0JERStrbHY4QXNmL3YycDRaaklhWlE1Tll1cFdkMmN6aG9xTmdsY3ZKbDdkd256SExvQjh2cDFCZU9iam14LzdHR00xMWE4OU1CTUVjQ2lHajRQWjBpeWhXQjJtK0JDN2VnVStkbUdzL2lnTU1jbkJBNDFKemx3TWtBazhGQ3dka1ZnVDBpNTFqTzFpQnkwQlJZVUlFRE4wSGtxWDR1VGMrdHkxeTdWc01oR01GeU9YQnNFNGRJRTViNyt1Mnprc1lzT2JCVWN0QWRjZjhmdWJDYTFRQUFBQUFCQUFBQUFYZ0J4YndMZU5UVnVmLzdYWk5obUlUSkVFTUlRNGdoTjhKRnBOUmFSVUVSdk5SNjdiWldSYTAzRkZBUkVWSEJTM2Z0N3IvYmY1OGVUN2Z0NlZIYjQxYTNwVWlSVW1STG9OU05TQkdSdHBSTktWTEZORUtJTVVJSUFVSklzczduZVovMWpETTdRcW5vT2ZOOTN0OXYvZGJ2WFd1OTYxM3ZldGRsMW95Y3BEeWRxbXNWT2UrQ1M2NVVjdnJOczJlb1ZGSHg4VjRSQ1VvL3daK2o2T1NaOTg1VUNWZXVkOTQyYTRiS3VYS1ZMRCt1SUtLWXJ1RXVLQTdscVJmSVV3U3ExbG1TdnFNblZhS245YXkrcU5mQkdQME9uS0Uzd0psNlUrczFWbHYwRjUzbGNseU94cnYvZFArcGMwZ3Y4aWtZZnNxbDM3N2gyemRza0hQUG0zd2JjdUk1aFRsTGM2cHpKdWJjbXZNOVFxOUd5Nk5YUkg4UWZhSlhkYTl2eFJLeFozcGYwdnVWK01qY2EzTTM1aFhuamN0N01PK0Z2UHJVZ3NIZlRoUU1yQWJUOHIvRnRUcC9jZjRyZlZNRkV3Yy9YdkMxZ2RNS25pK3NMcnhxOERPREc0dG45MXZhcjdXb29HcGQxWUtpYTR0dXJWcFhOS1BveWY1UEZNOHVmcUo0WWZHSzR2WUJwdzI0ZnNDM0Jyd3dZTzJBclFQcUI3U2tJcW1DVkUzRkxhbnJCMzg3UlRrQXBKYW0xcWJxQmtZb2E5VEFhUUFNZm1iZy9TV3JCbDAxNlBwQnR3eWFOdWo3cGVlZG1IZmlockxDc3BSUldWbDEyVlZsTjVYZFZGVmJOb1U4SGgvOEpCSTFEajR3dUxOOFUzbExSYVNpZ0N2WGlwS0s2b3BUS3E2cHVLVmlXc1VURmZNclZsUnNxTmhlMFZMUlhWbFFXVlk1dW5KaTViVEs3MVErVnJtZ2NtTmxVMVc4YWxUVmhWVlhWVDFjOVhqVno2b1dWTlZTdDFlaExWWHQxVFhWRjFiZlgvMUM5YWJxemlFbFF5NGNNbXZJRDRlc0dMSzFKbEl6c3VhcW1vZHJmbEt6cXFhaHBybW10YVo5YUdSb1ltamgwTlRRTTRmT0h2b3Q4SU9oVHc5ZFBIVGIwTHBoeGNPbENPMllvejZTOHRWWHVTb0VDUlZwRU0rRFZhWCtHcUlhTEdHWWhtTjVKMm1VeWpSYTQxV3BDWnFvVS9RVmNLcStDcjZzUzNTcFR0UGxZSXl1Qkdkb0VqaFQxNEd4dWtFM2E1d202M2JzWkFiNGltYnBYbDJvQjhCRm1nc3UxaVBnRWowS0x0VmoramRkcGgrQmEvUVVtS1NmNmpuNndpKzFoSnlXYWdVNXJRUXo5U3E0UjZ2QkxLM0JTdS9GUmpmb1ByME5IdEo3MnFXSDlRSDRYL29RZkU4ZmdYL1ZBUmZSWTY3U1Zlci9jdFd1Umo5eHc5d29QZVcrNGk3V3MrNVNkNU4rN201MXQycTVtK0ttYW9XNzE5MnJsZTRSOTRoKzYvN0ZmVmV2dXArNm4ycVYrN21icDlmY2ZEZGZyN3NGYnFIV3VNVnVzZDZ3SHJIT0xYUEw2UzBSNWZxdGJwbmZxcWdHK0U2OXpuMkRiM08xdmtPOVZlUmIxWjlRc1cvUkFPNHBhSkJ2NVcybjRyUkZEbThQOGJZOXZEMm9FdU5vdC9SeDJxaFF4ZEFBcFVBaHJaWFFJRUtsaXJsYTN2ZFJqdDhhY204bjdRSFNkdXNNWDZ0SnBMOU9NZVNKbzdsQ1pHcEUxc1hrOW1zVmtFUFNiMEs2TGtxSWs3NlQ5RnNvdjQwU0JwTkhHeVhrNlF5ZXhwTGlJa1hJcjBtUEs2a2Y2bFJhcjF6UHdiTUlDN0FjZVg2ZFBOYVExd1pGM1JCa3d0SlVRSzUxNU5wRlBra2hzOGI2WFpwRXp0ZEJ6NkVwdEVXcUFxUnJoU05CdWlMcWtGS011clFnaDZjdXEwbTFVWk9Jdjg0M2s0bzZLVUdxSWxMVnVWcjRIRFpWcG1yU2RxRFB0NUVvbDVML2c1TGZwK1JLOHFsVEtlblB3TmJId2plSk5KWVhPbmplYjljTGZvTitEdjNDcjlWOHYwb0wvRG90OUN2MEV2ZEZXT3BpMHZ5YXZyRUVIYnpzZjYrbHlQTUtPbDdtMTZ1VzhPdSszZXEranJaOHl6Y2kxd2JrMm8wY01lcVZqMmFTbE41ZnZheVZVb29pVlo0RzhWeEJyY2Y3QmswazdtYjRwcEJxRnJWWWpoYWRiM1FSMytGcUNKK0VSZnpVditNV0VsNEdYNVVLMFVPUjFYTy9hYmlVM0FZcmh4ejc4QmEvalM0blV0Yk44RTFXZ3B6Yk5JUHdMT2hlNkZGeWVBcSs1WXBSVWdNbHRicHF3a09VUTRsbGxOanBScXJBblV5Sm81VG5waWpYemVUZEk0b2pTUU5TZExoYTNpMG5EOUpScjdqeWtTZktOWS82ZGlKZERPbTZrU0ZpN1Q4SURxd0tDY3ROR2lUUkE2U2VDKytqaE4rR0dwRHFBeVdjbzc0UkZib3FKS3BHbWhyZjVVWVFqMVJJMHRmTkpQNmZUWklkN2huaUYvSzhtSHV0OHBDb0FHOFdKZGZlU0JQM0hTWlZnbnMrYlY2b0hPdVZ4ZHhMa0c0UXBWYWduMHBxVUVVYTB4dThrMVZvclRHVjhIUmZUNnZVNldIdURTWWRIc1p2UjdKaTlCVnp3NUIySkxxNHhlOTJVNGlmNmplN081RitCbjdnYm1pbXIzZjNRWThROTFPOHhUemZFU1F1Y2N1UnFRVDl0U0ZsVENZbDl5UlVoSFJJYVY2bFJGRWt6UW4yMG1ZUzNtZ1NIa1NQMGFEREJOS2xYTVIwZHFJYjdqc3ByZDVLVzB6Y2NuUi9JaVcxS0pkUWd0eVQ1RUlKb1lXS3pDSkx5VzB3VktIaWRFbTNRclNZcGdiN2FWQi81NmhYQkYzUTYyaWRnMWJhU2NROW9nU2xObHFwdFZacUF1OGZwYlFZUGFNM3VjUkYvOFJxRTlROG43Wkswb3NLL1JPVVgwanYzY2RiUjUyWEtRVy8rVHRhcGhRSkIrTUp5a2xmb1ZHcWhLdUtQTWNyZ1lUZlFoY1IrczhxVGViOXJhUzd6ZGNqOFR0SUhOYzBhQWI2bVVXcWU2bjlYSHI5by81eExZZjNBL1FsV3N6UlloR05kSlhvcTBvRjFHb01YbXd6Tlh2ZURWTVJ0VnZqUmhCL0VuRWpxZVhKdnBsZUVYZTNZQUczUXJkQlUxVHBwbEw3bVlUdmhYYzJkQi81MzY5Uzl3Qnhjd2lqSGV3MlpWYndEUGQ1bExmWWI2UTNNV0lvSDIwVld4czFvNTAyN0xVMTlLUW9tam1zWW1nQVBzWThLalFJcXFBdEs0a2I3emRhVzAyQnBxS3h1YlRUVTdTSjlXMzhaQVUyT2h5YVluMDRpZ1RyS0wyTmt2ZFJha1FuV0gvdHJ4RkkwRThEYUlzVWJXTld3WE1wb1RPUWFLeHE4TjlKL1BkcGVPTGk0SW5MdEVHNXlEOE15OElIa3pxQmZQV2tXSWZ2YmdqalVJRnNmS0JQOVEzallpYzVSRUpaTVZJMFUxWWlwSG9IRDkxT0dRbFNsbXNOdEFHZDF4S1hweUppQjloWUZVT3lCTnlkU0ZWRE9VVmh2RXVKY2NqS1lZU2pqeFREYmFNYnBhTTF5dmdqcWVwSUZTVlZoSkdnbTVSSlVsWlN6a0hLYVRXclBhUmN1UE94eWlSVVNFNFY1RjlKTytBcnlHVUh1ZXhCOTMvV0JEejhSRXFZeExzYjBNSE5QRThtMStsSVBCdTZqNUxua3Y0aHdnOURqMEtNb1Zvc2ZERDhOaExTLzNZUzNnWHRJZjhXTkxJWHZsYkMrMGpmQnUzbitRQmoxa0hTdG1QcGh3aDMwSU1PbytkT3JMc0w2cVptM20rajNUL0VKN1c3eVZqYnJkeHZnNmJpNTZkQnQwTjMwUDUzRWplZDhGM1FET2h1bm1kQzk5Si9aK1BuN2lQdWZzSVBLSTRGUjl4Y2ZOeUQwRVBFTDBCVHkrQlpqbnpYS1pkcndrYUJBVGJlRlRKQ2xsT1RDdXlpRXN1cVFzOW5pTmFpMWNaajVSTVVSV092b3JFOXRQVnUrdkFKYUsxVms2RnBoRy9uL1d6NDcxT2g1cGlQMjgrY3J4TE4vUTdOSGREenBIa0IramxhbmVmM2FoRjUvb3I3WXF6bzF4b29MRnUxMEhKYWNJMmlOanJ2eEVJYm9GMlVzVWVsYUxoYmV5bUQ4VUQ3ZUc3RFN2ZXJDQTIvZ0lhWHFwMzdJYWpEejBMRDg5SHdFalQ4QjNWejkzNCtQcU1jSDVCd3lJd2ZTTG5ib0NuUVZPS200ZjF1NTM0SFh2OU9ldHgwd25kQk02QzdvWm1rdllmN0xKWGlMNUw0aTBMOFJVbndGNmVnN1pGdUxuN2pRZUllNHQxaWZ3QnRkN3ZsWnZNWDBlYlA0OGwranUzTjQvNFN6NHVVaHdaMmE3SHZSQVA1ekZlMm9JVTNWQXM1ZEZDamEyaWxEdlVSS3dHMG5tL3p3QTVhYXBuTkhjcHRkSzVHeDZVMnd6aURmTWI2RDdIdmc3UldEcTIxZ0I3VG43WXVwTFZpdEZhN0puT2ZCdDBPVFllb0JTMldvTVdLelFjaHVSN20vaWhhZXdyTlAwZWU4OGxyRWZHTGRTSnk5dFh5akhucVRyVGZRT3Z2Z21jUEVyZnd2QmZKV3FGOVVCdTBIenJndjBzTHphZUZucVdGbmxRSG84Qmh3cDErSGkyMGloWjZtaFo2bXRaSjBUcWRQVnNIdWdQQy9qKzVWZUM3bC90c251K0Q3bGNSclZMajVrQnpGYVZWRXRZcVArYytqMzYyd0ZxR3ViSjVqQVM5TUI4YlRhTFJRdXh4TVBkeTg5UjcwV3dVemY0SnpiYWcyUlY0RGtaWmpVQ3pPYUlYb2Rtb0pzTTdqZnQwM3BuMzRFNnBlb2o3dzlDanROSHl0RmV0TXEreGgvZ1dhQy9VQ3Uwai96YnUrNkVEV0lWNURHUTZ4TDJEUE9tdDZpS1BidEo2N0RmaS80UzM2RVJibTl5dDNHK0Rwa0JUR2Mybm9hWGJvVHVnTzRtYjd0RWFOQU15ajRGbnVJYzdzd04zTCsrUjF6MEF6ZlV0N2tFSXJ4Zm1JY3hmdVMvM0xXWURVV3lnRUJ0Z3BZUTFyNmMvdjRaRi94Nkxma2NMQ0M4ay9KSi9HODVUNEt5RWN4aFcvVGRtNEc4eEExK0RkVy9EdXYraTMvRDhxdjl2dllhbHJzTlB2TVU2NHlaYVlpZDF6QXV6akQvWkxHTXc0MUk1cFZjQW0wVlErN0ZvWkx6S1pDM2hGOG5XVGpiRFNtRGpXL0ZJSHdoN0NSNHBwZnVnT1R6UFJjcUhOQUxiWHNwWTY3SHREbXJ4WnlUZnJJV1U5eEwzUlJwR24vd0k2YXVRdmtKTHlHc3A4YTlBeTVDODFyK3I1ZlN4MTBtN1JnN3BHN1FUblREUHhFdnRvQStVMDZydDJrdVpyZFJqSC8yekRUbVlQOUdxVDlLcTgyalZIOUtxVDlPcVA2QVB6QXQ5WUNFdCt4UHJBeEc4eVMxNGtWdWgyNkFwS3FNUEZORUg0dTUyN25jUWR5Zmg2WGlodTNpZXdmMXVhQ2JoZTdqUDR2Mjl2SjlOMlBvQzlJREcwQmZHMFJjSzZBczE5SVVpV3JnYkw3WERaalBMYmU2MmdORnBJZlFTWkpyd3U0TW1CbXNKdFg2RitHVzBWUzF0dW81V3VabzJlNXQwTVhwUGw1TG9xRkJKMm15RHlnbFhFSzVVUkZYbzAyWWo2R1U4NVV3ZzE0bFkwUG0yVHQxS3V5VnB0M1V5MzBSNHVzMzZ0Z2daOVREaFIxVk1lKzNWYzZSYlFQeEM2Q1Zva1VxUkxoL3BpcEJ1bTVZUlY0czh5eGxuMTlBKzZ5aDNKN3B2Z0hZeEN1M0J0bHBvbzFiSzJZZlViWXFGc2JrNWpNM3ZxSVA3WWNycFJOWXViSytiOTU0WlowUkZZV3h1VDQvTlU2Q3AwRFRma05IYjJucjJOc2g2R3pRYnVsOXgycU9FOWlpalBTTEJOOFZDZTNUUUhvMDJEMmMraEhYWm5nTGFHd0RaSE50MkhIYWowWGthcXlRYTNJd2ZLclAxK1JxSUdadnROZlNHNHgxMHZoYTlkZWwxZEJSVzdzeVdXRmVSOXlieWpwSDNCdktlcnhSM205UFJJcVcrZ2RTTHlMK0lrYXViTWpaYUdaWVRjcXloL0ExS1dUbXNLc3d2Uk1BaW5oZERlWGpLeGJxVS9QR0lObjk2VDA1MWpPajEzTi8zaC9CZVMvRXFPM1MyalhBSjMyVHJVQnZkYUVFYjNhQUtmVkdWbEYrbEVuTDhBNzE5QzlZU3gxcTZzSmJldGxhNEhiSjVoNDFpQS9VUTkwZHB1YWZ3NDh0TkozMjBFOWtiSU91ZEtzd1lvUXF3Z3NMUU8xL1ZRWFRTamg0T1lZMGQxUDh3OWU2RXV0QkhOM0hlcjBEeTNmVE9RbmNyZEJzMEJab0p6WUpZcVlkNVFZeFdUcm9IQ00rQkdGbXRoUmNxK0ZPbE5JYWF0eWtKRmFxU1B0TmhLMjFXTTlUMFRmcEhHWnJmcjBtSzJJejNabXJFS0lNK082bGxFZjNqZ0I2MlZXUUpOYzNEL25kaDk5M1VOcWFkUERkQU5pOGx2eGJpYk5aRVNXYjNrTlhZYkgrM3pQYWhEdnJhWWRyS2JCL3FwbFU4L3NGcWJMT210cDYxVHRjV200Wm5EbVQraFB4N20rMDhUdWovcEkxK3FGSHNSSTNFUnNiUVk5bHJDU3ZsUE5rc2svc2t1SzZEY21RekdZaFpodldDN2VwUHl4Y3pZZ3pBUWxQSVZVSnJEZkl0d1ZLWHdMMGFLOTNMT0ZCdmZ0MTZBVHg5c2NHb2lxRUJsSkNDYkczT3ZkVEc5WGNwT2FHdkswYnBmU2c5cVZYcDJVMlJyWThhS2J1SnNqOEtQWEN2V0N1RnNqK2lERmJJWVNlckN5NVdVOXpaTnd6OXRBT09Mc3RuTjVKRTROZ2Q4amtjVmplZFNCS0Jxek9kejBGYjVSc1hZVnZUV1Q0ZGlwcXVyTmViaEZFeFIwY2lRcVFvc2ozRlJsdDFSY04rVGlONXRGbnVZV2ZDZDFxdjdXVmxtYnhRa0pjK2FCSkF0Z0tUSTdhSkVyWm9MRFRKZDZMZkEwRTdTWFRjUXM0NzFJOVU5YVRZUWw3cnlHdEwwTkRiYUtpTjFQTk40b3VvNTZXNkZsMzNJNmQxd1ovc1FOKzlnazlwRVQ3RmRqM3pzSkE0ZFVpWVA4bmhLY2ZOSXh6VE9kVHJKaWpFdWhmeFFyOGtWUnplVTNrN2lyZWpNdElNZzJNVUhLT01veHlPa1hDTXpPQW9oMk0wSEtPdFpJdEZXdHRuaFFZZ1Jjb3NKaGtzcGc1ZGRJU1ZhRExzYjFwYm9OZUV6WktLd2l5cFFGZW9EM0cyTjBBdGs5UzhFQzgyV0NlcW5IQ0Zpb0ozS3lQZjkyd1ZQUjRibjZCY1BOMVdVcGRTVHNKbW1UZHd2NUZjYmxaZjIrdWFabk1iVmxxVVA1ZjdvNHpJVHluZlJvRWxwRnV1Z2NoVmhWeG5haWRTTlpCdUY3UUgvbFpvdjQxOU84TFkxNkJEM0R0WUFSNm12VHVoTG1UdTVyMzNXK24vNzVuSFkrekw2djlUZldkWU5jWGRIZENkeEUzbm5qMC9MMlpPRWd2ZU1aSGhIUk5wZjRIOGpJR3hqUG41YnJlQSsyTFNMcU9OOEdzYVludFN1ZlFIMjNPRGt2UWUyd25rWG1Wejh6OHlzOWlCNWp6MjFhVWI2QVUzVTZ2cDFHNE8vSE5aV3o1TW1IMDNaaE5kWVowWndVc3kzNGFQK1RZMTNXWmVqbDFFZHpzMEhib0xtZ0hkRGQwUExlQzlyYUpKNDhTS3dLN3o3YnBVN0RZb1NtaFRHUEc2d29qWFJkNDdTTE5ibzNoZmhqVlVLdy9DYXBWdnFZYXFpcWZ4OUpOemlEdWY5cmtZdW9TNFM2SExDRjhPM1VqNEp0N2Z5WDBtdEFoTCtoVjNtMjJyMnJ6WGF6eXZodFpBNzVGckhiWmR6LzE5N0R5aWk5eG9kSHNhZERvMEJob0xqWVBPZ3M2R3hrUG5RQk9naWRDNTBIS04wQmVSdkZDOXlDMFBzcjBESktsQTNrcmtybElwMXpLZWtyUkRWN29HYWNtaG0zaDNKM3pUVmFLWjNCOVdBUmFiRi9wTWpYMHpZVFZJUzM4eTBsZXJudnY3M0cwY1Y1eGExRkNMVW5jYWREbzBCaG9MallQT2dzNkd4a1BuUUJPZ2lkQzUwSEo2dzJqeks3Mm9UeDZVUUlwOGNxNmdKcFU2U1ZWSU1wNzRjMnllMmtFdGNuUXhkQmwwT1dTMTROMmRTbWs2TkJOaXZXeCtZQkg1TElhc0ZzcWhGb1gvVS8reTliTFY0RlJxa0hLblFhZERZNkN4MERqb0xPaHNhRHgwRGpRQm1naWRDeTNIZDUyQS9XL0M3amRpWjZ0MUhpVmR6Y3pxZWU3L0FiMEEvUnlhQi8wQ21nKzl4K3k0RG85U3ovMTk2OUVOWnE4L3Nlc2l1ejZ2aEkxU0EyeHZyeW40N2pkczM0MytaUHQ3dHVkbXU0Sk45bzFKQkNrNnlXMjk1YkJLRjZpUDdZcTMyMnl1a0xIQ2ZKenRKcFhEMFVIdmZDL3NTUXdNK3hHSnNBOVJvUHVnQjh5bmxZZTlpRlRZaTJqQ3QwWFJNZDZWNThYUXI2RTFhR0tuaXRVQTdTS2ZQU29KK3c5bGFpVzhEMnFEOWtNSDhCQUhvWGJvRUdSekhTaTlCd2Q1eHJPSWt0bHJMNGhkYVZ0N0JUK0hUeXZKV0dNVk8yYWV0Z3RrK3cwYWtlSFA0dmd5bSsyWjVQbElucXRmUTh5VXZlZXB3UFIybURvL2ovWmU4TDlsTmIyVzFmVHJySEZlMFV1UXJjTDhuOE9ZZUNMenZML3FaVmJhci9CdUdXdWFXbGJTdnlYdHE2UmJ4K283SjZ5S2l1Qm0vTGFXL2pLK3MxVzV0SDhmTko1SWY4ZTFqUlphRUZiWXJiUlV5bGJYWjN0VzEvQk5RQ01US1dXU1AyaXI2eHQ0dnBsVjhtUnNqZFVPL25RWExiTWFYM3JJVmx3N3liTUIyc1ZJZElDVjdVR29IVG9FMlVvWDZ2U1BxWXQ3TitUOUQ1Q3VFMjNIbmMwc3VkOEdUUkc3UGNUUHRGRWprWjVETDJUMFdVd0xMZk1mdU9YMmJXMS9qYUxsUzJ6L09xVWlRZ1VheExWVU5ZcWE1aFpyUlBnbXNNTTB3OHpBWnArbkNqK0lkYzZuM3F4QlZXVGZjTnE4azZla1BlWHlWSXYxdnhHK3krelFjMmpDOW4xNXV3RnZYbXZmMFJiWlRDa2hweVhxcXp4M3RUL0ZYZU92YzVQOE9IZXR2OVJkNTFQdWVuKysrNllmNDI3d3M5Mk4va3gza3o5VHZjTE1xRENzcmxLMjF4YVZ6V1lWSTVZOWRWdGJHUjhoMXNycG1CZU1oNVRwbUdkRFRDMHhNYXZMejNoYVkwK1p1VzVPdjYvbHFUSDkvcG1NSFBOa09ZWlMxeFBEZDBBWnM5eURHb0FkcHJDdEVrVnNoOTdtc0tTSzJXNi96Ym5KeGI3bEpxYlU5Sk9ndEhob3RTU3RsaHUrV3kybDFVN2dPb0ljVGxOdStHYmpBcmhxNEtxR2F3UmNJK0hDNSt0c3VNYVpsOW1hNGEvcWVadGpLMXYycG9ESnFYS2JrWmFRMXlCRlNSdTNXaXpoN1h4cXNaUzMzNkVXQzBpL25WcjhDcDlYU3g1clJTMndEUHV1bjN4Q0NieHBzRm4wQVZ1MWxGSlNibGliTk1QWGF2UHJGR2xLMERFemRuSmoxczc3YVBpR3BSMHBZalk3ejZGK0JiTHY4YTB0aWdqMUp3U1AyZWxKV2d5eGV5WVhWdGJqcVNtaHRBZkVHM0NQNnlPczdWSjZ5K1hzSFh3TitycWk3a3J1MzRDdVlzYlVCNDV4Y0J4MGwvbERjSFhDMWVIK2llY3JDSDhkdWhMNkJuU1Y3N1Q4em9QN0FOeVdINXlIcy9NTEplNkVvNFg4bXVDcWc2dU8vUGFSWHh2Y0hYQzN3YjNYdUw4RTl5NjQyK0RlRC9jK3VIY0U3bzdBM1FIM3ZxeTg5OEI5RU80R3VCdmdib1ViU2Z3aHVQZkMzYVk4dU1mQTNSSWtPUXozZnJqM3dOME85MEU0dStERVU4Q1pCMmN6bkdpS1dPUU5iN3ZTcFg3QTI5MjgzV2N5V2o3K0FQbDBVZXJoVU9wK0s3WEdTazNYQ0U3akpteTE4YTFXOTk3dWFrcWJoTjZ1aGI1SnU5ekEvVWJvSnZTSW4wRENhNmdQcXlvNE90eDFQRjlQK0p2UURkQ04wRTIrMC9JNUFLZmxBOWZoSHZuczVHMEwrVFRCVVFkSEhmbnNJNTgyT0R2Z2JJTnpyM0h1Z3JNTnp2MXc3b056UitEc0NKd2RjTzVMNTdrSHpvTndOc0RaQUdjcm5KVHVEOEc1Rjg0MjVjTFpFa28vRE9kK09QZkEyUTduUWJpNjRPcFFESzVtdU5BR01jZ1gzblJaU1Ivd1pqZHY5cGxNbHQ0ZklIMFhKUjBPSmUyWGxaUWgvWjdBdVQ5STNtcDFkQ3EyV1hsL3V3N3dXKzJiOGpNWlUxS0U4Q3UyeW5XTUgyMTIzV3hyN20zd3J5Zmx1NlJZU0EvZUNGZXJCakhxbG5KUFpxeVV0L0IyTnpuMjR5MnpJNnhoTFBRNE9mOVF3K3ljalgwekNjOGFhaGRKNzJIa3dKT0Fwd3llYXZPOTNlbDNyTVFKMlNvZitVb2h4aGh5dFIwRDNxVDNFMnpQYjYzdGZrK3l1UmkraEhqR0hlVURUaFlGcjlVYVBGWkQrTjVpVzNxSC9IVzh5aHFkRWs0ODdkT1psSlN5TXdaeFNzcFZBaFFvbnhTMkw2V3o4VXFwakwyYVBzZ1lNVzgrR0duS2lhdmdYU1hwcTNnZWp4WW5NRnVjcUF2dHRNUE56TnNtVTEvMlMzVWJhYVp5bjBiOGREendETkxNWXEwN2wzUVA4L3dvUHYwcDhsc096MDdlTlZEdUxzSWZZRFdpNVNOOGUxZkJ2Wkk1VmhWeDFkallFRnA5R0hIRHFjMUpXUDlJd2ljVG5zZWNqSFowaTZGbGl0RE8yMFE3cTlwOHJKM1Bzck1LMVdFZnFNVFY4all5V0doRGc1ZFdyTlkxT2xueTdmNWRmOUIzKzc5eGZkOXY4b2RCbDIrbFBXTEVkdlBVeWZOK3YwYzU5bzQ0Zlc0ZjMvRzU1ZnorTVhHdDhkTzV2cVU4Sk1GTy9HN21yVUliQjlBQ0xlWWJzTHhsNkxhdmFXd1BlcWtYVW9OdXRCLzE3ZkR0NFoySG52ZjdNbkplNytkZzRXdE5yNTMwWEttUDdaWDFWUUZwWmIxdkVURzVOcnIyczNONHNuTjFPVmdLTXc5Q1VzenkraEhsTTljUE9YZmFUbGpFcnlIOEYvOEtPWXFlMHBzOCtQQ1VoOFVWVW9jZFdIME9rSEtocUtWdDQzNkNlaUdWbExUOEMraFpCU0huUm1aUHpGN29qN24rUGI5U3hiYkdTZGxhSjhlZVlyN0p0MUgrWU1wSnFCQ1NCdHB1dnJpbVFLRnlRZFRPT2V4RkV2djR4ZjVicEh0RnlmQzhpYkorNzFmNGpiN2ViL2R2MFFJcC96VFdpMWNpcGdOOElIb0lwUjFRQWZuOGhwaE5Kclg4ZDdEOHFNS0hlamJ6Zm9NaTZBWEovSi9nbk9kci9VTHlib1NhMG1YdThtLzdyYjZCWE1SOUsyL3kvSC9EK3dIaExvczlTSnpwM0Q2MEwvWG9wRjJieWVmL2h1TklueGpwc1FncnBmM3YyelQ1YlZBaGViOUl1TTcvRWdrelAwVWduVE42cDlWQzJkRlB5ZzM5SEV6bnZNNS9pK2ROcktTRkhsLzluM0ptaEJOQjhvNVEwK3o0OE1IKzdXTnlyclQ3TTJoa3MvL0pVWG94ejdSY2M0L1l0cXlueG5Sb2dUK0g2NnZCUXRtMXl1RGE3WGRrcHd2bjA5QkZoc3doRk95akkwUG1kYUpuWXcyZHRQRUM2d3RLODJZOEtSK1N4VmpPUjJpM3BuUndwSVpaTFpkZ3U3WG9wRG1iejNkbjJPZEI5TFZGZVZ4WElFV29kMml6d2lCTHZFZGg4ZEF1Ui8ya09Ycnk1V2JySnZnTmF3Y0xjejIraitXVzZaRzRROTJFaiswVDFiRi9rditRTnVMSG9JMG12OHJ1UHpQUDh2aFJ4eWl6YU83cDU2Qkh3cGxQeDZITGovUTVmSTVkTHZ6Z0Q3ZzJmN0tHc2VIc3ZzeThvMGNMSm81Z0d4Mis0ZGlsQ1RuSHNuUCsvM3ErZ1ErdnQvc3JXUFlPdjZTbkxXWDdWTjlwZDVBWkMzMytMZmovUzg3V3oxdTVXZzFGMk1hb3hnd1dsOUZIdW85UUx2a0VQVytFdHZ1RldScUxaVC9aTldLaFBDaTdMZUR0TVFKUkJ2VFphelFCeGNuakhlZ2p4dG5zVCsvc01Kd0ZpZ3IwR0d0R0g4a25ZcU94ejdIVnM3VmJtQjRORTRwNW42R2p3eGs5SnBiUkMzT1A1cnVaY1gwb2EwOExiOEFtY3VnL1RwVEE4MEd1dTdQODZtcEdlTTZMR1ZiNnZjZHB6MnMrWlRyR3J5eHQ3R0QrMjVvMUR6bVVvWTBFVkpEV284VWUwWStneGZTOG5YVldHRXYyRURyY1E0WTJ2K2RJbXVWdEkyVVdVc09ZMzBaUEtjeXl5RUtRZmpLWm1BMFR5aU9jQ3ZGOU0zeHBJZlVseitPd25tUDVuQXBLS2F2WjdMa3BZMVlyMjJzOElmMlVvbTVKM28rQU02TTNXNG95ZzFTdFljYjVTWi9lU21UVUp3ZVUrRjNFRld1QTdib09UZWNvdU1yVngvWnpRMXNqeC9GOThpQlpPMy9HSC9yS3NYeUtnOS9ZWml1TGRZU3pac3RaOCtRWUZJY0VaYy81b3dieHR2UTRQY3ZuOVBHdG56SWh0V1pWMFpFWjQxdXljb3YwbkNVYzB3eVZYVFg4VjJQYUFqWm9qTi9LdGVjOHFKamV2Y1dzT2F3ZjdGcDVyS1B0NS9OQnV1UC81SDdXSTZ6dndPNDVuWUYydSsyVVlGMldSNjFEMytsUzBINFQvRzNNMGhvSVdhbCtxOTBUK3ByeXJGZkdNOXNWM2pyYmdjSExVUCsvcTNuS3F3ZWZYSjk0enhUcDYyZTBCcUpldFlwU3p3Mk1HVHY5cXFQTU56SlhTL1JsYXR1emxkRkhoaTQzV3Q5WVFjNzFmbEYyeiswNXA2SVBIYkxabDJtMUJ5ZDlMTTFaSC9aZXcxTjI2OUx6c2pWWURzUU1KSnFoejRJajJHZzErZTZtaFo5aDVyRE0vOGkvazVYenBvemF2YzA0K1NZeXlXL3g2NkQvVHU4N3dLbHJrUzZyRmhaTGE1QnZJM3RJUy81dXU5UkJUZGhkNCtjeFQrY3M5ZWYxU1NxbHhPZnZLWTU5aG9FT3QvdFZmbnZhQzVmNjc2cFUvWHJ1RmRrdjBoWi9QQzc2YVduN2loL0ZtM1JtajRjOVBYM21HdVVUMzc3b0w4UHFubFVORDhOVVRpL00zRUYrQVpuU1l4UjFhV01VM2dJYXdFRmwxOEQySGo5RE8vbkRaem9lN0QyZWtRUnRGV1RNUWFITTNiWmptU0hRbTQvV2s2Skg4NkZvK0IvNzVDTkhkcDc5ZXNoNURETHJGQTJqeGJkNXpxcmdTUmY1dFZrMVdwMFIzdXIvN0hmWXJ5bFhzbS80aDNSdDYreDJCU1RiclQ2dXo2ZVpoV2Jyem0vODVMWTVwcHhMbExDeDRJZlkvcW9lWGl5V1dhYnRyV3kzbWZ0T3FEUEQwMFNDSlNWVWxPMUZTTFBZdDZLN0o0KzJ1eTZsNXdKN010TUdDYlAzYmFTd0Z1Q2JnQjIwNEkvOXdhUDYvTzFoUGJNajIwOFFOeXc4NXFWempvVng5akcwVitzZnkvWXRtVDZWdmVGMmFLdmx2RDFERzIwV1RnWnZHa20zYjU3c0xUbXY4dk81MW1mT3ZiSkd4UTJlWFhEL0I5UDRsa3hmQ2gxUTZ1TnhNR2lNWjVQNVNiUkJ6aG10RGo5UG1mYmNqTTF2SmdWaHFEM3pPNE9RODRHTS9od1BMZmdEY2w3c0h6L3l6aHp2Mi9HZjI0SnRabWtqWXcwWVRaZFpZTmRDMnE0RDIzaFdSVmsyVjVCVlNzdzBuOGhZT3dYL2I2Y21ZNVpiWVlpUjVVVDVhS01lKy9oK2htM0FrZW1uc0l2OWFHU2J0V0M5cGM5Y3c1WDFrTGtrNVB3c0tWOUF6MjNaTnB3UnJrZnZtL3hteTNsYmovVlFxSUh5ampCS2gyODYvTDZQZHlHVThHdkNkM1VSaWJlWjMzQVVrMjhSa0QzL2xyZEg5elhVUER4OVFQa3hFRldFRXJxNHhxR01kYkovMzA1U2ZVWWYydUx2ZjV5dW9RYk1jdTFjVXgvbEswbXRPVWxsZXdNcERWU0ovVEt5M0g2SlY2VWhHcTR2NlZTZG9iRWFiLzlCTTBuWDZVYmRwSnMxV2JmcU5rM1JWRTNUN1pxdVdYcEFjelJYRCt0UlBhVm45WnlXYTQwMmFLY2F0RXQ3dFU4SGRGRHRPcVFPSFZhbnV0UXQ3K1FpcnRJTmNUVnVtQnZ1UnJxZk92N2h4ZjNTTFhTTDNUSlhhNytEdjFvNTRGeEZ3V0RUNlJmVUc1UXExOUFIZkZuNWhpUTRRNFZnb3JYYmFQVUhYMUV4T0Y4RHdCQnI2MG9OQkJOVUFzN1JJSENpQm9QaEtnZGxxZ0JEVlFuT1ZCVklhampJMFpkQVZLY0N6dmFCM2hvTDRob1ArbW9DNktPSjRFSk5BdC9RZGVBcTNRZ0tkQlBnOTlRZ29jbWdYTGVDL3JvTm5LY3BvRmhUd2RXYUJ2cnBkakJlMDhFcG1nVUc2Z0V3VW5QQXFab0x4dWhoOENVOUNzYnFLWEN5bmdXY1ZRWTFXZzVLdEFhTTBBWlFwWjFnQUMxaVp5OEFKMm5CVjdVUFhLUUQ0R0lkQkplb0hWeXFRK0F5ZFlETGRSaDhUWjNnbjlRRnJsQTMrTG84dUpLV2xDSU82QUw3bng5SHF3N1JTYlJzalFiUnVzTjBGaTA4WE1ObzVaRWFaZi9uVTAxci8xeW4wZUx6ZERxdC9rc1YwdklMVldILzZqTU9DMWltUEt5Z1ZsOTB5N0dGc3hWQkc3MUFvZklBSnhIQVVCV0FDcDBBaHFvZkdHU3RTNXVxREs1cTRHaDNwRkVOS0lWck9PRVJvSlQ3U09oa0VOVW9mWkh3S2FEVVd2cWtzR3YzWlhDU1RnTmxPaDMwMGhnUTA1bWd0OGFCdU00Q3czVU9HS3p6UUs3T0J6VzZBRnNvMEZkQnBTNENCYm9ZMU9nU1VLMUx3UkEwZkRreFgwT3ZmWFVGS05EWFFWOWRDUXIwRGRCWFY0Rmh1aG9VNnhvd1FOZUNsSzRIQS9WTlVHSVdObGgzZ25MZEJSSzZHMVJvSmlqWEk2QkszOUcveXVreEVOSC9CcVg2dnY2TjJqMEJjdlFqY0pKK3JDZUpmeHFjcUovcUdXcjY3eUF1Ykl1M3oycyt0WHRSTHlIYkl2dEZ3aEpRb0pkQlh5MVZMZUVWNEFUOVJxOGk1MytCZ1ZvRmF2UWFHS2pWb0ZxL0E2VmFDd3IwQmlqVE9qQk1iNEs0MW9QaGVndVU2RjF0cHhidmdTTFZnZjc2RytpbmVsQ2s5MEYvN1FEOTFBaUdxZ2trOUNHb3NuOU1HK2xHdTlFcWQ2ZTVNVnpIdW5PNThzOVRxblMvY0w5UUgvZWllMUVqSFBiSDlTWDNrdkxkcjl5dmxIUy9ka3Q0KzdKN21aaWxicW1TOWo5VHBlNFY5d28xamZTWnFhalVaMHRpbmdybzU3S1RzT3h0Z1hyOGNaU3hyTXRPYkRIT01wWjhSaC9iNGVsbUh0TUUybVQ3UWlET0hMT0Y1Nmd1NUgxZCtwc0Vkb1JBMDFIM1ZXTXFoSE92cjgrWWZmVG5hdVBsWnlVMTFKYVdPdXc1SVhYNzBYWjdqclp5WjNhNmdWd0VTU21yQnlsWXRkbG82TnMvaXgwSTVGMzk4Y3JJTHlYWGRjem0yelBuQVJiT0RUTjlyNk4vb3I0dVkvNWRsSjRUZG1WY096K1RuY3dvZDI5UGkyMG4vUGxQL0M0MmRreTcxRlgrWmI4RTJUdHByMzIyUDdVanJJSElHYlI3WnROK0s3UE5MY2NoOVh0K0FiYzRmaVBYdDZObDVubGNOOWxNYno5elF4QjIxeEtFUk8vNkVEdHFRWU9mL0JuZ1gvZnpMRlg4NHprU01qYWtaOVdmUVo5RXhzZk1Vbk9WajlYOWhQRHZtWG0vZWRSRUJVZTFFRTVqY2UrVmpyRlZuOWxHa3F0TDcrNlVISWZVWGJTZzdZbGFlQ1hYdjltVm1EQW5KV3hQeFZDU3VBaFBSODZ2RzJ2WWFKNnBJMHRxZTZLRlBwTVBubU9sZWJRMndONFNvZmY4cXFQbjd0dU9zb2R5SXV2UTJ2VFRxTEJXMlJiV3pNM0lYeC9XWFR1T1MrcjUxc2ZpNWdFZnQxM1Y3L3E2ek84S0NJY242dFZvRm5wa1R4QzNNMWF0SDYrWlRkNTN5TkhXSGZidDZQSHJlaTIySEtXSDk3R3pndk1rOW5UK3phLzZ0Ti9Ra05kM3pLWU8rc1pnRmVzZ3N4ZS9Rb1FVRDNzdDhlTVF1OVJLT21DbkhmbEZFclZZNEdjcWFmNnFTVUZiWVI5OE56dFFyeXZ2YUR1UThMVEIzeXBxMytPYjdVUTQ4N1RIbmlMSG9ldGYrUnNvYVdFWXVlek1HS1UyK0xhTWtiTWxvMi9Gamo0MitvOW91eUp5Mk1INDFXbnBYNE1hU0NQc1BZNFhLVGgrSDZJS05OQUVscUx0TFZqa2IxaTlUN2NSanJLd2dwUHhMSCsxMGpmUmo5NzAyOUQxaHFPc1ZLTkJHdG11WVY2UXJrWUpHOS9GbmRuQzhaNkJZdmQ2TmpMT0QzbVVxTGNxS0N0bVZsdG9NNkgyWUtIRnRqT1NTdTlvSFUxcXBEVTdpZ2VwUjVHWElKNkVQWVpXT3g2cFo1TFBzK0d4Q2pyUnBENWdKZGp2TWRGNU41TDJEVklqV2JDVTVxUHNCMFFnbWZ6a1pqblVoOU11MGVEMXFEM29WQzVlcDQzOFl1RjAvR1k0S0ZjOGl6YTNuZHo5U05GcWx0b0lkWHlxRVRESCtxbklpVEVWdm42V2F4T3lPRlpudlpDekw3RW5xSjlLYlgxM3RtN1FuYXgxN3RaTVBXSXJoZmRVeCtxZ1h1OXJoeHJWcEEvZGFHYitwN3N4elB6SHViUGMyVzY4TzhkTmNCUGR1Y3ovNTdzRjdpWG0rOHoxbWVrdlJTT1Y2Z1g2Q0oxdzdRdnlWQUE0S3c3eTFBLzBWU25vYXhMazZFNFFzUlZYekZaY1VjMEVFVnR4eFUybXFONEQrYW9EU1Z1OUpGUVA4dlUrU0dvSFNLZ1I1S2tKeEd6MUVyZDFTOFRXTFJGYnQwUnN4ZElMcWVmTElma0NPVnV4OUxZVlM2NnRXSHJaaXFXM3JWaHlrV0s1Y2tCL1JZR3NibGNyQm9hcU55aFhIQzZ6QU9MN2dHRktnQ0xsZzRGS0F0T0NXSmVDQ1VJTGhBdkJGMHdYbDZrSTVGR0MvZUlONUdzQWlDa0Zlb20xT0R3bElLRkJJR3E2TzhGMEp3MEdRMVFPS2d4VnFnUWp1VmVSb2hxY3FpSGduMVFEeG9pMU8ySFc3b1JadXhNK0dad3UxdTZFV2JzVHo5cWRNR3Qzd3F6ZENaOEd6clMxKzFpTkFlTjBCb2pvVEhDV3hvSWNqUU5uMnpwK3ZNNEc0ajRlZWM4Qmwyc0NrQ2FDMFRvWFNLenllWE0rK0pwWTVVT3M4bm5QS3A4d3EzemlXZVhEeXlvZlhsYjV4TERLSndXcmZIaFk1Uk5tbFUrWVZUNWhWdm5reENxZm5GamxrOU1rMEZlczljbnZPbEJzSy81TGJNVi9LYlovb3lUVy9lUjlzMjRqUEFXVWFpcjRrcWJwRGtsWUp5Vk1CeklidlVvemdNeFNKd2hMNWUwOW1pTnBMamhKRCtyYmhCOEZKOXR1d2FsNkRIelpkZ3ZHaU4wQ2F2QUVPRTNzRmhCbXQ0RDRwNEQwTkRqRDlnekcyWjdCMldMUEFKN25RRy9iT1RqSGRnNHVzSjJEYzhYT0FlR1h3ZmxpNTREd2NsQ21GZUFydG45d2tlMGZYS0pWNEd0aS80RHdhbkN1WGdkT2EwQmN2d05qdEJaY0VQNDFmUjI0VUcrQ3M3VWVqTmRiNEZKdEFQMzBlNzBqV2MrY1lEMXprdlhNYTYxblhpTjZKakgwVEdMb21jVHNCRklET0ZHN2dLeXZYcUVQZ0t6SFhrVi9QVVM0QTN4Umh4MUJ4MGVuMko1WWtuMkljbUlxWElWRzJQN1lBRmZscWlYYkpjdTFYYkxCYnFnYkp0a3VXYlViNFU2U2JLK3N4cDNzdmlDWkw3alNmZEY5bVRBZWdmQVo3a3pDK0FYQzU3a0xKTnZWbU9ndWNVOUx0c05XNlg3R0RwdHNoMjI0K1k1dm1PK1E3WGw4M1R5SUhEc2ZoTmx6bGN5RGZNTThvV3kzWTR6dGRweHZlM0VwMjRzcnRMMjRVWXFveER4S3VlMnY5WktJeWJNem5vNnE1L0FrS0daK0lhcGlrR04rUVVvQlp6dDBVaW1JS0RLMERSNE51MmJFYVByNjkyMVY4akpqeVZvYlQxWXl2dnpVY3c3QlA4YzhkeTM0YjhhazNkeWI3SitsYXBsUmQzQmR3VHlqRmpRWkxTWGRBcjhVYkNCVnZkL0s4eHNhemZVRlprRmZJSDZCZjU1WjdXcWR3anB4TWZHMWxMQ0l2RnA5TytBcWZLYUYyMWdmcmVDTjRWaDI0MzBuOUI1blZKckkrVjIvaG56M2s5ZDZ2NThaK2lZYjBUYjZRM0MxMmkrdWY2TVRxZHVMZmgrbklkLzNIeHhoTmhrangzcjdOa0hNY1EraVQ1SCtUWElJM3k5YlNCWkNhaVZOOWc2clR4dlBnbUtLWkowTEpxV3RrUk5jVzZDOXZ0azRlVU5zeUluNG5WejUvUWt6dlRiVHpVYzJUck1IUzZvV1lnNVNkcHgzYlVlZVMwUGV5aEoxM0k5V1ZudmtDcEswb0oxRE5wOHB0RzlsWXVuelZNNTRja3lTcmY0QVR6azlmb2ZYaDdlSG9YMjhvNzRTK2ZVaVpRYzRKR2Rsa0lhYW5ZQUU3UVpteGtidGNDYVFIMjFJTnR0M3lyVzZKNnhrUnpnUGtzV2dJMFc0czM5RkRWcG94enJRZ201WXQ0RzlLbEtLZWtUaFNNOTFrZTN2Zkc4RU40UThIbm50bVpwMmNXMDJDV2xuaTgrRnJQWTg3MFhqbWVzdFFzWWoydUZOcTBzWGFhMWVYTGV5ZHNOcUFLbk1ncmhiZldrM2lOUzg2K1FPQi9LTFoxclR1Q3duUWxHZVc0eS9oWFNiN1d4YUFYd0F0QnJxb1QxY0c3a0Q5UElCcVhsUHFNSHk3VkF4c245b09jYVBlSUxCcEtTL0hDU3ZsZXBEU1pLRFA1cXhXOVlISUR1MGgxVllGUDZ3UDRLY2RtNU9VV0JwVk1oYVpHZGFWekhMZjd2cHBEM2orK204OUhlSmNldEJjYlBJWkxBVFBoa1ducGRldi9MRzVKUHRmMW00NTNraGNuZ25XRC9YSHZ1cUtkOE16RTdNNnpRZWFiMkExTjIyVzVObmxvTjB5cmYra3JTVWVTR2R0Ylg5WnRoS1FrUHIvR0ZTNUNnR0pmNW4rVHluVHlMMGpKVlpSZWE1WWl5TnQwZjVMWWxKWWZ5a1VpU3RWd2wvQTYxRkcrdkJCcitGVUFQM3RiWXVLRUJiNmRLUGJRZWF2aE91MmJ5bWJjdkI0bnZXZFIvdmU2NzRXMnpQWmpNeTFlT1REN0ZqMktSeVA5L2E1d0JXOFRaVy9lZmdHYmNyakEvbVQxWkIyeUJXWUtSdXNKWGtHdlRlYnZiWENiV0hrMXdENFdMdlhoSHFUVm9WV1E1YjhLOHR0a2ZlQXVySllhTi9IUzVHU1BQU2RlUysyNnhqRi94TjZnMEVWd2Y5YVcrUXZzdHZCSnZKYVhmSVp3UDhiL0wwLy9oL0o5MlAvZVBzZS93QnVmN3k4VXFjZkgvblh5ZXVJNXpZdGIxQjJxWFI3aDIyLzdQWWR0NFdrdnRWL2kyZWZzUk81MHF3UnRnazl6OWJ1eElEUDdIVVppVWUvbzgyZXRjU1drZWF4VHd0cFBUWHVQOUNGVnp2d0pKVDNOZjViME9ybGVJNm4rY0FkTjJKdmJkWlM4WE1QM2JBa1FZbHYyL1dmUkRyTmg2NDZJWG0vMHduRnRxUHJKdHA3NmVRNmorWlMzU1E1MXI2eGtwYXVCRXIvTFZaK0E0MGttUVh1Z1Nwdm9mVXpVajZWc1llWjFmR3Zkai9pYmYwWSt3dWFtdjgzcVJmUWFnVEVFZE9qQnVoVmRxRlhRT0RrcmJiUloxNG9wY1NZejJYcDMzVXgzd045OTFnTTZHT01QWjJtSXh0WUR1UzFkTm1TeW14RVhsczc4L2V0S2Y5VTVuWmIxZUdUNDFuKzFpN2N2Zi9KV0hUQzFscE55RzlGL3Z2MkZVK3oraFQvWUt2YkVVZk8xU29uS0NObmZSZ0xDek04aEkyLzh0RHNzM3dLTDN2eTRoaE82aXNGazBuekJjZ1NzNDRpNUtBRkx5WFBabm5ra3duTmpJM2lCekpZWHVZczFqNTJUN0hOOXFPV1JQek9iU0JEcmZZYm1JaFNLUlA3eGFaVGpwQzNuSHNJOXBUSjliQ3BFVzNmK1NLVHFoZlB2ajRRMTFEdjhnK0E3UUxpMmkzRkIvdkNEci9vVmt1NHpDMHozZUJSdm9lM2hUa1pNelphSC83ZmZlQllCZG9QNUQ5Wmg1WW1kaG9MUGdUUWZtKzB5ejNFRytyQ2JkQnBMZnJOdDhFL29ZK1drQURYRytIZVZBZGZQdk5WaUptdlYxSDJKK0tCSjhDU04xSlAzdUg4bTBNSm4zSHg3L1ZETE1Sb1NlSHJmQTI2L3hWTk12ekpyQ1QrakFtZEFENkN6SHZoZThFMDc4aVQvdndnWGExRVZrUnJsM2NZK1JpYVUwVzZtdTZ4TWVLNTdRRzQ4YkhQTjY0bVY5Uml6Ym1IcnNwN3lOMHNwOXdIU1hSRnVaQjZHMVlSVzZZK1J4eHZJR3oyM0pqdEVTLzZ6Tit4Y2Vzalp4c3htcWV3dXBDam9lRWxrMHY4RnF2YlRQZllWcXg5RVZJVzAzTysrRmNhQ3NrYVFoZXF0eFE2cHRWYmoxaHQrMzRqVllSOXdUWElyL1pmRTBNcmxHbXdUaWNXLzA2bm9kekxkTXBLc0hMVnNOL21pcDV0d0crcUNyQk1KV3Frdk5XODFrSi9aRDdrMXlmTkx5anMxbExsNUs2Mm5RUlZ4SUw1VTdMcFNnMXZaK3VSUEN4QzdDT1p0c1BqYWdJaVY3ajJnKy8vNHlmaDNYOG1OQktORjZMNzMrQ1ZkZ0xHbzVVTFl3Nzc0QzNHUmwrcUtpVklPYlZmK0p1SHhzYnU3SlBMdk5jQXV5VHZzZE5rcmpkdzlXb0pJei84WFJLSVNWMlFiN3ZLbW1waExRdHhDaE5RdHB0Tmp0WjZUZmhTeHE1cnFaZU5TQUp3aTkrelFvT2YvSXZsRXpxdmRuendFK2NwWGk3MWxsZnlnbmZMVWZVMi9Ud1cwdlI0M3QwMnBEK0J1cHRQaEhGMjM5Z1ZwSm5JM2M1Ukc2MlBxODJPOGtUVjlJbGlVRjZZdmtRaWpNN3J5TmRzZjhkVCtUZ1g5RkkzbytDeXFseG1hM1dLM2t1dzA2ZVJTc0xhYzBGZ0pFY20va1oxbm8yS0JjMkZ0b2hZaXN3Q3dPOFlxYjB2cHYyYjZmZkhUWWRXczJ0WjNlZzQ1MWMxOU1mLzBiZjNNcnpFbXh2cVNxQWVIZUlkdnlBVWVmSGtra2xXMTEzcFhVYnRWWEhidmIyNCthVlM2aExrTUpHanMxQnk4MWlMemM5SzY5TmY3dFhSRnByUWRwNmpVU3FlY0c2bnpDYktDZFZuRHp6d3R5ODBIam4wRmNlOXpNQk15czA5QU4vUDdyRVByMTVNM0swVlRjMTJ5UmtNRy9MZCtYWnYzWm5YdkpuYXJ4VDhUQmpYV3E3OFV2UjcvTitPM24rMGk5blJ2VUw5RDVIS2VUcHJUeTB4TDhEMGxOZVoyOWh0dEN0ZVpUZmdMWXcrdVNwTk5oaHM2MTdPNm5qUHBVQ3N4T1ZRckpaZDhUaURGWS8za1BGS2syUGxheDA0ZXV2Zko0S2dNUTZGMG9xQlpXU055SGJCMDVTazFiUERBV3lmUlR6dHQwYWhtWGx3Vk1ZV2lVS3lTZ0tlbnhyNnh0Qmg2eVhXZHkrMElkZk1YKzcxbTh3dmU3QzIzWmhvZlp2eUthRHc2UlM4TUdXSXJzUG1hMTF3Y2Q2REd2Y2FoYkFTalZycldIN0FNWWJZT0d1OEhRQUdML0YvdFd1RGNiVENqYnlaR2t6WWQ5V3YydHpTanVYUTkzcXMvTTNpMnYrRktlQjJ0UGgvVDNldHRtbzNSMStBM3ZFajhuYkFleDNlZFJsZnFpTHpXVkNYYVBFRXlJMlV5ZHRJZFFNdUFlZGJNS0tUQk40dEFaNFZnV3ZpMFRaT3g5V3BzV0YvUmhiU1dYb1pCQXkvR08vRW5QazIyTk9wd2hJVUZJdUxiN0RTcU1OZStRYVNlZU9GaUM4RXRmMWNEZjRuNWxtZ01YYmJNeGlta044ZTNoSGZlMjV6bFppelg1MzROdHExN1ZRbDk4R1Z2QnVHMjBPSjdUTlZweHcrMjZUcmRuNmE0UzhDQnQ0Ryt3akg1M1lDdnpZZndWcWE3ZXVEQ3ZKcnVjYXY4bDZEbnMzUnoxSlBNNDhRNUs2bDJtSVNqVmF4SUZoUE1lNU02cUNVcFhyVEExTFE2b2t0cEwzakNzV0dxbUVwUnpwUCtUcEZKMktsazZGazV3SU44RlhTbWdVWUphQ0ZuZEFmd0JveWI4RC9ZSDBsNEZoT2cwZTA0bVNkbWQwTTZRL050Wi84a253Sk9uRFBpTlBJcFhORld4SGVBZDFPNWxjUlVuTWFESi9QNXV0UCtzRExiWnI5bGZyQjc4Sy9kcG02M2JuRS94RGxqOUo5NlEyWUROMjQyY214N1V1emI4T3lrekxHN0ROL0NyZXhKNWF1ZSsyMVBZVVN1MXRmdlR3c2YrQzJ2d2k0MnpHSGsrM2xQSFViS1VRbDYxVG0rbG1ma3BDWHV6cmhsa0xjY0RDZHJkeEJ5b043Uk1Ic3ZsZm5rcnNEVThXcDhDZjVNbkdIYTdGUm9MeUNCRVdWM28yM3hNYjJrdzNQRWthb1ZHOEpWVjY5MG1mM1crNnlTMFg2K2s0aG0vNFN6NHBEbVMvVFprRkorMU5DcUsrUnBWQi9nUUk4MWlidzNaYUtNWGJFcWpjZVBNZ2c1TFlTVE5qamVuRTBHUnowbUVBM1VFS3V2OUhQL0VqNy8yWmxJVWhsSFBVWEJLc3Y1cHNKdmVoOVJaMlA2eUd6TEhUNitJWW9SajVFVEpTMmtNVlpucHYvNUh4RDVCczVsV2FjVzRyWlcvSU4vMzdva1pLMnVyclRTTzd6VTdzZlhybVNoNFpvMGl1anVGajU0cHM5bWhydjdxd1Evdyt2YkV0bkhYdGhEcEVTVDE2M1lHZTQ3cHhIdjJUT3VLM1Qyam9pRzFhL0lscHRwbVZzQzczVFNHMFdaL3hCNnZObm8zRkFMcjYrM2JpMzRGYWJhZVRXUjlqNkF1RTNnRWZrYWU0TXdjRW5FTUs4WTBRYWJpMmhXZEdEM3ZxTW81MTlxN1dlTFpRNTFjOEZpRngzV3BwNnkwVmUzQzJLbUczRmJRU3BqY1Jid2p6RXZieC90Ri9ialNiTTEyRTAxbFFlRzZHZmt2OTl0a01vL0dvM3h0aFozRFYyVnExaGZIN0o5UnRCNmczQzJnS095dk1kcXpYdHdEZVNsd2JvYTJBUFhkcmJhUWdabzNORmxmWXp2Rkc2cjZFRUdtdHAyd0hhTWpTMnR6VitoQ240MHhUbEFsYW9FWlp2elNwdXFFUFF1c2R5MG5ydmZZdEJ1TlZqLyt0Ni9CTEFIM0VWaFdoOTZmMVp0VHoyeGE3TGpuaUw3YmpSK3pGelJtNTExbW9LWjNmcTUvNnQrMTkvL0V6cE1IQ1lsQm12d216YUt5eS9saHlzUk5LRWF0QkgxVngvek01bElGQ0ZTaHA5emhJY2g4T3BXeGRCcmdYUTJXOGlZSUVUM3g0SDBjcnh1OTNFNXYwQndnbi9FYkxKd2tzdFg4VjYxb05sbGpQMnd5dHAveVU1Uy9sQlRzeCsxQ2NOd25pLy80blFpMEt3N2V4aGFhUHZrRTNLOUR3RmlWQWYzTEtWeEZYWmZtWjNrY280UVRyUzlsckMrN0hkRUtTbWdkdnZaV3JuVXEzWjU1TXBxd1AvV2d6V0VjZld3ZTJRbXVRS3Z0VDVOOE9vWnhqOXlkMmNyRVh3VDQyZnNaQ3Y1Z1ByU1BHdmh2a2ZkSFI1aksyR2p0a3E5Tk5OaDc4VXVRTVBpSUhRcUVIME9zVjV5bEE5aVk4L1JYd1pOK0tzSkpVak9zRysrNmpFYXkxZFRGcHd3bzR6R1lKN1FiMTl0MWFONkZtaTJrRk8wSlA2NDFzbis2WDN6azl6NS9iR3ZBdmZxZUYyYXM5NGkvenJUVnN2QUNXRjc0ell4NFJEL2VZU1ZuOXlmN0ZkRVNhdExlS2ZmemJEMEo3UG1sRUR0OGM3ckJ2ZTJ5ZGlzN1Q1UVo1RXlFL2JQM1labTlXaTRSeVFGZ0ZaczJsY2lpck5ZUlo0eDF0eFcwNk9RQWRzbDFzczNLclZZYit6RjVZYngvTng5cStMRGFYNGV0RWFNTVJ2dlcyUFNWZ0Z1YXhreDVNdmRIVHAvalh2L1ErL043TWtZTHl1bW1KZDQ4cG0wSkczRmF6dEpoUzNOOFFjU0FKcEZSYWl6R3prMFNXOTRFekhSTTNQUmJhTjFBSjBpWHNuakJQeS9kZk5zY3ZCREdMWFlrM1djKzR2WkRyZW5yc0ttdUxoTDJYa2UwVnBPMFJhWTVCSTRkSVVacWVueCt3ZE9pRitLM2MvMGorNEJnOFZLRjlKNFFlNGNQYTA5L0hGUUZDcGc4b3UrK1FnbmRaT2tuYS9MZ3duSGZBdStHZnFIOFlmVmFpazJMak5qOXZ1bmlGM2VudmNWM0ozRzZwWDBncFNKeWhrN2oxWXhFZmdld2J2NzluSmVpRUVjWDZhMi9DcGhQelZDOHFodFlwSDhqR1RoM3QvSUxmbjNIMnh2YkZldnpMTHQrWkhubDlGWGF0NHBteHhsK1E4ZThaZlhxTU95MGY3OGRhMzJuc09SS2s4enZHdGFEdE1VUS9saXZjbVlsbi9BTGZtV1lqMmFzVDRtV3hCYW9HVW8yR3lXbUVUaUcvTDJ1TThuVW1PRUhqZEJhYVBVL1hvUHRyd1hCZHIyL0M5eDA5cVpGNld2K3VjL1c4YXZWVnJkRHJ1a20vMDF1Nnc4NUEzc1BaeFZkMFAyVmNwaHJnTkJURU5ReEVOQUxrMk9uaFhqb1o1R3NVNEhmbG9MZEcyem56VTBCY1h3WjVPZzMwMGVrZ29URnArWklhQi9ycUxGQ2c4OEFKT2g4TTBnV2dVRjhCQTNVaDZLZXZnaUpkQlBycllsQ2lTMEN4TGdVRGRCbEk2WEl3ME00SGwrZ0tmWjE4cmdURitnWTRVVmVCd2JvYWxPc2FVR0VhcWRUMW9FcmZCTlVaditwMStyNytEOEtQNjkrb3l4TWdMazdyRXVhMEx1R25RYTZkMDgzWHY0Tys2UEVYeUQ4ZjlOT0xvRkFMOUJKaHp1a2l3eEl3U0MrREVuRk9sL0FLVUdvbmRDdjBYNkJLcThBZ3ZRYXF0Qm9VNjNYUVc3OERFYTBGL2ZRRzZLTjFZTERlQkgyMUhoVG9MVkJOeTMxRlJlNUNkNkdLM1ZmZFZ6WFFYZVF1SW53eExUclFUcU5HN1RScUdmblZLUXI2cXhlWW81aFpiUzdvcFR3d1IzM0E5VXFBSzVRUGNwVUVJOVFYUEtBQ01FTW5nQWRVQ0w1b3Z5ZVFuVW0vUzRNTjVhQklGV0JneHBuMFBMUFpSelVFM0d5Mk5WbWNTU2VNVlJIR3FnaWZERzRSWjlJSlkwbkVjeWFkOEtsZ3NyQXF3cWVCMjh5cXBwaFZUYzA0a3o0dDQwejY3V1poLzVKeEpqMmhjOENkbWdCNmF5STRQZU5NK2gxbWhkK3pNK24zbWVYTkZKWkhHTXNqL2hMd3Y4enkvcmVkU2YrZTJkeS82Z3B3bnppVFRoakxJNHpsRWI0S1BHYVc5N0JaM2lPYUJMNXE5dmV0OEE4SDE0Ti9OaXY4dG00QWwrdEdjTFZ1QW5mcVpoRFhMVUNhRElwMUs3V1Zwb0ZyZER2NGh1NUluMVdmYmhpaXU4QTlINTlWNXo0VFRDZnVYa216d1pkMUgvaVM3Z2ZTQStCR3pRSEROQmNNMTROQWVnaFU2MkZRbzBmQXZVaWRkY0tkT3oySEVEMEg2VGpoanJ6MEdXU256eENtenhEL0ZLaXdubk9yOVp5cDFuTnUxN1BnWmowSHJyUVQ3bmZZQ2ZmN1JNOUJ6L1Fjd3ZRY3lxSG5FRjRPQ3EzLzNHLzk1eEhyUC85cy9lZDdvdjhRcHYrUU5uM0NuZmFoRnlIRFduQ2Y5YUxickJjOVpyM29kdXRGLzJLOTZOdmFBQ1psbkhDZm9mZkFnNm9ERCtsdllLN3F3WU42SHp5a0hXQ3Vkb0lDTllBVHRBdmtxeEU4a0hIQy9SNTlDTzVWczNaTDJnUEdxQVdjb2IzZ1RMV0NzZG9IeHFrTm5LWDk0R3dkQU9OMUVKeWpkakJCaDhCRWRZQnpkUmljcDA1d3ZyckFCZW9HWDVFSEZ6bzVKOWtKK2xOZFR2b1UvUFNNVS9EVE0wN0JUODg0QlQrVFUvQTNFNzdGM1lMWG1Pd21xNCs3MWQycXBMdk4zYWErYm9xYm9uNXVxcHVxQVc2YW02YVV1OTNkcmhKM2g3dERnOXlkN2s2VnV1bHV1azUwZDdtN1ZPWm11QmtxZDNlN3UxWHBacnFacW5MM3VIczAxTTF5czNTU3U5ZmRxMUZ1dHB1dDBlNCtkNTlPY2ZlNyszV2FlOEE5b0l2Y0hEZEhGN3U1YnE0dWNRKzZCM1dwZThnOXBNdmN3KzRGeWY0RDQ1dDJRdi9yZGtML2JqdWhmNTJkMFArdW5kRC9tcDNRLzY3OU44WU45bnVmV1c2Uld5VFpyMzVtMjc5bFhHc245KysyMy83TXN0Lyt6RGFQT2RrODVyL2ErZjJZbmQrWG5kLy93djhMZ084WHFIZ0JqWlZiY0ZWWEhjWi92NzNQSllSVENDSGNRd2hwUUlySVlFR2NLU0VFaUJVVURyZHd2elNCRUVyTnpWeHFGSXE5VWxyd2h0VUMxcXJ4VXEwV2ExVzBEOWJxVThmeHlVY2RlVkFmckU1c1MxdXR0WXByempsTlR1eDVjTDdaMzdkbnJmOWFaODg2Ly9rdEJNbzVHVUhVZk91bUZpWjF0ZzEwMDBRQzRQcDFxb0NJQkNuS0tDZkRKQ3FvcElycHpHUTIxZFJRU3gzMUxDeGFJVEZKMGt4Z0lqY3dtU2xNWlJvem1NVWM1aktQK2R6SUF0N0ZvcmEyemdHdTVmMUljTjU4Mi91UFN0N2J1M3U2VE9XOW82L3RpSm04ZHg0LzF1Yml2SGVIVlM0citHQlhueXZ6M3RQWDNtMUQzdnZEck9zS2ZyeTd3dzBGNzEvMlhyT2p2dHlXVVYvaHZsRi9uNjJqdnRLT1VYKy9uUVVmUE54djM5dmUyKzlRM2dmQ3AzZ3E3MEFFQ0ZoNG13bElHWEFERXlobklwbndOb25KVkRDRlNxWlN4VFJBWmdFeUI1QTBJTk1CbVExSUVwQnFRT1lDVWdQSVBFQnFBWWtCU1FDU0FtUUdON0xCODFGSGREbXVEVm9hYjQxUHhlY1NpVVJONHBiRW5zUlE0bExpdWNTZmtwbmt5dVR0eWZQSkY1SnZwWjVKSjlMRDZRM2h1WkwrVmZwcStscFpxcXdGQVNrallwaXNkM25LVC9vVHYrbTN2TnQ3Zk1KN0dmRlRmdHJQK0ZrLzU0OWQ1cmY5am9jOVlydEg3ZkNZdDN2Y08veUluWGJaYlkrOWZ0UStCeHowVGovbWtCLzNFNTd3U2Ivcjl6enY1MzNFTC9oRm4vSlJML3VzRi95K1QzdlJTMzdKeC95eVAvQVpIL2VIL29nUnYrSlhnMy9OWWIvdU41QXNLZEtVNWZvelUzVFdjNmxoSHJYTVp6SExhYVNKWmo3QXJYeVFEV3prUTN5WVRXd215eGEyc28zdDdLQ0ZYZXhtRDN2WngzNE9jSkJEdEhLRWRvN1N3VEdPMDBVM1BmVFN6MTNjdzBXZTVkZjhsdC94ZTY3eUluL2hyNHlJQzF6b3UxM2llMXhLWERoSnVVS0dHdXBaUmhOWkRuQUhRNXptRVlaNW1zZzJUNUowczd0NXlmdjRPMm16N3VHRTkvTVBWL2xUVW01eEx3TSt3QnMya0hLcit4ajBOUDkwTlNtM3VaK1hmWkEzYlNUbGRnL3dpbWY0bDJ0SXVjT0RYUE1oM3JLSmxDMGU0bFVmNXQrdUplVk9iK00xei9JZjE1RnlsNjI4N2ptdXU1N0lmcThRRWVjRVU2bEdkZ1pOSkFWRWxGTkRqSEVqc3FTUU1KK1lpSnA0TVRJei8xWVlGOW1QSklnNW5EdTF4T2padE9keUFsVlVVODhTVnRCQU01dG9jUlV4VldSc0NEa3Q1T3FRMDBNMmhwd1JjazNJbVNHYlFzNEt1VGJrN0pEclFzNEp1VDVrTlJsRUpvNzJ0ZEZwL2pqVzVkRVE1YnpFQ1FZWTVHVmU0UnF2OGhxdmoxVlF6VVJHM0d6V0xXNTFtOXZkWVlzNzNVV0VWRklOUmJzdnNwa1VrS1NDT2xiUXpENWlRSnFKbzhxb01pVEU0WjBJYnNid0FJV2FXaUwvRmh4aUlxOVNnZUVCRUtra1JsOUFxZ3FaUDkyWVNrWmNTS3J3RlRHZ3craXVRczM0bVRORVhyQ2g1Rnduc1NlRGFrdk9aa2w0S0tlbzVQeFNramJteFI5S1ZtUklXVzFCUEYrcWhqK1Q1bzBpUFZheTZwZVU4WnR4dXJOazNTVW04T1I0a1MxWjJVczVkNzlEOVVWZFBGSzBRaXFSUmtDZ2ppaG9KQWgzMjRyaktxdVFHaHpkSzBLbUZqcEhZaUowczd2Z0hmdlhGZStmWCtOaFQxQk9oRFJ6RUlwNmRRODNlYkpBN2NCcjcvVSs3L2NCVC91Z1ozekloejNydVRGK0YvSDNVUzhVVWZkeEEydUxTSHNUY1lHMWdiSk1LZHhtMDVuQlRHWXhtemxVajFHM2lKcmQ5QmV4OGtWeHdTZ2Z4NzU2SVJXNUcrWUp3MTFTdUJtZThuTHVKZ2o4ejlGZktnaVVEeDU0WHFCekZ6MDVHZ2NHRXdoY1JKV1Z1VXlTeVhHbGprVStSOHhHTnZuelhHN3haMFJzOVBuZ20veEY4QzJJYkN5aTlqckttVTBOZFN4a01VdTVtWlhjUWlPNkNtMUFWNk9ONkJxMENWMkxya1BYbzh1SWlISy9Ec3VESm93eGdwUm5FVms4YnF3TmtaM2p4aTRqamwrYit6K2thdHpZUmtSNmk4NjBuc20ybGVZV0Z4a0prc25FVkpiOEwvY1RlRkswVzVaNmQ3dkh2ZTV6dndjODZDRnZzL1gvdVBmNy8vZm1IK3ZqWFBlVy94Y25ONGcyQUFBQVwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvc3R5bGVzL0NpcmN1bGFyU3RkLUJvbGRJdGFsaWMud29mZlxuLy8gbW9kdWxlIGlkID0gNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///64\n");

/***/ })
/******/ ]);